<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Uncle_drew</title>
  
  <subtitle>Hand down,man down</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://cndrew.cn/blog/"/>
  <updated>2019-07-25T14:25:29.060Z</updated>
  <id>https://cndrew.cn/blog/</id>
  
  <author>
    <name>Uncle_drew</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>树的直径以及邻接表，链式前向星的存图</title>
    <link href="https://cndrew.cn/blog/2019/07/25/mapsave/"/>
    <id>https://cndrew.cn/blog/2019/07/25/mapsave/</id>
    <published>2019-07-25T14:23:57.943Z</published>
    <updated>2019-07-25T14:25:29.060Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天的学习及刷题的过程中遇到了一些新的知识——树的直径，和前几天学到但没使用过的邻接表存图以及链式前向星存图。内容也不少，所以特意新开一篇文章进行介绍。<a id="more"></a></p><p>先来了解一下什么是树：<br>树（tree）是包含n（n&gt;0）个结点的有穷集，其中：</p><ul><li>每个元素称为结点（node）；</li><li>有一个特定的结点被称为根结点或树根（root）；</li><li>除根结点之外的其余数据元素被分为m（m≥0）个互不相交<br>的集合T1，T2，…Tm-1，其中每一个集合Tm-1（1≤i≤m）<br>本身也是一棵树，被称作原树的子树（subtree）。</li></ul><p>树中距离最大的两个结点之间的距离称为树的直径。<br><img src="https://i.loli.net/2019/07/25/5d3959f00f0cf36997.png" alt></p><p>树的直径的求法：</p><p>两次dfs或bfs。第一次任意选一个点进行dfs(bfs)找到离它最远的<br>点，此点就是最长路的一个端点，再以此点进行dfs（bfs），找到<br>离它最远的点，此点就是最长路的另一个端点，于是就找到了树<br>的直径。</p><p>证明：<br>假设此树的最长路径是从s到t,我们选择的点为u。<br>反证法：假设搜到的点是v。<br>1、v在这条最长路径上，那么dis[u,v]&gt;dis[u,v]+dis[v,s],显然矛<br>盾。<br>2、v不在这条最长路径上，我们在最长路径上选择一个点为po，<br>则dis[u,v]&gt;dis[u,po]+dis[po,t]，那么有dis[s,v]=dis[s,po]+dis[po,u]<br>+dis[u,v]&gt;dis[s,po]+dis[po,t]=dis[s,t],即dis[s,v]&gt;dis[s,t],矛盾。<br>也许你想说u本身就在最长路径，或则其它的一些情况，但其实<br>都能用类似于上面的反证法来证明的。<br>综上所述，你两次dfs(bfs)就可以求出最长路径的两个端点和路<br>径长度。        以上内容参考与学长的PDF</p><p>其实证明看不太懂得话问题不大，就是随便找一个位置先进行dfs或者bfs到达一个端点，再以这个端点为起点dfs或者bfs到达另一个端点即可。</p><p>有的题它让你处理的就是字符串组成的图，但是有的题就不会这么好心了，他会给出你节点，边，甚至有的还会给你出权值。此时我们就需要自己存图。</p><p>说到存图，一般都有三种方法。</p><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>用二维数组进行存图，这个是最普通的办法，但是有一个致命的缺点就是当题目数据中的点比较多的时候有极高的空间复杂度，会爆内存。不过数据范围小的时候用二维数组来存图。还是很简单的。<br>举个栗子：<br>5个点 4条边<br>对每条边输入三个数，两个端点以及这条边的权值<br>1 2 2<br>2 3 4<br>4 5 1<br>1 4 2<br>1 5 3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">char s[maxn][maxn];</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y&gt;&gt;p;</span><br><span class="line">    s[x][y]=p;</span><br><span class="line">s[y][x]=p;//如果是有向图的话，就不需要这一句了    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>访问的时候直接s[i][j]就行了</p><h2 id="邻接表法"><a href="#邻接表法" class="headerlink" title="邻接表法"></a>邻接表法</h2><p>邻接表法就是用vector来进行存储，这个也挺好理解，跟二维数组可以一样的理解。<br>举个栗子：<br>5个点 4条边<br>对每条边输入三个数，两个端点以及这条边的权值<br>1 2 2<br>2 3 4<br>4 5 1<br>1 4 2<br>1 5 3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//无权值</span><br><span class="line">vector&lt;int&gt; v[maxn];</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    v[x].push_back(y);</span><br><span class="line">    v[y].push_back(x);//有向边的话不需要者一句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//有权值</span><br><span class="line">vector&lt;pair&lt;int,int&gt; &gt; v[maxn]；</span><br><span class="line">fot(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">    v[x].push_back(make_pair(y,z));</span><br><span class="line">    v[y].push_back(make_pair(x,z));//有向边的话不需要者一句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问每条边的时候需要这样写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;v[i].size();j++)</span><br><span class="line">    &#123;</span><br><span class="line">    cout&lt;&lt;v[i][j].first&lt;&lt;&quot;-&gt;&quot;&lt;&lt;v[i][j].second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h2><p>链式前向星是一种很巧妙地方法。<br>首先建立一个结构体<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Edge</span><br><span class="line">&#123;</span><br><span class="line">    int e;//表示第i条边的终点</span><br><span class="line">    int w;//权值</span><br><span class="line">    int next;//表示同起点的下一条边</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>加边<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cnt=0,head=-1;</span><br><span class="line">void add ( int u, int v, int w)</span><br><span class="line">&#123;</span><br><span class="line">edge [cnt ].w = w;</span><br><span class="line">edge [cnt ]. to = v;</span><br><span class="line">edge [cnt ]. next = head [u];</span><br><span class="line">head [u] = cnt ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>边的遍历<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (int i= head [u];~i;i= edge [i]. next )</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt;u&lt;&lt;&quot; -&gt;&quot; &lt;&lt;edge [i].e&lt;&lt; endl ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>链式前向星不会遍历到不存在的边。<br>内存利用率高，相比vector实现的邻接表而言，可以准确开辟最多边数的内存，不像vector实现的邻接表有爆内存的风险。</p><p>如果有兴趣深入理解存图的话可以参考一下这几篇博客：<a href="https://blog.csdn.net/acdreamers/article/details/16902023" target="_blank" rel="noopener">https://blog.csdn.net/acdreamers/article/details/16902023</a></p><p><a href="https://jzqt.github.io/2015/07/21/ACM%E5%9B%BE%E8%AE%BA%E4%B9%8B%E5%AD%98%E5%9B%BE%E6%96%B9%E5%BC%8F/" target="_blank" rel="noopener">https://jzqt.github.io/2015/07/21/ACM%E5%9B%BE%E8%AE%BA%E4%B9%8B%E5%AD%98%E5%9B%BE%E6%96%B9%E5%BC%8F/</a></p><p>三种存图方式的介绍就到这里了，我最喜欢用的是第二种，好理解又方便写，但是不得不承认链式前向星的优秀，还是应该会用的。</p><p>说完了存图，我还想说一下用邻接表存了图之后该如何进行搜索（这里以bfs为例）。</p><p>我们只需要对每个顶点进行搜索即可，即bfs传递的参数为邻接表中的第一个元素。<br>直接上代码吧<br>无权值得<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e5+10;</span><br><span class="line">int dis[maxn],ans,vis[maxn],n,a,b;</span><br><span class="line">vector&lt;int&gt; v[maxn];</span><br><span class="line">int bfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">memset(dis,0,sizeof(dis));</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">q.push(x);</span><br><span class="line">vis[x]=1,dis[x]=0;</span><br><span class="line">int point;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">x=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">if(dis[x]&gt;ans)</span><br><span class="line">&#123;</span><br><span class="line">ans=dis[x];</span><br><span class="line">point=x;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;v[x].size();i++)</span><br><span class="line">&#123;</span><br><span class="line">if(!vis[v[x][i]])</span><br><span class="line">&#123;</span><br><span class="line">vis[v[x][i]]=1;</span><br><span class="line">dis[v[x][i]]=dis[x]+1;</span><br><span class="line">q.push(v[x][i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return point;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i=1;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">v[a].push_back(b);</span><br><span class="line">v[b].push_back(a);</span><br><span class="line">&#125;</span><br><span class="line">ans=0;</span><br><span class="line">int point=bfs(1);</span><br><span class="line">ans=0;</span><br><span class="line">bfs(point);</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有权值的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a,b,c,ans;</span><br><span class="line">const int maxn = 1e5+10;</span><br><span class="line">int vis[maxn],dis[maxn];//dis数组储存的就是当前点能向一个确定的方向走的最大的距离。vis就是一个标记数组防止重复访问。</span><br><span class="line">vector&lt;pair&lt;int,int&gt; &gt; v[maxn]; //用来存图，可以看成是一个二维数组,因为是有权值的，所以在vector中套用了一个pair</span><br><span class="line">int bfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">    memset(vis,0,sizeof(vis));//因为要进行多次bfs，所以每次都要清空一下数组</span><br><span class="line">    memset(dis,0,sizeof(dis));</span><br><span class="line">    vis[x]=1;//已经访问过的节点标记为1</span><br><span class="line">    int point=0;//用来储存当前所能走到的最远的点</span><br><span class="line">    queue&lt;int&gt; q;//用来实现bfs的队列</span><br><span class="line">    q.push(x);</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        x=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        if(dis[x]&gt;ans)//如果当前点能走的最大的步数大于ans，ans初始为0，如果大于就更新ans和point的值</span><br><span class="line">        &#123;</span><br><span class="line">            ans=dis[x];</span><br><span class="line">            point=x;</span><br><span class="line">        &#125;</span><br><span class="line">        pair&lt;int,int&gt; mid;</span><br><span class="line">        for(int i=0;i&lt;v[x].size();i++)//对v[x]中的每一个元素进行bfs</span><br><span class="line">        &#123;</span><br><span class="line">            mid=v[x][i];</span><br><span class="line">            if(!vis[mid.first])//没访问过就继续</span><br><span class="line">            &#123;</span><br><span class="line">                vis[mid.first]=1;//标记成已经访问过的</span><br><span class="line">                dis[mid.first]=dis[x]+mid.second;//这个点的能走的最大的距离多了一个dis[x]</span><br><span class="line">                q.push(mid.first);//放进队列以进行bfs</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return point;//把当前走到的最远的点返回</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c)</span><br><span class="line">    &#123;</span><br><span class="line">        v[a].push_back(make_pair(b,c));//存图</span><br><span class="line">        v[b].push_back(make_pair(a,c));</span><br><span class="line">    &#125;</span><br><span class="line">    ans=0;//初始化</span><br><span class="line">    int point=bfs(1);</span><br><span class="line">    ans=0;</span><br><span class="line">    bfs(point);//第二次以某一端点位起点的bfs</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里只需要看一下对邻接表中vector下标的使用即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的学习及刷题的过程中遇到了一些新的知识——树的直径，和前几天学到但没使用过的邻接表存图以及链式前向星存图。内容也不少，所以特意新开一篇文章进行介绍。
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="Algorithm" scheme="https://cndrew.cn/blog/tags/Algorithm/"/>
    
      <category term="BFS" scheme="https://cndrew.cn/blog/tags/BFS/"/>
    
      <category term="树的直径" scheme="https://cndrew.cn/blog/tags/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"/>
    
      <category term="邻接表" scheme="https://cndrew.cn/blog/tags/%E9%82%BB%E6%8E%A5%E8%A1%A8/"/>
    
      <category term="“链式前向星”" scheme="https://cndrew.cn/blog/tags/%E2%80%9C%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F%E2%80%9D/"/>
    
  </entry>
  
  <entry>
    <title>HPU Summer Training Day 9（河南理工大学暑期第九天）</title>
    <link href="https://cndrew.cn/blog/2019/07/25/d9/"/>
    <id>https://cndrew.cn/blog/2019/07/25/d9/</id>
    <published>2019-07-25T14:21:15.879Z</published>
    <updated>2019-07-25T14:38:43.067Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天主要讲了树的直径，是用bfs和dfs实现的，但是我的dfs，emm，一言难尽，所以我只用了bfs。<a id="more"></a><br>关于今天刷题遇到的主要的知识，请去这里查看。</p><center><font color="red">-------------------------------------&gt;<a href="https://cndrew.cn/blog/2019/07/25/mapsave">戳这里</a>&lt;-------------------------------------</font></center><h3 id="Labyrinth"><a href="#Labyrinth" class="headerlink" title="Labyrinth"></a>Labyrinth</h3><p>Description:<br>The northern part of the Pyramid contains a very large and complicated labyrinth. The labyrinth is divided into square blocks, each of them either filled by rock, or free. There is also a little hook on the floor in the center of every free block. The ACM have found that two of the hooks must be connected by a rope that runs through the hooks in every block on the path between the connected ones. When the rope is fastened, a secret door opens. The problem is that we do not know which hooks to connect. That means also that the neccessary length of the rope is unknown. Your task is to determine the maximum length of the rope we could need for a given labyrinth.<br>Input</p><blockquote><p>The input consists of T test cases. The number of them (T) is given on the first line of the input file. Each test case begins with a line containing two integers C and R (3 &lt;= C,R &lt;= 1000) indicating the number of columns and rows. Then exactly R lines follow, each containing C characters. These characters specify the labyrinth. Each of them is either a hash mark (#) or a period (.). Hash marks represent rocks, periods are free blocks. It is possible to walk between neighbouring blocks only, where neighbouring blocks are blocks sharing a common side. We cannot walk diagonally and we cannot step out of the labyrinth.</p></blockquote><blockquote><p>The labyrinth is designed in such a way that there is exactly one path between any two free blocks. Consequently, if we find the proper hooks to connect, it is easy to find the right path connecting them.<br>Output<br>Your program must print exactly one line of output for each test case. The line must contain the sentence &quot;Maximum rope length is X.&quot; where Xis the length of the longest path between any two free blocks, measured in blocks.</p></blockquote><p>Sample Input</p><blockquote><p>2<br>3 3</p></blockquote><p>###</p><p>#.#</p><p>###<br>7 6</p><p>#######</p><p>#.#.###</p><p>#.#.###</p><p>#.#.#.#</p><p>#.....#</p><p>#######</p><p>Sample Output</p><blockquote><p>Maximum rope length is 0.<br>Maximum rope length is 8.</p></blockquote><p>Hint</p><blockquote><p>Huge input, scanf is recommended.<br>If you use recursion, maybe stack overflow. and now C++/c &#39;s stack size is larger than G++/gcc</p></blockquote><p>Problem solving:<br>这一题是最简单的求树的直径的题，bfs两次即可，注意虽然第一次开始查找的位置可以是任意的，但是第二次开始的位置应该是第一次查找到最后的那个位置，还有就是两个bfs之间不要忘了memset。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int dis[1005][1005];</span><br><span class="line">int vis[1005][1005];</span><br><span class="line">char s[1005][1005];</span><br><span class="line">int d[4][2]=&#123;1,0,0,1,-1,0,0,-1&#125;;</span><br><span class="line">struct node&#123;</span><br><span class="line">int x,y;</span><br><span class="line">&#125;;</span><br><span class="line">int n,c,r,sx,sy;</span><br><span class="line">int bfs(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">node now,mid;</span><br><span class="line">queue&lt;node&gt; que;</span><br><span class="line">now.x=x;now.y=y;</span><br><span class="line">que.push(now);</span><br><span class="line">vis[x][y]=1;dis[x][y]=0;</span><br><span class="line">while(!que.empty())</span><br><span class="line">&#123;</span><br><span class="line">now=que.front();</span><br><span class="line">que.pop();</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">mid.x=now.x+d[i][0];</span><br><span class="line">mid.y=now.y+d[i][1];</span><br><span class="line">if(mid.x&lt;0||mid.x&gt;=r||mid.y&lt;0||mid.y&gt;=c||s[mid.x][mid.y]==&apos;#&apos;||vis[mid.x][mid.y])continue;</span><br><span class="line">vis[mid.x][mid.y]=1;</span><br><span class="line">dis[mid.x][mid.y]=dis[now.x][now.y]+1;</span><br><span class="line">que.push(mid);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">while(n--)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">memset(dis,0,sizeof(dis));</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;c,&amp;r);</span><br><span class="line">int flag=0;</span><br><span class="line">for(int i=0;i&lt;r;i++)scanf(&quot;%s&quot;,s[i]);</span><br><span class="line">for(int i=0;i&lt;r;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;c;j++)</span><br><span class="line">&#123;</span><br><span class="line">if(s[i][j]==&apos;.&apos;)</span><br><span class="line">&#123;</span><br><span class="line">sx=i,sy=j;</span><br><span class="line">flag=1;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">if(flag)break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bfs(sx,sy);int px=0;</span><br><span class="line">for(int i=0;i&lt;r;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;c;j++)</span><br><span class="line">&#123;</span><br><span class="line">if(dis[i][j]&gt;px)</span><br><span class="line">&#123;</span><br><span class="line">sx=i;</span><br><span class="line">sy=j;</span><br><span class="line">px=dis[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">memset(dis,0,sizeof(dis));</span><br><span class="line">bfs(sx,sy);</span><br><span class="line">int ans=0;</span><br><span class="line">for(int i=0;i&lt;r;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;c;j++)</span><br><span class="line">&#123;</span><br><span class="line">ans=max(ans,dis[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;Maximum rope length is %d.\n&quot;,ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Cow-Marathon"><a href="#Cow-Marathon" class="headerlink" title="Cow Marathon"></a>Cow Marathon</h3><p>Description:<br>After hearing about the epidemic of obesity in the USA, Farmer John wants his cows to get more exercise, so he has committed to create a bovine marathon for his cows to run. The marathon route will include a pair of farms and a path comprised of a sequence of roads between them. Since FJ wants the cows to get as much exercise as possible he wants to find the two farms on his map that are the farthest apart from each other (distance being measured in terms of total length of road on the path between the two farms). Help him determine the distances between this farthest pair of farms.<br>有n个农田和m条路，以及每条路的方向（方向在这道题中没有用），求最长的一条路，也就是两点间的最大距离，即树的直径.<br>Input</p><blockquote><ul><li>Lines 1.....: Same input format as &quot;Navigation Nightmare&quot;.</li></ul></blockquote><p>Output</p><blockquote><ul><li>Line 1: An integer giving the distance between the farthest pair of farms.</li></ul></blockquote><p>Sample Input</p><blockquote><p>7 6<br>1 6 13 E<br>6 3 9 E<br>3 5 7 S<br>4 1 3 N<br>2 4 20 W<br>4 7 2 S</p></blockquote><p>Sample Output</p><blockquote><p>52</p></blockquote><p>Hint</p><blockquote><p>The longest marathon runs from farm 2 via roads 4, 1, 6 and 3 to farm 5 and is of length 20+3+13+9+7=52.</p></blockquote><p>Problem solving:<br>这道题就是一道带权的无向图求树的最大直径。<br>直接套模板即可。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a,b,c,ans,n,m;</span><br><span class="line">const int maxn = 1e5+10;</span><br><span class="line">int vis[maxn],dis[maxn];</span><br><span class="line">char s;</span><br><span class="line">vector&lt;pair&lt;int,int&gt; &gt; v[maxn];</span><br><span class="line">int bfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">memset(dis,0,sizeof(dis));</span><br><span class="line">vis[x]=1;</span><br><span class="line">int point=0;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">q.push(x);</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">x=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">if(dis[x]&gt;ans)</span><br><span class="line">&#123;</span><br><span class="line">ans=dis[x];</span><br><span class="line">point=x;</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;int,int&gt; mid;</span><br><span class="line">for(int i=0;i&lt;v[x].size();i++)</span><br><span class="line">&#123;</span><br><span class="line">mid=v[x][i];</span><br><span class="line">if(!vis[mid.first])</span><br><span class="line">&#123;</span><br><span class="line">vis[mid.first]=1;</span><br><span class="line">dis[mid.first]=dis[x]+mid.second;</span><br><span class="line">q.push(mid.first);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return point;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">while(m--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;s;</span><br><span class="line">v[a].push_back(make_pair(b,c));</span><br><span class="line">v[b].push_back(make_pair(a,c));</span><br><span class="line">&#125;</span><br><span class="line">ans=0;</span><br><span class="line">int point=bfs(1);</span><br><span class="line">ans=0;</span><br><span class="line">bfs(point);</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Roads-in-the-North"><a href="#Roads-in-the-North" class="headerlink" title="Roads in the North"></a>Roads in the North</h3><p>Description:<br>Building and maintaining roads among communities in the far North is an expensive business. With this in mind, the roads are build such that there is only one route from a village to a village that does not pass through some other village twice.<br>Given is an area in the far North comprising a number of villages and roads among them such that any village can be reached by road from any other village. Your job is to find the road distance between the two most remote villages in the area.</p><p>The area has up to 10,000 villages connected by road segments. The villages are numbered from 1.<br>Input</p><blockquote><p>Input to the problem is a sequence of lines, each containing three positive integers: the number of a village, the number of a different village, and the length of the road segment connecting the villages in kilometers. All road segments are two-way.</p></blockquote><p>Output</p><blockquote><p>You are to output a single integer: the road distance between the two most remote villages in the area.</p></blockquote><p>Sample Input</p><blockquote><p>5 1 6<br>1 4 5<br>6 3 9<br>2 6 8<br>6 1 7</p></blockquote><p>Sample Output</p><blockquote><p>22</p></blockquote><p>Problem solving:<br>同B，直接套模板即可。这里是输入组数不确定，所以直接while(cin)即可。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a,b,c,ans;</span><br><span class="line">const int maxn = 1e5+10;</span><br><span class="line">int vis[maxn],dis[maxn];</span><br><span class="line">vector&lt;pair&lt;int,int&gt; &gt; v[maxn];</span><br><span class="line">int bfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">memset(dis,0,sizeof(dis));</span><br><span class="line">vis[x]=1;</span><br><span class="line">int point=0;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">q.push(x);</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">x=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">if(dis[x]&gt;ans)</span><br><span class="line">&#123;</span><br><span class="line">ans=dis[x];</span><br><span class="line">point=x;</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;int,int&gt; mid;</span><br><span class="line">for(int i=0;i&lt;v[x].size();i++)</span><br><span class="line">&#123;</span><br><span class="line">mid=v[x][i];</span><br><span class="line">if(!vis[mid.first])</span><br><span class="line">&#123;</span><br><span class="line">vis[mid.first]=1;</span><br><span class="line">dis[mid.first]=dis[x]+mid.second;</span><br><span class="line">q.push(mid.first);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return point;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c)</span><br><span class="line">&#123;</span><br><span class="line">v[a].push_back(make_pair(b,c));</span><br><span class="line">v[b].push_back(make_pair(a,c));</span><br><span class="line">&#125;</span><br><span class="line">ans=0;</span><br><span class="line">int point=bfs(1);</span><br><span class="line">ans=0;</span><br><span class="line">bfs(point);</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Computer"><a href="#Computer" class="headerlink" title="Computer"></a>Computer</h3><p>Description:<br>一所学校不久前买了第一台电脑（所以这台电脑的ID是1）。近年来，学校购买了N-1新电脑。每台新电脑都连接到一台先前安装的电脑上。学校的管理人员担心网络运行缓慢，希望知道第i台计算机需要发送信号的最大距离si（即到最远计算机的电缆长度）。您需要提供此信息。<br><img src="https://i.loli.net/2019/07/25/5d3973a05d63146229.png" alt></p><p>提示：示例输入与此图对应。从图中，你可以看到计算机4离1最远，所以s1=3。计算机4和5是距离2最远的，所以s2=2。计算机5是离3最远的，所以s3=3。我们也得到了s4=4，s5=4。<br>输入</p><blockquote><p>输入文件包含多组测试样例。在每组样例中，第一行中都有自然数n（n&lt;=10000），然后是（n-1）行，其中包含对计算机的描述。第i行包含两个自然数-第i计算机所连接的计算机和用于连接的电缆长度。电缆总长度不超过1e9。输入行中的数字用空格分隔。</p></blockquote><p>输出</p><blockquote><p>对于每组样例，输出n行。第i行第i台计算机的到其他计算机的最大长度Si（1&lt;=i&lt;=n）。</p></blockquote><p>样例输入</p><blockquote><p>5<br>1 1<br>2 1<br>3 1<br>1 1</p></blockquote><p>样例输出</p><blockquote><p>3<br>2<br>3<br>4<br>4</p></blockquote><p>提示</p><blockquote><p>示例输入与此图对应。从图中，你可以看到计算机4离1最远，所以s1=3。计算机4和5是距离2最远的，所以s2=2。计算机5是离3最远的，所以s3=3。我们也得到了s4=4，s5=4。</p></blockquote><p>Problem solving:<br>这道题应该是今天最难的题了。一开始毫无思路，但是后来听了学长一句话。离某个点最远的一定是树的直径的端点。我们第一次bfs结束时的点是这个树的两个端点之一，再以这个端点就行bfs结束的时候就到了另外一个端点，而且我们在查找的过程中使用的dis数组就是当前位置距离将要到达的！！端点！！的距离，所以就在bfs一次，与上一次得到的距离去max最大值即可。总结一下就是三次bfs。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const long long maxn=1e5;</span><br><span class="line">long long n,a,b,ans;</span><br><span class="line">long long vis[maxn],dis[maxn],dis2[maxn];</span><br><span class="line">vector&lt;pair&lt;long long,long long&gt; &gt; v[maxn];</span><br><span class="line">long long bfs(long long x)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">memset(dis,0,sizeof(dis));</span><br><span class="line">ans=0;</span><br><span class="line">queue&lt;long long&gt; q;</span><br><span class="line">q.push(x);</span><br><span class="line">vis[x]=1;</span><br><span class="line">long long point;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">x=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">if(dis[x]&gt;ans)</span><br><span class="line">&#123;</span><br><span class="line">ans=dis[x];</span><br><span class="line">point=x;</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;long long,long long&gt; mid;</span><br><span class="line">for(long long i=0;i&lt;v[x].size();i++)</span><br><span class="line">&#123;</span><br><span class="line">mid=v[x][i];</span><br><span class="line">if(!vis[mid.first])</span><br><span class="line">&#123;</span><br><span class="line">vis[mid.first]=1;</span><br><span class="line">dis[mid.first]=dis[x]+mid.second;</span><br><span class="line">q.push(mid.first);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return point;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(cin&gt;&gt;n)</span><br><span class="line">&#123;</span><br><span class="line">memset(v,0,sizeof(v));</span><br><span class="line">for(long long i=2;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">v[a].push_back(make_pair(i,b));</span><br><span class="line">v[i].push_back(make_pair(a,b));</span><br><span class="line">&#125;</span><br><span class="line">long long point=bfs(1);</span><br><span class="line">long long next=bfs(point);</span><br><span class="line">for(long long i=1;i&lt;=n;i++)dis2[i]=dis[i];</span><br><span class="line">bfs(next);</span><br><span class="line">for(long long i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;max(dis2[i],dis[i])&lt;&lt;endl;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Farthest-Nodes-in-a-Tree"><a href="#Farthest-Nodes-in-a-Tree" class="headerlink" title="Farthest Nodes in a Tree"></a>Farthest Nodes in a Tree</h3><p>Description:<br>Given a tree (a connected graph with no cycles), you have to find the farthest nodes in the tree. The edges of the tree are weighted and undirected. That means you have to find two nodes in the tree whose distance is maximum amongst all nodes.</p><p>Input</p><blockquote><p>Input starts with an integer T (≤ 10), denoting the number of test cases.<br>Each case starts with an integer n (2 ≤ n ≤ 30000) denoting the total number of nodes in the tree. The nodes are numbered from 0 to n-1. Each of the next n-1 lines will contain three integers u v w (0 ≤ u, v &lt; n, u ≠ v, 1 ≤ w ≤ 10000) denoting that node u and v are connected by an edge whose weight is w. You can assume that the input will form a valid tree.</p></blockquote><p>Output</p><blockquote><p>For each case, print the case number and the maximum distance.</p></blockquote><p>Sample Input</p><blockquote><p>2<br>4<br>0 1 20<br>1 2 30<br>2 3 50<br>5<br>0 2 20<br>2 1 10<br>0 3 29<br>0 4 50</p></blockquote><p>Sample Output</p><blockquote><p>Case 1: 100<br>Case 2: 80</p></blockquote><p>Problem solving:<br>同BC，直接套模板就行。然后就是输出格式的控制</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">const int maxn= 1e5+10;</span><br><span class="line">using namespace std;</span><br><span class="line">int dis[maxn],ans;</span><br><span class="line">bool vis[maxn];</span><br><span class="line">vector&lt;pair&lt;int,int&gt; &gt; v[maxn];</span><br><span class="line">int bfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">memset(dis,0,sizeof(dis));</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">queue&lt;int&gt; que;</span><br><span class="line">que.push(x);vis[x]=1;</span><br><span class="line">int point=0;</span><br><span class="line">while(!que.empty())</span><br><span class="line">&#123;</span><br><span class="line">int f=que.front();</span><br><span class="line">que.pop();</span><br><span class="line">if(dis[f]&gt;ans)</span><br><span class="line">&#123;</span><br><span class="line">ans=dis[f];</span><br><span class="line">point=f;</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;int,int&gt; t;</span><br><span class="line">for(int i=0;i&lt;v[f].size();i++)</span><br><span class="line">&#123;</span><br><span class="line">t=v[f][i];</span><br><span class="line">if(vis[t.first]==0)</span><br><span class="line">&#123;</span><br><span class="line">vis[t.first]=1;</span><br><span class="line">dis[t.first]=dis[f]+t.second;</span><br><span class="line">que.push(t.first);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return point;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,m,x,y,z,flag=0;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">while(n--)</span><br><span class="line">&#123;</span><br><span class="line">memset(v,0,sizeof(v));</span><br><span class="line">cin&gt;&gt;m;</span><br><span class="line">for(int i=1;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">v[x].push_back(make_pair(y,z));</span><br><span class="line">v[y].push_back(make_pair(x,z));</span><br><span class="line">&#125;</span><br><span class="line">ans=0;</span><br><span class="line">int point=bfs(1);</span><br><span class="line">ans=0;</span><br><span class="line">bfs(point);</span><br><span class="line">printf(&quot;Case %d: %d\n&quot;,++flag,ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="51nod-2602-树的直径"><a href="#51nod-2602-树的直径" class="headerlink" title="51nod 2602 树的直径"></a>51nod 2602 树的直径</h3><p>Description:<br>一棵树的直径就是这棵树上存在的最长路径。现在有一棵n个节点的树，现在想知道这棵树的直径包含的边的个数是多少？<br><img src="https://i.loli.net/2019/07/25/5d3973771759017661.png" alt></p><p>如图所示的数据，这棵树的直径为(1-2-3-6-9)这条路径，包含的边的个数为4，所以答案是4。</p><p>输入</p><blockquote><p>第1行：一个整数n，表示树上的节点个数。(1&lt;=n&lt;=100000)<br>第2-n行：每行有两个整数u,v,表示u与v之间有一条路径。(1&lt;=u,v&lt;=n)</p></blockquote><p>输出</p><blockquote><p>输出一个整数，表示这棵树直径所包含的边的个数。</p></blockquote><p>输入样例</p><blockquote><p>10<br>1 2<br>2 3<br>3 4<br>3 5<br>3 6<br>3 7<br>3 10<br>6 8<br>6 9</p></blockquote><p>输出样例</p><blockquote><p>4</p></blockquote><p>Problem solving:<br>求树的直径的模板题。不过无权值。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e5+10;</span><br><span class="line">int dis[maxn],ans,vis[maxn],n,a,b;</span><br><span class="line">vector&lt;int&gt; v[maxn];</span><br><span class="line">int bfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">memset(dis,0,sizeof(dis));</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">q.push(x);</span><br><span class="line">vis[x]=1,dis[x]=0;</span><br><span class="line">int point;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">x=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">if(dis[x]&gt;ans)</span><br><span class="line">&#123;</span><br><span class="line">ans=dis[x];</span><br><span class="line">point=x;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;v[x].size();i++)</span><br><span class="line">&#123;</span><br><span class="line">if(!vis[v[x][i]])</span><br><span class="line">&#123;</span><br><span class="line">vis[v[x][i]]=1;</span><br><span class="line">dis[v[x][i]]=dis[x]+1;</span><br><span class="line">q.push(v[x][i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return point;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i=1;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">v[a].push_back(b);</span><br><span class="line">v[b].push_back(a);</span><br><span class="line">&#125;</span><br><span class="line">ans=0;</span><br><span class="line">int point=bfs(1);</span><br><span class="line">ans=0;</span><br><span class="line">bfs(point);</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>上面有三道题我都直接说得套模板。那么求树的直径的模板是什么呢？这里只写上带权的吧，不带权的可以类比得出。或者去这里看：<center><font color="red">------------------------------&gt;<a href="https://cndrew.cn/blog/2019/07/25/mapsave">戳这里</a>&lt;------------------------------</font></center></p><p>在这里我结合代码想详细的分析一下这个模板。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a,b,c,ans;</span><br><span class="line">const int maxn = 1e5+10;</span><br><span class="line">int vis[maxn],dis[maxn];//dis数组储存的就是当前点能向一个确定的方向走的最大的距离。vis就是一个标记数组防止重复访问。</span><br><span class="line">vector&lt;pair&lt;int,int&gt; &gt; v[maxn]; //用来存图，可以看成是一个二维数组,因为是有权值的，所以在vector中套用了一个pair</span><br><span class="line">int bfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">    memset(vis,0,sizeof(vis));//因为要进行多次bfs，所以每次都要清空一下数组</span><br><span class="line">    memset(dis,0,sizeof(dis));</span><br><span class="line">    vis[x]=1;//已经访问过的节点标记为1</span><br><span class="line">    int point=0;//用来储存当前所能走到的最远的点</span><br><span class="line">    queue&lt;int&gt; q;//用来实现bfs的队列</span><br><span class="line">    q.push(x);</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        x=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        if(dis[x]&gt;ans)//如果当前点能走的最大的步数大于ans，ans初始为0，如果大于就更新ans和point的值</span><br><span class="line">        &#123;</span><br><span class="line">            ans=dis[x];</span><br><span class="line">            point=x;</span><br><span class="line">        &#125;</span><br><span class="line">        pair&lt;int,int&gt; mid;</span><br><span class="line">        for(int i=0;i&lt;v[x].size();i++)//对v[x]中的每一个元素进行bfs</span><br><span class="line">        &#123;</span><br><span class="line">            mid=v[x][i];</span><br><span class="line">            if(!vis[mid.first])//没访问过就继续</span><br><span class="line">            &#123;</span><br><span class="line">                vis[mid.first]=1;//标记成已经访问过的</span><br><span class="line">                dis[mid.first]=dis[x]+mid.second;//这个点的能走的最大的距离多了一个dis[x]</span><br><span class="line">                q.push(mid.first);//放进队列以进行bfs</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return point;//把当前走到的最远的点返回</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c)</span><br><span class="line">    &#123;</span><br><span class="line">        v[a].push_back(make_pair(b,c));//存图</span><br><span class="line">        v[b].push_back(make_pair(a,c));</span><br><span class="line">    &#125;</span><br><span class="line">    ans=0;//初始化</span><br><span class="line">    int point=bfs(1);</span><br><span class="line">    ans=0;</span><br><span class="line">    bfs(point);//第二次以某一端点位起点的bfs</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="学长标程"><a href="#学长标程" class="headerlink" title="学长标程"></a>学长标程</h3><p>学长写的代码比我的好看多了。。。贴一下</p><h4 id="Labyrinth-1"><a href="#Labyrinth-1" class="headerlink" title="Labyrinth"></a>Labyrinth</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int N,M,u,v,ans;</span><br><span class="line">int dir[4][2]=&#123;1,0,0,1,-1,0,0,-1&#125;;</span><br><span class="line">char MAP[1200][1200];</span><br><span class="line">bool vis[1200][1200];</span><br><span class="line">void dfs(int x,int y,int res)&#123;</span><br><span class="line">for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">int nx=dir[i][0]+x;</span><br><span class="line">int ny=dir[i][1]+y;</span><br><span class="line">if(nx&gt;=0&amp;&amp;nx&lt;N&amp;&amp;ny&gt;=0&amp;&amp;ny&lt;M&amp;&amp;vis[nx][ny]==0&amp;&amp;MAP[nx][ny]==&apos;.&apos;)&#123;</span><br><span class="line">vis[nx][ny]=1;</span><br><span class="line">dfs(nx,ny,res+1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(res&gt;=ans)&#123;</span><br><span class="line">u=x;v=y;ans=res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">int T;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;T);</span><br><span class="line">while(T--)&#123;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;M,&amp;N);</span><br><span class="line">for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">scanf(&quot;%s&quot;,&amp;MAP[i]);</span><br><span class="line">&#125;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">ans=0;</span><br><span class="line">for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">for(int j=0;j&lt;M;j++)&#123;</span><br><span class="line">if(MAP[i][j]==&apos;.&apos;)&#123;</span><br><span class="line">dfs(i,j,0);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">dfs(u,v,0);</span><br><span class="line">cout&lt;&lt;&quot;Maximum rope length is &quot;&lt;&lt;ans&lt;&lt;&apos;.&apos;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Cow-Marathon-1"><a href="#Cow-Marathon-1" class="headerlink" title="Cow Marathon"></a>Cow Marathon</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int N,M,X,Y,Z,ans;</span><br><span class="line">int dis[40020];</span><br><span class="line">bool vis[40020];</span><br><span class="line">vector&lt;pair&lt;int,int&gt; &gt;V[40020];</span><br><span class="line">int bfs(int n)&#123;</span><br><span class="line">memset(dis,0,sizeof(dis));</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">queue&lt;int&gt;Q;</span><br><span class="line">Q.push(n);</span><br><span class="line">vis[n]=1;</span><br><span class="line">ans=0;</span><br><span class="line">int point=0,t;</span><br><span class="line">while(!Q.empty())&#123;</span><br><span class="line">t=Q.front();</span><br><span class="line">Q.pop();</span><br><span class="line">if(dis[t]&gt;ans)&#123;</span><br><span class="line">ans=dis[t];</span><br><span class="line">point=t;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;V[t].size();i++)&#123;</span><br><span class="line">if(vis[V[t][i].first]==0)&#123;</span><br><span class="line">vis[V[t][i].first]=1;</span><br><span class="line">dis[V[t][i].first]=dis[t]+V[t][i].second;</span><br><span class="line">Q.push(V[t][i].first);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return point;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;N,&amp;M);</span><br><span class="line">for(int i=0;i&lt;M;i++)&#123;</span><br><span class="line">scanf(&quot;%d%d%d %*c&quot;,&amp;X,&amp;Y,&amp;Z);</span><br><span class="line">V[X].push_back(make_pair(Y,Z));</span><br><span class="line">V[Y].push_back(make_pair(X,Z));</span><br><span class="line">&#125;</span><br><span class="line">bfs(bfs(1));</span><br><span class="line">printf(&quot;%d\n&quot;,ans);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Roads-in-the-North-1"><a href="#Roads-in-the-North-1" class="headerlink" title="Roads in the North"></a>Roads in the North</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int N,M,X,Y,Z,ans;</span><br><span class="line">int dis[40020];</span><br><span class="line">bool vis[40020];</span><br><span class="line">vector&lt;pair&lt;int,int&gt; &gt;V[40020];</span><br><span class="line">int bfs(int n)&#123;</span><br><span class="line">memset(dis,0,sizeof(dis));</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">queue&lt;int&gt;Q;</span><br><span class="line">Q.push(n);</span><br><span class="line">vis[n]=1;</span><br><span class="line">ans=0;</span><br><span class="line">int point=0,t;</span><br><span class="line">while(!Q.empty())&#123;</span><br><span class="line">t=Q.front();</span><br><span class="line">Q.pop();</span><br><span class="line">if(dis[t]&gt;ans)&#123;</span><br><span class="line">ans=dis[t];</span><br><span class="line">point=t;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;V[t].size();i++)&#123;</span><br><span class="line">if(vis[V[t][i].first]==0)&#123;</span><br><span class="line">vis[V[t][i].first]=1;</span><br><span class="line">dis[V[t][i].first]=dis[t]+V[t][i].second;</span><br><span class="line">Q.push(V[t][i].first);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return point;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">while(scanf(&quot;%d%d%d&quot;,&amp;X,&amp;Y,&amp;Z)!=EOF)&#123;</span><br><span class="line">V[X].push_back(make_pair(Y,Z));</span><br><span class="line">V[Y].push_back(make_pair(X,Z));</span><br><span class="line">&#125;</span><br><span class="line">bfs(bfs(1));</span><br><span class="line">printf(&quot;%d\n&quot;,ans);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Computer-1"><a href="#Computer-1" class="headerlink" title="Computer"></a>Computer</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int N,M,X,Y,Z,ans;</span><br><span class="line">int dis[40020];</span><br><span class="line">int diss[40020];</span><br><span class="line">bool vis[40020];</span><br><span class="line">vector&lt;pair&lt;int,int&gt; &gt;V[40020];</span><br><span class="line">int bfs(int n)&#123;</span><br><span class="line">memset(dis,0,sizeof(dis));</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">queue&lt;int&gt;Q;</span><br><span class="line">Q.push(n);</span><br><span class="line">vis[n]=1;</span><br><span class="line">ans=0;</span><br><span class="line">int point,t;</span><br><span class="line">while(!Q.empty())&#123;</span><br><span class="line">t=Q.front();</span><br><span class="line">Q.pop();</span><br><span class="line">if(dis[t]&gt;ans)&#123;</span><br><span class="line">ans=dis[t];</span><br><span class="line">point=t;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;V[t].size();i++)&#123;</span><br><span class="line">if(vis[V[t][i].first]==0)&#123;</span><br><span class="line">vis[V[t][i].first]=1;</span><br><span class="line">dis[V[t][i].first]=dis[t]+V[t][i].second;</span><br><span class="line">Q.push(V[t][i].first);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return point;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">while(scanf(&quot;%d&quot;,&amp;N)!=EOF)&#123;</span><br><span class="line">for(int i=0;i&lt;=N;i++)V[i].clear();</span><br><span class="line">for(int i=1;i&lt;N;i++)&#123;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;X,&amp;Z);</span><br><span class="line">V[i+1].push_back(make_pair(X,Z));</span><br><span class="line">V[X].push_back(make_pair(i+1,Z));</span><br><span class="line">&#125;</span><br><span class="line">int point=bfs(bfs(1));</span><br><span class="line">for(int i=1;i&lt;=N;i++)&#123;</span><br><span class="line">diss[i]=dis[i];</span><br><span class="line">&#125;</span><br><span class="line">bfs(point);</span><br><span class="line">for(int i=1;i&lt;=N;i++)&#123;</span><br><span class="line">printf(&quot;%d\n&quot;,max(dis[i],diss[i]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Farthest-Nodes-in-a-Tree-1"><a href="#Farthest-Nodes-in-a-Tree-1" class="headerlink" title="Farthest Nodes in a Tree"></a>Farthest Nodes in a Tree</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int N,M,X,Y,Z,ans;</span><br><span class="line">int dis[40020];</span><br><span class="line">bool vis[40020];</span><br><span class="line">vector&lt;pair&lt;int,int&gt; &gt;V[40020];</span><br><span class="line">int bfs(int n)&#123;</span><br><span class="line">memset(dis,0,sizeof(dis));</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">queue&lt;int&gt;Q;</span><br><span class="line">Q.push(n);</span><br><span class="line">vis[n]=1;</span><br><span class="line">ans=0;</span><br><span class="line">int point,t;</span><br><span class="line">while(!Q.empty())&#123;</span><br><span class="line">t=Q.front();</span><br><span class="line">Q.pop();</span><br><span class="line">if(dis[t]&gt;ans)&#123;</span><br><span class="line">ans=dis[t];</span><br><span class="line">point=t;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;V[t].size();i++)&#123;</span><br><span class="line">if(vis[V[t][i].first]==0)&#123;</span><br><span class="line">vis[V[t][i].first]=1;</span><br><span class="line">dis[V[t][i].first]=dis[t]+V[t][i].second;</span><br><span class="line">Q.push(V[t][i].first);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return point;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">int T,Case=1;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;T);</span><br><span class="line">while(T--)&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;N);</span><br><span class="line">for(int i=0;i&lt;N;i++)V[i].clear();</span><br><span class="line">for(int i=1;i&lt;N;i++)&#123;</span><br><span class="line">scanf(&quot;%d%d%d&quot;,&amp;X,&amp;Y,&amp;Z);</span><br><span class="line">V[X].push_back(make_pair(Y,Z));</span><br><span class="line">V[Y].push_back(make_pair(X,Z));</span><br><span class="line">&#125;</span><br><span class="line">bfs(bfs(0));</span><br><span class="line">printf(&quot;Case %d: %d\n&quot;,Case++,ans);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int N,M,X,Y,Z,ans;</span><br><span class="line">int dis[100020];</span><br><span class="line">bool vis[100020];</span><br><span class="line">vector&lt;pair&lt;int,int&gt; &gt;V[100020];</span><br><span class="line">int bfs(int n)&#123;</span><br><span class="line">memset(dis,0,sizeof(dis));</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">queue&lt;int&gt;Q;</span><br><span class="line">Q.push(n);</span><br><span class="line">vis[n]=1;</span><br><span class="line">ans=0;</span><br><span class="line">int point,t;</span><br><span class="line">while(!Q.empty())&#123;</span><br><span class="line">t=Q.front();</span><br><span class="line">Q.pop();</span><br><span class="line">if(dis[t]&gt;ans)&#123;</span><br><span class="line">ans=dis[t];</span><br><span class="line">point=t;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;V[t].size();i++)&#123;</span><br><span class="line">if(vis[V[t][i].first]==0)&#123;</span><br><span class="line">vis[V[t][i].first]=1;</span><br><span class="line">dis[V[t][i].first]=dis[t]+V[t][i].second;</span><br><span class="line">Q.push(V[t][i].first);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return point;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;N);</span><br><span class="line">for(int i=1;i&lt;N;i++)&#123;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;X,&amp;Y);</span><br><span class="line">V[X].push_back(make_pair(Y,1));</span><br><span class="line">V[Y].push_back(make_pair(X,1));</span><br><span class="line">&#125;</span><br><span class="line">bfs(bfs(1));</span><br><span class="line">printf(&quot;%d\n&quot;,ans);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天主要讲了树的直径，是用bfs和dfs实现的，但是我的dfs，emm，一言难尽，所以我只用了bfs。
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="Algorithm" scheme="https://cndrew.cn/blog/tags/Algorithm/"/>
    
      <category term="HDU" scheme="https://cndrew.cn/blog/tags/HDU/"/>
    
      <category term="51nod" scheme="https://cndrew.cn/blog/tags/51nod/"/>
    
      <category term="poj" scheme="https://cndrew.cn/blog/tags/poj/"/>
    
      <category term="BFS" scheme="https://cndrew.cn/blog/tags/BFS/"/>
    
      <category term="树的直径" scheme="https://cndrew.cn/blog/tags/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>HPU Summer Training Day 8（河南理工大学暑期第八天）</title>
    <link href="https://cndrew.cn/blog/2019/07/24/d8/"/>
    <id>https://cndrew.cn/blog/2019/07/24/d8/</id>
    <published>2019-07-24T14:11:20.567Z</published>
    <updated>2019-07-24T14:17:56.359Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天主要讲的是递归和DFS，因为涉及到递归，很抽象，所以比较难理解。题也很难做。<a id="more"></a></p><h3 id="Oil-Deposits"><a href="#Oil-Deposits" class="headerlink" title="Oil Deposits"></a>Oil Deposits</h3><p>Description：<br>The GeoSurvComp geologic survey company is responsible for detecting underground oil deposits. GeoSurvComp works with one large rectangular region of land at a time, and creates a grid that divides the land into numerous square plots. It then analyzes each plot separately, using sensing equipment to determine whether or not the plot contains oil. A plot containing oil is called a pocket. If two pockets are adjacent, then they are part of the same oil deposit. Oil deposits can be quite large and may contain numerous pockets. Your job is to determine how many different oil deposits are contained in a grid.<br>Input<br>The input file contains one or more grids. Each grid begins with a line containing m and n, the number of rows and columns in the grid, separated by a single space. If m = 0 it signals the end of the input; otherwise 1 &lt;= m &lt;= 100 and 1 &lt;= n &lt;= 100. Following this are m lines of n characters each (not counting the end-of-line characters). Each character corresponds to one plot, and is either `*&#39;, representing the absence of oil, or `@&#39;, representing an oil pocket.</p><p>Output</p><blockquote><p>For each grid, output the number of distinct oil deposits. Two different pockets are part of the same oil deposit if they are adjacent horizontally, vertically, or diagonally. An oil deposit will not contain more than 100 pockets.</p></blockquote><p>Sample Input<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1 1</span><br><span class="line">*</span><br><span class="line">3 5</span><br><span class="line">*@*@*</span><br><span class="line">**@**</span><br><span class="line">*@*@*</span><br><span class="line">1 8</span><br><span class="line">@@****@*</span><br><span class="line">5 5</span><br><span class="line">****@</span><br><span class="line">*@@*@</span><br><span class="line">*@**@</span><br><span class="line">@@@*@</span><br><span class="line">@@**@</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure></p><p>Sample Output</p><blockquote><p>0<br>1<br>2<br>2</p></blockquote><p>Problem solving:<br>简单题，输入一个图，@表示油田，*表示没有油田，@只要是相邻的都可以算成是一个，所以就是八个方向上dfs就行，访问过的@就换成*或者其他的字符就行只要不是@.(如果这样写的话其实就不需要标记数组了)</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">char s[105][105];</span><br><span class="line">int vis[105][105];</span><br><span class="line">int m,n,ans;</span><br><span class="line">int d[8][2]=&#123;1,0,0,1,0,-1,-1,0,1,1,1,-1,-1,-1,-1,1&#125;;</span><br><span class="line">void dfs(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">vis[x][y]=1;</span><br><span class="line">if(x&lt;0||x&gt;=m||y&lt;0||y&gt;=n)return ;</span><br><span class="line">for(int i=0;i&lt;8;i++)</span><br><span class="line">&#123;</span><br><span class="line">int dx=x+d[i][0];</span><br><span class="line">int dy=y+d[i][1];</span><br><span class="line">if(dx&gt;=0&amp;&amp;dx&lt;m&amp;&amp;dy&gt;=0&amp;&amp;dy&lt;n&amp;&amp;!vis[dx][dy]&amp;&amp;s[dx][dy]==&apos;@&apos;)</span><br><span class="line">&#123;</span><br><span class="line">s[dx][dy]=&apos;*&apos;;</span><br><span class="line">dfs(dx,dy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(cin&gt;&gt;m&gt;&gt;n&amp;&amp;m)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">ans=0;</span><br><span class="line">for(int i=0;i&lt;m;i++)cin&gt;&gt;s[i];</span><br><span class="line">for(int i=0;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line">if(s[i][j]==&apos;@&apos;)</span><br><span class="line">&#123;</span><br><span class="line">dfs(i,j);</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="How-Many-Equations-Can-You-Find"><a href="#How-Many-Equations-Can-You-Find" class="headerlink" title="How Many Equations Can You Find"></a>How Many Equations Can You Find</h3><p>Description：<br>Now give you an string which only contains 0, 1 ,2 ,3 ,4 ,5 ,6 ,7 ,8 ,9.You are asked to add the sign ‘+’ or ’-’ between the characters. Just like give you a string “12345”, you can work out a string “123+4-5”. Now give you an integer N, please tell me how many ways can you find to make the result of the string equal to N .You can only choose at most one sign between two adjacent characters.<br>Input</p><blockquote><p>Each case contains a string s and a number N . You may be sure the length of the string will not exceed 12 and the absolute value of N will not exceed 999999999999.</p></blockquote><p>Output</p><blockquote><p>The output contains one line for each data set : the number of ways you can find to make the equation.</p></blockquote><p>Sample Input</p><blockquote><p>123456789 3<br>21 1</p></blockquote><p>Sample Output</p><blockquote><p>18<br>1</p></blockquote><p>Problem solving:<br>每两个数中间都有两种可能，一种是加号一种是减号，并且能放入操作符的位置我们也是知道的，所以只需要查找每个位置放上不同的运算符之后得到的所有结果，看有几个与n相等即可。查找的过程用dfs来实现。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">string s;int n,ans;</span><br><span class="line">void dfs(int x,int now)//x代表的是当前要进行操作的位置，now代表当前得到的值</span><br><span class="line">&#123;</span><br><span class="line">if(x==s.size())//如果x已经跟字符串的长度相等说明这一次遍历已经结束了</span><br><span class="line">&#123;</span><br><span class="line">if(now==n)ans++;//如果得到的值跟n相等，答案就加一</span><br><span class="line">//cout&lt;&lt;now&lt;&lt;endl;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=x;i&lt;s.size();i++)</span><br><span class="line">&#123;</span><br><span class="line">int mid=0;</span><br><span class="line">for(int j=x;j&lt;=i;j++)</span><br><span class="line">&#123;</span><br><span class="line">mid=mid*10+s[j]-&apos;0&apos;;//得到运算符左边字符串所代表数的大小</span><br><span class="line">//cout&lt;&lt;mid&lt;&lt;&quot;?&quot;&lt;&lt;now&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">dfs(i+1,now+mid);//去访问下一个位置，并且此时的值加上上面得到的运算符左边字符串所代表的数</span><br><span class="line">if(x)dfs(i+1,now-mid);//减号不能放在最前面，所以要有一个x不为0的判断</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(cin&gt;&gt;s&gt;&gt;n)</span><br><span class="line">&#123;</span><br><span class="line">ans=0;</span><br><span class="line">dfs(0,0);//从s[0]开始，当前值为0</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h3><p>Description：<br>在N*N的方格棋盘放置了N个皇后，使得它们不相互攻击（即任意2个皇后不允许处在同一排，同一列，也不允许处在与棋盘边框成45角的斜线上。<br>你的任务是，对于给定的N，求出有多少种合法的放置方法。</p><p>Input</p><blockquote><p>共有若干行，每行一个正整数N≤10，表示棋盘和皇后的数量；如果N=0，表示结束。</p></blockquote><p>Output</p><blockquote><p>共有若干行，每行一个正整数，表示对应输入行的皇后的不同放置数量。</p></blockquote><p>Sample Input</p><blockquote><p>1<br>8<br>5<br>0</p></blockquote><p>Sample Output</p><blockquote><p>1<br>92<br>10</p></blockquote><p>Problem solving:<br>从第一行开始放，然后放下一行，如果出现了在同一行的或者同一列的或者同一条斜线上的就return，如果放进去的个数等于n，答案就加一。这道题N虽然小于等于10，但是是多组输入，如果每次输入都计算一次并且输入数据很多的话，肯定会TLE。所以需要打表，就是如果这个计算过了就把它的结果记录下来，如果下次又要求这个的结果直接调用就行。也可以直接从输入前就先计算好存进数组。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,mid;</span><br><span class="line">int ans[12],mmp[12];</span><br><span class="line">void dfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">if(x==n+1)</span><br><span class="line">&#123;</span><br><span class="line">mid++;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">int flag=1;</span><br><span class="line">mmp[x]=i;</span><br><span class="line">for(int j=1;j&lt;x;j++)</span><br><span class="line">&#123;</span><br><span class="line">if(mmp[j]==i||(abs(j-x)==abs(mmp[j]-mmp[x])))</span><br><span class="line">&#123;</span><br><span class="line">flag=0;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(flag)dfs(x+1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">for(n=1;n&lt;=10;n++)</span><br><span class="line">&#123;</span><br><span class="line">mid=0;</span><br><span class="line">dfs(1);</span><br><span class="line">ans[n]=mid;</span><br><span class="line">&#125;</span><br><span class="line">int t;</span><br><span class="line">while(cin&gt;&gt;t&amp;&amp;t)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;ans[t]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Fox-And-Two-Dots"><a href="#Fox-And-Two-Dots" class="headerlink" title="Fox And Two Dots"></a>Fox And Two Dots</h3><p>Description：<br>Fox Ciel is playing a mobile puzzle game called &quot;Two Dots&quot;. The basic levels are played on a board of size n × m cells, like this:</p><p><center><img src="https://i.loli.net/2019/07/24/5d3816e429b0036148.png" alt></center><br>Each cell contains a dot that has some color. We will use different uppercase Latin characters to express different colors.</p><p>The key of this game is to find a cycle that contain dots of same color. Consider 4 blue dots on the picture forming a circle as an example. Formally, we call a sequence of dots d1, d2, ..., dk a cycle if and only if it meets the following condition:</p><ol><li>These k dots are different: if i ≠ j then di is different from dj.</li><li>k is at least 4.</li><li>All dots belong to the same color.</li><li>For all 1 ≤ i ≤ k - 1: di and di + 1 are adjacent. Also, dk and d1 should also be adjacent. Cells x and y are called adjacent if they share an edge.</li></ol><p>Determine if there exists a cycle on the field.<br>Input</p><blockquote><p>The first line contains two integers n and m (2 ≤ n, m ≤ 50): the number of rows and columns of the board.<br>Then n lines follow, each line contains a string consisting of m characters, expressing colors of dots in each line. Each character is an uppercase Latin letter.</p></blockquote><p>Output</p><blockquote><p>Output &quot;Yes&quot; if there exists a cycle, and &quot;No&quot; otherwise.</p></blockquote><p>Examples<br>Input</p><blockquote><p>3 4<br>AAAA<br>ABCA<br>AAAA</p></blockquote><p>Output</p><blockquote><p>Yes</p></blockquote><p>Input</p><blockquote><p>3 4<br>AAAA<br>ABCA<br>AADA</p></blockquote><p>Output</p><blockquote><p>No</p></blockquote><p>Input</p><blockquote><p>4 4<br>YYYR<br>BYBY<br>BBBY<br>BBBY</p></blockquote><p>Output</p><blockquote><p>Yes</p></blockquote><p>Input</p><blockquote><p>7 6<br>AAAAAB<br>ABBBAB<br>ABAAAB<br>ABABBB<br>ABAAAB<br>ABBBAB<br>AAAAAB</p></blockquote><p>Output</p><blockquote><p>Yes</p></blockquote><p>Input</p><blockquote><p>2 13<br>ABCDEFGHIJKLM<br>NOPQRSTUVWXYZ</p></blockquote><p>Output</p><blockquote><p>No</p></blockquote><p>Note<br>In first sample test all &#39;A&#39; form a cycle.</p><p>In second sample there is no such cycle.</p><p>The third sample is displayed on the picture above (&#39;Y&#39; = Yellow, &#39;B&#39; = Blue, &#39;R&#39; = Red).<br>Problem solving:<br>这道题的意思就是输入一个由大写字母组成的图，如果相同的字母可以组成一个环，就输出Yes，否则输出No。<br>这道题跟昨天的那个机器人有点类似，不过那个机器人每次走的方向是定的，而这个是可以随意走的。<br>所以如何进行判断会不会有环的存在呢？<br>我们只需要在每次进行dfs的查找之前把最初的初始位置记录一下，然后开始dfs查找，上下左右四个方向，遇到与当前字母一样的字母就以这个为初始位置继续dfs，并且记录下来当前走的步数。如果在dfs结束之前遇到了一个(dx,dy)与我们记录的最初始的初始位置相等并且步数大于等于4的情况，就说明存在环，输出&#39;Yes&#39;即可，反之输出&#39;No&#39;。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">char s[60][60];</span><br><span class="line">int vis[60][60],flag,n,m,sx,sy;</span><br><span class="line">int d[4][2]=&#123;1,0,0,1,-1,0,0,-1&#125;;</span><br><span class="line">void dfs(int x,int y,int step)</span><br><span class="line">&#123;</span><br><span class="line">if(flag)return ;</span><br><span class="line">vis[x][y]=1;</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">int dx=x+d[i][0];</span><br><span class="line">int dy=y+d[i][1];</span><br><span class="line">if(dx==sx&amp;&amp;dy==sy&amp;&amp;step&gt;=4)</span><br><span class="line">&#123;</span><br><span class="line">flag=1;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">if(dx&gt;=0&amp;&amp;dx&lt;n&amp;&amp;dy&gt;=0&amp;&amp;dy&lt;m&amp;&amp;!vis[dx][dy]&amp;&amp;s[dx][dy]==s[x][y])</span><br><span class="line">&#123;</span><br><span class="line">dfs(dx,dy,step+1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">for(int i=0;i&lt;n;i++)cin&gt;&gt;s[i];</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;m;j++)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">sx=i,sy=j;</span><br><span class="line">dfs(sx,sy,1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(flag)puts(&quot;Yes&quot;);</span><br><span class="line">elseputs(&quot;No&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="棋盘问题"><a href="#棋盘问题" class="headerlink" title="棋盘问题"></a>棋盘问题</h3><p>Description：<br>在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。<br>Input</p><blockquote><p>输入含有多组测试数据。<br>每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n &lt;= 8 , k &lt;= n<br>当为-1 -1时表示输入结束。<br>随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。</p></blockquote><p>Output</p><blockquote><p>对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C\&lt;2^31）。</p></blockquote><p>Sample Input<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2 1</span><br><span class="line">#.</span><br><span class="line">.#</span><br><span class="line">4 4</span><br><span class="line">...#</span><br><span class="line">..#.</span><br><span class="line">.#..</span><br><span class="line">#...</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure></p><p>Sample Output</p><blockquote><p>2<br>1</p></blockquote><p>Problem solving:<br>跟n皇后很像的一个问题。判断条件还少了一个。注意回溯就行。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,k,vis[10],ans,now;</span><br><span class="line">char s[10][10];</span><br><span class="line">void dfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">if(now==k)</span><br><span class="line">&#123;</span><br><span class="line">ans++;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">if(x&gt;=n)return ;</span><br><span class="line">for(int j=0;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line">if(!vis[j]&amp;&amp;s[x][j]==&apos;#&apos;)</span><br><span class="line">&#123;</span><br><span class="line">vis[j]=1;</span><br><span class="line">now++;</span><br><span class="line">dfs(x+1);</span><br><span class="line">now--;</span><br><span class="line">vis[j]=0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dfs(x+1);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(scanf(&quot;%d %d&quot;,&amp;n,&amp;k)&amp;&amp;n!=-1&amp;&amp;k!=-1)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">for(int i=0;i&lt;n;i++)cin&gt;&gt;s[i];</span><br><span class="line">ans=0,now=0;</span><br><span class="line">dfs(0);</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Sudoku"><a href="#Sudoku" class="headerlink" title="Sudoku"></a>Sudoku</h3><p>Description：<br>Sudoku is a very simple task. A square table with 9 rows and 9 columns is divided to 9 smaller squares 3x3 as shown on the Figure. In some of the cells are written decimal digits from 1 to 9. The other cells are empty. The goal is to fill the empty cells with decimal digits from 1 to 9, one digit per cell, in such way that in each row, in each column and in each marked 3x3 subsquare, all the digits from 1 to 9 to appear. Write a program to solve a given Sudoku-task.</p><p><img src="https://i.loli.net/2019/07/24/5d3817f744d8511698.png" alt="JUT0QY($RVW[_(1EGZ@@)PK.png" title="JUT0QY($RVW[_(1EGZ@@)PK.png"></p><p>Input</p><blockquote><p>The input data will start with the number of the test cases. For each test case, 9 lines follow, corresponding to the rows of the table. On each line a string of exactly 9 decimal digits is given, corresponding to the cells in this line. If a cell is empty it is represented by 0.</p></blockquote><p>Output</p><blockquote><p>For each test case your program should print the solution in the same format as the input data. The empty cells have to be filled according to the rules. If solutions is not unique, then the program may print any one of them.</p></blockquote><p>Sample Input</p><blockquote><p>1<br>103000509<br>002109400<br>000704000<br>300502006<br>060000050<br>700803004<br>000401000<br>009205800<br>804000107</p></blockquote><p>Sample Output</p><blockquote><p>143628579<br>572139468<br>986754231<br>391542786<br>468917352<br>725863914<br>237481695<br>619275843<br>854396127</p></blockquote><p>Problem solving:<br>这道题的处理方式很巧妙。dfs中的参数只设置一个n(n就是代表着这是第几个数)就够了，就是当前的位置，在dfs中每次加一，如果当前位置不为0，就直接查找下一个位置。否则就从1～9中选一个数放进去，看同一行同一列以及同一小方格的同一行同一列有没有与之相同的，如果没有，就将当前位置的数更新成这个没有重复出现过的数。知道查找到n&gt;=81的时候，即每个位置都查找完了，结束查找输出即可。注意在查找的过程中需要用到回溯，因为如果这一条路行不通而返回上一条路的时候，此时当前位置还应该是0.<br>思路还是很清晰的，难点主要有两个</p><ol><li>如何用n来表示当前的位置</li><li>如何判断同一行同一列以及同一小方格的同一行同一列有没有与之相同的数</li></ol><p>n/9代表的就是当前位置的行，n%9代表的就是当前位置的列。<br>n/9/3*3表示的就是当前位置在小方格里的行，n%9/3*3代表的就是当前位置在小方格里的列。</p><p>位置都能表示出来了，那么判断也就简单了。<br>分别确定二维数组的第一个和第二个坐标进行判断就行了。这一点可能说的不是很好理解，可以看看代码，还是很好理解的。</p><p>这里还用到了一个很巧妙的输入<code>scanf(&quot;%1d&quot;,&amp;a)</code>;这样的话就不用输入字符再转换成整型了。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[10][10],flag;</span><br><span class="line">bool check(int n,int now)</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;9;i++)</span><br><span class="line">&#123;</span><br><span class="line">int j=n%9;</span><br><span class="line">if(a[i][j]==now)</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">    for(int j=0;j&lt;9;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        int i=n/9;</span><br><span class="line">        if(a[i][j]==now)</span><br><span class="line">            return 0;</span><br><span class="line">    &#125;</span><br><span class="line">int di=n/9/3*3;</span><br><span class="line">int dj=n%9/3*3;</span><br><span class="line">for(int i =di;i&lt;di+3;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=dj;j&lt;dj+3;j++)</span><br><span class="line">&#123;</span><br><span class="line">if(a[i][j]==now)return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">int dfs(int n)</span><br><span class="line">&#123;</span><br><span class="line">if(n&gt;=81)</span><br><span class="line">&#123;</span><br><span class="line">flag=1;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">if(a[n/9][n%9]!=0)dfs(n+1);</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">for(int i=1;i&lt;=9;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(check(n,i)==1)</span><br><span class="line">&#123;</span><br><span class="line">a[n/9][n%9]=i;</span><br><span class="line">dfs(n+1);</span><br><span class="line">if(flag==1)</span><br><span class="line">return 0;</span><br><span class="line">a[n/9][n%9]=0;//回溯</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//cout&lt;&lt;&quot;?&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">flag=0;</span><br><span class="line">for(int i=0;i&lt;9;i++)</span><br><span class="line">for(int j=0;j&lt;9;j++)</span><br><span class="line">scanf(&quot;%1d&quot;,&amp;a[i][j]);</span><br><span class="line">dfs(0);</span><br><span class="line">for(int i=0;i&lt;9;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;9;j++)</span><br><span class="line">printf(&quot;%d&quot;,a[i][j]);</span><br><span class="line">puts(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="放苹果"><a href="#放苹果" class="headerlink" title="放苹果"></a>放苹果</h3><p>Description：<br>把M个同样的苹果放在N个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？（用K表示）5，1，1和1，5，1 是同一种分法。<br>Input</p><blockquote><p>第一行是测试数据的数目t（0 &lt;= t &lt;= 20）。以下每行均包含二个整数M和N，以空格分开。1&lt;=M，N&lt;=10。</p></blockquote><p>Output</p><blockquote><p>对输入的每组数据M和N，用一行输出相应的K。</p></blockquote><p>Sample Input</p><blockquote><p>1<br>7 3</p></blockquote><p>Sample Output</p><blockquote><p>8</p></blockquote><p>Problem solving:<br>思维题。(让我说也说不清，还是借用一下大佬的解释吧)<br>设f(m,n) 为m个苹果，n个盘子的放法数目，则先对n作讨论，<br>        当n&gt;m：必定有n-m个盘子永远空着，去掉它们对摆放苹果方法数目不产生影响。即if(n&gt;m) f(m,n) = f(m,m)　　<br>        当n&lt;=m：不同的放法可以分成两类：<br>        1、有至少一个盘子空着，即相当于f(m,n) = f(m,n-1);<br>        2、所有盘子都有苹果，相当于可以从每个盘子中拿掉一个苹果，不影响不同放法的数目，即f(m,n) = f(m-n,n).<br>        而总的放苹果的放法数目等于两者的和，即 f(m,n) =f(m,n-1)+f(m-n,n) </p><p> 递归出口条件说明：<br>        当n=1时，所有苹果都必须放在一个盘子里，所以返回１；<br>        当没有苹果可放时，定义为１种放法；<br>        递归的两条路，第一条n会逐渐减少，终会到达出口n==1;<br>        第二条m会逐渐减少，因为n&gt;m时，我们会return f(m,m)　所以终会到达出口m==0．<br>此解释源于：<a href="https://blog.csdn.net/jason0539/article/details/12183817" target="_blank" rel="noopener">https://blog.csdn.net/jason0539/article/details/12183817</a></p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int t,n,m,ans;</span><br><span class="line">int dfs(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">if(x==0||y==1)&#123;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">else if(x&lt;y)return dfs(x,x);</span><br><span class="line">return dfs(x,y-1)+dfs(x-y,y);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">cout&lt;&lt;dfs(m,n)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Tempter-of-the-Bone"><a href="#Tempter-of-the-Bone" class="headerlink" title="Tempter of the Bone"></a>Tempter of the Bone</h3><p>Description：<br>小明做了一个很久很久的梦，醒来后他竟发现自己和朋友在一个摇摇欲坠的大棋盘上，他们必须得想尽一切办法逃离这里。<br>经过长时间的打探，小明发现，自己所在的棋盘格子上有个机关，上面写着“你只有一次机会，出发后t秒大门会为你敞开”，而他自己所在的棋盘是大小为 N*M 的长方形，他可以向上下左右四个方向移动（不可走有障碍点）。棋盘中有一扇门。根据机关的提示，小明顿时明白了，他和朋友必须在第 t 秒到门口。而这一切，没有回头路！因为一旦他移动了，他刚才所在的点就会消失，并且他不能在一个点上停留超过一秒，不然格子会爆炸。大逃亡开始了，请问小明和朋友能安全的逃出这奇怪的棋盘吗？</p><p>Input</p><blockquote><p>输入多组测试数据。每个测试用例的第一行包含三个整数 N、M 和 T ( 1 &lt; N , M &lt; 7 ; 0 &lt; T &lt; 50 )，分别表示棋盘的大小和门打开的时间。接下来的N行给出棋盘布局，每一行包含M个字符。其中<br>&quot;.&quot;: 无障碍点<br>&quot;X&quot;: 障碍点<br>&quot;S&quot;: 起点<br>&quot;D&quot;: 门<br>输入以 3 个 0 结束。这个测试用例不需要处理。<br>输入数据中的空格有些问题，请不要使用getchar()，如果一定要用可以选择scanf(&quot;%s&quot;,) 自动忽略空格</p></blockquote><p>Output</p><blockquote><p>对于每组样例输出一行。<br>如果小明能够安全逃出，输出 &quot;YES&quot; ，否则输出 &quot;NO&quot;。</p></blockquote><p>Sample Input<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">4 4 5</span><br><span class="line">S.X.</span><br><span class="line">..X.</span><br><span class="line">..XD</span><br><span class="line">....</span><br><span class="line">3 4 5</span><br><span class="line">S.X.</span><br><span class="line">..X.</span><br><span class="line">...D</span><br><span class="line">0 0 0</span><br></pre></td></tr></table></figure></p><p>Sample Output</p><blockquote><p>NO<br>YES</p></blockquote><p>Problem solving:<br>注意题目中要求的是当你走到D的时候你走的步数与它开门的时间即T相等，所以需要用DFS查找每一条到达D的路，看与T相等的值是否存在。<br>因为要查询到每一条路，这道题可能会超时。所以会用到一种很神奇的剪枝——<a href="https://baike.baidu.com/item/%E5%A5%87%E5%81%B6%E5%89%AA%E6%9E%9D" target="_blank" rel="noopener">奇偶剪枝</a><br>除去这个剪枝的难度的话这道题就很简单了。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m,t,sx,sy,ex,ey,ti,flag;</span><br><span class="line">char s[10][10];</span><br><span class="line">int vis[10][10];</span><br><span class="line">int d[4][2]=&#123;0,1,0,-1,1,0,-1,0&#125;;</span><br><span class="line">void dfs(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">if(x&lt;0||x&gt;=n||y&lt;0||y&gt;=m||ti&gt;t)return ;</span><br><span class="line">if(flag)return ;</span><br><span class="line">if(s[x][y]==&apos;D&apos;&amp;&amp;ti==t)</span><br><span class="line">&#123;</span><br><span class="line">//cout&lt;&lt;ti&lt;&lt;endl;</span><br><span class="line">flag=1;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int temp1 = abs(ex-x) + abs(ey-y);</span><br><span class="line">int temp2 = abs(t-ti);</span><br><span class="line">int temp = abs(temp1-temp2);</span><br><span class="line">if(temp%2!=0)return ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vis[x][y]=1;</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">int dx=x+d[i][0];</span><br><span class="line">int dy=y+d[i][1];</span><br><span class="line">if(dx&gt;=0&amp;&amp;dx&lt;n&amp;&amp;dy&gt;=0&amp;&amp;dy&lt;m&amp;&amp;!vis[dx][dy]&amp;&amp;s[dx][dy]!=&apos;X&apos;)</span><br><span class="line">&#123;</span><br><span class="line">//cout&lt;&lt;ti&lt;&lt;&quot;--&gt;&quot;&lt;&lt;dx&lt;&lt;&quot; --&gt;&quot;&lt;&lt;dy&lt;&lt;&quot;\n&quot;;</span><br><span class="line">ti++;</span><br><span class="line">dfs(dx,dy);</span><br><span class="line">vis[dx][dy]=0;</span><br><span class="line">ti--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">        ios::sync_with_stdio(0);</span><br><span class="line">while(cin&gt;&gt;n&gt;&gt;m&gt;&gt;t)</span><br><span class="line">&#123;</span><br><span class="line">if(n==0&amp;&amp;m==0&amp;&amp;t==0)break;</span><br><span class="line">flag=0,ti=0;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">for(int i=0;i&lt;n;i++)cin&gt;&gt;s[i];</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">for(int j=0;j&lt;m;j++)</span><br><span class="line">if(s[i][j]==&apos;S&apos;)</span><br><span class="line">&#123;</span><br><span class="line">sx=i,sy=j;</span><br><span class="line">&#125;</span><br><span class="line">else if(s[i][j]==&apos;D&apos;)</span><br><span class="line">&#123;</span><br><span class="line">ex=i,ey=j;</span><br><span class="line">&#125;</span><br><span class="line">dfs(sx,sy);</span><br><span class="line">if(flag)puts(&quot;YES&quot;);</span><br><span class="line">elseputs(&quot;NO&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Red-and-Black"><a href="#Red-and-Black" class="headerlink" title="Red and Black"></a>Red and Black</h3><p>Description：<br>There is a rectangular room, covered with square tiles. Each tile is colored either red or black. A man is standing on a black tile. From a tile, he can move to one of four adjacent tiles. But he can&#39;t move on red tiles, he can move only on black tiles.</p><p>Write a program to count the number of black tiles which he can reach by repeating the moves described above.<br>Input</p><blockquote><p>The input consists of multiple data sets. A data set starts with a line containing two positive integers W and H; W and H are the numbers of tiles in the x- and y- directions, respectively. W and H are not more than 20.<br>There are H more lines in the data set, each of which includes W characters. Each character represents the color of a tile as follows.<br>&#39;.&#39; - a black tile<br>&#39;#&#39; - a red tile<br>&#39;@&#39; - a man on a black tile(appears exactly once in a data set)</p></blockquote><p>Output</p><blockquote><p>For each data set, your program should output a line which contains the number of tiles he can reach from the initial tile (including itself).</p></blockquote><p>Sample Input<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">6 9</span><br><span class="line">....#.</span><br><span class="line">.....#</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">#@...#</span><br><span class="line">.#..#.</span><br><span class="line">11 9</span><br><span class="line">.#.........</span><br><span class="line">.#.#######.</span><br><span class="line">.#.#.....#.</span><br><span class="line">.#.#.###.#.</span><br><span class="line">.#.#..@#.#.</span><br><span class="line">.#.#####.#.</span><br><span class="line">.#.......#.</span><br><span class="line">.#########.</span><br><span class="line">...........</span><br><span class="line">11 6</span><br><span class="line">..#..#..#..</span><br><span class="line">..#..#..#..</span><br><span class="line">..#..#..###</span><br><span class="line">..#..#..#@.</span><br><span class="line">..#..#..#..</span><br><span class="line">..#..#..#..</span><br><span class="line">7 7</span><br><span class="line">..#.#..</span><br><span class="line">..#.#..</span><br><span class="line">###.###</span><br><span class="line">...@...</span><br><span class="line">###.###</span><br><span class="line">..#.#..</span><br><span class="line">..#.#..</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure></p><p>Sample Output</p><blockquote><p>45<br>59<br>6<br>13</p></blockquote><p>Problem solving:<br>对没错就是昨天那道题，用bfs可以写，用dfs也可以写。太强了。只要下一个还是可以走得就一直dfs查找下去就行。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">char s[25][25];</span><br><span class="line">int vis[25][25];</span><br><span class="line">int a,b,ans;</span><br><span class="line">int d[4][2]=&#123;1,0,0,1,0,-1,-1,0&#125;;</span><br><span class="line">void dfs(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">vis[x][y]=1;</span><br><span class="line">if(x&lt;0||x&gt;=b||y&lt;0||y&gt;=a)return ;</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">int dx=x+d[i][0];</span><br><span class="line">int dy=y+d[i][1];</span><br><span class="line">if(dx&gt;=0&amp;&amp;dx&lt;b&amp;&amp;dy&gt;=0&amp;&amp;dy&lt;a&amp;&amp;!vis[dx][dy]&amp;&amp;s[dx][dy]!=&apos;#&apos;)</span><br><span class="line">&#123;</span><br><span class="line">ans++;</span><br><span class="line">dfs(dx,dy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(cin&gt;&gt;a&gt;&gt;b)</span><br><span class="line">&#123;</span><br><span class="line">if(a==0&amp;&amp;b==0)break;</span><br><span class="line">ans=1;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">for(int i=0;i&lt;b;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;a;j++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;s[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        for(int i=0;i&lt;b;i++)</span><br><span class="line">for(int j=0;j&lt;a;j++)</span><br><span class="line">&#123;</span><br><span class="line">if(s[i][j]==&apos;@&apos;)dfs(i,j);</span><br><span class="line">&#125;        </span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天主要讲的是递归和DFS，因为涉及到递归，很抽象，所以比较难理解。题也很难做。
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="Algorithm" scheme="https://cndrew.cn/blog/tags/Algorithm/"/>
    
      <category term="c/c++" scheme="https://cndrew.cn/blog/tags/c-c/"/>
    
      <category term="CodeForces" scheme="https://cndrew.cn/blog/tags/CodeForces/"/>
    
      <category term="HDU" scheme="https://cndrew.cn/blog/tags/HDU/"/>
    
      <category term="poj" scheme="https://cndrew.cn/blog/tags/poj/"/>
    
      <category term="STL" scheme="https://cndrew.cn/blog/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>HPU Summer Training Day 7（河南理工大学暑期第七天）</title>
    <link href="https://cndrew.cn/blog/2019/07/23/d7/"/>
    <id>https://cndrew.cn/blog/2019/07/23/d7/</id>
    <published>2019-07-23T14:38:28.576Z</published>
    <updated>2019-07-23T14:49:03.567Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天主要讲了BFS和DFS，还有存图和链式前向星，后面这两个在今天刷题的过程中还没有遇到，晚会把他们加到我的模板里面。<a id="more"></a></p><h3 id="Rescue"><a href="#Rescue" class="headerlink" title="Rescue"></a>Rescue</h3><p>Description:<br>Angel was caught by the MOLIGPY! He was put in prison by Moligpy. The prison is described as a N * M (N, M &lt;= 200) matrix. There are WALLs, ROADs, and GUARDs in the prison.</p><p>Angel&#39;s friends want to save Angel. Their task is: approach Angel. We assume that &quot;approach Angel&quot; is to get to the position where Angel stays. When there&#39;s a guard in the grid, we must kill him (or her?) to move into the grid. We assume that we moving up, down, right, left takes us 1 unit time, and killing a guard takes 1 unit time, too. And we are strong enough to kill all the guards.</p><p>You have to calculate the minimal time to approach Angel. (We can move only UP, DOWN, LEFT and RIGHT, to the neighbor grid within bound, of course.)<br>Input</p><blockquote><p>First line contains two integers stand for N and M.<br>Then N lines follows, every line has M characters. &quot;.&quot; stands for road, &quot;a&quot; stands for Angel, and &quot;r&quot; stands for each of Angel&#39;s friend.<br>Process to the end of the file.</p></blockquote><p>Output</p><blockquote><p>For each test case, your program should output a single integer, standing for the minimal time needed. If such a number does no exist, you should output a line containing &quot;Poor ANGEL has to stay in the prison all his life.&quot;</p></blockquote><p>Sample Input<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">7 8</span><br><span class="line">#.#####.</span><br><span class="line">#.a#..r.</span><br><span class="line">#..#x...</span><br><span class="line">..#..#.#</span><br><span class="line">#...##..</span><br><span class="line">.#......</span><br><span class="line">........</span><br></pre></td></tr></table></figure></p><p>Sample Output</p><blockquote><p>13</p></blockquote><p>Problem solving:<br>注意是多组输入，这里用到了运算符重载和优先队列，这两个东西最近在刷题的过程中出现的频率很高。<br>因为这道题中r可能有多个所以我们用a去寻找r，用结构体存点的坐标，用优先队列存结构体实现BFS，先定义一个ans变量用来存放答案，初始化为-1，如果可以找到符合条件的点就更新ans的值并结束查找。查找结束之后，如果ans仍是-1，那么输出<code>Poor ANGEL has to stay in the prison all his life.</code>，否则就输出ans的值，查找过程就是bfs的模板，但是用的是优先队列。我们遇到X的时候只需要+2即可。其他的判断条件都挺好理解，可以直接看代码。</p><p>结构体如果想套到优先队列中就需要运算符重载。运算符重载的方法有好几种，这里我就会这一种。</p><p>Code<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">char s[205][205];</span><br><span class="line">int d[4][2]=&#123;-1,0,0,1,1,0,0,-1&#125;;</span><br><span class="line">struct node&#123;</span><br><span class="line">int x,y,step;</span><br><span class="line">friend bool operator &lt; (node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">return a.step&gt;b.step;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int n,m;</span><br><span class="line">int vis[205][205];</span><br><span class="line">void bfs(int x,int y,int xx,int yy)</span><br><span class="line">&#123;</span><br><span class="line">int ans=-1;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line">node mid,mmp;</span><br><span class="line">mid.x=x,mid.y=y,mid.step=0;</span><br><span class="line">vis[x][y]=1;</span><br><span class="line">q.push(mid);</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">mid=q.top();</span><br><span class="line">q.pop();</span><br><span class="line">if(mid.x==xx&amp;&amp;mid.y==yy)</span><br><span class="line">&#123;</span><br><span class="line">ans=mid.step;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">mmp.x=mid.x+d[i][0];</span><br><span class="line">mmp.y=mid.y+d[i][1];</span><br><span class="line">if(mmp.x&lt;0||mmp.x&gt;=n||mmp.y&lt;0||mmp.y&gt;=m||vis[mmp.x][mmp.y]==1||s[mmp.x][mmp.y]==&apos;#&apos;)continue;</span><br><span class="line">if(s[mmp.x][mmp.y]==&apos;x&apos;)mmp.step=mid.step+2;</span><br><span class="line">elsemmp.step=mid.step+1;</span><br><span class="line">q.push(mmp);</span><br><span class="line">vis[mmp.x][mmp.y]=1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(ans==-1)puts(&quot;Poor ANGEL has to stay in the prison all his life.&quot;);</span><br><span class="line">elsecout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int sx,sy,ex,ey;</span><br><span class="line">while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;m))</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;m;j++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;s[i][j];</span><br><span class="line">if(s[i][j]==&apos;a&apos;)</span><br><span class="line">&#123;</span><br><span class="line">sx=i;</span><br><span class="line">sy=j;</span><br><span class="line">&#125;</span><br><span class="line">if(s[i][j]==&apos;r&apos;)</span><br><span class="line">&#123;</span><br><span class="line">ex=i;</span><br><span class="line">ey=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bfs(sx,sy,ex,ey);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Red-and-Black"><a href="#Red-and-Black" class="headerlink" title="Red and Black"></a>Red and Black</h3><p>Description:<br>There is a rectangular room, covered with square tiles. Each tile is colored either red or black. A man is standing on a black tile. From a tile, he can move to one of four adjacent tiles. But he can&#39;t move on red tiles, he can move only on black tiles.</p><p>Write a program to count the number of black tiles which he can reach by repeating the moves described above.<br>Input</p><blockquote><p>The input consists of multiple data sets. A data set starts with a line containing two positive integers W and H; W and H are the numbers of tiles in the x- and y- directions, respectively. W and H are not more than 20.<br>There are H more lines in the data set, each of which includes W characters. Each character represents the color of a tile as follows.<br>&#39;.&#39; - a black tile<br>&#39;#&#39; - a red tile<br>&#39;@&#39; - a man on a black tile(appears exactly once in a data set)</p></blockquote><p>Output</p><blockquote><p>For each data set, your program should output a line which contains the number of tiles he can reach from the initial tile (including itself).</p></blockquote><p>Sample Input<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">6 9</span><br><span class="line">....#.</span><br><span class="line">.....#</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">#@...#</span><br><span class="line">.#..#.</span><br><span class="line">11 9</span><br><span class="line">.#.........</span><br><span class="line">.#.#######.</span><br><span class="line">.#.#.....#.</span><br><span class="line">.#.#.###.#.</span><br><span class="line">.#.#..@#.#.</span><br><span class="line">.#.#####.#.</span><br><span class="line">.#.......#.</span><br><span class="line">.#########.</span><br><span class="line">...........</span><br><span class="line">11 6</span><br><span class="line">..#..#..#..</span><br><span class="line">..#..#..#..</span><br><span class="line">..#..#..###</span><br><span class="line">..#..#..#@.</span><br><span class="line">..#..#..#..</span><br><span class="line">..#..#..#..</span><br><span class="line">7 7</span><br><span class="line">..#.#..</span><br><span class="line">..#.#..</span><br><span class="line">###.###</span><br><span class="line">...@...</span><br><span class="line">###.###</span><br><span class="line">..#.#..</span><br><span class="line">..#.#..</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure></p><p>Sample Output</p><blockquote><p>45<br>59<br>6<br>13</p></blockquote><p>Problem solving:<br>简单的BFS模板题，注意答案要加上一开始所处位置的点。</p><p>Code<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">char s[25][25];</span><br><span class="line">int vis[25][25];</span><br><span class="line">int d[4][2]=&#123;1,0,0,1,0,-1,-1,0&#125;;</span><br><span class="line">struct node&#123;</span><br><span class="line">int x,y;</span><br><span class="line">&#125;;</span><br><span class="line">int w,h;</span><br><span class="line">queue&lt;node&gt; que;</span><br><span class="line">void bfs(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">node mid,now,mmp;</span><br><span class="line">int ans=0;</span><br><span class="line">mid.x=x;</span><br><span class="line">mid.y=y;</span><br><span class="line">vis[x][y]=1;</span><br><span class="line">que.push(mid);</span><br><span class="line">while(!que.empty())</span><br><span class="line">&#123;</span><br><span class="line">now=que.front();</span><br><span class="line">que.pop();</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">mmp.x=now.x+d[i][0];</span><br><span class="line">mmp.y=now.y+d[i][1];</span><br><span class="line">if(mmp.x&lt;0||mmp.x&gt;=h||mmp.y&lt;0||mmp.y&gt;=w||vis[mmp.x][mmp.y]==1||s[mmp.x][mmp.y]==&apos;#&apos;)continue;</span><br><span class="line">ans++;</span><br><span class="line">vis[mmp.x][mmp.y]=1;</span><br><span class="line">que.push(mmp);</span><br><span class="line">s[mmp.x][mmp.y]=&apos;?&apos;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans+1&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int sx,sy;</span><br><span class="line">while(scanf(&quot;%d %d&quot;,&amp;w,&amp;h)&amp;&amp;w&amp;&amp;h)</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;h;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;w;j++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;s[i][j];</span><br><span class="line">if(s[i][j]==&apos;@&apos;)</span><br><span class="line">&#123;</span><br><span class="line">sx=i;</span><br><span class="line">sy=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//cout&lt;&lt;sx&lt;&lt;&quot; &quot;&lt;&lt;sy&lt;&lt;endl;</span><br><span class="line">bfs(sx,sy);</span><br><span class="line">//for(int i=0;i&lt;h;i++)</span><br><span class="line">//&#123;</span><br><span class="line">//for(int j=0;j&lt;w;j++)</span><br><span class="line">//&#123;</span><br><span class="line">//cout&lt;&lt;s[i][j];</span><br><span class="line">//&#125;</span><br><span class="line">//puts(&quot;&quot;);</span><br><span class="line">//&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Battle-City"><a href="#Battle-City" class="headerlink" title="Battle City"></a>Battle City</h3><p>Description:<br>Many of us had played the game &quot;Battle city&quot; in our childhood, and some people (like me) even often play it on computer now.<br><img src="https://i.loli.net/2019/07/23/5d36d872067fb73590.png" alt><br>What we are discussing is a simple edition of this game. Given a map that consists of empty spaces, rivers, steel walls and brick walls only. Your task is to get a bonus as soon as possible suppose that no enemies will disturb you (See the following picture).<br><img src="https://i.loli.net/2019/07/23/5d36d8964beff99419.png" alt><br>Your tank can&#39;t move through rivers or walls, but it can destroy brick walls by shooting. A brick wall will be turned into empty spaces when you hit it, however, if your shot hit a steel wall, there will be no damage to the wall. In each of your turns, you can choose to move to a neighboring (4 directions, not 8) empty space, or shoot in one of the four directions without a move. The shot will go ahead in that direction, until it go out of the map or hit a wall. If the shot hits a brick wall, the wall will disappear (i.e., in this turn). Well, given the description of a map, the positions of your tank and the target, how many turns will you take at least to arrive there?</p><p>Input</p><blockquote><p>The input consists of several test cases. The first line of each test case contains two integers M and N (2 &lt;= M, N &lt;= 300). Each of the following M lines contains N uppercase letters, each of which is one of &#39;Y&#39; (you), &#39;T&#39; (target), &#39;S&#39; (steel wall), &#39;B&#39; (brick wall), &#39;R&#39; (river) and &#39;E&#39; (empty space). Both &#39;Y&#39; and &#39;T&#39; appear only once. A test case of M = N = 0 indicates the end of input, and should not be processed.</p></blockquote><p>Output</p><blockquote><p>For each test case, please output the turns you take at least in a separate line. If you can&#39;t arrive at the target, output &quot;-1&quot; instead.</p></blockquote><p>Sample Input</p><blockquote><p>3 4<br>YBEB<br>EERE<br>SSTE<br>0 0</p></blockquote><p>Sample Output</p><blockquote><p>8</p></blockquote><p>Problem solving:<br>这道题跟A很像。用优先队列进行BFS查找。判断条件也很简单。不懂的话，可以直接看代码</p><p>Code<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int m,n;</span><br><span class="line">char s[305][305];</span><br><span class="line">int vis[305][305];</span><br><span class="line">struct node&#123;</span><br><span class="line">int x,y,step;</span><br><span class="line">friend bool operator &lt; (node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">return a.step&gt;b.step;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int d[4][2]=&#123;1,0,0,1,-1,0,0,-1&#125;;</span><br><span class="line">void bfs(int x,int y,int xx,int yy)</span><br><span class="line">&#123;</span><br><span class="line">int ans=-1;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">node mid,now;</span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line">mid.x=x;mid.y=y;mid.step=0;</span><br><span class="line">q.push(mid);</span><br><span class="line">vis[x][y]=1;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">mid=q.top();</span><br><span class="line">if(mid.x==xx&amp;&amp;mid.y==yy)</span><br><span class="line">&#123;</span><br><span class="line">//cout&lt;&lt;mid.x&lt;&lt;&quot; &quot;&lt;&lt;mid.y&lt;&lt;endl;</span><br><span class="line">ans=mid.step;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">q.pop();</span><br><span class="line">for(int i=0;i&lt;8;i++)</span><br><span class="line">&#123;</span><br><span class="line">now.x=mid.x+d[i][0];</span><br><span class="line">now.y=mid.y+d[i][1];</span><br><span class="line">if(now.x&lt;0||now.x&gt;=m||now.y&lt;0||now.y&gt;=n||s[now.x][now.y]==&apos;S&apos;||s[now.x][now.y]==&apos;R&apos;||vis[now.x][now.y]==1)continue;</span><br><span class="line">if(s[now.x][now.y]==&apos;B&apos;)now.step=mid.step+2;</span><br><span class="line">elsenow.step=mid.step+1;</span><br><span class="line">vis[now.x][now.y]=1;</span><br><span class="line">s[now.x][now.y]=now.step+&apos;0&apos;;</span><br><span class="line">q.push(now);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int sx,sy,ex,ey;</span><br><span class="line">while(scanf(&quot;%d %d&quot;,&amp;m,&amp;n)&amp;&amp;m&amp;&amp;n)</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;s[i][j];</span><br><span class="line">if(s[i][j]==&apos;Y&apos;)</span><br><span class="line">&#123;</span><br><span class="line">sx=i;</span><br><span class="line">sy=j;</span><br><span class="line">&#125;</span><br><span class="line">if(s[i][j]==&apos;T&apos;)</span><br><span class="line">&#123;</span><br><span class="line">ex=i;</span><br><span class="line">ey=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bfs(sx,sy,ex,ey);</span><br><span class="line">//for(int i=0;i&lt;m;i++)</span><br><span class="line">//&#123;</span><br><span class="line">//for(int j=0;j&lt;n;j++)</span><br><span class="line">//&#123;</span><br><span class="line">//cout&lt;&lt;s[i][j];</span><br><span class="line">//&#125;</span><br><span class="line">//puts(&quot;&quot;);</span><br><span class="line">//&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Catch-That-Cow"><a href="#Catch-That-Cow" class="headerlink" title="Catch That Cow"></a>Catch That Cow</h3><p>Description:<br>农夫知道一头牛的位置，想要抓住它。农夫和牛都于数轴上 ，农夫起始位于点 N(0&lt;=N&lt;=100000) ，牛位于点 K(0&lt;=K&lt;=100000) 。农夫有两种移动方式： 1、从 X移动到 X-1或X+1 ，每次移动花费一分钟 2、从 X移动到 2\X ，每次移动花费一分钟 假设牛没有意识到农夫的行动，站在原地不。最少要花多少时间才能抓住牛？<br>Input<br>一行: 以空格分隔的两个字母: N 和 K<br>Output<br>一行: 农夫抓住牛需要的最少时间，单位分钟<br>Sample Input</p><blockquote><p>5 17</p></blockquote><p>Sample Output</p><blockquote><p>4</p></blockquote><p>Hint<br>农夫使用最短时间抓住牛的方案如下: 5-10-9-18-17, 需要4分钟.</p><p>Problem solving:<br>经典的BFS例题。每次往下扩展队列的时候只有3种情况。就像是经常在图里面用到的四个方向一样。判断条件中要有一个最大值，不然就有可能会一直查找下去。</p><p>Code<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int vis[1000000];</span><br><span class="line">int step[1000000];</span><br><span class="line">void bfs(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">q.push(x);</span><br><span class="line">step[x]=0;</span><br><span class="line">vis[x]=1;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">int mid=q.front(),mmp;</span><br><span class="line">q.pop();</span><br><span class="line">if(mid==y)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;step[y]&lt;&lt;endl;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;3;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(i==0)mmp=mid-1;</span><br><span class="line">if(i==1)mmp=mid+1;</span><br><span class="line">if(i==2)mmp=mid*2;</span><br><span class="line">if(mmp&gt;=0&amp;&amp;mmp&lt;1000000&amp;&amp;vis[mmp]==0)</span><br><span class="line">&#123;</span><br><span class="line">q.push(mmp);</span><br><span class="line">step[mmp]=step[mid]+1;</span><br><span class="line">vis[mmp]=1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,k;</span><br><span class="line">while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;k))</span><br><span class="line">&#123;</span><br><span class="line">if(n&gt;=k)cout&lt;&lt;n-k&lt;&lt;endl;</span><br><span class="line">elsebfs(n,k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Dungeon-Master"><a href="#Dungeon-Master" class="headerlink" title="Dungeon Master"></a>Dungeon Master</h3><p>Description:<br>[NWUACM]<br>你被困在一个三维的空间中,现在要寻找最短路径逃生！<br>空间由立方体单位构成<br>你每次向上下前后左右移动一个单位需要一分钟<br>你不能对角线移动并且四周封闭<br>是否存在逃出生天的可能性？如果存在，则需要多少时间？</p><p>Input<br>输入第一行是一个数表示空间的数量。<br>每个空间的描述的第一行为L，R和C（皆不超过30）。<br>L表示空间的高度。<br>R和C分别表示每层空间的行与列的大小。<br>随后L层地牢，每层R行，每行C个字符。<br>每个字符表示空间的一个单元。&#39;#&#39;表示不可通过单元，&#39;.&#39;表示空白单元。你的起始位置在&#39;S&#39;，出口为&#39;E&#39;。<br>每层空间后都有一个空行。L，R和C均为0时输入结束。</p><p>Output - 输出<br>每个空间对应一行输出。<br>如果可以逃生，则输出如下<br>Escaped in x minute(s).<br>x为最短脱离时间。<br>如果无法逃生，则输出如下<br>Trapped!</p><p>Sample Input<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">3 4 5</span><br><span class="line">S....</span><br><span class="line">.###.</span><br><span class="line">.##..</span><br><span class="line">###.#</span><br><span class="line"></span><br><span class="line">#####</span><br><span class="line">#####</span><br><span class="line">##.##</span><br><span class="line">##...</span><br><span class="line"></span><br><span class="line">#####</span><br><span class="line">#####</span><br><span class="line">#.###</span><br><span class="line">####E</span><br><span class="line"></span><br><span class="line">1 3 3</span><br><span class="line">S##</span><br><span class="line">#E#</span><br><span class="line">###</span><br><span class="line"></span><br><span class="line">0 0 0</span><br></pre></td></tr></table></figure></p><p>Sample Output</p><blockquote><p>Escaped in 11 minute(s).<br>Trapped!</p></blockquote><p>Problem solving:<br>三维中的BFS，跟平常用到的差不多。不过是6个方向，上下左右前后，然后开三位数组进行BFS就好了</p><p>Code<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">char map[30][30][30];        </span><br><span class="line">int sta[30][30][30];        </span><br><span class="line">int base[6][3] = &#123; &#123;-1,0,0&#125;,&#123;1,0,0&#125;,&#123;0,-1,0&#125;,&#123;0,1,0&#125;,&#123;0,0,-1&#125;,&#123;0,0,1&#125; &#125;;</span><br><span class="line">int L, R, C;</span><br><span class="line">struct Piont</span><br><span class="line">&#123;</span><br><span class="line">    int x, y, z;            </span><br><span class="line">    int step;                </span><br><span class="line">&#125;;</span><br><span class="line">struct Piont s;               </span><br><span class="line">struct Piont e;               </span><br><span class="line">struct Piont curp;            </span><br><span class="line"></span><br><span class="line">bool success(struct Piont cur)</span><br><span class="line">&#123;</span><br><span class="line">    if (cur.x == e.x &amp;&amp; cur.y == e.y &amp;&amp; cur.z == e.z)</span><br><span class="line">        return true;</span><br><span class="line">    else</span><br><span class="line">        return false;</span><br><span class="line">&#125;</span><br><span class="line">bool check(int x, int y, int z)</span><br><span class="line">&#123;</span><br><span class="line">    if ((x &gt;= 0) &amp;&amp; (x &lt; L) &amp;&amp; (y &gt;= 0) &amp;&amp; (y &lt; R) &amp;&amp; (z &gt;= 0) &amp;&amp; (z &lt; C) &amp;&amp; (!sta[x][y][z]) &amp;&amp; (map[x][y][z] == &apos;.&apos; || map[x][y][z] == &apos;E&apos;))</span><br><span class="line">        return true;</span><br><span class="line">    else</span><br><span class="line">        return false;</span><br><span class="line">&#125;</span><br><span class="line">void bfs()</span><br><span class="line">&#123;</span><br><span class="line">    struct Piont next;</span><br><span class="line">    queue&lt;Piont&gt;q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    while (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        curp = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        if (success(curp))</span><br><span class="line">            return;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            sta[curp.x][curp.y][curp.z] = 1;</span><br><span class="line">            for (int i = 0; i &lt; 6; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                next.x = curp.x + base[i][0];</span><br><span class="line">                next.y = curp.y + base[i][1];</span><br><span class="line">                next.z = curp.z + base[i][2];</span><br><span class="line">                if (check(next.x, next.y, next.z))        </span><br><span class="line">                &#123;</span><br><span class="line">                    next.step = curp.step + 1;</span><br><span class="line">                    sta[next.x][next.y][next.z] = 1;</span><br><span class="line">                    q.push(next);</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while (scanf(&quot;%d%d%d&quot;, &amp;L, &amp;R, &amp;C))</span><br><span class="line">    &#123;</span><br><span class="line">        if((L == 0) &amp;&amp; (R == 0) &amp;&amp; (C == 0))</span><br><span class="line">            break;</span><br><span class="line">        memset(sta, 0, sizeof(sta));</span><br><span class="line">        for (int i = 0; i &lt; L; i++) &#123;</span><br><span class="line">            getchar();</span><br><span class="line">            for (int j = 0; j &lt; R; j++) &#123;</span><br><span class="line">                for (int k = 0; k &lt; C; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    scanf(&quot;%c&quot;, &amp;map[i][j][k]);</span><br><span class="line">                    if (map[i][j][k] == &apos;S&apos;) &#123;</span><br><span class="line">                        s.x = i;</span><br><span class="line">                        s.y = j;</span><br><span class="line">                        s.z = k;</span><br><span class="line">                        s.step = 0;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if (map[i][j][k] == &apos;E&apos;)</span><br><span class="line">                    &#123;</span><br><span class="line">                        e.x = i;</span><br><span class="line">                        e.y = j;</span><br><span class="line">                        e.z = k;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                getchar();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bfs();</span><br><span class="line">        if (curp.x == e.x &amp;&amp; curp.y == e.y &amp;&amp; curp.z == e.z)</span><br><span class="line">            printf(&quot;Escaped in %d minute(s).\n&quot;, curp.step);</span><br><span class="line">        else</span><br><span class="line">            printf(&quot;Trapped!\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Robot-Motion"><a href="#Robot-Motion" class="headerlink" title="Robot Motion"></a>Robot Motion</h3><p>Description:<br><img src="https://i.loli.net/2019/07/23/5d36d9a28aa0831996.png" alt><br>A robot has been programmed to follow the instructions in its path. Instructions for the next direction the robot is to move are laid down in a grid. The possible instructions are</p><p>N north (up the page)<br>S south (down the page)<br>E east (to the right on the page)<br>W west (to the left on the page)</p><p>For example, suppose the robot starts on the north (top) side of Grid 1 and starts south (down). The path the robot follows is shown. The robot goes through 10 instructions in the grid before leaving the grid.</p><p>Compare what happens in Grid 2: the robot goes through 3 instructions only once, and then starts a loop through 8 instructions, and never exits.</p><p>You are to write a program that determines how long it takes a robot to get out of the grid or how the robot loops around.<br>Input</p><blockquote><p>There will be one or more grids for robots to navigate. The data for each is in the following form. On the first line are three integers separated by blanks: the number of rows in the grid, the number of columns in the grid, and the number of the column in which the robot enters from the north. The possible entry columns are numbered starting with one at the left. Then come the rows of the direction instructions. Each grid will have at least one and at most 10 rows and columns of instructions. The lines of instructions contain only the characters N, S, E, or W with no blanks. The end of input is indicated by a row containing 0 0 0.</p></blockquote><p>Output</p><blockquote><p>For each grid in the input there is one line of output. Either the robot follows a certain number of instructions and exits the grid on any one the four sides or else the robot follows the instructions on a certain number of locations once, and then the instructions on some number of locations repeatedly. The sample input below corresponds to the two grids above and illustrates the two forms of output. The word &quot;step&quot; is always immediately followed by &quot;(s)&quot; whether or not the number before it is 1.</p></blockquote><p>Sample Input</p><blockquote><p>3 6 5<br>NEESWE<br>WWWESS<br>SNWWWW<br>4 5 1<br>SESWE<br>EESNW<br>NWEEN<br>EWSEN<br>0 0 0</p></blockquote><p>Sample Output</p><blockquote><p>10 step(s) to exit<br>3 step(s) before a loop of 8 step(s)</p></blockquote><p>Problem solving:<br>这道题我是CSDN上搜的，一开始有思路不知道怎么实现。<br>但是我们可以发现这个里面每个点就会决定自己下一步是往哪里走，所以情况是唯一的。可以直接模拟。<br>这个模拟方式很巧妙地就是标记了走到任意一个位置需要的步数，如果是走出去了，直接调用中间用来存放步数的变量的值进行输出就行。如果在循环的过程中发现下一个要去到的点对应的步数的数组已经有值了就说明此时是在里面刚好转了一圈了。而转圈之前走的步数正好是从开始走走到这个点用到的步数减一，<br>每次转圈的长度就可以用存放步数的变量的值减去到达转圈的第一个点所需要的步数来得到（可以看着代码理解，模拟一下。</p><p>Code<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">char s[12][12];</span><br><span class="line">int vis[12][12];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a,b,c;</span><br><span class="line">while(scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c))</span><br><span class="line">&#123;</span><br><span class="line">if(a==0&amp;&amp;b==0&amp;&amp;c==0)break;</span><br><span class="line">for(int i=0;i&lt;a;i++)</span><br><span class="line">for(int j=0;j&lt;b;j++)</span><br><span class="line">cin&gt;&gt;s[i][j];</span><br><span class="line">int x=0,y=c-1,step=0;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">while(true)</span><br><span class="line">&#123;</span><br><span class="line">step++;</span><br><span class="line">if(s[x][y]==&apos;N&apos;&amp;&amp;!vis[x][y])</span><br><span class="line">&#123;</span><br><span class="line">vis[x][y]=step;</span><br><span class="line">x--;</span><br><span class="line">&#125;</span><br><span class="line">else if(s[x][y]==&apos;S&apos;&amp;&amp;!vis[x][y])</span><br><span class="line">&#123;</span><br><span class="line">vis[x][y]=step;</span><br><span class="line">x++;</span><br><span class="line">&#125;</span><br><span class="line">else if(s[x][y]==&apos;W&apos;&amp;&amp;!vis[x][y])</span><br><span class="line">&#123;</span><br><span class="line">vis[x][y]=step;</span><br><span class="line">y--;</span><br><span class="line">&#125;</span><br><span class="line">else if(s[x][y]==&apos;E&apos;&amp;&amp;!vis[x][y])</span><br><span class="line">&#123;</span><br><span class="line">vis[x][y]=step;</span><br><span class="line">y++;</span><br><span class="line">&#125;</span><br><span class="line">if(x&lt;0||x==a||y&lt;0||y==b)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d step(s) to exit\n&quot;,step);break;</span><br><span class="line">&#125;</span><br><span class="line">else if(vis[x][y])</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d step(s) before a loop of %d step(s)\n&quot;,vis[x][y]-1,step+1-vis[x][y]);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Number-Transformation"><a href="#Number-Transformation" class="headerlink" title="Number Transformation"></a>Number Transformation</h3><p>Description:<br>In this problem, you are given an integer number s. You can transform any integer number A to another integer number B by adding x to A. This x is an integer number which is a prime factor of A (please note that 1 and A are not being considered as a factor of A). Now, your task is to find the minimum number of transformations required to transform s to another integer number t.</p><p>Input</p><blockquote><p>Input starts with an integer T (≤ 500), denoting the number of test cases.<br>Each case contains two integers: s (1 ≤ s ≤ 100) and t (1 ≤ t ≤ 1000).</p></blockquote><p>Output</p><blockquote><p>For each case, print the case number and the minimum number of transformations needed. If it&#39;s impossible, then print -1.</p></blockquote><p>Sample Input</p><blockquote><p>2<br>6 12<br>6 13</p></blockquote><p>Sample Output</p><blockquote><p>Case 1: 2<br>Case 2: -1</p></blockquote><p>Problem solving:<br>暴力解决就行，数据范围很小。<br>先对素数打表，然后再进行BFS查找即可。<br>BFS中扩展队列的方式<br>对输入的s，求出s的每个质因子加上它本身之后放进队列，如果出现了与t相同的情况，退出查找即可。关于特殊情况的判定我们还用A题的方式，定义一个ans变量初始值设为-1，如果出现了相等的就对ans进行更新即可。注意，如果在扩展队列的过程中遇到了之前已经出现过的数或者这个数已经大于了t，就不需要再把这个数放进队列了。</p><p>Code<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 2005;</span><br><span class="line">int p[2005];</span><br><span class="line">int vis[2005];</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">p[1]=p[0]=1;</span><br><span class="line">for(int i=2;i&lt;sqrt(maxn);i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=i*2;j&lt;maxn;j+=i)</span><br><span class="line">p[j]=1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">struct node&#123;</span><br><span class="line">int x,step;</span><br><span class="line">&#125;;</span><br><span class="line">int flag;</span><br><span class="line">void bfs(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">flag=-1;</span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line">node now,mid;</span><br><span class="line">now.x=x;now.step=0;</span><br><span class="line">vis[x]=1;</span><br><span class="line">q.push(now);</span><br><span class="line">int ans=-1;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">now=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">for(int i=2;i&lt;now.x;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(now.x%i==0&amp;&amp;!p[i])</span><br><span class="line">&#123;</span><br><span class="line">mid.x=now.x+i;</span><br><span class="line">if(vis[mid.x]||mid.x&gt;y)continue;</span><br><span class="line">vis[mid.x]=1;</span><br><span class="line">mid.step=now.step+1;</span><br><span class="line">if(mid.x==y)</span><br><span class="line">&#123;</span><br><span class="line">flag=mid.step;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">q.push(mid);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,a,b;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">init();</span><br><span class="line">int cnt=1;</span><br><span class="line">while(n--)</span><br><span class="line">&#123;</span><br><span class="line">int a,b;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">cout&lt;&lt;&quot;Case &quot;&lt;&lt;cnt++&lt;&lt;&quot;: &quot;;</span><br><span class="line">if(a==b)</span><br><span class="line">&#123;</span><br><span class="line">puts(&quot;0&quot;);</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">bfs(a,b);</span><br><span class="line">cout&lt;&lt;flag&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Knight-Moves"><a href="#Knight-Moves" class="headerlink" title="Knight Moves"></a>Knight Moves</h3><p>Description:<br>A friend of you is doing research on the Traveling Knight Problem (TKP) where you are to find the shortest closed tour of knight moves that visits each square of a given set of n squares on a chessboard exactly once. He thinks that the most difficult part of the problem is determining the smallest number of knight moves between two given squares and that, once you have accomplished this, finding the tour would be easy.<br>Of course you know that it is vice versa. So you offer him to write a program that solves the &quot;difficult&quot; part.</p><p>Your job is to write a program that takes two squares a and b as input and then determines the number of knight moves on a shortest route from a to b.<br>Input</p><blockquote><p>The input file will contain one or more test cases. Each test case consists of one line containing two squares separated by one space. A square is a string consisting of a letter (a-h) representing the column and a digit (1-8) representing the row on the chessboard.</p></blockquote><p>Output</p><blockquote><p>For each test case, print one line saying &quot;To get from xx to yy takes n knight moves.&quot;.</p></blockquote><p>Sample Input</p><blockquote><p>e2 e4<br>a1 b2<br>b2 c3<br>a1 h8<br>a1 h7<br>h8 a1<br>b1 c3<br>f6 f6</p></blockquote><p>Sample Output</p><blockquote><p>To get from e2 to e4 takes 2 knight moves.<br>To get from a1 to b2 takes 4 knight moves.<br>To get from b2 to c3 takes 2 knight moves.<br>To get from a1 to h8 takes 6 knight moves.<br>To get from a1 to h7 takes 5 knight moves.<br>To get from h8 to a1 takes 6 knight moves.<br>To get from b1 to c3 takes 1 knight moves.<br>To get from f6 to f6 takes 0 knight moves.</p></blockquote><p>Problem solving:<br>这道题就是一道简单的BFS模板题，只不过题不太好懂，这里我找到一张图可以参考一下。<br><img src="https://i.loli.net/2019/07/23/5d36d61f72c1f58484.png" alt><br>就是马走日的问题，分8个方向进行查找即可。从图上就可以以看出输入的字符串如何处理成坐标的形式。即<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while(~scanf(&quot;%s %s&quot;,a,b))</span><br><span class="line">&#123;</span><br><span class="line">sx=a[0]-&apos;a&apos;+1;sy=a[1]-&apos;0&apos;;ex=b[0]-&apos;a&apos;+1;ey=b[1]-&apos;0&apos;;</span><br></pre></td></tr></table></figure></p><p>Code<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int vis[10][10],sx,sy,ex,ey;</span><br><span class="line">struct node&#123;</span><br><span class="line">int x,y,step;</span><br><span class="line">&#125;;</span><br><span class="line">int d[8][2]=&#123;-2,-1, -1,-2, 1,-2, 2,-1, 2,1, 1,2, -1,2, -2,1&#125;;</span><br><span class="line">int bfs(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">queue&lt;node&gt; que;</span><br><span class="line">vis[x][y]=1;</span><br><span class="line">node now,mid;</span><br><span class="line">now.x=x;now.y=y;now.step=0;</span><br><span class="line">que.push(now);</span><br><span class="line">while(!que.empty())</span><br><span class="line">&#123;</span><br><span class="line">now=que.front();que.pop();</span><br><span class="line">if(now.x==ex&amp;&amp;now.y==ey)</span><br><span class="line">&#123;</span><br><span class="line">return now.step;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;8;i++)</span><br><span class="line">&#123;</span><br><span class="line">mid.x=now.x+d[i][0];</span><br><span class="line">mid.y=now.y+d[i][1];</span><br><span class="line">if(mid.x&lt;=0||mid.x&gt;8||mid.y&lt;=0||mid.y&gt;8||vis[mid.x][mid.y])continue;</span><br><span class="line">vis[mid.x][mid.y]=1;</span><br><span class="line">mid.step=now.step+1;</span><br><span class="line">que.push(mid);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">char a[3],b[3];</span><br><span class="line">while(~scanf(&quot;%s %s&quot;,a,b))</span><br><span class="line">&#123;</span><br><span class="line">int m;</span><br><span class="line">sx=a[0]-&apos;a&apos;+1;sy=a[1]-&apos;0&apos;;ex=b[0]-&apos;a&apos;+1;ey=b[1]-&apos;0&apos;;</span><br><span class="line">//cout&lt;&lt;sx&lt;&lt;sy&lt;&lt;ex&lt;&lt;ey&lt;&lt;endl;</span><br><span class="line">m=bfs(sx,sy);</span><br><span class="line">cout&lt;&lt;&quot;To get from &quot;&lt;&lt;a&lt;&lt;&quot; to &quot;&lt;&lt;b&lt;&lt;&quot; takes &quot;&lt;&lt;m&lt;&lt;&quot; knight moves.&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//To get from e2 to e4 takes 2 knight moves.</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天主要讲了BFS和DFS，还有存图和链式前向星，后面这两个在今天刷题的过程中还没有遇到，晚会把他们加到我的模板里面。
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="Algorithm" scheme="https://cndrew.cn/blog/tags/Algorithm/"/>
    
      <category term="DFS" scheme="https://cndrew.cn/blog/tags/DFS/"/>
    
      <category term="Thinking" scheme="https://cndrew.cn/blog/tags/Thinking/"/>
    
      <category term="Simulation" scheme="https://cndrew.cn/blog/tags/Simulation/"/>
    
      <category term="BFS" scheme="https://cndrew.cn/blog/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>HPU Summer Training Day 6（河南理工大学暑期第六天）</title>
    <link href="https://cndrew.cn/blog/2019/07/22/d6/"/>
    <id>https://cndrew.cn/blog/2019/07/22/d6/</id>
    <published>2019-07-22T14:19:00.504Z</published>
    <updated>2019-07-24T14:10:32.356Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天主要讲的是二分和贪心，题有点难。已经开始了不能写完题的日子了<a id="more"></a></p><h3 id="Pie"><a href="#Pie" class="headerlink" title="Pie"></a>Pie</h3><p>Description:<br>My birthday is coming up and traditionally I&#39;m serving pie. Not just one pie, no, I have a number N of them, of various tastes and of various sizes. F of my friends are coming to my party and each of them gets a piece of pie. This should be one piece of one pie, not several small pieces since that looks messy. This piece can be one whole pie though.</p><p>My friends are very annoying and if one of them gets a bigger piece than the others, they start complaining. Therefore all of them should get equally sized (but not necessarily equally shaped) pieces, even if this leads to some pie getting spoiled (which is better than spoiling the party). Of course, I want a piece of pie for myself too, and that piece should also be of the same size.</p><p>What is the largest possible piece size all of us can get? All the pies are cylindrical in shape and they all have the same height 1, but the radii of the pies can be different.<br>Input<br>One line with a positive integer: the number of test cases. Then for each test case:<br>---One line with two integers N and F with 1 &lt;= N, F &lt;= 10 000: the number of pies and the number of friends.<br>---One line with N integers ri with 1 &lt;= ri &lt;= 10 000: the radii of the pies.<br>Output<br>For each test case, output one line with the largest possible volume V such that me and my friends can all get a pie piece of size V. The answer should be given as a floating point number with an absolute error of at most 10^(-3).<br>Sample Input</p><blockquote><p>3<br>3 3<br>4 3 3<br>1 24<br>5<br>10 5<br>1 4 2 3 4 5 6 5 4 2</p></blockquote><p>Sample Output</p><blockquote><p>25.1327<br>3.1416<br>50.2655</p></blockquote><p>Problem solving:<br>注意到人数也得算得上自己，然后因为每个人分到的pie必须是一块（所以不可以平均分），这个时候就用到二分答案了。<br>二分中检测是否满足题意的判断方法是，用一个for循环计算出以每人分到mid面积时可以分给多少人，跟需要分到的人数进行比较就行了。<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const double pi = acos(-1.0);</span><br><span class="line">double       s[10005];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    while (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        int a, b, x; double sum = 0, pm = 0;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        b += 1;</span><br><span class="line">        for (int i = 0; i &lt; a; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            s[i] = x * x * pi;</span><br><span class="line">            sum += s[i];</span><br><span class="line">            pm   = max(pm, s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        double l = 0, r = sum / b, mid;</span><br><span class="line">        while (r - l &gt; 0.000001)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (r + l) / 2;</span><br><span class="line">            int now = 0;</span><br><span class="line">            for (int i = 0; i &lt; a; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                now += int(s[i] / mid);</span><br><span class="line">            &#125;</span><br><span class="line">            if (now &lt; b)</span><br><span class="line">                r = mid;</span><br><span class="line">            else</span><br><span class="line">                l = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%.4lf\n&quot;, mid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Best-Cow-Line"><a href="#Best-Cow-Line" class="headerlink" title="Best Cow Line"></a>Best Cow Line</h3><p>Description:<br>FJ is about to take his N (1 ≤ N ≤ 2,000) cows to the annual&quot;Farmer of the Year&quot; competition. In this contest every farmer arranges his cows in a line and herds them past the judges.</p><p>The contest organizers adopted a new registration scheme this year: simply register the initial letter of every cow in the order they will appear (i.e., If FJ takes Bessie, Sylvia, and Dora in that order he just registers BSD). After the registration phase ends, every group is judged in increasing lexicographic order according to the string of the initials of the cows&#39; names.</p><p>FJ is very busy this year and has to hurry back to his farm, so he wants to be judged as early as possible. He decides to rearrange his cows, who have already lined up, before registering them.</p><p>FJ marks a location for a new line of the competing cows. He then proceeds to marshal the cows from the old line to the new one by repeatedly sending either the first or last cow in the (remainder of the) original line to the end of the new line. When he&#39;s finished, FJ takes his cows for registration in this new order.</p><p>Given the initial order of his cows, determine the least lexicographic string of initials he can make this way.</p><p>Input</p><ul><li>Line 1: A single integer: N</li><li>Lines 2: N+1: Line i+1 contains a single initial (&#39;A&#39;..&#39;Z&#39;) of the cow in the ith position in the original line</li></ul><p>Output<br>The least lexicographic string he can make. Every line (except perhaps the last one) contains the initials of 80 cows (&#39;A&#39;..&#39;Z&#39;) in the new line.</p><p>Sample Input</p><blockquote><p>6<br>A<br>C<br>D<br>B<br>C<br>B</p></blockquote><p>Sample Output</p><blockquote><p>ABCBCD</p></blockquote><p>Problem solving:<br>白书原题，经典贪心问题。先比较当前的第一个和最后一个字符，如果想等就比较第二个和倒数第二个字符，以此找到前后字符的大小关系，然后进行删除和添加的操作就行了。具体看代码。<br>注意，每输出80个字符就得换行！！！</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n;</span><br><span class="line">char a[2005];</span><br><span class="line">void solve()</span><br><span class="line">&#123;</span><br><span class="line">int p=0,x=0,b=n-1;</span><br><span class="line">while(x&lt;=b)</span><br><span class="line">&#123;</span><br><span class="line">int flag=0;</span><br><span class="line">for(int i=0;x+i&lt;=b;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(a[x+i]&lt;a[b-i])</span><br><span class="line">&#123;</span><br><span class="line">flag=1;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">else if(a[x+i]&gt;a[b-i])</span><br><span class="line">&#123;</span><br><span class="line">flag=0;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(flag)putchar(a[x++]);</span><br><span class="line">elseputchar(a[b--]);</span><br><span class="line">p++;</span><br><span class="line">if(p%80==0)puts(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">puts(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i=0;i&lt;n;i++)cin&gt;&gt;a[i];</span><br><span class="line">solve();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Trailing-Zeroes-III"><a href="#Trailing-Zeroes-III" class="headerlink" title="Trailing Zeroes (III)"></a>Trailing Zeroes (III)</h3><p>Description:<br>You task is to find minimal natural number N, so that N! contains exactly Q zeroes on the trail in decimal notation. As you know N! = 1<em>2</em>...*N. For example, 5! = 120, 120 contains one zero on the trail.</p><p>Input<br>Input starts with an integer T (≤ 10000), denoting the number of test cases.</p><p>Each case contains an integer Q (1 ≤ Q ≤ 1e8) in a line.</p><p>Output<br>For each case, print the case number and N. If no solution is found then print &#39;impossible&#39;.</p><p>Sample Input</p><blockquote><p>3<br>1<br>2<br>5</p></blockquote><p>Sample Output</p><blockquote><p>Case 1: 5<br>Case 2: 10<br>Case 3: impossible</p></blockquote><p>Problem solving:<br>求n的阶乘的0的个数，只需要求得n中5得个数即可。因为只有2*5=10，所以每一个0都对应着一个2和一个5，而二的个数多于5，所以我们只要找到5得个数就是0得个数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">\\找5得个数得方法</span><br><span class="line">long long co(long long x)</span><br><span class="line">&#123;</span><br><span class="line">    long long ans = 0;</span><br><span class="line">    while (x)</span><br><span class="line">    &#123;</span><br><span class="line">        ans += x / 5;</span><br><span class="line"></span><br><span class="line">        x /= 5;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>剩下的就是二分答案。注意这道题存在着“impossible”得情况，所以在二分得过程中如果遇到了满足题意得mid，一定要记录下来。方便后面判断。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">long long co(long long x)</span><br><span class="line">&#123;</span><br><span class="line">    long long ans = 0;</span><br><span class="line">    while (x)</span><br><span class="line">    &#123;</span><br><span class="line">        ans += x / 5;</span><br><span class="line"></span><br><span class="line">        x /= 5;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    long long t, q;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    long long cas = 1;</span><br><span class="line">    while (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; q; long long flag = 0;</span><br><span class="line">        long long           l = 1, r = 1000000000000, mid;</span><br><span class="line">        while (l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (l + r) / 2;</span><br><span class="line">            if (co(mid) == q)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = mid;</span><br><span class="line">                r    = mid - 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (co(mid) &gt; q)</span><br><span class="line">                r = mid - 1;</span><br><span class="line">            else</span><br><span class="line">                l = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (flag)</span><br><span class="line">            cout &lt;&lt; &quot;Case &quot; &lt;&lt; cas++ &lt;&lt; &quot;: &quot; &lt;&lt; flag &lt;&lt; endl;</span><br><span class="line">        else</span><br><span class="line">            cout &lt;&lt; &quot;Case &quot; &lt;&lt; cas++ &lt;&lt; &quot;: &quot; &lt;&lt; &quot;impossible&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="The-Frog-39-s-Games"><a href="#The-Frog-39-s-Games" class="headerlink" title="The Frog&#39;s Games"></a>The Frog&#39;s Games</h3><p>Description:<br>The annual Games in frogs&#39; kingdom started again. The most famous game is the Ironfrog Triathlon. One test in the Ironfrog Triathlon is jumping. This project requires the frog athletes to jump over the river. The width of the river is L (1&lt;= L &lt;= 1000000000). There are n (0&lt;= n &lt;= 500000) stones lined up in a straight line from one side to the other side of the river. The frogs can only jump through the river, but they can land on the stones. If they fall into the river, they<br>are out. The frogs was asked to jump at most m (1&lt;= m &lt;= n+1) times. Now the frogs want to know if they want to jump across the river, at least what ability should they have. (That is the frog&#39;s longest jump distance).<br>Input<br>The input contains several cases. The first line of each case contains three positive integer L, n, and m.<br>Then n lines follow. Each stands for the distance from the starting banks to the nth stone, two stone appear in one place is impossible.<br>Output<br>For each case, output a integer standing for the frog&#39;s ability at least they should have.<br>Sample Input</p><blockquote><p>6 1 2<br>2<br>25 3 3<br>11<br>2<br>18</p></blockquote><p>Sample Output</p><blockquote><p>4<br>11</p></blockquote><p>Problem solving:<br>题意就是让你找到青蛙得最大的最小弹跳力，即每次可以跳的最远距离。<br>左边界时每个石头间距的最大值，右边界是河的宽度，然后进行二分。每次二分的时候，找到处于当前位置位置的青蛙跳一次mid的距离刚好最小到达的点，然后进行下一次循环（具体看代码吧）<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=500005;</span><br><span class="line">int a[maxn];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int i,L,n,m;</span><br><span class="line">while(scanf(&quot;%d%d%d&quot;,&amp;L,&amp;n,&amp;m)!=EOF)</span><br><span class="line">&#123;</span><br><span class="line">memset(a,0,sizeof(a));</span><br><span class="line">for(i=1;i&lt;=n;i++)</span><br><span class="line">scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">a[n+1]=L;</span><br><span class="line">sort(a+1,a+n+2);</span><br><span class="line">int maxx=0;</span><br><span class="line">for(i=1;i&lt;=n+1;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(a[i]-a[i-1]&gt;maxx)</span><br><span class="line">maxx=a[i]-a[i-1];</span><br><span class="line">&#125;</span><br><span class="line">int l=maxx,r=L;</span><br><span class="line">while(l&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line">int ans=0,pos=0;</span><br><span class="line">int mid=(l+r)/2;</span><br><span class="line">for(i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(a[i]-a[pos]&lt;=mid&amp;&amp;a[i+1]-a[pos]&gt;mid)//i即为青蛙跳一次之后到达的最远的石头</span><br><span class="line">&#123;</span><br><span class="line">pos=i;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans++;</span><br><span class="line">if(ans&lt;=m)r=mid-1;</span><br><span class="line">elsel=mid+1;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d\n&quot;,l);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="湫湫系列故事——消灭兔子"><a href="#湫湫系列故事——消灭兔子" class="headerlink" title="湫湫系列故事——消灭兔子"></a>湫湫系列故事——消灭兔子</h3><p>Description:<br>湫湫减肥<br>　　越减越肥！<br>　　<br>　　最近，减肥失败的湫湫为发泄心中郁闷，在玩一个消灭免子的游戏。<br>　　游戏规则很简单，用箭杀死免子即可。<br>　　箭是一种消耗品，已知有M种不同类型的箭可以选择，并且每种箭都会对兔子造成伤害，对应的伤害值分别为Di（1 &lt;= i &lt;= M），每种箭需要一定的QQ币购买。<br>　　假设每种箭只能使用一次，每只免子也只能被射一次，请计算要消灭地图上的所有兔子最少需要的QQ币。<br>Input<br>输入数据有多组，每组数据有四行；<br>第一行有两个整数N，M（1 &lt;= N, M &lt;= 100000），分别表示兔子的个数和箭的种类；<br>第二行有N个正整数，分别表示兔子的血量Bi（1 &lt;= i &lt;= N）；<br>第三行有M个正整数，表示每把箭所能造成的伤害值Di（1 &lt;= i &lt;= M）；<br>第四行有M个正整数，表示每把箭需要花费的QQ币Pi（1 &lt;= i &lt;= M）。</p><p>特别说明：<br>1、当箭的伤害值大于等于兔子的血量时，就能将兔子杀死；<br>2、血量Bi，箭的伤害值Di，箭的价格Pi，均小于等于100000。<br>Output<br>如果不能杀死所有兔子，请输出”No”，否则，请输出最少的QQ币数，每组输出一行。<br>Sample Input</p><blockquote><p>3 3<br>1 2 3<br>2 3 4<br>1 2 3<br>3 4<br>1 2 3<br>1 2 3 4<br>1 2 3 1</p></blockquote><p>Sample Output</p><blockquote><p>6<br>4</p></blockquote><p>Problem solving:<br>将兔子的血量进行降序排序，然后将剑按照攻击力降序排列，如果攻击力相等就按照qq币的花费降序排列。<br>要用到优先队列，对降序排列的兔子，找到攻击力大于它的剑，放进优先队列，直到攻击力小于兔子的血量，然后答案加上优先队列顶部的qq消费。如果兔子还没杀完队列就为空了，就输出no。贪心的思想。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e5+10;</span><br><span class="line">struct node&#123;</span><br><span class="line">int d,p;</span><br><span class="line">friend bool operator &lt; (node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">return a.p&gt;b.p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;x[maxn];</span><br><span class="line">int b[maxn];</span><br><span class="line">bool cmp2(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">return x&gt;y;</span><br><span class="line">&#125;</span><br><span class="line">bool cmp(node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">if(a.d==b.d)return a.p&gt;b.p;</span><br><span class="line">return a.d&gt;b.d;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,m;</span><br><span class="line">while(cin&gt;&gt;n&gt;&gt;m)</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;n;i++)cin&gt;&gt;b[i];</span><br><span class="line">sort(b,b+n,cmp2);</span><br><span class="line">for(int i=0;i&lt;m;i++)cin&gt;&gt;x[i].d;</span><br><span class="line">for(int i=0;i&lt;m;i++)cin&gt;&gt;x[i].p;</span><br><span class="line">sort(x,x+m,cmp);</span><br><span class="line">priority_queue&lt;node&gt; sta;</span><br><span class="line">int pos=0;</span><br><span class="line">long long ans=0;</span><br><span class="line">int flag=0;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">while(x[pos].d&gt;=b[i]&amp;&amp;pos&lt;m)</span><br><span class="line">&#123;</span><br><span class="line">sta.push(x[pos]);</span><br><span class="line">//cout&lt;&lt;x[pos].d&lt;&lt;&quot; &quot;&lt;&lt;x[pos].p&lt;&lt;endl;</span><br><span class="line">pos++;</span><br><span class="line">&#125;</span><br><span class="line">if(sta.empty())</span><br><span class="line">&#123;</span><br><span class="line">flag=1;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">//cout&lt;&lt;sta.top().p&lt;&lt;&quot;?\n&quot;;</span><br><span class="line">ans+=sta.top().p;</span><br><span class="line">sta.pop();</span><br><span class="line">&#125;</span><br><span class="line">if(flag)puts(&quot;No&quot;);</span><br><span class="line">elsecout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Strange-fuction"><a href="#Strange-fuction" class="headerlink" title="Strange fuction"></a>Strange fuction</h3><p>Description:<br>Now, here is a fuction:<br>  F(x) = 6 <em> x^7+8</em>x^6+7<em>x^3+5</em>x^2-y*x (0 &lt;= x &lt;=100)<br>Can you find the minimum value when x is between 0 and 100.<br>Input<br>The first line of the input contains an integer T(1&lt;=T&lt;=100) which means the number of test cases. Then T lines follow, each line has only one real numbers Y.(0 &lt; Y &lt;1e10)<br>Output<br>Just the minimum value (accurate up to 4 decimal places),when x is between 0 and 100.<br>Sample Input</p><blockquote><p>2<br>100<br>200</p></blockquote><p>Sample Output</p><blockquote><p>-74.4291<br>-178.8534</p></blockquote><p>Problem solving:<br>简单的数学题，求函数极值，对函数求一阶导，另它为0即可，因为本题中二次导之后函数恒大于0所以一阶导为0求出来的极值就是极小值。确定x的值得时候用二分确定</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int    t;</span><br><span class="line">    double y;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; y;</span><br><span class="line">        double l = 0, r = 100, x;</span><br><span class="line">        while (r - l &gt; 0.000001)</span><br><span class="line">        &#123;</span><br><span class="line">            x = (l + r) / 2;</span><br><span class="line">            double mmp;</span><br><span class="line">            mmp = 42 * pow(x, 6) + 48 * pow(x, 5) + 21 * pow(x, 2) + 10 * x;</span><br><span class="line">            if (mmp &lt; y)</span><br><span class="line">                l = x;</span><br><span class="line">            else</span><br><span class="line">                r = x;</span><br><span class="line">        &#125;</span><br><span class="line">        double ans = 6 * pow(x, 7) + 8 * pow(x, 6) + 7 * pow(x, 3) + 5 * x * x - y * x;</span><br><span class="line">        printf(&quot;%.4lf\n&quot;, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Can-you-find-it"><a href="#Can-you-find-it" class="headerlink" title="Can you find it?"></a>Can you find it?</h3><p>Description:<br>Give you three sequences of numbers A, B, C, then we give you a number X. Now you need to calculate if you can find the three numbers Ai, Bj, Ck, which satisfy the formula Ai+Bj+Ck = X.<br>Input<br>There are many cases. Every data case is described as followed: In the first line there are three integers L, N, M, in the second line there are L integers represent the sequence A, in the third line there are N integers represent the sequences B, in the forth line there are M integers represent the sequence C. In the fifth line there is an integer S represents there are S integers X to be calculated. 1&lt;=L, N, M&lt;=500, 1&lt;=S&lt;=1000. all the integers are 32-integers.<br>Output<br>For each case, firstly you have to print the case number as the form &quot;Case d:&quot;, then for the S queries, you calculate if the formula can be satisfied or not. If satisfied, you print &quot;YES&quot;, otherwise print &quot;NO&quot;.<br>Sample Input</p><blockquote><p>3 3 3<br>1 2 3<br>1 2 3<br>1 2 3<br>3<br>1<br>4<br>10</p></blockquote><p>Sample Output</p><blockquote><p>Case 1:<br>NO<br>YES<br>NO</p></blockquote><p>Problem solving:<br>优雅的暴力之后再二分查找。<br>把前两个数组可以组成的所有的和用一个数组存下来（这一步最坏的情况的复杂度也才O（2e5），显然不会超时。然后对接下来输入的需要判断的每个值进行查找，对第三个数组中的每一个数<br>使用二分查找去找两者的差值再上一步得到的新数组中有没有存在。有即YES，否则就是NO。<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 505;</span><br><span class="line">int       a[maxn], b[maxn], c[maxn], d[250005];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int l, n, m, cas = 0;</span><br><span class="line">    while (~scanf(&quot;%d %d %d&quot;, &amp;l, &amp;n, &amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i &lt; l; i++)</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        for (int j = 0; j &lt; n; j++)</span><br><span class="line">            cin &gt;&gt; b[j];</span><br><span class="line">        for (int k = 0; k &lt; m; k++)</span><br><span class="line">            cin &gt;&gt; c[k];</span><br><span class="line">        int pos = 0;</span><br><span class="line">        sort(a, a + l); sort(b, b + n);</span><br><span class="line">        for (int i = 0; i &lt; l; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                d[pos++] = a[i] + b[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(d, d + pos); sort(c, c + m);</span><br><span class="line">        cout &lt;&lt; &quot;Case &quot; &lt;&lt; ++cas &lt;&lt; &quot;:\n&quot;;</span><br><span class="line">        int p, mid;</span><br><span class="line">        cin &gt;&gt; p;</span><br><span class="line">        while (p--)</span><br><span class="line">        &#123;</span><br><span class="line">            int flag = 0;</span><br><span class="line">            cin &gt;&gt; mid;</span><br><span class="line">            for (int i = 0; i &lt; m; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if (binary_search(d, d + pos, mid - c[i]))</span><br><span class="line">                &#123;</span><br><span class="line">                    flag = 1;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (flag)</span><br><span class="line">                puts(&quot;YES&quot;);</span><br><span class="line">            else</span><br><span class="line">                puts(&quot;NO&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="pairs"><a href="#pairs" class="headerlink" title="pairs"></a>pairs</h3><p>Description:<br>John has n points on the X axis, and their coordinates are (x[i],0),(i=0,1,2,…,n−1). He wants to know how many pairs&lt;a,b&gt; that |x[b]−x[a]|≤k.(a&lt;b)<br>Input<br>The first line contains a single integer T (about 5), indicating the number of cases.<br>Each test case begins with two integers n,k(1≤n≤100000,1≤k≤1e9).<br>Next n lines contain an integer xi(−1e9≤x[i]≤1e9), means the X coordinates.<br>Output<br>For each case, output an integer means how many pairs&lt;a,b&gt; that |x[b]−x[a]|≤k.<br>Sample Input</p><blockquote><p>2<br>5 5<br>-100<br>0<br>100<br>101<br>102<br>5 300<br>-100<br>0<br>100<br>101<br>102</p></blockquote><p>Sample Output</p><blockquote><p>3<br>10</p></blockquote><p>Problem solving:<br>排序之后直接进行二分查找，用lower_bound()或者手写也行，复杂度是O(N)</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const long long maxn=1e5+7;</span><br><span class="line">long long p[maxn];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">long long t,a,b;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">for(long long i=0;i&lt;a;i++)cin&gt;&gt;p[i];</span><br><span class="line">sort(p,p+a);</span><br><span class="line">long long ans=0,pos=0;</span><br><span class="line">for(long long i=0;i&lt;a;i++)</span><br><span class="line">&#123;</span><br><span class="line">while(p[pos]-p[i]&lt;=b&amp;&amp;pos&lt;a)pos++;</span><br><span class="line">ans+=pos-i-1;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Radar-Installation"><a href="#Radar-Installation" class="headerlink" title="Radar Installation"></a>Radar Installation</h3><p>Description:<br>Assume the coasting is an infinite straight line. Land is in one side of coasting, sea in the other. Each small island is a point locating in the sea side. And any radar installation, locating on the coasting, can only cover d distance, so an island in the sea can be covered by a radius installation, if the distance between them is at most d.</p><p>We use Cartesian coordinate system, defining the coasting is the x-axis. The sea side is above x-axis, and the land side below. Given the position of each island in the sea, and given the distance of the coverage of the radar installation, your task is to write a program to find the minimal number of radar installations to cover all the islands. Note that the position of an island is represented by its x-y coordinates.</p><p>Figure A Sample Input of Radar Installations<br><img src="https://i.loli.net/2019/07/23/5d35de6bd0a7a22502.png" alt></p><p>Input<br>The input consists of several test cases. The first line of each case contains two integers n (1&lt;=n&lt;=1000) and d, where n is the number of islands in the sea and d is the distance of coverage of the radar installation. This is followed by n lines each containing two integers representing the coordinate of the position of each island. Then a blank line follows to separate the cases.</p><p>The input is terminated by a line containing pair of zeros<br>Output<br>For each test case output one line consisting of the test case number followed by the minimal number of radar installations needed. &quot;-1&quot; installation means no solution for that case.<br>Sample Input</p><blockquote><p>3 2<br>1 2<br>-3 1<br>2 1<br>1 2<br>0 2<br>0 0</p></blockquote><p>Sample Output</p><blockquote><p>Case 1: 2<br>Case 2: 1</p></blockquote><p>Problem solving:<br>这道题跟暑假不AC很像（在前几天的训练中做过），对每个岛的坐标求出来以它为圆心，雷达探测半径为半径的圆与x的两个交点，然后对得到的每组左右端点进行贪心。（我的代码这里写的有点麻烦了，直接输入求交点就行，不用存岛的坐标）。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">int x,y;</span><br><span class="line">double l,r;</span><br><span class="line">&#125;p[1005];</span><br><span class="line">bool cmp(node x,node y)</span><br><span class="line">&#123;</span><br><span class="line">if(x.r==y.r)return x.l&gt;y.l;</span><br><span class="line">return x.r&lt;y.r;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,d,i=0;</span><br><span class="line">while(scanf(&quot;%d %d&quot;,&amp;n,&amp;d)&amp;&amp;n&amp;&amp;d)</span><br><span class="line">&#123;</span><br><span class="line">int flag=0;</span><br><span class="line">for(int i=0;i&lt;n;i++)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(p[i].y&gt;d)</span><br><span class="line">&#123;</span><br><span class="line">flag=1;</span><br><span class="line">&#125;</span><br><span class="line">double mid;</span><br><span class="line">mid=sqrt(d*d-p[i].y*p[i].y);</span><br><span class="line">p[i].l=p[i].x-mid;</span><br><span class="line">p[i].r=p[i].x+mid;</span><br><span class="line">&#125;</span><br><span class="line">if(flag)cout&lt;&lt;&quot;Case &quot;&lt;&lt;++i&lt;&lt;&quot;: -1&quot;&lt;&lt;endl;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">sort(p,p+n,cmp);</span><br><span class="line">int ans=1;double ri=p[0].r;</span><br><span class="line">for(int i=1;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(p[i].l&gt;ri)</span><br><span class="line">&#123;</span><br><span class="line">ans++;</span><br><span class="line">ri=p[i].r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;&quot;Case &quot;&lt;&lt;++i&lt;&lt;&quot;: &quot;&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Aggressive-cows"><a href="#Aggressive-cows" class="headerlink" title="Aggressive cows"></a>Aggressive cows</h3><p>Description:<br>Farmer John has built a new long barn, with N (2 &lt;= N &lt;= 100,000) stalls. The stalls are located along a straight line at positions x1,...,xN (0 &lt;= xi &lt;= 1,000,000,000).</p><p>His C (2 &lt;= C &lt;= N) cows don&#39;t like this barn layout and become aggressive towards each other once put into a stall. To prevent the cows from hurting each other, FJ want to assign the cows to the stalls, such that the minimum distance between any two of them is as large as possible. What is the largest minimum distance?<br>Input</p><ul><li><p>Line 1: Two space-separated integers: N and C</p></li><li><p>Lines 2..N+1: Line i+1 contains an integer stall location, xi<br>Output</p></li><li>Line 1: One integer: the largest minimum distance</li></ul><p>Sample Input</p><blockquote><p>5 3<br>1<br>2<br>8<br>4<br>9</p></blockquote><p>Sample Output</p><blockquote><p>3</p></blockquote><p>Hint<br>OUTPUT DETAILS:</p><p>FJ can put his 3 cows in the stalls at positions 1, 4 and 8, resulting in a minimum distance of 3.</p><p>Huge input data,scanf is recommended.</p><p>Problem solving:<br>白书原题，经典二分题，二分答案，对mid的检测方法是看它能不能满足以mid为最小的距离时能住下的牛的个数大于等于要求的个数。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll n,c;</span><br><span class="line">ll a[100005];</span><br><span class="line">bool check(ll x)</span><br><span class="line">&#123;</span><br><span class="line">ll mmp=0;</span><br><span class="line">for(int i=1;i&lt;c;i++)</span><br><span class="line">&#123;</span><br><span class="line">ll mid=mmp+1;</span><br><span class="line">while(mid&lt;n&amp;&amp;a[mid]-a[mmp]&lt;x)</span><br><span class="line">&#123;</span><br><span class="line">mid++;</span><br><span class="line">&#125;</span><br><span class="line">if(mid==n)return 0;</span><br><span class="line">mmp=mid;</span><br><span class="line">&#125;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%lld %lld&quot;,&amp;n,&amp;c);</span><br><span class="line">for(ll i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%lld&quot;,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line">sort(a,a+n);</span><br><span class="line">ll l=0,r=1e18,mid;</span><br><span class="line">while(r-l&gt;1)</span><br><span class="line">&#123;</span><br><span class="line">mid=(l+r)/2;</span><br><span class="line">if(check(mid))</span><br><span class="line">&#123;</span><br><span class="line">l=mid;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">r=mid;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%lld\n&quot;,l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="River-Hopscotch"><a href="#River-Hopscotch" class="headerlink" title="River Hopscotch"></a>River Hopscotch</h3><p>Description:<br>Every year the cows hold an event featuring a peculiar version of hopscotch that involves carefully jumping from rock to rock in a river. The excitement takes place on a long, straight river with a rock at the start and another rock at the end, L units away from the start (1 ≤ L ≤ 1,000,000,000). Along the river between the starting and ending rocks, N (0 ≤ N ≤ 50,000) more rocks appear, each at an integral distance Di from the start (0 &lt; Di &lt; L).</p><p>To play the game, each cow in turn starts at the starting rock and tries to reach the finish at the ending rock, jumping only from rock to rock. Of course, less agile cows never make it to the final rock, ending up instead in the river.</p><p>Farmer John is proud of his cows and watches this event each year. But as time goes by, he tires of watching the timid cows of the other farmers limp across the short distances between rocks placed too closely together. He plans to remove several rocks in order to increase the shortest distance a cow will have to jump to reach the end. He knows he cannot remove the starting and ending rocks, but he calculates that he has enough resources to remove up to M rocks (0 ≤ M ≤ N).</p><p>FJ wants to know exactly how much he can increase the shortest distance <em>before</em> he starts removing the rocks. Help Farmer John determine the greatest possible shortest distance a cow has to jump after removing the optimal set of M rocks.</p><p>Input<br>Line 1: Three space-separated integers: L, N, and M<br>Lines 2.. N+1: Each line contains a single integer indicating how far some rock is away from the starting rock. No two rocks share the same position.<br>Output<br>Line 1: A single integer that is the maximum of the shortest distance a cow has to jump after removing M rocks<br>Sample Input</p><blockquote><p>25 5 2<br>2<br>14<br>11<br>21<br>17</p></blockquote><p>Sample Output</p><blockquote><p>4</p></blockquote><p>Hint<br>Before removing any rocks, the shortest jump was a jump of 2 from 0 (the start) to 2. After removing the rocks at 2 and 14, the shortest required jump is a jump of 4 (from 17 to 21 or from 21 to 25).</p><p>Problem solving:<br>一开始以为这道题用贪心，但是涉及到删除这个操作就很烦。<br>后来发现者就是一道二分答案的题，套板子就行。<br>check函数里面判断的条件就是当最小距离已知时，求出它对应的需要拿走石头的值，与输入的进行比较。（一开始直接循环判断样例都不过，后来才想到不能直接判断，因为有可能一次跳两个石头。所以需要这样写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int mid=0,pos=0;</span><br><span class="line">for(int i=1;i&lt;=n+1;i++)</span><br><span class="line">&#123;</span><br><span class="line">    if(a[i]-a[pos]&lt;x)</span><br><span class="line">        mid++;</span><br><span class="line">    else</span><br><span class="line">        pos=i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>mid即为当前假设的最小距离所对应的需要拿走的石头个数，然后二分答案就行了。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=50005;</span><br><span class="line">int a[maxn];</span><br><span class="line">int l,n,m;</span><br><span class="line">bool check(int x)</span><br><span class="line">&#123;</span><br><span class="line">int mid=0,pos=0;</span><br><span class="line">for(int i=1;i&lt;=n+1;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(a[i]-a[pos]&lt;x)</span><br><span class="line">mid++;</span><br><span class="line">else</span><br><span class="line">pos=i;</span><br><span class="line">&#125;</span><br><span class="line">if(mid&gt;m)return 0;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;l&gt;&gt;n&gt;&gt;m;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line">sort(a+1,a+n+1);</span><br><span class="line">a[n+1]=l,a[0]=0;</span><br><span class="line">int l=0,r=1e9,mid;</span><br><span class="line">while(l&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line">mid=(l+r)/2;</span><br><span class="line">if(check(mid))l=mid+1;</span><br><span class="line">else r=mid-1;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;l-1&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天主要讲的是二分和贪心，题有点难。已经开始了不能写完题的日子了
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="Algorithm" scheme="https://cndrew.cn/blog/tags/Algorithm/"/>
    
      <category term="Greedy" scheme="https://cndrew.cn/blog/tags/Greedy/"/>
    
      <category term="STL" scheme="https://cndrew.cn/blog/tags/STL/"/>
    
      <category term="Binary" scheme="https://cndrew.cn/blog/tags/Binary/"/>
    
  </entry>
  
  <entry>
    <title>HPU Summer Training Day 5（河南理工大学暑期第五天）</title>
    <link href="https://cndrew.cn/blog/2019/07/21/d5/"/>
    <id>https://cndrew.cn/blog/2019/07/21/d5/</id>
    <published>2019-07-21T09:32:00.890Z</published>
    <updated>2019-07-21T09:42:10.922Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>昨天积分赛的结束给今天带来了一天的休息，虽然机房开放而且好多同学都在刻苦学习，但是我以为放假就应该休息（其实就是懒<a id="more"></a><br>跟几个玩的不错的朋友去看了银河补习班，一开始朋友邀请我去看的时候我是拒绝的，但一听说是邓超演的我就同意了，还是很喜欢邓超的。这个电影看之前就听说让自备纸巾，还是很有自信心的。一开始演的还不错，影片就是讲述了一个成功的儿子是如何在爸爸的帮助下变得成功的。看到后来有些无聊，不过还是很值的去看的，虽然我自己带的纸巾也没用上，主要是我泪点高？<br>没有刷题的一天，按理说应该挺开心的，但是看到旁边的人都在刷题，唉，这可能就是我菜的原因吧Orz。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天积分赛的结束给今天带来了一天的休息，虽然机房开放而且好多同学都在刻苦学习，但是我以为放假就应该休息（其实就是懒
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="life" scheme="https://cndrew.cn/blog/tags/life/"/>
    
      <category term="movie" scheme="https://cndrew.cn/blog/tags/movie/"/>
    
  </entry>
  
  <entry>
    <title>HPU Summer Training Day 4（河南理工大学暑期第四天）</title>
    <link href="https://cndrew.cn/blog/2019/07/20/d4/"/>
    <id>https://cndrew.cn/blog/2019/07/20/d4/</id>
    <published>2019-07-20T14:07:04.105Z</published>
    <updated>2019-07-20T14:15:44.257Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>第四天啦。<a id="more"></a><br>又是自闭的一天，第一次积分赛暗淡收场，这种被打爆的感觉没人会喜欢的吧，好好补题，好好学习。<br>刷题日记：<a href="http://blog.cndrew.cn/blog/2019/07/20/jifen/" target="_blank" rel="noopener">http://blog.cndrew.cn/blog/2019/07/20/jifen/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第四天啦。
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="Algorithm" scheme="https://cndrew.cn/blog/tags/Algorithm/"/>
    
      <category term="c/c++" scheme="https://cndrew.cn/blog/tags/c-c/"/>
    
      <category term="life" scheme="https://cndrew.cn/blog/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>河南理工大学算法协会暑期集训积分赛（一）</title>
    <link href="https://cndrew.cn/blog/2019/07/20/jifen/"/>
    <id>https://cndrew.cn/blog/2019/07/20/jifen/</id>
    <published>2019-07-20T13:59:45.104Z</published>
    <updated>2019-07-21T00:46:51.892Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>积分赛，被打爆的积分赛（music<a id="more"></a></p><h3 id="Nth-power-of-n"><a href="#Nth-power-of-n" class="headerlink" title="Nth power of n"></a>Nth power of n</h3><p>Descripition:<br>求 nn 的个位数。</p><p>输入格式<br>多组输入，处理到文件结束。<br>每组数据输入一个 n。(1≤n≤1e9)</p><p>输出格式<br>输出 nn 的个位数。</p><p>样例<br>input<br>1<br>2<br>3<br>output<br>1<br>4<br>7<br>Problem solving:<br>快速幂的板子题，对10取模即可。<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll poww(ll x,ll y)</span><br><span class="line">&#123;</span><br><span class="line">ll ans=1;</span><br><span class="line">while(y)</span><br><span class="line">&#123;</span><br><span class="line">if(y&amp;1)ans=ans*x%10;</span><br><span class="line">x=x*x%10;</span><br><span class="line">y/=2;</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">ll n;</span><br><span class="line">while(~scanf(&quot;%lld&quot;,&amp;n))</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;poww(n,n)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="复读机的力量"><a href="#复读机的力量" class="headerlink" title="复读机的力量"></a>复读机的力量</h3><p>Descripition:<br>Codancer: “我好菜啊！”<br>Dicer: “我好菜啊！”<br>Todest: “我好菜啊！”<br>CaprYang: “我好菜啊！”<br>…<br>大佬们又开始装弱了，真正的菜鸡瑟瑟发抖不敢说话。</p><p>我们规定一个人是复读机当且仅当他说的每一句话都是复读前一个人说的话。<br>我们规定一个人是复读机当且仅当他说的每一句话都是复读前一个人说的话。<br>我们规定一个人是复读机当且仅当他说的每一句话都是复读前一个人说的话。<br>规定一个复读机的熟练度为复读数量的多少。现在给你一段聊天记录，请你找出其中的复读机们。<br>规定一个复读机的熟练度为复读数量的多少。现在给你一段聊天记录，请你找出其中的复读机们。<br>规定一个复读机的熟练度为复读数量的多少。现在给你一段聊天记录，请你找出其中的复读机们。</p><p>输入格式<br>输入T组,(1≤T≤10)<br>每组第一行输入一个正整数N,表示聊天记录的长度（1≤N≤10000）。<br>接下来N行，每行两个字符串，前一个字符串为姓名，后一个字符为聊天记录。<br>保证所有字符串长度不超过50，保证所有字符串只包含小写字母.</p><p>输出格式<br>如果没有复读机，输出 “Unbelievable!”(不包含引号）<br>否则按照熟练度从大到小输出所有的复读机，如果熟练度相同，按照字典序从小到大输出。</p><p>样例<br>input<br>1<br>4<br>codancer iamsovegetable<br>dicer iamsovegetable<br>todest iamsovegetable<br>capryang iamsovegetable<br>output<br>capryang<br>dicer<br>todest<br>提示<br>数据保证上面大佬们说的话都是瞎话。</p><p>Problem solving:<br>不难，但是是一道送命题。需要注意的是当一个人说的每一句话都是复读的上一个人说的话的时候他才能算得上是复读机。然后就是map，结构体，set之类的使用。具体可以看代码</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">string x,y;</span><br><span class="line">&#125;p[10005];</span><br><span class="line">struct nod&#123;</span><br><span class="line">string na;</span><br><span class="line">int fo;</span><br><span class="line">&#125;pp[10005];</span><br><span class="line">bool cmp(nod m,nod n)</span><br><span class="line">&#123;</span><br><span class="line">if(m.fo==n.fo)return m.na&lt;n.na;</span><br><span class="line">return m.fo&gt;n.fo;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t,n;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">string x,y;</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">set&lt;string&gt; se;</span><br><span class="line">map&lt;string,int&gt; ma;</span><br><span class="line">map&lt;string,int&gt; mp;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">se.insert(p[i].x);</span><br><span class="line">ma[p[i].x]=1;</span><br><span class="line">&#125;</span><br><span class="line">ma[p[0].x]=0;</span><br><span class="line">for(int i=1;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(p[i].y==p[i-1].y)</span><br><span class="line">mp[p[i].x]++;</span><br><span class="line">if(p[i].y!=p[i-1].y)</span><br><span class="line">ma[p[i].x]=0;</span><br><span class="line">&#125;</span><br><span class="line">int pos=0;</span><br><span class="line">for(set&lt;string&gt;::iterator it=se.begin();it!=se.end();it++)</span><br><span class="line">&#123;</span><br><span class="line">if(ma[*it])</span><br><span class="line">&#123;</span><br><span class="line">pp[pos].na=*it;</span><br><span class="line">pp[pos].fo=mp[*it];</span><br><span class="line">pos++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(pos==0) puts(&quot;Unbelievable!&quot;);</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">sort(pp,pp+pos,cmp);</span><br><span class="line">for(int i=0;i&lt;pos;i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;pp[i].na&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="无穷的小数"><a href="#无穷的小数" class="headerlink" title="无穷的小数"></a>无穷的小数</h3><p>Descripition:<br>在十进制下，我们能够很轻易地判断一个小数的位数是有穷的或无穷的，但是把这个小数用二进制表示出的情况下其有穷性和无穷性就会发生改变，比如</p><p>十进制下的 0.5 ,在二进制下的值为 0.1 ；<br>十进制下的 0.75 ,在二进制下的值为 0.11 ；<br>十进制下的 0.6 ,在二进制下的值为 0.1001100......</p><p>给你一个十进制的小数，判断其在二进制表示下小数位数是否无穷。</p><p>输入格式<br>多组输入，处理到文件结束<br>每组数据输入一个六位的小数 n.(0≤n\&lt;1)</p><p>输出格式<br>如果在二进制下小数位数是有穷的，输出”YES”,否则输出”NO”.</p><p>样例<br>input<br>0.500000<br>0.600000<br>0.750000<br>output<br>YES<br>NO<br>YES</p><p>Problem solving:<br>我拿了一血，主要是一开始大佬们没有注意到这个水题233.<br>模拟就行了，小数转换成二进制就是每次乘以2直到等于1.如果一个小数在二进制表示下小数位数是无穷的，意思就是无论它承几次2，都不会正好等于1。我们只需要乘以2一定的次数，如果出现1，就不是无穷的，反之即无穷的。这个次数我写的时候用的100，后来结束后各种测试发现最小改成6也能过Orz。<br>官方题解里面说会有精度问题，但是我没遇到哈，double过了。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">double s;</span><br><span class="line">while(~scanf(&quot;%lf&quot;,&amp;s))</span><br><span class="line">&#123;</span><br><span class="line">int i=0,flag=0;</span><br><span class="line">while(i&lt;=6)</span><br><span class="line">&#123;</span><br><span class="line">s*=2;</span><br><span class="line">if(s==int(s))flag=1;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">if(!flag)cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">elseputs(&quot;YES&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Special-String"><a href="#Special-String" class="headerlink" title="Special String"></a>Special String</h3><p>Descripition:<br>我们定义一个字符串S为Special String只要这个字符串满足下面这些条件:<br>1.这个串是回文的，即把这个字符串正着读和反着读相同，如abba和aca，而ba和abca则不是。<br>2.26个小写字母必须全部出现<br>3.这个串的长度为偶数。<br>对于给定的S,判断它是否是Special String.</p><p>输入格式<br>输入一个只由小写字母组成的字符串S。(1≤|S|≤1e5)</p><p>输出格式<br>如果这个字符串是Special String，输出”YE5”,否则输出”N0”</p><p>样例<br>input<br>aaaa<br>output<br>N0<br>input<br>abcdefghijklmnopqrstuvwxyzzyxwvutsrqponmlkjihgfedcba<br>output<br>YE5</p><p>Problem solving:<br>这道题，很厉害，很难！<br>三个条件的判断：<br>回文串的判断可以通过可以翻转之后比较或者比较对称位置上的字符是否相等来实现<br>26个字母都必须出现的判断，因为保证输入是小写字母，用一个set就行，最后看set的大小是否为26.<br>长度为偶数这个就不用说了。</p><p>最难的地方来了，<font color="red">是&#39;YE5&#39;和&#39;N0&#39;，不是&#39;YES&#39;和&#39;NO&#39;。。。学长tql。</font></p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">string s,mid;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">set&lt;char&gt; se;</span><br><span class="line">int flag=0,len=s.size();</span><br><span class="line">if(len%2==0)flag++;</span><br><span class="line">for(int i=0;i&lt;len;i++)se.insert(s[i]);</span><br><span class="line">if(se.size()==26)flag++;</span><br><span class="line">mid=s;</span><br><span class="line">reverse(s.begin(),s.end());</span><br><span class="line">if(mid==s)flag++;</span><br><span class="line">if(flag==3)puts(&quot;YE5&quot;);</span><br><span class="line">else puts(&quot;N0&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Max-Gcd"><a href="#Max-Gcd" class="headerlink" title="Max Gcd"></a>Max Gcd</h3><p>Descripition:<br>一个数组a，现在你需要删除某一项使得它们的gcd最大，求出这个最大值。</p><p>输入格式<br>第一行输入一个正整数n，表示数组的大小，接下来一行n个数，第i个数为ai。(2≤n≤1e5,1≤ai≤1e9)</p><p>输出格式<br>输出删除掉某个数以后的gcd的最大值。</p><p>样例<br>input<br>4<br>2 4 8 1<br>output<br>2<br>input<br>4<br>1 2 3 4<br>output<br>1<br>提示<br>样例一：删除第四个元素后，2,4,8的最大公因子为2。<br>样例二：无论删除哪一个，最大公因子都为1。</p><p>Problem solving:<br>比赛的时候这题毫无思路，，，<br>完了之后了解到，是使用了一个前缀gcd数组和一个后缀gcd数组来实现求去掉第I位数字之后剩余所有数字的gcd。<br>b为前缀gcd数组，c为后缀gcd数组<br>那么去点第I位的数字之后剩余所有数字的gcd就是<br>gcd（b[i-1],c[i+1]）<br>这种思想是真的巧妙。<br>我师父还想到了一种贪心的解法，但是我没听太懂233，总之很强就对了。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[200005];</span><br><span class="line">int b[200005];</span><br><span class="line">int c[200005];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i=0;i&lt;n;i++)cin&gt;&gt;a[i];</span><br><span class="line">b[0]=a[0];</span><br><span class="line">for(int i=1;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">b[i]=__gcd(b[i-1],a[i]);</span><br><span class="line">//cout&lt;&lt;b[i]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">c[0]=a[n-1];</span><br><span class="line">for(int i=n-1;i&gt;=0;i--)</span><br><span class="line">&#123;</span><br><span class="line">c[i]=__gcd(c[i+1],a[i]);</span><br><span class="line">&#125;</span><br><span class="line">int ans=0;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(i==0)ans=max(ans,c[1]);</span><br><span class="line">else if(i==n-1)ans=max(ans,b[n-2]);</span><br><span class="line">else ans=max(ans,__gcd(b[i-1],c[i+1]));</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Count-Prime-Pairs"><a href="#Count-Prime-Pairs" class="headerlink" title="Count Prime Pairs"></a>Count Prime Pairs</h3><p>Descripition:<br>对于数组a，如果i≠j并且ai+aj是一个质数，那么我们就称(i,j)为质数对，计算数组中质数对的个数。</p><p>输入格式<br>第一行输入一个n，表示数组的长度,接下来n个整数，第i个数代表ai。<br>(1≤n≤100000,0≤ai≤100)</p><p>输出格式<br>输出数组中质数对的个数。</p><p>样例<br>input<br>3<br>1 2 3<br>output<br>4<br>提示<br>样例说明：a1+a2,a2+a1,a2+a3,a3+a2都为质数，总共有四对。<br>Problem solving:<br>其实比赛的时候想到了这样去暴力，但是没实现。<br>题目中最大的素数是199，每个素数对所有出现过的数进行判断看差值是否出现过，就行了。<br>先来个素数打表，还有就是用map统计每个数出现的次数。<br>假设1出现了2次，2出现了2次，那么和为3的次数就是2*2=4次<br>假设1出现了4次，那么和为2出现的次数就是4*（4-1）/2=6次<br>按照这上面两种进行统计输出就行。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int t[205];</span><br><span class="line">int p[205];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">p[0]=p[1]=1;</span><br><span class="line">for(int i=2;i&lt;=205;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=i*2;j&lt;=205;j+=i)</span><br><span class="line">p[j]=1;</span><br><span class="line">&#125;</span><br><span class="line">int n,a;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">while(n--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a;</span><br><span class="line">t[a]++;</span><br><span class="line">&#125;</span><br><span class="line">int ans=0;</span><br><span class="line">for(int i=0;i&lt;=100;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=i+1;j&lt;=100;j++)</span><br><span class="line">&#123;</span><br><span class="line">if(i==j)continue;</span><br><span class="line">if(!p[i+j])</span><br><span class="line">&#123;</span><br><span class="line">ans+=t[i]*t[j];</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans*2+t[1]*(t[1]-1)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="平行线"><a href="#平行线" class="headerlink" title="平行线"></a>平行线</h3><p>Descripition:<br>“大猩猩为什么不喜欢平行线？”“因为平行线没有相交”<br>哈哈哈哈哈哈哈哈哈</p><p>为了管理动物园不听话的大猩猩们，动物管理员Boctorio 决定去远方的ACM之城找一些平行线，当他逛到一个神奇的店铺时，他发现了一副黑色的图，上面依稀可见一些白色的点。Boctorio 询问店铺老板这幅画是什么，老板说：“天机不可泄露”。等Boctorio仔细端详了一会这幅画后，他惊讶的发现其中所蕴含的奥秘。向店铺老板道谢后，他拿着刚买的这幅画，就连忙赶回动物园。</p><p>输入格式<br>输入一个数 n(1≤n≤1000)，表示点的个数。<br>接下来n行，每行两个整数 xi,yi(1≤xi,yi≤1e9),表示第i个点。<br>数据保证没有重复的点</p><p>输出格式<br>输出用这些点所能表示出来的平行线段的对数。（两条不同的线段重合也算为平行）</p><p>样例<br>input<br>6<br>0 0<br>1 0<br>1 1<br>3 1<br>3 3<br>5 4<br>output<br>10</p><p>Problem solving:<br>两线平行的条件就是斜率相等（也可以用向量做）统计每个斜率出现的次数即可<br>斜率不能直接用double存，会爆精度，可以用一个pair来存，但是注意，分数要进行约分，同时除以它们的gcd就行了</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1005;</span><br><span class="line">int x[maxn],y[maxn];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">set&lt;pair&lt;int,int&gt; &gt; se;</span><br><span class="line">map&lt;pair&lt;int,int&gt; ,int&gt; ma;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;x[i]&gt;&gt;y[i];</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=i+1;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line">int dx=x[j]-x[i];</span><br><span class="line">int dy=y[j]-y[i];</span><br><span class="line">int mid=__gcd(dx,dy);</span><br><span class="line">dx/=mid;</span><br><span class="line">dy/=mid;</span><br><span class="line">ma[&#123;dx,dy&#125;]++;</span><br><span class="line">se.insert(&#123;dx,dy&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int ans=0;</span><br><span class="line">for(set&lt;pair&lt;int,int&gt; &gt;::iterator it=se.begin();it!=se.end();it++)</span><br><span class="line">&#123;</span><br><span class="line">ans+=(ma[*it]*(ma[*it]-1))/2;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Area-of-polygons"><a href="#Area-of-polygons" class="headerlink" title="Area of polygons"></a>Area of polygons</h3><p>Descripition:<br>现在有a个边长为1的正方形，b个半径为1的圆，c个边长为1的等边三角形，现在你随机拿出一个图形，求这个图形面积的期望。</p><p>输入格式<br>第一行输入一个T,代表输入的组数。(1≤T≤100)<br>接下来T行，每行三个数字a,b,c(1≤a,b,c≤1000)。</p><p>输出格式<br>输出T行，对于每一组输入，输出面积的期望，小数点后保留三位小数。</p><p>样例<br>input<br>3<br>1 2 3<br>4 5 6<br>7 8 9<br>output<br>1.430<br>1.487<br>1.501<br>提示<br>圆周率为3.1415926535897</p><p>Problem solving:<br>简单数学题<br>期望即平均值</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define PI 3.1415926535897</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">double t,a,b,c;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">double sum=0;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">sum+=a+PI*b+sqrt(3)*c/4;</span><br><span class="line">printf(&quot;%.3lf\n&quot;,sum/(a+b+c));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="双色球"><a href="#双色球" class="headerlink" title="双色球"></a>双色球</h3><p>Descripition:<br>双色球投注区分为红色球号码区和蓝色球号码区，红色球号码区由1-33共三十三个号码组成，蓝色球号码区由1-16共十六个号码组成。投注时选择6个红色球号码和1个蓝色球号码组成一注进行单式投注。其中奖规则为：</p><p>一等奖（6+1）<br>二等奖（6+0）<br>三等奖（5+1）<br>四等奖（5+0、4+1）<br>五等奖（4+0、3+1）<br>六等奖（2+1、1+1、0+1）<br>其中(a+b)即为有a个红色球，b个蓝色球与开奖某个数字相同（只与数字有关，与位置无关）。<br>现在你有 n 张双色球彩票，以及本场彩票开奖结果，请你求出这 n 张彩票获得的最高奖。</p><p>输入格式<br>第一行输入一个 n ，表示 n 张彩票<br>接下来 n 行，每行 7 个数字，表示每张彩票的选号，其中前六个位红色球，后一个为蓝色球。<br>接下来一行，输入 7 个数字，表示开奖结果，其中前六个为红色球，后一个为蓝色球。</p><p>输出格式<br>输出所有彩票中能获得的最高等级奖，若无，则输出”0”。</p><p>样例<br>input<br>5<br>2 17 21 28 30 32 10<br>2 12 17 29 30 31 15<br>9 10 19 25 26 30 12<br>6 8 18 29 30 31 10<br>13 14 21 22 27 32 8<br>6 7 12 19 27 28 12<br>output<br>6<br>input<br>3<br>2 17 21 28 30 32 10<br>2 12 17 29 30 31 15<br>9 10 19 25 26 30 12<br>6 8 18 29 30 31 10<br>output<br>6<br>提示<br>彩票六个红色球数字均为从小到大排列<br>Problem solving:<br>看懂题意后直接暴力模拟就行</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">int ball[10];</span><br><span class="line">&#125;p[100];</span><br><span class="line">int re[10];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;7;j++)</span><br><span class="line">cin&gt;&gt;p[i].ball[j];</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;7;i++)cin&gt;&gt;re[i];</span><br><span class="line">int ans,mmp=7,mmm=7;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">ans=0;</span><br><span class="line">int flag=0;</span><br><span class="line">for(int j=0;j&lt;6;j++)</span><br><span class="line">&#123;</span><br><span class="line">if(binary_search(re,re+6,p[i].ball[j]))</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">if(p[i].ball[6]==re[6])flag=1;</span><br><span class="line">if(ans==1&amp;flag)mmm=6;</span><br><span class="line">else if(ans==0&amp;&amp;flag)mmm=6;</span><br><span class="line">else if(ans==2&amp;&amp;flag)mmm=6;</span><br><span class="line">else if(ans==3&amp;&amp;flag==1)mmm=5;</span><br><span class="line">else if(ans==4)</span><br><span class="line">&#123;</span><br><span class="line">if(!flag)mmm=5;</span><br><span class="line">elsemmm=4;</span><br><span class="line">&#125;</span><br><span class="line">else if(ans==5)</span><br><span class="line">&#123;</span><br><span class="line">if(!flag)mmm=4;</span><br><span class="line">elsemmm=3;</span><br><span class="line">&#125;</span><br><span class="line">else if(ans==6)</span><br><span class="line">&#123;</span><br><span class="line">if(!flag)mmm=2;</span><br><span class="line">elsemmm=1;</span><br><span class="line">&#125;</span><br><span class="line">mmp=min(mmm,mmp);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;mmp%7&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Remainder-Minimization-2019"><a href="#Remainder-Minimization-2019" class="headerlink" title="Remainder Minimization 2019"></a>Remainder Minimization 2019</h3><p>Descripition:<br>给你一个区间[L,R],在这个区间内找到两个不同的数字i,j，使得(i∗j)%2019的值最小。</p><p>输入格式<br>输入两个数 L,R,(1≤L\&lt;R≤1e9）</p><p>输出格式<br>如题</p><p>样例<br>input<br>4 5<br>output<br>20<br>input<br>2020 2040<br>output<br>2<br>Problem solving:<br>区间内只要出现2019的倍数，那么答案就是0。<br>所以我们只需要判断区间大小与2019的关系，如果大于2019，直接输出0就行，反之直接两个for循环就行，因为这时区间长度小于2019，时间复杂度也不高。注意要用long long。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a,b=input().split()</span><br><span class="line">a=eval(a)</span><br><span class="line">b=eval(b)</span><br><span class="line">ans=1111111111111</span><br><span class="line">for i in range(a,b):</span><br><span class="line">    for j in range(a+1,b+1):</span><br><span class="line">        mid = i*j % 2019</span><br><span class="line">        ans = min(ans,mid)</span><br><span class="line">        if ans==0:</span><br><span class="line">            break</span><br><span class="line">    if ans==0:</span><br><span class="line">            break</span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure></p><h3 id="学长标程-amp-amp-题解"><a href="#学长标程-amp-amp-题解" class="headerlink" title="学长标程 &amp;&amp; 题解"></a>学长标程 &amp;&amp; 题解</h3><p>我的代码会显得有点笨拙，因为还是不够熟练，所以把学长的代码也放在这里吧。</p><h4 id="B"><a href="#B" class="headerlink" title="B"></a>B</h4><ul><li>只要有一次某个人不是复读的就不是复读机</li><li>第一个人一定不是复读机</li><li>使用 map&lt;string,bool&gt; 判断这个人是否是复读机</li><li>使用 map&lt;string,int&gt; 记录这个人复读的次数</li><li>用结构体记录排序</li><li>复杂度 O(n∗log(n))</li></ul><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e6+100;</span><br><span class="line">struct peo&#123;</span><br><span class="line">string name;</span><br><span class="line">int num;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;peo&gt; all;</span><br><span class="line">map&lt;string,bool&gt; jud;</span><br><span class="line">map&lt;string,int&gt; num;</span><br><span class="line">string a[N],b[N];</span><br><span class="line">set&lt;string&gt; name;</span><br><span class="line">bool cmp(peo a,peo b)&#123;</span><br><span class="line">if(a.num==b.num) return a.name&lt;b.name;</span><br><span class="line">return a.num&gt;b.num;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">int T;</span><br><span class="line">cin&gt;&gt;T;</span><br><span class="line">while(T--)&#123;</span><br><span class="line">int n;</span><br><span class="line">jud.clear();num.clear();name.clear();all.clear();</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]&gt;&gt;b[i],jud[a[i]]=1,num[a[i]]=0,name.insert(a[i]);</span><br><span class="line">jud[a[1]]=0;</span><br><span class="line">for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">if(b[i]!=b[i-1])&#123;</span><br><span class="line">jud[a[i]]=0;</span><br><span class="line">&#125;</span><br><span class="line">num[a[i]]++;</span><br><span class="line">&#125;</span><br><span class="line">for(auto v:name)&#123;</span><br><span class="line">if(jud[v]) all.push_back(&#123;v,num[v]&#125;);</span><br><span class="line">&#125;</span><br><span class="line">sort(all.begin(),all.end(),cmp);</span><br><span class="line">if(all.size()==0)&#123;</span><br><span class="line">cout&lt;&lt;&quot;Unbelievable!&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">for(auto v:all) cout&lt;&lt;v.name&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="C"><a href="#C" class="headerlink" title="C"></a>C</h4><ul><li>由于只有后六位，先乘上 106 防止爆精度。</li><li>按照最普通的算法，每次乘以 2 再对 106 取余</li><li>当循环次数超过某一个值时，即可判定为无</li></ul><p>Code:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">double y;</span><br><span class="line">while(scanf(&quot;%lf&quot;,&amp;y)!=EOF)&#123;</span><br><span class="line">y*=10000000;</span><br><span class="line">bool flag=0;</span><br><span class="line">long long x=(long long)y;</span><br><span class="line">int num=0;</span><br><span class="line">while(1)&#123;</span><br><span class="line">    if(x==0) break;</span><br><span class="line">if(num&gt;=200)&#123;</span><br><span class="line">flag=1;break;</span><br><span class="line">&#125;</span><br><span class="line">num++;</span><br><span class="line">x=2*x;</span><br><span class="line">if(x&gt;=10000000) x-=10000000;</span><br><span class="line">if(x==0) break;</span><br><span class="line">&#125;</span><br><span class="line">if(flag) puts(&quot;NO&quot;);</span><br><span class="line">else puts(&quot;YES&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="D"><a href="#D" class="headerlink" title="D"></a>D</h4><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">bool check(string s)&#123;</span><br><span class="line">string c=s;</span><br><span class="line">reverse(c.begin(), c.end());</span><br><span class="line">return s==c;</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;int,int&gt; pii;</span><br><span class="line">int main()&#123;</span><br><span class="line">pii.first=1;</span><br><span class="line">pii.second=2;</span><br><span class="line">pii=make_pair(1,2);</span><br><span class="line">//cout&lt;&lt;pii.first&lt;&lt;&apos; &apos;&lt;&lt;pii.second&lt;&lt;endl;</span><br><span class="line">string s;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">bool flag=0;</span><br><span class="line">int l=s.length();</span><br><span class="line">if(l&amp;1) flag=1;</span><br><span class="line">if(!check(s)) flag=1;</span><br><span class="line">int num[27];</span><br><span class="line">memset(num,0,sizeof(num));</span><br><span class="line">for(int i=0;i&lt;l;i++)&#123;</span><br><span class="line">num[s[i]-&apos;a&apos;]++;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;26;i++)&#123;</span><br><span class="line">if(num[i]==0)&#123;</span><br><span class="line">flag=1;break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(flag) cout&lt;&lt;&quot;N0&quot;&lt;&lt;endl;</span><br><span class="line">else cout&lt;&lt;&quot;YE5&quot;&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="E"><a href="#E" class="headerlink" title="E"></a>E</h4><ul><li>维护前缀 gcd 数组 pre 和后缀 gcd 数组 od</li><li>删除第 i 个数之后剩余数的 gcd 即为 gcd(pre[i−1],od[i+1])</li><li>线性枚举即可, 复杂度 O(n)</li></ul><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">//前缀后缀解法</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e5+100;</span><br><span class="line">long long a[N];</span><br><span class="line">long long pre[N],sa[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">int n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">pre[1]=a[1];sa[n]=a[n];</span><br><span class="line">for(int i=2;i&lt;=n;i++) pre[i]=__gcd(pre[i-1],a[i]);</span><br><span class="line">for(int i=n-1;i&gt;=1;i--) sa[i]=__gcd(sa[i+1],a[i]);</span><br><span class="line">long long ans=max(sa[2],pre[n-1]);</span><br><span class="line">for(int i=2;i&lt;=n-1;i++) ans=max(ans,__gcd(pre[i-1],sa[i+1]));</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">//贪心解法</span><br><span class="line">//#include&lt;bits/stdc++.h&gt;</span><br><span class="line">//using namespace std;</span><br><span class="line">//const int maxn = 1e5 + 10;</span><br><span class="line">//int a[maxn];</span><br><span class="line">//bool cmp(int x,int y)</span><br><span class="line">//&#123;</span><br><span class="line">//return x &gt; y;</span><br><span class="line">//&#125;</span><br><span class="line">//int gcd(int a,int b)</span><br><span class="line">//&#123;</span><br><span class="line">//return b ? gcd(b,a % b) : a;</span><br><span class="line">//&#125;</span><br><span class="line">//int main()</span><br><span class="line">//&#123;</span><br><span class="line">//int n;</span><br><span class="line">//scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">//for (int i = 0;i &lt; n;i ++)</span><br><span class="line">//scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">//sort(a,a + n,cmp);</span><br><span class="line">//int ans = a[0],now = a[0];</span><br><span class="line">//for (int i = 1;i &lt; n;i ++)</span><br><span class="line">//&#123;</span><br><span class="line">//ans = max(gcd(ans,a[i]),now);</span><br><span class="line">//now = gcd(now,a[i]);</span><br><span class="line">//&#125;</span><br><span class="line">//printf(&quot;%d\n&quot;,ans);</span><br><span class="line">//return 0;</span><br><span class="line">//&#125;</span><br></pre></td></tr></table></figure></p><h4 id="F"><a href="#F" class="headerlink" title="F"></a>F</h4><ul><li>注意到 ai 的范围很小，我们可以先打出 [1,200] 以内的质数 表</li><li>O(n) 或 O(nlog(n)) 的统计每个数出现的次数</li><li>对于第 i 个质数 pi，和数组中第 j 个元素 aj，答案应该累加 上 pi−aj 出现的次数</li><li>注意 pi = 2∗aj 的情况，应该加上 aj 出现的次数减去 1</li></ul><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e6+100;</span><br><span class="line">bool check(int x)&#123;</span><br><span class="line">if(x==1) return 0;</span><br><span class="line">if(x==2) return 1;</span><br><span class="line">for(int i=2;i*i&lt;=x;i++)&#123;</span><br><span class="line">if(x%i==0) return 0;</span><br><span class="line">&#125;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;int&gt; pr;</span><br><span class="line">void init()&#123;</span><br><span class="line">for(int i=1;i&lt;=250;i++)&#123;</span><br><span class="line">if(check(i)) pr.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int a[N];</span><br><span class="line">int vis[300];</span><br><span class="line">int main()&#123;</span><br><span class="line">init();</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">long long ans=0;</span><br><span class="line">int n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i],vis[a[i]]++;</span><br><span class="line">for(int i=0;i&lt;(int)pr.size();i++)&#123;</span><br><span class="line">int now=pr[i];</span><br><span class="line">for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">if(now&gt;=a[j])&#123;</span><br><span class="line">if(now==(a[j]*2)) ans+=vis[a[j]]-1;</span><br><span class="line">else&#123;</span><br><span class="line"> if(vis[a[j]]&amp;&amp;vis[now-a[j]]) ans+=vis[now-a[j]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="G"><a href="#G" class="headerlink" title="G"></a>G</h4><ul><li>对 yi−yj/xi−xj 用 gcd 约分后用 pair 存储</li><li>利用 map 统计每个斜率的线段条数, 假设为 num, 那么斜率 k 的贡献即为 num∗(num−1)/2</li><li>累加不同的斜率的贡献即可 复杂度 O(n2log(n2))</li></ul><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 2000;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int x[N],y[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">int n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">map&lt;pair&lt;int,int&gt; ,int&gt; k;</span><br><span class="line">set&lt;pair&lt;long long,long long&gt;&gt; all;</span><br><span class="line">long long ans=0;</span><br><span class="line">for(int i=1;i&lt;=n;i++) cin&gt;&gt;x[i]&gt;&gt;y[i];</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">for(int j=i+1;j&lt;=n;j++)&#123;</span><br><span class="line">int dx=x[j]-x[i];</span><br><span class="line">int dy=y[j]-y[i];</span><br><span class="line">if(dx&lt;0&amp;&amp;dy&lt;0)&#123;</span><br><span class="line">dx=-dx;</span><br><span class="line">dy=-dy;</span><br><span class="line">&#125;</span><br><span class="line">long long gc=__gcd(dx,dy);</span><br><span class="line">dx/=gc;dy/=gc;</span><br><span class="line">k[&#123;dx,dy&#125;]++;</span><br><span class="line">all.insert(&#123;dx,dy&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(auto v:all)&#123;</span><br><span class="line">ans+=(k[v]*(k[v]-1)/2);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="H"><a href="#H" class="headerlink" title="H"></a>H</h4><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">int T;</span><br><span class="line">cin&gt;&gt;T;</span><br><span class="line">while(T--)&#123;</span><br><span class="line">double a,b,c;</span><br><span class="line">scanf(&quot;%lf %lf %lf&quot;,&amp;a,&amp;b,&amp;c);</span><br><span class="line">double all=(a+b+c);</span><br><span class="line">printf(&quot;%.3lf\n&quot;,(a+M_PI*b+sqrt(3)*c/4)/(a+b+c));</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="I"><a href="#I" class="headerlink" title="I"></a>I</h4><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">pair&lt;int,int&gt; solve(vector&lt;int&gt; a,vector&lt;int&gt; b)&#123;</span><br><span class="line">int num[34];</span><br><span class="line">memset(num,0,sizeof(num));</span><br><span class="line">int r=0;</span><br><span class="line">int bl=0;</span><br><span class="line">for(int i=0;i&lt;6;i++)&#123;</span><br><span class="line">num[a[i]]++;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;6;i++)&#123;</span><br><span class="line">if(num[b[i]]) r++;</span><br><span class="line">&#125;</span><br><span class="line">if(a[6]==b[6]) bl=1;</span><br><span class="line">return &#123;r,bl&#125;;</span><br><span class="line">&#125;</span><br><span class="line">int cal(pair&lt;int,int&gt; pii)&#123;</span><br><span class="line">if(pii.first==6&amp;&amp;pii.second==1) return 1;</span><br><span class="line">if(pii.first==6&amp;&amp;pii.second==0) return 2;</span><br><span class="line">if(pii.first==5&amp;&amp;pii.second==1) return 3;</span><br><span class="line">if((pii.first==5&amp;&amp;pii.second==0)||(pii.first==4&amp;&amp;pii.second==1)) return 4;</span><br><span class="line">if((pii.first==4&amp;&amp;pii.second==0)||(pii.first==3&amp;&amp;pii.second==1)) return 5;</span><br><span class="line">if((pii.first==2&amp;&amp;pii.second==1)||(pii.first==1&amp;&amp;pii.second==1)||(pii.first==0&amp;&amp;pii.second==1)) return 6;</span><br><span class="line">return 99999;</span><br><span class="line">&#125;</span><br><span class="line">const int N = 1e3+100;</span><br><span class="line">vector&lt;int&gt; a[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">int n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">int x;</span><br><span class="line">for(int j=0;j&lt;7;j++)&#123;</span><br><span class="line">cin&gt;&gt;x;</span><br><span class="line">a[i].push_back(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int ans=7;</span><br><span class="line">vector&lt;int&gt; b(7);</span><br><span class="line">for(int i=0;i&lt;7;i++) cin&gt;&gt;b[i];</span><br><span class="line">for(int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">ans=min(ans,cal(solve(a[i],b)));</span><br><span class="line">&#125;</span><br><span class="line">if(ans==7) ans=0;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="J"><a href="#J" class="headerlink" title="J"></a>J</h4><ul><li>当 L 和 R 的差值大于 2019 的时候，其中必定含有 2019 的 倍数，此时答案为 0</li><li>否则暴力枚举</li></ul><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    long long L,R;</span><br><span class="line">    cin&gt;&gt;L&gt;&gt;R;</span><br><span class="line">    if(R-L&gt;2019) cout&lt;&lt;0&lt;&lt;endl;</span><br><span class="line">    else&#123;</span><br><span class="line">        int ans=9999;</span><br><span class="line">        for(int i=L;i&lt;=R;i++)&#123;</span><br><span class="line">            for(int j=i+1;j&lt;=R;j++)&#123;</span><br><span class="line">                ans=min(ans,((i%2019)*(j%2019))%2019);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>今天的题确实不算太难吧，就过了6题，还罚时巨高，主要还是自己的原因。STL和结构体的使用能力还有点欠缺，另外用map统计出现次数这个真的是很有用的东西，set去重，这些都知道的东西用不到平常写题的过程中太亏了。继续加油，Fighting！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;积分赛，被打爆的积分赛（music
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="Algorithm" scheme="https://cndrew.cn/blog/tags/Algorithm/"/>
    
      <category term="c/c++" scheme="https://cndrew.cn/blog/tags/c-c/"/>
    
      <category term="STL" scheme="https://cndrew.cn/blog/tags/STL/"/>
    
      <category term="前缀和" scheme="https://cndrew.cn/blog/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>stringstream(常见函数及其常见用法)</title>
    <link href="https://cndrew.cn/blog/2019/07/19/sstream/"/>
    <id>https://cndrew.cn/blog/2019/07/19/sstream/</id>
    <published>2019-07-19T08:19:10.783Z</published>
    <updated>2019-07-19T09:12:12.768Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Give me three minutes,I will make you learn more about stringstream.<a id="more"></a></p><h3 id="Some-common-usage"><a href="#Some-common-usage" class="headerlink" title="Some common usage"></a>Some common usage</h3><h4 id="Data-type-conversion-数据类型的转换"><a href="#Data-type-conversion-数据类型的转换" class="headerlink" title="Data type conversion(数据类型的转换)"></a>Data type conversion(数据类型的转换)</h4><p>For example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string       a = &quot;521&quot;, b;</span><br><span class="line">    int          c, d = 1314;</span><br><span class="line">    stringstream x, y;</span><br><span class="line">    x &lt;&lt; a;   y &lt;&lt; d;</span><br><span class="line">    x &gt;&gt; c;   y &gt;&gt; b;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl &lt;&lt; c &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;The size of b is &quot; &lt;&lt; sizeof(b) &lt;&lt; &quot;\nThe size of c is &quot; &lt;&lt; sizeof(c) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Output:</p><blockquote><p>5211314<br>5211314<br>The size of b is 24<br>The size of c is 4</p></blockquote><p>In this case,we transform a string to int and an int to string through stringstream.</p><h4 id="Can-be-used-to-split-strings-separated-by-spaces-etc-可以分割被空格分割的字符串"><a href="#Can-be-used-to-split-strings-separated-by-spaces-etc-可以分割被空格分割的字符串" class="headerlink" title="Can be used to split strings separated by spaces etc.(可以分割被空格分割的字符串)"></a>Can be used to split strings separated by spaces etc.(可以分割被空格分割的字符串)</h4><p>For example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string       s = &quot;521 1314&quot;,mid;</span><br><span class="line">    stringstream x(s);</span><br><span class="line">    while (x &gt;&gt; mid)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; mid &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Output:</p><blockquote><p>521<br>1314</p></blockquote><p>This part is always useful in some type.</p><h3 id="Official-explanation"><a href="#Official-explanation" class="headerlink" title="Official explanation"></a>Official explanation</h3><p>CPP: <a href="http://www.cplusplus.com/reference/sstream/stringstream/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/sstream/stringstream/</a></p><p>As far as I know,If you can grasp the common usage,it&#39;s enough in ACM.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Give me three minutes,I will make you learn more about stringstream.
    
    </summary>
    
      <category term="c/c++" scheme="https://cndrew.cn/blog/categories/c-c/"/>
    
    
      <category term="c/c++" scheme="https://cndrew.cn/blog/tags/c-c/"/>
    
      <category term="functions" scheme="https://cndrew.cn/blog/tags/functions/"/>
    
  </entry>
  
  <entry>
    <title>HPU Summer Training Day 3（河南理工暑期集训第三天）</title>
    <link href="https://cndrew.cn/blog/2019/07/19/d3/"/>
    <id>https://cndrew.cn/blog/2019/07/19/d3/</id>
    <published>2019-07-19T06:45:01.725Z</published>
    <updated>2019-07-19T07:48:04.601Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天主要讲了点基本的STL的用法。题写的有点吃力了，以后可能就写不完了，然后攒着写不完的题一天比一天多。<br>Nothing can change my love for you,even you.<a id="more"></a></p><p><center><p color="red">Today&#39;s problem I spent too much wrong on the format,I should be more careful.</p></center></p><h3 id="Windows-Message-Queue"><a href="#Windows-Message-Queue" class="headerlink" title="Windows Message Queue"></a>Windows Message Queue</h3><p>Description:<br>Message queue is the basic fundamental of windows system. For each process, the system maintains a message queue. If something happens to this process, such as mouse click, text change, the system will add a message to the queue. Meanwhile, the process will do a loop for getting message from the queue according to the priority value if it is not empty. Note that the less priority value means the higher priority. In this problem, you are asked to simulate the message queue for putting messages to and getting message from the message queue.<br>Input</p><blockquote><p>There&#39;s only one test case in the input. Each line is a command, &quot;GET&quot; or &quot;PUT&quot;, which means getting message or putting message. If the command is &quot;PUT&quot;, there&#39;re one string means the message name and two integer means the parameter and priority followed by. There will be at most 60000 command. Note that one message can appear twice or more and if two messages have the same priority, the one comes first will be processed first.(i.e., FIFO for the same priority.) Process to the end-of-file.</p></blockquote><p>Output</p><blockquote><p>For each &quot;GET&quot; command, output the command getting from the message queue with the name and parameter in one line. If there&#39;s no message in the queue, output &quot;EMPTY QUEUE!&quot;. There&#39;s no output for &quot;PUT&quot; command.</p></blockquote><p>Sample Input</p><blockquote><p>GET<br>PUT msg1 10 5<br>PUT msg2 10 4<br>GET<br>GET<br>GET</p></blockquote><p>Sample Output</p><blockquote><p>EMPTY QUEUE!<br>msg2 10<br>msg1 10<br>EMPTY QUEUE!</p></blockquote><p>Problem solving:<br>Through a special queue with a struct and Operator overloading.The main question is understand this,oh my poor English.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    string s;</span><br><span class="line">    int    p, q, id;</span><br><span class="line">&#125; n[6005];</span><br><span class="line">bool operator &lt;(const node &amp;x, const node &amp;y)//Operator overloading.</span><br><span class="line">&#123;</span><br><span class="line">    if (x.q == y.q)</span><br><span class="line">        return x.id &gt; y.id;</span><br><span class="line">    return x.q &gt; y.q;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;node&gt; que;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s;</span><br><span class="line">    int    k = 0;</span><br><span class="line">    while (cin &gt;&gt; s)</span><br><span class="line">    &#123;</span><br><span class="line">        if (s[0] == &apos;G&apos;)</span><br><span class="line">        &#123;</span><br><span class="line">            if (que.empty())</span><br><span class="line">                puts(&quot;EMPTY QUEUE!&quot;);</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; que.top().s &lt;&lt; &quot; &quot; &lt;&lt; que.top().p &lt;&lt; endl;</span><br><span class="line">                que.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (s[0] == &apos;P&apos;)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; n[0].s &gt;&gt; n[0].p &gt;&gt; n[0].q;</span><br><span class="line">            n[0].id = k;</span><br><span class="line">            k++;</span><br><span class="line">            que.push(n[0]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Train-Problem-I"><a href="#Train-Problem-I" class="headerlink" title="Train Problem I"></a>Train Problem I</h3><p>Description:<br>As the new term comes, the Ignatius Train Station is very busy nowadays. A lot of student want to get back to school by train(because the trains in the Ignatius Train Station is the fastest all over the world ^v^). But here comes a problem, there is only one railway where all the trains stop. So all the trains come in from one side and get out from the other side. For this problem, if train A gets into the railway first, and then train B gets into the railway before train A leaves, train A can&#39;t leave until train B leaves. The pictures below figure out the problem. Now the problem for you is, there are at most 9 trains in the station, all the trains has an ID(numbered from 1 to n), the trains get into the railway in an order O1, your task is to determine whether the trains can get out in an order O2.<br><img src="https://i.loli.net/2019/07/19/5d31701948a0b85739.png" alt><br><img src="https://i.loli.net/2019/07/19/5d317019666c116696.png" alt><br><img src="https://i.loli.net/2019/07/19/5d3170197930e92310.png" alt><br>Input</p><blockquote><p>The input contains several test cases. Each test case consists of an integer, the number of trains, and two strings, the order of the trains come in:O1, and the order of the trains leave:O2. The input is terminated by the end of file. More details in the Sample Input.</p></blockquote><p>Output</p><blockquote><p>The output contains a string &quot;No.&quot; if you can&#39;t exchange O2 to O1, or you should output a line contains &quot;Yes.&quot;, and then output your way in exchanging the order(you should output &quot;in&quot; for a train getting into the railway, and &quot;out&quot; for a train getting out of the railway). Print a line contains &quot;FINISH&quot; after each test case. More details in the Sample Output.</p></blockquote><p>Sample Input</p><blockquote><p>3 123 321<br>3 123 312</p></blockquote><p>Sample Output</p><blockquote><p>Yes.<br>in<br>in<br>in<br>out<br>out<br>out<br>FINISH<br>No.<br>FINISH</p></blockquote><p>For the first Sample Input, we let train 1 get in, then train 2 and train 3.<br>So now train 3 is at the top of the railway, so train 3 can leave first, then train 2 and train 1.<br>In the second Sample input, we should let train 3 leave first, so we have to let train 1 get in, then train 2 and train 3.<br>Now we can let train 3 leave.<br>But after that we can&#39;t let train 1 leave before train 2, because train 2 is at the top of the railway at the moment.<br>So we output &quot;No.&quot;.<br>Problem solving:<br>An easy problem.Use a stack to simulate this process and a queue to record &#39;in&#39; or &#39;out&#39;.Judge if we can pop or push.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    while (~scanf(&quot;%d&quot;, &amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        int           flag = 0;</span><br><span class="line">        string        a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        stack&lt;char&gt;   s;</span><br><span class="line">        queue&lt;string&gt; q;</span><br><span class="line">        for (int i = 0, j = 0; i &lt; n &amp;&amp; j &lt;= n;)</span><br><span class="line">        &#123;</span><br><span class="line">            if (s.empty() || s.top() != b[i])</span><br><span class="line">            &#123;</span><br><span class="line">                if (j == n)</span><br><span class="line">                &#123;</span><br><span class="line">                    cout &lt;&lt; &quot;No.\nFINISH\n&quot;;</span><br><span class="line">                    flag = 1;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                s.push(a[j]);</span><br><span class="line">                j++;</span><br><span class="line">                q.push(&quot;in&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                s.pop();</span><br><span class="line">                q.push(&quot;out&quot;);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (flag)</span><br><span class="line">            continue;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot;Yes.\n&quot;;</span><br><span class="line">            while (!q.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; q.front() &lt;&lt; endl;</span><br><span class="line">                q.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; &quot;FINISH\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Rails"><a href="#Rails" class="headerlink" title="Rails"></a>Rails</h3><p>Description:<br>There is a famous railway station in PopPush City. Country there is incredibly hilly. The station was built in last century. Unfortunately, funds were extremely limited that time. It was possible to establish only a surface track. Moreover, it turned out that the station could be only a dead-end one (see picture) and due to lack of available space it could have only one track.<br><img src="https://i.loli.net/2019/07/19/5d31704637c7063277.png" alt><br>The local tradition is that every train arriving from the direction A continues in the direction B with coaches reorganized in some way. Assume that the train arriving from the direction A has N &lt;= 1000 coaches numbered in increasing order 1, 2, ..., N. The chief for train reorganizations must know whether it is possible to marshal coaches continuing in the direction B so that their order will be a1, a2, ..., aN. Help him and write a program that decides whether it is possible to get the required order of coaches. You can assume that single coaches can be disconnected from the train before they enter the station and that they can move themselves until they are on the track in the direction B. You can also suppose that at any time there can be located as many coaches as necessary in the station. But once a coach has entered the station it cannot return to the track in the direction A and also once it has left the station in the direction B it cannot return back to the station.</p><p>Input</p><blockquote><p>The input consists of blocks of lines. Each block except the last describes one train and possibly more requirements for its reorganization. In the first line of the block there is the integer N described above. In each of the next lines of the block there is a permutation of 1, 2, ..., N. The last line of the block contains just 0.<br>The last block consists of just one line containing 0.</p></blockquote><p>Output</p><blockquote><p>The output contains the lines corresponding to the lines with permutations in the input. A line of the output contains Yes if it is possible to marshal the coaches in the order required on the corresponding line of the input. Otherwise it contains No. In addition, there is one empty line after the lines corresponding to one block of the input. There is no line in the output corresponding to the last null&#39; block of the input.</p></blockquote><p>Sample Input</p><blockquote><p>5<br>1 2 3 4 5<br>5 4 1 2 3<br>0<br>6<br>6 5 4 3 2 1<br>0<br>0</p></blockquote><p>Sample Output<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line"></span><br><span class="line">Yes</span><br></pre></td></tr></table></figure></p><p>Problem solving:<br>An easy stack question.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[1005];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    while (scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        while (1)</span><br><span class="line">        &#123;</span><br><span class="line">            int flag = 0;</span><br><span class="line">            for (int i = 0; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                cin &gt;&gt; a[i];</span><br><span class="line">                if (a[i] == 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    flag = 1; break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (flag)</span><br><span class="line">                break;</span><br><span class="line">            stack&lt;int&gt; sta;</span><br><span class="line">            int        pos = 0;</span><br><span class="line">            for (int i = 1; i &lt;= n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                sta.push(i);</span><br><span class="line">                while (!sta.empty() &amp;&amp; sta.top() == a[pos])</span><br><span class="line">                &#123;</span><br><span class="line">                    sta.pop();</span><br><span class="line">                    pos++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (sta.empty())</span><br><span class="line">                puts(&quot;Yes&quot;);</span><br><span class="line">            else</span><br><span class="line">                puts(&quot;No&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        puts(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="D-A-B"><a href="#D-A-B" class="headerlink" title="D - {A} + {B}"></a>D - {A} + {B}</h3><p>Description:<br>给你两个集合，要求{A} + {B}.<br>注:同一个集合中不会有两个相同的元素.<br>Input</p><blockquote><p>每组输入数据分为三行,第一行有两个数字n,m(0&lt;n,m&lt;=10000),分别表示集合A和集合B的元素个数.后两行分别表示集合A和集合B.每个元素为不超出int范围的整数,每个元素之间有一个空格隔开.</p></blockquote><p>Output</p><blockquote><p>针对每组数据输出一行数据,表示合并后的集合,要求从小到大输出,每个元素之间有一个空格隔开.</p></blockquote><p>Sample Input</p><blockquote><p>1 2<br>1<br>2 3<br>1 2<br>1<br>1 2</p></blockquote><p>Sample Output</p><blockquote><p>1 2 3<br>1 2</p></blockquote><p>Problem solving:<br>An easy set question.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n, m, a;</span><br><span class="line">    while (~scanf(&quot;%d %d&quot;, &amp;n, &amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        set&lt;int&gt; s;</span><br><span class="line">        for (int i = 0; i &lt; n + m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; a;</span><br><span class="line">            s.insert(a);</span><br><span class="line">        &#125;</span><br><span class="line">        for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (it == s.begin())</span><br><span class="line">                cout &lt;&lt; *it;</span><br><span class="line">            else</span><br><span class="line">                cout &lt;&lt; &quot; &quot; &lt;&lt; *it;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="水果"><a href="#水果" class="headerlink" title="水果"></a>水果</h3><p>Description:<br>夏天来了<del>好开心啊,呵呵,好多好多水果</del><br>Joe经营着一个不大的水果店.他认为生存之道就是经营最受顾客欢迎的水果.现在他想要一份水果销售情况的明细表,这样Joe就可以很容易掌握所有水果的销售情况了.<br>Input</p><blockquote><p>第一行正整数N(0&lt;N&lt;=10)表示有N组测试数据.<br>每组测试数据的第一行是一个整数M(0&lt;M&lt;=100),表示工有M次成功的交易.其后有M行数据,每行表示一次交易,由水果名称(小写字母组成,长度不超过80),水果产地(小写字母组成,长度不超过80)和交易的水果数目(正整数,不超过100)组成.</p></blockquote><p>Output</p><blockquote><p>对于每一组测试数据,请你输出一份排版格式正确(请分析样本输出)的水果销售情况明细表.这份明细表包括所有水果的产地,名称和销售数目的信息.水果先按产地分类,产地按字母顺序排列;同一产地的水果按照名称排序,名称按字母顺序排序.<br>两组测试数据之间有一个空行.最后一组测试数据之后没有空行.</p></blockquote><p>Sample Input</p><blockquote><p>1<br>5<br>apple shandong 3<br>pineapple guangdong 1<br>sugarcane guangdong 1<br>pineapple guangdong 3<br>pineapple guangdong 1</p></blockquote><p>Sample Output</p><blockquote><p>guangdong<br>　　|----pineapple(5)<br>　　|----sugarcane(1)<br>shandong<br>　　|----apple(3)</p></blockquote><p>Problem solving:<br>An unusual problem.We can ues a map in map.And then the iterator is a little different now.Just see the Code.Luckily,map can automatic sorting makes this problem is not so hard.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int    n, m, p;</span><br><span class="line">    string x, y;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    int xxxx=0;</span><br><span class="line">    while (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        if(xxxx!=0) puts(&quot;&quot;);</span><br><span class="line">        xxxx=1;</span><br><span class="line">        int                            i = 0;</span><br><span class="line">        map&lt;string, map&lt;string, int&gt; &gt; ma;</span><br><span class="line">        cin &gt;&gt; m;</span><br><span class="line">        while (m--)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; p;</span><br><span class="line">            ma[y][x] += p;</span><br><span class="line">        &#125;</span><br><span class="line">        map&lt;string, int&gt;::iterator iit;</span><br><span class="line">        for (map&lt;string, map&lt;string, int&gt; &gt;::iterator it = ma.begin(); it != ma.end(); it++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; it-&gt;first &lt;&lt; endl;</span><br><span class="line">            for (iit = it-&gt;second.begin(); iit != it-&gt;second.end(); iit++)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; &quot;   |----&quot; &lt;&lt; iit-&gt;first &lt;&lt; &quot;(&quot; &lt;&lt; iit-&gt;second &lt;&lt; &quot;)&quot; &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Let-the-Balloon-Rise"><a href="#Let-the-Balloon-Rise" class="headerlink" title="Let the Balloon Rise"></a>Let the Balloon Rise</h3><p>Description:<br>Contest time again! How excited it is to see balloons floating around. But to tell you a secret, the judges&#39; favorite time is guessing the most popular problem. When the contest is over, they will count the balloons of each color and find the result.<br>This year, they decide to leave this lovely job to you.<br>Input</p><blockquote><p>Input contains multiple test cases. Each test case starts with a number N (0 &lt; N &lt;= 1000) -- the total number of balloons distributed. The next N lines contain one color each. The color of a balloon is a string of up to 15 lower-case letters.<br>A test case with N = 0 terminates the input and this test case is not to be processed.</p></blockquote><p>Output</p><blockquote><p>For each case, print the color of balloon for the most popular problem on a single line. It is guaranteed that there is a unique solution for each test case.</p></blockquote><p>Sample Input</p><blockquote><p>5<br>green<br>red<br>blue<br>red<br>red<br>3<br>pink<br>orange<br>pink<br>0</p></blockquote><p>Sample Output</p><blockquote><p>red<br>pink</p></blockquote><p>Problem solving:<br>An easy map problem.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int    n;</span><br><span class="line">    string s;</span><br><span class="line">    while (cin &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        map&lt;string, int&gt; ma;</span><br><span class="line">        if (n == 0)</span><br><span class="line">            break;</span><br><span class="line">        while (n--)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; s;</span><br><span class="line">            ma[s]++;</span><br><span class="line">        &#125;</span><br><span class="line">        int    mid = 0;</span><br><span class="line">        string ans;</span><br><span class="line">        for (map&lt;string, int&gt;::iterator it = ma.begin(); it != ma.end(); it++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (it-&gt;second &gt; mid)</span><br><span class="line">            &#123;</span><br><span class="line">                ans = it-&gt;first;</span><br><span class="line">                mid = it-&gt;second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="不重复数字"><a href="#不重复数字" class="headerlink" title="不重复数字"></a>不重复数字</h3><p>Description:<br>给出N个数，要求把其中重复的去掉，只保留第一次出现的数。<br>例如，给出的数为1 2 18 3 3 19 2 3 6 5 4，其中2和3有重复，去除后的结果为1 2 18 3 19 6 5 4。</p><p>Input</p><blockquote><p>输入第一行为正整数T，表示有T组数据。<br>接下来每组数据包括两行，第一行为正整数N，表示有N个数。第二行为要去重的N个正整数。</p></blockquote><p>Output</p><blockquote><p>对于每组数据，输出一行，为去重后剩下的数字，数字之间用一个空格隔开。</p></blockquote><p>Sample Input</p><blockquote><p>2<br>11<br>1 2 18 3 3 19 2 3 6 5 4<br>6<br>1 2 3 4 5 6</p></blockquote><p>Sample Output</p><blockquote><p>1 2 18 3 19 6 5 4<br>1 2 3 4 5 6</p></blockquote><p>Hint</p><blockquote><p>对于30%的数据，1 &lt;= N &lt;= 100，给出的数不大于100，均为非负整数；<br>对于50%的数据，1 &lt;= N &lt;= 10000，给出的数不大于10000，均为非负整数；<br>对于100%的数据，1 &lt;= N &lt;= 50000，给出的数在32位有符号整数范围内。<br>提示:<br>由于数据量很大，使用C++的同学请使用scanf和printf来进行输入输出操作，以免浪费不必要的时间。</p></blockquote><p>Problem solving:<br>We can&#39;t use set here because set will automatic sort.I wanted to ues a flag array to know the number has appread or not.But always RE.So I choose a set to know if the number has already appeared.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">    while (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        int        n, a;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">        set&lt;int&gt;   s;</span><br><span class="line">        int        mid = s.size();</span><br><span class="line">        queue&lt;int&gt; q;</span><br><span class="line">        while (n--)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;a);</span><br><span class="line">            s.insert(a);</span><br><span class="line">            if (s.size() != mid)</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(a);</span><br><span class="line">                mid = s.size();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; q.front() &lt;&lt; &quot; &quot;;</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        puts(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Andy-39-s-First-Dictionary"><a href="#Andy-39-s-First-Dictionary" class="headerlink" title="Andy&#39;s First Dictionary"></a>Andy&#39;s First Dictionary</h3><p>Description:<br>Andy, 8, has a dream - he wants to produce his very own dictionary. This is not an easy task for him, as the number of words that he knows is, well, not quite enough. Instead of thinking up all the words himself, he has a briliant idea. From his bookshelf he would pick one of his favourite story books, from which he would copy out all the distinct words. By arranging the words in<br>alphabetical order, he is done! Of course, it is a really time-consuming job, and this is where a computer program is helpful.You are asked to write a program that lists all the different words in the input text. In this problem, a word is defined as a consecutive sequence of alphabets, in upper and/or lower case. Words with only one letter are also to be considered. Furthermore, your program must be CaSe InSeNsItIvE. For example, words like “Apple”, “apple” or “APPLE” must be considered the same.<br>Input</p><blockquote><p>The input file is a text with no more than 5000 lines. An input line has at most 200 characters. Input<br>is terminated by EOF.</p></blockquote><p>Output</p><blockquote><p>Your output should give a list of different words that appears in the input text, one in a line. The<br>words should all be in lower case, sorted in alphabetical order. You can be sure that he number of<br>distinct words in the text does not exceed 5000.</p></blockquote><p>Sample Input</p><blockquote><p>Adventures in Disneyland<br>Two blondes were going to Disneyland when they came to a fork in the<br>road. The sign read: &quot;Disneyland Left.&quot;<br>So they went home.</p></blockquote><p>Sample Output</p><blockquote><p>a<br>adventures<br>blondes<br>came<br>disneyland<br>fork<br>going<br>home<br>in<br>left<br>read<br>road<br>sign<br>so<br>the<br>they<br>to<br>two<br>went<br>were<br>when</p></blockquote><p>Problem solving:<br>I know a new useful function through this problem--Stringstream.I will write a new artical about this these days.It&#39;s amazing,suitable for us who is lazy.About this problem,you just know what you should do:</p><ol><li>Turn uppercase letter to lower case letters.</li><li>Delete the char which is not a letter.</li></ol><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string      s;</span><br><span class="line">    set&lt;string&gt; se;</span><br><span class="line">    while (cin &gt;&gt; s)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i &lt; s.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (s[i] &gt;= &apos;A&apos; &amp;&amp; s[i] &lt;= &apos;Z&apos;)</span><br><span class="line">                s[i] += 32;</span><br><span class="line">            else if (s[i] &gt;= &apos;a&apos; &amp;&amp; s[i] &lt;= &apos;z&apos;)</span><br><span class="line">                s[i] = s[i];</span><br><span class="line">            else</span><br><span class="line">                s[i] = &apos; &apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        string       mi;</span><br><span class="line">        stringstream mid(s);</span><br><span class="line">        while (mid &gt;&gt; mi)</span><br><span class="line">        &#123;</span><br><span class="line">            se.insert(mi);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (set&lt;string&gt;::iterator it = se.begin(); it != se.end(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="A-and-B-and-Compilation-Errors"><a href="#A-and-B-and-Compilation-Errors" class="headerlink" title="A and B and Compilation Errors"></a>A and B and Compilation Errors</h3><p>Description:<br>A and B are preparing themselves for programming contests.</p><p>B loves to debug his code. But before he runs the solution and starts debugging, he has to first compile the code.</p><p>Initially, the compiler displayed n compilation errors, each of them is represented as a positive integer. After some effort, B managed to fix some mistake and then another one mistake.</p><p>However, despite the fact that B is sure that he corrected the two errors, he can not understand exactly what compilation errors disappeared — the compiler of the language which B uses shows errors in the new order every time! B is sure that unlike many other programming languages, compilation errors for his programming language do not depend on each other, that is, if you correct one error, the set of other error does not change.</p><p>Can you help B find out exactly what two errors he corrected?</p><p>Input</p><blockquote><p>The first line of the input contains integer n (3 ≤ n ≤ 105) — the initial number of compilation errors.<br>The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 109) — the errors the compiler displayed for the first time.<br>The third line contains n - 1 space-separated integers b1, b2, ..., bn - 1 — the errors displayed at the second compilation. It is guaranteed that the sequence in the third line contains all numbers of the second string except for exactly one.<br>The fourth line contains n - 2 space-separated integers с1, с2, ..., сn - 2 — the errors displayed at the third compilation. It is guaranteed that the sequence in the fourth line contains all numbers of the third line except for exactly one.</p></blockquote><p>Output</p><blockquote><p>Print two numbers on a single line: the numbers of the compilation errors that disappeared after B made the first and the second correction, respectively.</p></blockquote><p>Examples<br>Input</p><blockquote><p>5<br>1 5 8 123 7<br>123 7 5 1<br>5 1 7</p></blockquote><p>Output</p><blockquote><p>8<br>123</p></blockquote><p>Input</p><blockquote><p>6<br>1 4 3 3 5 7<br>3 7 5 4 3<br>4 3 7 5</p></blockquote><p>Output</p><blockquote><p>1<br>3</p></blockquote><p>Note</p><blockquote><p>In the first test sample B first corrects the error number 8, then the error number 123.<br>In the second test sample B first corrects the error number 1, then the error number 3. Note that if there are multiple errors with the same number, B can correct only one of them in one step.</p></blockquote><p>Problem solving:<br>Through reding,you will kown the first line we output is the different number between the second line and the third line we input,and the second line we output is the different number between the third line and the fourth line we input.I choose a force way but easy to understand.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int           n, a;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    map&lt;int, int&gt; ma;</span><br><span class="line">    map&lt;int, int&gt; ma1;</span><br><span class="line">    map&lt;int, int&gt; ma2;</span><br><span class="line">    for (int i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        ma[a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; n - 1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        ma1[a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; n - 2; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        ma2[a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    int x = 0, y = 0;</span><br><span class="line">    for (map&lt;int, int&gt;::iterator it = ma.begin(); it != ma.end(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid = it-&gt;first;</span><br><span class="line">        if (ma[mid] != ma1[mid])</span><br><span class="line">            cout &lt;&lt; mid &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    for (map&lt;int, int&gt;::iterator it = ma1.begin(); it != ma1.end(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid = it-&gt;first;</span><br><span class="line">        if (ma2[mid] != ma1[mid])</span><br><span class="line">            cout &lt;&lt; mid &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="排列2"><a href="#排列2" class="headerlink" title="排列2"></a>排列2</h3><p>Description:<br>Ray又对数字的列产生了兴趣：<br>现有四张卡片，用这四张卡片能排列出很多不同的4位数，要求按从小到大的顺序输出这些4位数。<br>Input</p><blockquote><p>每组数据占一行，代表四张卡片上的数字（0&lt;=数字&lt;=9），如果四张卡片都是0，则输入结束。</p></blockquote><p>Output</p><blockquote><p>对每组卡片按从小到大的顺序输出所有能由这四张卡片组成的4位数，千位数字相同的在同一行，同一行中每个四位数间用空格分隔。<br>每组输出数据间空一行，最后一组数据后面没有空行。</p></blockquote><p>Sample Input</p><blockquote><p>1 2 3 4<br>1 1 2 3<br>0 1 2 3<br>0 0 0 0</p></blockquote><p>Sample Output<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1234 1243 1324 1342 1423 1432</span><br><span class="line">2134 2143 2314 2341 2413 2431</span><br><span class="line">3124 3142 3214 3241 3412 3421</span><br><span class="line">4123 4132 4213 4231 4312 4321</span><br><span class="line"></span><br><span class="line">1123 1132 1213 1231 1312 1321</span><br><span class="line">2113 2131 2311</span><br><span class="line">3112 3121 3211</span><br><span class="line"></span><br><span class="line">1023 1032 1203 1230 1302 1320</span><br><span class="line">2013 2031 2103 2130 2301 2310</span><br><span class="line">3012 3021 3102 3120 3201 3210</span><br></pre></td></tr></table></figure></p><p>Problem solving:<br>An easy problem through &#39;next_permutation()&#39;.The most disgusting place is the format.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[5];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int mid, x = 0;</span><br><span class="line">    while (scanf(&quot;%d %d %d %d&quot;, &amp;a[0], &amp;a[1], &amp;a[2], &amp;a[3]) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        sort(a, a + 4);</span><br><span class="line">        if (a[0] == 0 &amp;&amp; a[1] == 0 &amp;&amp; a[2] == 0 &amp;&amp; a[3] == 0)</span><br><span class="line">            break;</span><br><span class="line">        if (x)</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        x = 1;</span><br><span class="line">        int flag = 1;</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            if (a[0] == 0)</span><br><span class="line">                continue;</span><br><span class="line">            if (flag)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; a[0] &lt;&lt; a[1] &lt;&lt; a[2] &lt;&lt; a[3];</span><br><span class="line">                flag = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (mid == a[0])</span><br><span class="line">                cout &lt;&lt; &quot; &quot; &lt;&lt; a[0] &lt;&lt; a[1] &lt;&lt; a[2] &lt;&lt; a[3];</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; endl;</span><br><span class="line">                cout &lt;&lt; a[0] &lt;&lt; a[1] &lt;&lt; a[2] &lt;&lt; a[3];</span><br><span class="line">            &#125;</span><br><span class="line">            mid = a[0];</span><br><span class="line">        &#125; while (next_permutation(a, a + 4));</span><br><span class="line">        puts(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>I have too much PE before I passed this problem.</p><h3 id="Ignatius-and-the-Princess-II"><a href="#Ignatius-and-the-Princess-II" class="headerlink" title="Ignatius and the Princess II"></a>Ignatius and the Princess II</h3><p>Description:<br>Now our hero finds the door to the BEelzebub feng5166. He opens the door and finds feng5166 is about to kill our pretty Princess. But now the BEelzebub has to beat our hero first. feng5166 says, &quot;I have three question for you, if you can work them out, I will release the Princess, or you will be my dinner, too.&quot; Ignatius says confidently, &quot;OK, at last, I will save the Princess.&quot;</p><p>&quot;Now I will show you the first problem.&quot; feng5166 says, &quot;Given a sequence of number 1 to N, we define that 1,2,3...N-1,N is the smallest sequence among all the sequence which can be composed with number 1 to N(each number can be and should be use only once in this problem). So it&#39;s easy to see the second smallest sequence is 1,2,3...N,N-1. Now I will give you two numbers, N and M. You should tell me the Mth smallest sequence which is composed with number 1 to N. It&#39;s easy, isn&#39;t is? Hahahahaha......&quot;<br>Can you help Ignatius to solve this problem?<br>Input</p><blockquote><p>The input contains several test cases. Each test case consists of two numbers, N and M(1&lt;=N&lt;=1000, 1&lt;=M&lt;=10000). You may assume that there is always a sequence satisfied the BEelzebub&#39;s demand. The input is terminated by the end of file.</p></blockquote><p>Output</p><blockquote><p>For each test case, you only have to output the sequence satisfied the BEelzebub&#39;s demand. When output a sequence, you should print a space between two numbers, but do not output any spaces after the last number.</p></blockquote><p>Sample Input</p><blockquote><p>6 4<br>11 8</p></blockquote><p>Sample Output</p><blockquote><p>1 2 3 5 6 4<br>1 2 3 4 5 6 7 9 8 11 10</p></blockquote><p>Problem solving:<br>An easy problem through &#39;next_permutation()&#39;.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[1005];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    while (~scanf(&quot;%d %d&quot;, &amp;n, &amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        int flag = 0;</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            flag++;</span><br><span class="line">            if (flag == m)</span><br><span class="line">                break;</span><br><span class="line">        &#125; while (next_permutation(a + 1, a + n + 1));</span><br><span class="line">        for (int i = 1; i &lt; n; i++)</span><br><span class="line">            cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">        cout &lt;&lt; a[n] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天主要讲了点基本的STL的用法。题写的有点吃力了，以后可能就写不完了，然后攒着写不完的题一天比一天多。&lt;br&gt;Nothing can change my love for you,even you.
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="Algorithm" scheme="https://cndrew.cn/blog/tags/Algorithm/"/>
    
      <category term="c/c++" scheme="https://cndrew.cn/blog/tags/c-c/"/>
    
      <category term="Thinking" scheme="https://cndrew.cn/blog/tags/Thinking/"/>
    
      <category term="CodeForces" scheme="https://cndrew.cn/blog/tags/CodeForces/"/>
    
      <category term="HDU" scheme="https://cndrew.cn/blog/tags/HDU/"/>
    
      <category term="poj" scheme="https://cndrew.cn/blog/tags/poj/"/>
    
      <category term="STL" scheme="https://cndrew.cn/blog/tags/STL/"/>
    
      <category term="UVA" scheme="https://cndrew.cn/blog/tags/UVA/"/>
    
      <category term="math" scheme="https://cndrew.cn/blog/tags/math/"/>
    
      <category term="Stack" scheme="https://cndrew.cn/blog/tags/Stack/"/>
    
      <category term="Queue" scheme="https://cndrew.cn/blog/tags/Queue/"/>
    
      <category term="Stringstream" scheme="https://cndrew.cn/blog/tags/Stringstream/"/>
    
  </entry>
  
  <entry>
    <title>HPU Summer Training Day x（河南理工大学暑期第x天）</title>
    <link href="https://cndrew.cn/blog/2019/07/18/dx/"/>
    <id>https://cndrew.cn/blog/2019/07/18/dx/</id>
    <published>2019-07-18T15:18:12.867Z</published>
    <updated>2019-07-19T12:11:05.984Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主要学的是快速幂，gcd<br>I don&#39;t know what day this is,just record it.<a id="more"></a></p><h3 id="Pseudoprime-numbers"><a href="#Pseudoprime-numbers" class="headerlink" title="Pseudoprime numbers"></a>Pseudoprime numbers</h3><p>Description:<br>Fermat&#39;s theorem states that for any prime number p and for any integer a &gt; 1, ap = a (mod p). That is, if we raise a to the pth power and divide by p, the remainder is a. Some (but not very many) non-prime values of p, known as base-a pseudoprimes, have this property for some a. (And some, known as Carmichael Numbers, are base-a pseudoprimes for all a.)</p><p>Given 2 &lt; p ≤ 1000000000 and 1 &lt; a &lt; p, determine whether or not p is a base-a pseudoprime.</p><p>Input</p><blockquote><p>Input contains several test cases followed by a line containing &quot;0 0&quot;. Each test case consists of a line containing p and a.</p></blockquote><p>Output</p><blockquote><p>For each test case, output &quot;yes&quot; if p is a base-a pseudoprime; otherwise output &quot;no&quot;.</p></blockquote><p>Sample Input</p><blockquote><p>3 2<br>10 3<br>341 2<br>341 3<br>1105 2<br>1105 3<br>0 0</p></blockquote><p>Sample Output</p><blockquote><p>no<br>no<br>yes<br>no<br>yes<br>yes</p></blockquote><p>Problem solving:<br>First judge p is a prime number or not,if p is a prime number output &#39;no&#39;,else then judge a^p%p is equal to a or not,if not equal output &#39;no&#39;.We should use fast power to avoid TLE.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">int s(long long a)</span><br><span class="line">&#123;</span><br><span class="line">if(a==2)</span><br><span class="line">return 1;</span><br><span class="line">for(int i=2;i*i&lt;=a;i++)</span><br><span class="line">if(a%i==0)</span><br><span class="line">return 0;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">long long f(long long a,long long b,long long c)//快速幂模板</span><br><span class="line">&#123;</span><br><span class="line">long long t=1;</span><br><span class="line">a=a%c;</span><br><span class="line">while(b&gt;0)</span><br><span class="line">&#123;</span><br><span class="line">if(b%2==1)</span><br><span class="line">t=t*a%c;</span><br><span class="line">b=b/2;</span><br><span class="line">a=a*a%c;</span><br><span class="line">&#125;</span><br><span class="line">return t;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">long long  a,p;</span><br><span class="line">while(~scanf(&quot;%lld%lld&quot;,&amp;p,&amp;a)&amp;&amp;!(a==0&amp;&amp;p==0))</span><br><span class="line">&#123;</span><br><span class="line">if(s(p))</span><br><span class="line">printf(&quot;no\n&quot;);</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">if(f(a,p,p)==a)</span><br><span class="line">        printf(&quot;yes\n&quot;);</span><br><span class="line">       else</span><br><span class="line">       printf(&quot;no\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Raising-Modulo-Numbers"><a href="#Raising-Modulo-Numbers" class="headerlink" title="Raising Modulo Numbers"></a>Raising Modulo Numbers</h3><p>Description:<br>People are different. Some secretly read magazines full of interesting girls&#39; pictures, others create an A-bomb in their cellar, others like using Windows, and some like difficult mathematical games. Latest marketing research shows, that this market segment was so far underestimated and that there is lack of such games. This kind of game was thus included into the KOKODáKH. The rules follow:</p><p>Each player chooses two numbers Ai and Bi and writes them on a slip of paper. Others cannot see the numbers. In a given moment all players show their numbers to the others. The goal is to determine the sum of all expressions Ai Bi from all players including oneself and determine the remainder after division by a given number M. The winner is the one who first determines the correct result. According to the players&#39; experience it is possible to increase the difficulty by choosing higher numbers.</p><p>You should write a program that calculates the result and is able to find out who won the game.</p><p>Input</p><blockquote><p>The input consists of Z assignments. The number of them is given by the single positive integer Z appearing on the first line of input. Then the assignements follow. Each assignement begins with line containing an integer M (1 &lt;= M &lt;= 45000). The sum will be divided by this number. Next line contains number of players H (1 &lt;= H &lt;= 45000). Next exactly H lines follow. On each line, there are exactly two numbers Ai and Bi separated by space. Both numbers cannot be equal zero at the same time.</p></blockquote><p>Output</p><blockquote><p>For each assingnement there is the only one line of output. On this line, there is a number, the result of expression</p></blockquote><p><img src="https://i.loli.net/2019/07/18/5d30905f4767b53419.png" alt></p><p>Sample Input</p><blockquote><p>3<br>16<br>4<br>2 3<br>3 4<br>4 5<br>5 6<br>36123<br>1<br>2374859 3029382<br>17<br>1<br>3 18132</p></blockquote><p>Sample Output</p><blockquote><p>2<br>13195<br>13</p></blockquote><p>Problem solving:<br>I don&#39;t understand this problem clearly first time,and then I find a little hint in the output,so it&#39;s easy now.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll poww(ll x, ll y, ll maxn)</span><br><span class="line">&#123;</span><br><span class="line">    ll res = 1;</span><br><span class="line">    while (y)</span><br><span class="line">    &#123;</span><br><span class="line">        if (y % 2 != 0)</span><br><span class="line">            res = res * x % maxn;</span><br><span class="line">        x  = x * x % maxn;</span><br><span class="line">        y /= 2;</span><br><span class="line">    &#125;</span><br><span class="line">    return res % maxn;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    ll a, b, c, d, e;</span><br><span class="line">    while (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll sum = 0;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        while (b--)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; d &gt;&gt; e;</span><br><span class="line">            sum += poww(d, e, a);</span><br><span class="line">            sum %= a;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Wolf-and-Rabbit"><a href="#Wolf-and-Rabbit" class="headerlink" title="Wolf and Rabbit"></a>Wolf and Rabbit</h3><p>Description:<br>There is a hill with n holes around. The holes are signed from 0 to n-1.<br><img src="https://i.loli.net/2019/07/18/5d3090c87d97386427.png" alt><br>A rabbit must hide in one of the holes. A wolf searches the rabbit in anticlockwise order. The first hole he get into is the one signed with 0. Then he will get into the hole every m holes. For example, m=2 and n=6, the wolf will get into the holes which are signed 0,2,4,0. If the rabbit hides in the hole which signed 1,3 or 5, she will survive. So we call these holes the safe holes.<br>Input</p><blockquote><p>The input starts with a positive integer P which indicates the number of test cases. Then on the following P lines,each line consists 2 positive integer m and n(0&lt;m,n&lt;2147483648).</p></blockquote><p>Output</p><blockquote><p>For each input m n, if safe holes exist, you should output &quot;YES&quot;, else output &quot;NO&quot; in a single line.</p></blockquote><p>Sample Input</p><blockquote><p>2<br>1 2<br>2 2</p></blockquote><p>Sample Output</p><blockquote><p>NO<br>YES</p></blockquote><p>Problem solving:<br>Nothing to say,just judge the gcd of m and n is equal to 1 or not.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,a,b;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">while(n--)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;a,&amp;b);</span><br><span class="line">if(__gcd(a,b)==1)puts(&quot;NO&quot;);</span><br><span class="line">elseputs(&quot;YES&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Cake"><a href="#Cake" class="headerlink" title="Cake"></a>Cake</h3><p>Description:<br>一次生日Party可能有p人或者q人参加,现准备有一个大蛋糕.问最少要将蛋糕切成多少块(每块大小不一定相等),才能使p人或者q人出席的任何一种情况,都能平均将蛋糕分食.<br>Input</p><blockquote><p>每行有两个数p和q.</p></blockquote><p>Output</p><blockquote><p>输出最少要将蛋糕切成多少块.</p></blockquote><p>Sample Input</p><blockquote><p>2 3</p></blockquote><p>Sample Output</p><blockquote><p>4</p></blockquote><p>Hint</p><blockquote><p>将蛋糕切成大小分别为1/3,1/3,1/6,1/6的四块即满足要求.<br>当2个人来时，每人可以吃1/3+1/6=1/2 , 1/2块。<br>当3个人来时，每人可以吃1/6+1/6=1/3 , 1/3, 1/3块。</p></blockquote><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int p, q;</span><br><span class="line">    while (~scanf(&quot;%d %d&quot;, &amp;p, &amp;q))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; p + q - __gcd(p, q) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="又见GCD"><a href="#又见GCD" class="headerlink" title="又见GCD"></a>又见GCD</h3><p>Description:<br>有三个正整数a,b,c(0&lt;a,b,c&lt;10^6)，其中c不等于b。若a和c的最大公约数为b，现已知a和b，求满足条件的最小的c。<br>Input</p><blockquote><p>第一行输入一个n，表示有n组测试数据，接下来的n行，每行输入两个正整数a,b。</p></blockquote><p>Output</p><blockquote><p>输出对应的c，每组测试数据占一行。</p></blockquote><p>Sample Input</p><blockquote><p>2<br>6 2<br>12 4</p></blockquote><p>Sample Output</p><blockquote><p>4<br>8</p></blockquote><p>Problem solving:<br>What we would like to find is the smallest c,so begin with 2*b.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n, a, b;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    while (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        for (int i = b * 2; ; i += b)</span><br><span class="line">        &#123;</span><br><span class="line">            if (__gcd(a, i) == b)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; i &lt;&lt; endl; break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h3><p>Description:<br>给定两个正整数，计算这两个数的最小公倍数。<br>Input</p><blockquote><p>输入包含多组测试数据，每组只有一行，包括两个不大于1000的正整数.</p></blockquote><p>Output</p><blockquote><p>对于每个测试用例，给出这两个数的最小公倍数，每个实例输出一行。</p></blockquote><p>Sample Input</p><blockquote><p>10 14</p></blockquote><p>Sample Output</p><blockquote><p>70</p></blockquote><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ll n, a, b;</span><br><span class="line">    while (~scanf(&quot;%lld %lld&quot;, &amp;a, &amp;b))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a * b / __gcd(a, b) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="素数判定"><a href="#素数判定" class="headerlink" title="素数判定"></a>素数判定</h3><p>Description:<br>对于表达式n^2+n+41，当n在（x,y）范围内取整数值时（包括x,y）(-39&lt;=x&lt;y&lt;=50)，判定该表达式的值是否都为素数。<br>Input</p><blockquote><p>输入数据有多组，每组占一行，由两个整数x，y组成，当x=0,y=0时，表示输入结束，该行不做处理。</p></blockquote><p>Output</p><blockquote><p>对于每个给定范围内的取值，如果表达式的值都为素数，则输出&quot;OK&quot;,否则请输出“Sorry”,每组输出占一行。</p></blockquote><p>Sample Input</p><blockquote><p>0 1<br>0 0</p></blockquote><p>Sample Output</p><blockquote><p>OK</p></blockquote><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">bool check(ll x)</span><br><span class="line">&#123;</span><br><span class="line">    if (x == 2)</span><br><span class="line">        return 0;</span><br><span class="line">    for (int i = 2; i &lt; sqrt(x + 1); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (x % i == 0)</span><br><span class="line">            return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ll n, a, b;</span><br><span class="line">    while (scanf(&quot;%lld %lld&quot;, &amp;a, &amp;b))</span><br><span class="line">    &#123;</span><br><span class="line">        int flag = 0;</span><br><span class="line">        if (a == 0 &amp;&amp; b == 0)</span><br><span class="line">            break;</span><br><span class="line">        for (ll i = a; i &lt;= b; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ll mid = i*i+ i + 41;</span><br><span class="line">            if (check(mid))</span><br><span class="line">            &#123;</span><br><span class="line">                flag = 1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (flag)</span><br><span class="line">            puts(&quot;Sorry&quot;);</span><br><span class="line">        else</span><br><span class="line">            puts(&quot;OK&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="分拆素数和"><a href="#分拆素数和" class="headerlink" title="分拆素数和"></a>分拆素数和</h3><p>Description:<br>把一个偶数拆成两个不同素数的和，有几种拆法呢？<br>Input</p><blockquote><p>输入包含一些正的偶数，其值不会超过10000，个数不会超过500，若遇0，则结束。</p></blockquote><p>Output</p><blockquote><p>对应每个偶数，输出其拆成不同素数的个数，每个结果占一行。</p></blockquote><p>Sample Input</p><blockquote><p>30<br>26<br>0</p></blockquote><p>Sample Output</p><blockquote><p>3<br>2</p></blockquote><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn = 1e4 + 7;</span><br><span class="line">int       p[maxn];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; maxn; i++)</span><br><span class="line">        p[i] = 1;</span><br><span class="line">    p[0] = p[1] = 0;</span><br><span class="line">    for (int i = 2; i &lt;= sqrt(maxn + 1); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = i + i; j &lt; maxn; j += i)</span><br><span class="line">        &#123;</span><br><span class="line">            p[j] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll n, a, b;</span><br><span class="line">    while (scanf(&quot;%lld&quot;, &amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        if (n == 0)</span><br><span class="line">            break;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int i = 2; i &lt;n / 2; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (p[i] &amp;&amp; p[n - i])</span><br><span class="line">                ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="美素数"><a href="#美素数" class="headerlink" title="美素数"></a>美素数</h3><p>Description:<br>小明对数的研究比较热爱，一谈到数，脑子里就涌现出好多数的问题，今天，小明想考考你对素数的认识。<br>　　问题是这样的：一个十进制数，如果是素数，而且它的各位数字和也是素数，则称之为“美素数”，如29，本身是素数，而且2+9 = 11也是素数，所以它是美素数。<br>　　给定一个区间，你能计算出这个区间内有多少个美素数吗？<br>Input</p><blockquote><p>第一行输入一个正整数T，表示总共有T组数据(T &lt;= 10000)。<br>接下来共T行，每行输入两个整数L，R(1&lt;= L &lt;= R &lt;= 1000000)，表示区间的左值和右值。</p></blockquote><p>Output</p><blockquote><p>对于每组数据，先输出Case数，然后输出区间内美素数的个数（包括端点值L,R）。<br>每组数据占一行，具体输出格式参见样例。</p></blockquote><p>Sample Input</p><blockquote><p>3<br>1 100<br>2 2<br>3 19</p></blockquote><p>Sample Output</p><blockquote><p>Case #1: 14<br>Case #2: 1<br>Case #3: 4</p></blockquote><p>Problem solving:<br>Just By meter(打表).<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e6+7;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll p[maxn];</span><br><span class="line">ll a[maxn];</span><br><span class="line">bool check(ll x)</span><br><span class="line">&#123;</span><br><span class="line">if(p[x])return 0;</span><br><span class="line">ll mid=0;</span><br><span class="line">while(x)</span><br><span class="line">&#123;</span><br><span class="line">mid+=x%10;x/=10;</span><br><span class="line">&#125;</span><br><span class="line">if(p[mid])return 0;</span><br><span class="line">elsereturn 1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">p[0]=p[1]=1;</span><br><span class="line">for(ll i=2;i&lt;sqrt(maxn);i++)</span><br><span class="line">&#123;</span><br><span class="line">for(ll j=i*2;j&lt;maxn;j+=i)</span><br><span class="line">&#123;</span><br><span class="line">p[j]=1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a[0]=0;</span><br><span class="line">for(int i=1;i&lt;maxn;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(check(i))a[i]=a[i-1]+1;</span><br><span class="line">elsea[i]=a[i-1];</span><br><span class="line">&#125;</span><br><span class="line">ll t,l,r;</span><br><span class="line">while(~scanf(&quot;%lld&quot;,&amp;t))</span><br><span class="line">&#123;</span><br><span class="line">for(int i=1;i&lt;=t;i++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%lld %lld&quot;,&amp;l,&amp;r);</span><br><span class="line">printf(&quot;Case #%lld: %lld\n&quot;,i,a[r]-a[l-1]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Key-Set"><a href="#Key-Set" class="headerlink" title="Key Set"></a>Key Set</h3><p>Description:<br>soda has a set S with n integers {1,2,…,n}. A set is called key set if the sum of integers in the set is an even number. He wants to know how many nonempty subsets of S are key set.<br>Input</p><blockquote><p>There are multiple test cases. The first line of input contains an integer T (1≤T≤1e5), indicating the number of test cases. For each test case:<br>The first line contains an integer n (1≤n≤1e9), the number of integers in the set.</p></blockquote><p>Output</p><blockquote><p>For each test case, output the number of key sets modulo 1000000007.</p></blockquote><p>Sample Input</p><blockquote><p>4<br>1<br>2<br>3<br>4</p></blockquote><p>Sample Output</p><blockquote><p>0<br>1<br>3<br>7</p></blockquote><p>Problem solving:<br>The answer is 2^(a-1)-1<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn = 1000000007;</span><br><span class="line">ll poww(ll x, ll y)</span><br><span class="line">&#123;</span><br><span class="line">    ll res = 1;</span><br><span class="line">    while (y)</span><br><span class="line">    &#123;</span><br><span class="line">        if (y % 2 != 0)</span><br><span class="line">            res = res * x % maxn;</span><br><span class="line">        x  = x * x % maxn;</span><br><span class="line">        y /= 2;</span><br><span class="line">    &#125;</span><br><span class="line">    return res % maxn;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n, a, b;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    while (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        cout &lt;&lt; poww(2, a - 1) - 1 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="人见人爱A-B"><a href="#人见人爱A-B" class="headerlink" title="人见人爱A^B"></a>人见人爱A^B</h3><p>Description:<br>求A^B的最后三位数表示的整数。<br>说明：A^B的含义是“A的B次方”<br>Input</p><blockquote><p>输入数据包含多个测试实例，每个实例占一行，由两个正整数A和B组成（1&lt;=A,B&lt;=10000），如果A=0, B=0，则表示输入数据的结束，不做处理。</p></blockquote><p>Output</p><blockquote><p>对于每个测试实例，请输出A^B的最后三位表示的整数，每个输出占一行。</p></blockquote><p>Sample Input</p><blockquote><p>2 3<br>12 6<br>6789 10000<br>0 0</p></blockquote><p>Sample Output</p><blockquote><p>8<br>984<br>1</p></blockquote><p>Problem solving:<br>Fast power.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll poww(ll x, ll y, ll z)</span><br><span class="line">&#123;</span><br><span class="line">    ll ans = 1, base = x; while (y != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        if (y &amp; 1 != 0)</span><br><span class="line">            ans = ans * base % z;</span><br><span class="line">        base = (base % z) * (base % z) % z; y &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ll a, b;</span><br><span class="line">    while (scanf(&quot;%lld %lld&quot;, &amp;a, &amp;b))</span><br><span class="line">    &#123;</span><br><span class="line">        if (a == 0 &amp;&amp; b == 0)</span><br><span class="line">            break;</span><br><span class="line">        cout &lt;&lt; poww(a, b, 1000) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Rightmost-Digit"><a href="#Rightmost-Digit" class="headerlink" title="Rightmost Digit"></a>Rightmost Digit</h3><p>Description:<br>Given a positive integer N, you should output the most right digit of N^N.<br>Input</p><blockquote><p>The input contains several test cases. The first line of the input is a single integer T which is the number of test cases. T test cases follow.<br>Each test case contains a single positive integer N(1&lt;=N&lt;=1,000,000,000).</p></blockquote><p>Output</p><blockquote><p>For each test case, you should output the rightmost digit of N^N.</p></blockquote><p>Sample Input</p><blockquote><p>2<br>3<br>4</p></blockquote><p>Sample Output</p><blockquote><p>7<br>6</p></blockquote><p>Hint</p><blockquote><p>In the first case, 3 <em> 3 </em> 3 = 27, so the rightmost digit is 7.<br>In the second case, 4 <em> 4 </em> 4 * 4 = 256, so the rightmost digit is 6.</p></blockquote><p>Problem solving:<br>Fast power.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll poww(ll x, ll y, ll z)</span><br><span class="line">&#123;</span><br><span class="line">    ll ans = 1, base = x; while (y != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        if (y &amp; 1 != 0)</span><br><span class="line">            ans = ans * base % z;</span><br><span class="line">        base = (base % z) * (base % z) % z; y &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ll n, a;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    while (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        cout &lt;&lt; poww(a, a, 10) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要学的是快速幂，gcd&lt;br&gt;I don&amp;#39;t know what day this is,just record it.
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="Algorithm" scheme="https://cndrew.cn/blog/tags/Algorithm/"/>
    
      <category term="c/c++" scheme="https://cndrew.cn/blog/tags/c-c/"/>
    
      <category term="math" scheme="https://cndrew.cn/blog/tags/math/"/>
    
      <category term="Fast power" scheme="https://cndrew.cn/blog/tags/Fast-power/"/>
    
      <category term="prime" scheme="https://cndrew.cn/blog/tags/prime/"/>
    
      <category term="gcd" scheme="https://cndrew.cn/blog/tags/gcd/"/>
    
      <category term="lcm" scheme="https://cndrew.cn/blog/tags/lcm/"/>
    
  </entry>
  
  <entry>
    <title>Something about __gcd</title>
    <link href="https://cndrew.cn/blog/2019/07/18/sp-gcd/"/>
    <id>https://cndrew.cn/blog/2019/07/18/sp-gcd/</id>
    <published>2019-07-18T15:04:02.870Z</published>
    <updated>2019-07-18T15:43:48.047Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>I have written an article about gcd and lcm,I meet a new way to calculate gcd these days.<a id="more"></a><br>My past gcd aritical: <a href="https://cndrew.cn/blog/2019/03/26/GCD-LCM/">https://cndrew.cn/blog/2019/03/26/GCD-LCM/</a><br>For example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a=199,b=199*2;</span><br><span class="line">printf(&quot;%d\n&quot;,__gcd(a,b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">199</span><br></pre></td></tr></table></figure></p><p>The header file of __gcd is &#39;algorithm&#39;.<br>How about the Time complexity(时间复杂度) of it.<br>I found the source code for its implementation in the source file.Just like Division algorithm(辗转相除法).<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line">  *  This is a helper function for the rotate algorithm specialized on RAIs.</span><br><span class="line">  *  It returns the greatest common divisor of two integer values.</span><br><span class="line"> */</span><br><span class="line"> template&lt;typename _EuclideanRingElement&gt;</span><br><span class="line">   _EuclideanRingElement</span><br><span class="line">   __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)</span><br><span class="line">   &#123;</span><br><span class="line">     while (__n != 0)</span><br><span class="line">&#123;</span><br><span class="line">  _EuclideanRingElement __t = __m % __n;</span><br><span class="line">  __m = __n;</span><br><span class="line">  __n = __t;</span><br><span class="line">&#125;</span><br><span class="line">     return __m;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>Now it&#39;s clear that the Time complexity(时间复杂度) of it is log(n).<br>About this function,many people say it&#39;s probably forbidden in some test,and gcd is not so hard to write,just get too know it.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;I have written an article about gcd and lcm,I meet a new way to calculate gcd these days.
    
    </summary>
    
      <category term="Algorithm" scheme="https://cndrew.cn/blog/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://cndrew.cn/blog/tags/Algorithm/"/>
    
      <category term="c/c++" scheme="https://cndrew.cn/blog/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>HPU Summer Training Day 2（河南理工暑期集训第二天）</title>
    <link href="https://cndrew.cn/blog/2019/07/18/d2/"/>
    <id>https://cndrew.cn/blog/2019/07/18/d2/</id>
    <published>2019-07-18T14:55:32.227Z</published>
    <updated>2019-07-18T15:43:28.837Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天主要学习了sort，结构体的sort。<br>第一天算是结束了，还是有点累的，但是也很有收获，趁着这些题还都勉强能做出来，赶紧多写点吧.<a id="more"></a></p><h3 id="前m大的数"><a href="#前m大的数" class="headerlink" title="前m大的数"></a>前m大的数</h3><p>Description:<br>还记得Gardon给小希布置的那个作业么？（上次比赛的1005）其实小希已经找回了原来的那张数表，现在她想确认一下她的答案是否正确，但是整个的答案是很庞大的表，小希只想让你把答案中最大的M个数告诉她就可以了。<br>给定一个包含N(N&lt;=3000)个正整数的序列，每个数不超过5000，对它们两两相加得到的N*(N-1)/2个和，求出其中前M大的数(M&lt;=1000)并按从大到小的顺序排列。<br>Input</p><blockquote><p>输入可能包含多组数据，其中每组数据包括两行：<br>第一行两个数N和M，<br>第二行N个数，表示该序列。</p></blockquote><p>Output</p><blockquote><p>对于输入的每组数据，输出M个数，表示结果。输出应当按照从大到小的顺序排列。</p></blockquote><p>Sample Input</p><blockquote><p>4 4<br>1 2 3 4<br>4 5<br>5 3 6 4</p></blockquote><p>Sample Output</p><blockquote><p>7 6 5 5<br>11 10 9 9 8</p></blockquote><p>Problem solving:<br>I have nothing to say about this *** problem,just do it without thinking.</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e7;</span><br><span class="line">int a[maxn],b[4000];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,m;</span><br><span class="line">while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;m))</span><br><span class="line">&#123;</span><br><span class="line">int k=0;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">scanf(&quot;%d&quot;,&amp;b[i]);</span><br><span class="line">for(int i=0;i&lt;n-1;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=i+1;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line">a[k]=b[i]+b[j];</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sort(a,a+k);</span><br><span class="line">for(int i=k-1;i&gt;0;i--)</span><br><span class="line">&#123;</span><br><span class="line">if(m==0)break;</span><br><span class="line">if(i==k-1)cout&lt;&lt;a[i];</span><br><span class="line">elsecout&lt;&lt;&quot; &quot;&lt;&lt;a[i];</span><br><span class="line">m--;</span><br><span class="line">&#125;</span><br><span class="line">puts(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="稳定排序"><a href="#稳定排序" class="headerlink" title="稳定排序"></a>稳定排序</h3><p>Description:<br>大家都知道，快速排序是不稳定的排序方法。<br>如果对于数组中出现的任意a[i],a<a href="i&lt;j">j</a>,其中a[i]==a[j]，在进行排序以后a[i]一定出现在a[j]之前，则认为该排序是稳定的。</p><p>某高校招生办得到一份成绩列表，上面记录了考生名字和考生成绩。并且对其使用了某排序算法按成绩进行递减排序。现在请你判断一下该排序算法是否正确，如果正确的话，则判断该排序算法是否为稳定的。<br>Input</p><blockquote><p>本题目包含多组输入，请处理到文件结束。<br>对于每组数据，第一行有一个正整数N(0&lt;N&lt;300)，代表成绩列表中的考生数目。<br>接下来有N行，每一行有一个字符串代表考生名字(长度不超过50，仅包含&#39;a&#39;~&#39;z&#39;),和一个整数代表考生分数(小于500)。其中名字和成绩用一个空格隔开。<br>再接下来又有N行，是上述列表经过某排序算法以后生成的一个序列。格式同上。</p></blockquote><p>Output</p><blockquote><p>对于每组数据，如果算法是正确并且稳定的，就在一行里面输出&quot;Right&quot;。如果算法是正确的但不是稳定的，就在一行里面输出&quot;Not Stable&quot;，并且在下面输出正确稳定排序的列表，格式同输入。如果该算法是错误的，就在一行里面输出&quot;Error&quot;,并且在下面输出正确稳定排序的列表，格式同输入。<br>注意，本题目不考虑该排序算法是错误的，但结果是正确的这样的意外情况。</p></blockquote><p>Sample Input</p><blockquote><p>3<br>aa 10<br>bb 10<br>cc 20<br>cc 20<br>bb 10<br>aa 10<br>3<br>aa 10<br>bb 10<br>cc 20<br>cc 20<br>aa 10<br>bb 10<br>3<br>aa 10<br>bb 10<br>cc 20<br>aa 10<br>bb 10<br>cc 20</p></blockquote><p>Sample Output</p><blockquote><p>Not Stable<br>cc 20<br>aa 10<br>bb 10<br>Right<br>Error<br>cc 20<br>aa 10<br>bb 10</p></blockquote><p>Problem solving:<br>Attention: we&#39;d better make the order in which it arrears.And then just sort for structures.Compare the second input with the right and stable result.If the score&#39;s order is wrong,output &#39;Error&#39;,if the name&#39;s order is wrong,output &#39;Not Stable&#39;,if all order are right,output &#39;Right&#39;.</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">string na;</span><br><span class="line">int s,i;</span><br><span class="line">&#125;p[305],pp[305];</span><br><span class="line">bool cmp(node x,node y)</span><br><span class="line">&#123;</span><br><span class="line">if(x.s==y.s)return x.i&lt;y.i;</span><br><span class="line">return x.s&gt;y.s;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">while(~scanf(&quot;%d&quot;,&amp;n))</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;p[i].na&gt;&gt;p[i].s;</span><br><span class="line">p[i].i=i;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;pp[i].na&gt;&gt;pp[i].s;</span><br><span class="line">&#125;</span><br><span class="line">sort(p,p+n,cmp);</span><br><span class="line">int flag=0;</span><br><span class="line">for(int i=0;i&lt;n-1;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(pp[i].s&lt;pp[i+1].s)</span><br><span class="line">&#123;</span><br><span class="line">flag=1;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(flag)</span><br><span class="line">&#123;</span><br><span class="line">puts(&quot;Error&quot;);</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;p[i].na&lt;&lt;&quot; &quot;&lt;&lt;p[i].s&lt;&lt;&quot;\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(p[i].na!=pp[i].na)</span><br><span class="line">&#123;</span><br><span class="line">flag=1;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(flag)</span><br><span class="line">&#123;</span><br><span class="line">puts(&quot;Not Stable&quot;);</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;p[i].na&lt;&lt;&quot; &quot;&lt;&lt;p[i].s&lt;&lt;&quot;\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">puts(&quot;Right&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="开门人和关门人"><a href="#开门人和关门人" class="headerlink" title="开门人和关门人"></a>开门人和关门人</h3><p>Description:<br>每天第一个到机房的人要把门打开，最后一个离开的人要把门关好。现有一堆杂乱的机房签<br>到、签离记录，请根据记录找出当天开门和关门的人。<br>Input</p><blockquote><p>测试输入的第一行给出记录的总天数N ( &gt; 0 )。下面列出了N天的记录。<br>每天的记录在第一行给出记录的条目数M ( &gt; 0 )，下面是M行，每行的格式为<br>证件号码 签到时间 签离时间<br>其中时间按“小时:分钟:秒钟”（各占2位）给出，证件号码是长度不超过15的字符串。</p></blockquote><p>Output</p><blockquote><p>对每一天的记录输出1行，即当天开门和关门人的证件号码，中间用1空格分隔。<br>注意：在裁判的标准测试输入中，所有记录保证完整，每个人的签到时间在签离时间之前，<br>且没有多人同时签到或者签离的情况。</p></blockquote><p>Sample Input</p><blockquote><p>3<br>1<br>ME3021112225321 00:00:00 23:59:59<br>2<br>EE301218 08:05:35 20:56:35<br>MA301134 12:35:45 21:40:42<br>3<br>CS301111 15:30:28 17:00:10<br>SC3021234 08:00:00 11:25:25<br>CS301133 21:45:00 21:58:40</p></blockquote><p>Sample Output</p><blockquote><p>ME3021112225321 ME3021112225321<br>EE301218 MA301134<br>SC3021234 CS301133</p></blockquote><p>Problem solving:<br>The earliest person and the lastest person is what we should output.The way we get these two person&#39;s name is sort,sort for structures.The best thing is we can find this efficient through sort string.You can look my code carefully to understand this.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">string n,b,e;</span><br><span class="line">&#125;p[1000];</span><br><span class="line">bool cmp(node x,node y)</span><br><span class="line">&#123;</span><br><span class="line">return x.b&lt;y.b;</span><br><span class="line">&#125;</span><br><span class="line">bool ccmp(node x,node y)</span><br><span class="line">&#123;</span><br><span class="line">return x.e&gt;y.e;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">while(n--)</span><br><span class="line">&#123;</span><br><span class="line">int m;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">for(int i=0;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;p[i].n&gt;&gt;p[i].b&gt;&gt;p[i].e;</span><br><span class="line">&#125;</span><br><span class="line">sort(p,p+m,cmp);</span><br><span class="line">cout&lt;&lt;p[0].n&lt;&lt;&quot; &quot;;</span><br><span class="line">sort(p,p+m,ccmp);</span><br><span class="line">cout&lt;&lt;p[0].n;</span><br><span class="line">puts(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="EXCEL排序"><a href="#EXCEL排序" class="headerlink" title="EXCEL排序"></a>EXCEL排序</h3><p>Description:<br>Excel可以对一组纪录按任意指定列排序。现请你编写程序实现类似功能。<br>Input</p><blockquote><p>测试输入包含若干测试用例。每个测试用例的第1行包含两个整数 N (&lt;=100000) 和 C，其中 N 是纪录的条数，C 是指定排序的列号。以下有 N<br>行，每行包含一条学生纪录。每条学生纪录由学号（6位数字，同组测试中没有重复的学号）、姓名（不超过8位且不包含空格的字符串）、成绩（闭区间[0, 100]内的整数）组成，每个项目间用1个空格隔开。当读到 N=0 时，全部输入结束，相应的结果不要输出。</p></blockquote><p>Output</p><blockquote><p>对每个测试用例，首先输出1行“Case i:”，其中 i 是测试用例的编号（从1开始）。随后在 N 行中输出按要求排序后的结果，即：当 C=1 时，按学号递增排序；当 C=2时，按姓名的非递减字典序排序；当 C=3<br>时，按成绩的非递减排序。当若干学生具有相同姓名或者相同成绩时，则按他们的学号递增排序。</p></blockquote><p>Sample Input</p><blockquote><p>3 1<br>000007 James 85<br>000010 Amy 90<br>000001 Zoe 60<br>4 2<br>000007 James 85<br>000010 Amy 90<br>000001 Zoe 60<br>000002 James 98<br>4 3<br>000007 James 85<br>000010 Amy 90<br>000001 Zoe 60<br>000002 James 90<br>0 0</p></blockquote><p>Sample Output</p><blockquote><p>Case 1:<br>000001 Zoe 60<br>000007 James 85<br>000010 Amy 90<br>Case 2:<br>000010 Amy 90<br>000002 James 98<br>000007 James 85<br>000001 Zoe 60<br>Case 3:<br>000001 Zoe 60<br>000007 James 85<br>000002 James 90<br>000010 Amy 90</p></blockquote><p>Problem solving:<br>Look the problem description carefully,and sort for structures.Easy.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">string id,na;</span><br><span class="line">int s;</span><br><span class="line">&#125;p[100008];</span><br><span class="line">bool cmp1(node x,node y)</span><br><span class="line">&#123;</span><br><span class="line">return x.id&lt;y.id;</span><br><span class="line">&#125;</span><br><span class="line">bool cmp2(node x,node y)</span><br><span class="line">&#123;</span><br><span class="line">if(x.na==y.na)</span><br><span class="line">return x.id&lt;y.id;</span><br><span class="line">return x.na&lt;y.na;</span><br><span class="line">&#125;</span><br><span class="line">bool cmp3(node x,node y)</span><br><span class="line">&#123;</span><br><span class="line">if(x.s==y.s)</span><br><span class="line">return x.id&lt;y.id;</span><br><span class="line">return x.s&lt;y.s;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,c,j=0;</span><br><span class="line">while(scanf(&quot;%d %d&quot;,&amp;n,&amp;c)&amp;&amp;n)</span><br><span class="line">&#123;</span><br><span class="line">j++;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">cin&gt;&gt;p[i].id&gt;&gt;p[i].na&gt;&gt;p[i].s;</span><br><span class="line">if(c==1)</span><br><span class="line">&#123;</span><br><span class="line">sort(p,p+n,cmp1);</span><br><span class="line">&#125;</span><br><span class="line">if(c==2)</span><br><span class="line">&#123;</span><br><span class="line">sort(p,p+n,cmp2);</span><br><span class="line">&#125;</span><br><span class="line">if(c==3)</span><br><span class="line">&#123;</span><br><span class="line">sort(p,p+n,cmp3);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;Case %d:\n&quot;,j);</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">cout&lt;&lt;p[i].id&lt;&lt;&quot; &quot;&lt;&lt;p[i].na&lt;&lt;&quot; &quot;&lt;&lt;p[i].s&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="统计同成绩学生人数"><a href="#统计同成绩学生人数" class="headerlink" title="统计同成绩学生人数"></a>统计同成绩学生人数</h3><p>Description:<br>读入N名学生的成绩，将获得某一给定分数的学生人数输出。<br>Input</p><blockquote><p>测试输入包含若干测试用例，每个测试用例的格式为<br>第1行：N<br>第2行：N名学生的成绩，相邻两数字用一个空格间隔。<br>第3行：给定分数<br>当读到N=0时输入结束。其中N不超过1000，成绩分数为（包含）0到100之间的一个整数。</p></blockquote><p>Output</p><blockquote><p>对每个测试用例，将获得给定分数的学生人数输出。</p></blockquote><p>Sample Input</p><blockquote><p>3<br>80 60 90<br>60<br>2<br>85 66<br>0<br>5<br>60 75 90 55 75<br>75<br>0</p></blockquote><p>Sample Output</p><blockquote><p>1<br>0<br>2</p></blockquote><p>Problem solving:<br>We can solve this by loop for,but I think map is exciting.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,a,m;</span><br><span class="line">while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n)</span><br><span class="line">&#123;</span><br><span class="line">map&lt;int,int&gt; ma;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;a);</span><br><span class="line">ma[a]++;</span><br><span class="line">&#125;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">printf(&quot;%d\n&quot;,ma[m]);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="What-Is-Your-Grade"><a href="#What-Is-Your-Grade" class="headerlink" title="What Is Your Grade?"></a>What Is Your Grade?</h3><p>Description:<br>“Point, point, life of student!”<br>This is a ballad（歌谣）well known in colleges, and you must care about your score in this exam too. How many points can you get? Now, I told you the rules which are used in this course.<br>There are 5 problems in this final exam. And I will give you 100 points if you can solve all 5 problems; of course, it is fairly difficulty for many of you. If you can solve 4 problems, you can also get a high score 95 or 90 (you can get the former(前者) only when your rank is in the first half of all students who solve 4 problems). Analogically（以此类推）, you can get 85、80、75、70、65、60. But you will not pass this exam if you solve nothing problem, and I will mark your score with 50.<br>Note, only 1 student will get the score 95 when 3 students have solved 4 problems.<br>I wish you all can pass the exam!<br>Come on!<br>Input</p><blockquote><p>Input contains multiple test cases. Each test case contains an integer N (1&lt;=N&lt;=100, the number of students) in a line first, and then N lines follow. Each line contains P (0&lt;=P&lt;=5 number of problems that have been solved) and T（consumed time）. You can assume that all data are different when 0\&lt;p.<br>A test case starting with a negative integer terminates the input and this test case should not to be processed.</p></blockquote><p>Output</p><blockquote><p>Output the scores of N students in N lines for each case, and there is a blank line after each case.</p></blockquote><p>Sample Input</p><blockquote><p>4<br>5 06:30:17<br>4 07:31:27<br>4 08:12:12<br>4 05:23:13<br>1<br>5 06:30:17<br>-1</p></blockquote><p>Sample Output</p><blockquote><p>100<br>90<br>90<br>95<br>100</p></blockquote><p>Problem solving:<br>&#39;only when your rank is in the first half of all students who solve 4 problems&#39;-&gt;This is important.What we should pay more attention to is the meaning of this problem.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">int na;</span><br><span class="line">string t;</span><br><span class="line">int s;</span><br><span class="line">int i;</span><br><span class="line">&#125;p[105];</span><br><span class="line">bool cmp(node x,node y)</span><br><span class="line">&#123;</span><br><span class="line">if(x.s==y.s)return x.t&lt;y.t;</span><br><span class="line">return x.s&gt;y.s;</span><br><span class="line">&#125;</span><br><span class="line">bool cmp1(node x,node y)</span><br><span class="line">&#123;</span><br><span class="line">return x.i&lt;y.i;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n&gt;0)</span><br><span class="line">&#123;</span><br><span class="line">int mid=0,aa=0,bb=0,cc=0,dd=0;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">p[i].i=i;</span><br><span class="line">cin&gt;&gt;p[i].na&gt;&gt;p[i].t;</span><br><span class="line">if(p[i].na==5)p[i].s=100;</span><br><span class="line">if(p[i].na==0)p[i].s=50;</span><br><span class="line">if(p[i].na==4)&#123;p[i].s=90;aa++;&#125;</span><br><span class="line">if(p[i].na==3)&#123;p[i].s=80;bb++;&#125;</span><br><span class="line">if(p[i].na==2)&#123;p[i].s=70;cc++;&#125;</span><br><span class="line">if(p[i].na==1)&#123;p[i].s=60;dd++;&#125;</span><br><span class="line">&#125;</span><br><span class="line">aa/=2;</span><br><span class="line">bb/=2;</span><br><span class="line">cc/=2;</span><br><span class="line">dd/=2;</span><br><span class="line">sort(p,p+n,cmp);</span><br><span class="line"></span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(p[i].s==90&amp;&amp;aa)</span><br><span class="line">&#123;</span><br><span class="line">p[i].s=95;</span><br><span class="line">aa--;</span><br><span class="line">&#125;</span><br><span class="line">if(p[i].s==80&amp;&amp;bb)</span><br><span class="line">&#123;</span><br><span class="line">p[i].s=85;</span><br><span class="line">bb--;</span><br><span class="line">&#125;</span><br><span class="line">if(p[i].s==70&amp;&amp;cc)</span><br><span class="line">&#123;</span><br><span class="line">p[i].s=75;</span><br><span class="line">cc--;</span><br><span class="line">&#125;</span><br><span class="line">if(p[i].s==60&amp;&amp;dd)</span><br><span class="line">&#123;</span><br><span class="line">p[i].s=65;</span><br><span class="line">dd--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sort(p,p+n,cmp1);</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">cout&lt;&lt;p[i].s&lt;&lt;&quot;\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line">puts(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Magical-Bamboos"><a href="#Magical-Bamboos" class="headerlink" title="Magical Bamboos"></a>Magical Bamboos</h3><p>Description:<br>In a magical forest, there exists N bamboos that don&#39;t quite get cut down the way you would expect.</p><p>Originally, the height of the ith bamboo is equal to hi. In one move, you can push down a bamboo and decrease its height by one, but this move magically causes all the other bamboos to increase in height by one.</p><p>If you can do as many moves as you like, is it possible to make all the bamboos have the same height?</p><p>Input</p><blockquote><p>The first line of input is T – the number of test cases.<br>The first line of each test case contains an integer N (1 ≤ N ≤ 105) - the number of bamboos.<br>The second line contains N space-separated integers hi (1 ≤ hi ≤ 105) - the original heights of the bamboos.</p></blockquote><p>Output</p><blockquote><p>For each test case, output on a single line &quot;yes” (without quotes), if you can make all the bamboos have the same height, and &quot;no&quot; otherwise.</p></blockquote><p>Example</p><blockquote><p>Input<br>2<br>3<br>2 4 2<br>2<br>1 2</p></blockquote><blockquote><p>Output<br>yes<br>no</p></blockquote><p>Problem solving:<br>Sorted this array fist.If the difference of two adjacent numbers have odd,output &#39;no&#39;,otherwise,output &#39;yes&#39;.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e5+7;</span><br><span class="line">int a[maxn];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">while(n--)</span><br><span class="line">&#123;</span><br><span class="line">int m,flag=0;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">for(int i=0;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;m-1;i++)</span><br><span class="line">&#123;</span><br><span class="line">if((a[i+1]-a[i])%2!=0)</span><br><span class="line">&#123;</span><br><span class="line">flag=1;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(flag)puts(&quot;no&quot;);</span><br><span class="line">elseputs(&quot;yes&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Bear-and-Three-Balls"><a href="#Bear-and-Three-Balls" class="headerlink" title="Bear and Three Balls"></a>Bear and Three Balls</h3><p>Description:<br>Limak is a little polar bear. He has n balls, the i-th ball has size ti.</p><p>Limak wants to give one ball to each of his three friends. Giving gifts isn&#39;t easy — there are two rules Limak must obey to make friends happy:</p><p>No two friends can get balls of the same size.<br>No two friends can get balls of sizes that differ by more than 2.<br>For example, Limak can choose balls with sizes 4, 5 and 3, or balls with sizes 90, 91 and 92. But he can&#39;t choose balls with sizes 5, 5 and 6 (two friends would get balls of the same size), and he can&#39;t choose balls with sizes 30, 31 and 33 (because sizes 30 and 33 differ by more than 2).</p><p>Your task is to check whether Limak can choose three balls that satisfy conditions above.</p><p>Input</p><blockquote><p>The first line of the input contains one integer n (3 ≤ n ≤ 50) — the number of balls Limak has.<br>The second line contains n integers t1, t2, ..., tn (1 ≤ ti ≤ 1000) where ti denotes the size of the i-th ball.</p></blockquote><p>Output</p><blockquote><p>Print &quot;YES&quot; (without quotes) if Limak can choose three balls of distinct sizes, such that any two of them differ by no more than 2. Otherwise, print &quot;NO&quot; (without quotes).</p></blockquote><p>Examples</p><blockquote><p>Input<br>4<br>18 55 16 17</p></blockquote><blockquote><p>Output<br>YES</p></blockquote><p>Input</p><blockquote><p>6<br>40 41 43 44 44 44</p></blockquote><p>Output</p><blockquote><p>NO</p></blockquote><p>Input</p><blockquote><p>8<br>5 972 3 4 1 4 970 971</p></blockquote><p>Output</p><blockquote><p>YES</p></blockquote><p>Note</p><blockquote><p>In the first sample, there are 4 balls and Limak is able to choose three of them to satisfy the rules. He must must choose balls with sizes 18, 16 and 17.<br>In the second sample, there is no way to give gifts to three friends without breaking the rules.<br>In the third sample, there is even more than one way to choose balls:</p><ol><li>Choose balls with sizes 3, 4 and 5.</li><li>Choose balls with sizes 972, 970, 971.</li></ol></blockquote><p>Problem solving:<br>If there have three numbers which are adjacent,output &#39;yes&#39;,otherwise ouput&#39;no&#39;.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[100];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,flag=0;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line">sort(a,a+n);</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(binary_search(a,a+n,a[i]+1)&amp;&amp;binary_search(a,a+n,a[i]+2))</span><br><span class="line">&#123;</span><br><span class="line">flag=1;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(flag)puts(&quot;YES&quot;);</span><br><span class="line">elseputs(&quot;NO&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="今年暑假不AC"><a href="#今年暑假不AC" class="headerlink" title="今年暑假不AC"></a>今年暑假不AC</h3><p>Description:<br>“今年暑假不AC？”<br>“是的。”<br>“那你干什么呢？”<br>“看世界杯呀，笨蛋！”<br>“@#\$%^&amp;*%...”</p><p>确实如此，世界杯来了，球迷的节日也来了，估计很多ACMer也会抛开电脑，奔向电视了。<br>作为球迷，一定想看尽量多的完整的比赛，当然，作为新时代的好青年，你一定还会看一些其它的节目，比如新闻联播（永远不要忘记关心国家大事）、非常6+7、超级女生，以及王小丫的《开心辞典》等等，假设你已经知道了所有你喜欢看的电视节目的转播时间表，你会合理安排吗？（目标是能看尽量多的完整节目）<br>Input</p><blockquote><p>输入数据包含多个测试实例，每个测试实例的第一行只有一个整数n(n&lt;=100)，表示你喜欢看的节目的总数，然后是n行数据，每行包括两个数据Ti_s,Ti_e (1&lt;=i&lt;=n)，分别表示第i个节目的开始和结束时间，为了简化问题，每个时间都用一个正整数表示。n=0表示输入结束，不做处理。</p></blockquote><p>Output</p><blockquote><p>对于每个测试实例，输出能完整看到的电视节目的个数，每个测试实例的输出占一行。</p></blockquote><p>Sample Input</p><blockquote><p>12<br>1 3<br>3 4<br>0 7<br>3 8<br>15 19<br>15 20<br>10 15<br>8 18<br>6 12<br>5 10<br>4 14<br>2 9<br>0</p></blockquote><p>Sample Output</p><blockquote><p>5</p></blockquote><p>Problem solving:<br>Greedy,sort by the end time,and then start counting.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 105;</span><br><span class="line">struct node&#123;</span><br><span class="line">int b,s;</span><br><span class="line">&#125;x[maxn];</span><br><span class="line">bool cmp(node q,node w)</span><br><span class="line">&#123;</span><br><span class="line">return q.s&lt;w.s;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n)</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;x[i].b&gt;&gt;x[i].s;</span><br><span class="line">&#125;</span><br><span class="line">sort(x,x+n,cmp);</span><br><span class="line">int o=x[0].s,ans=1;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(x[i].b&gt;=o)</span><br><span class="line">&#123;</span><br><span class="line">ans++;</span><br><span class="line">o=x[i].s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="The-sum-problem"><a href="#The-sum-problem" class="headerlink" title="The sum problem"></a>The sum problem</h3><p>Description:<br>Given a sequence 1,2,3,......N, your job is to calculate all the possible sub-sequences that the sum of the sub-sequence is M.<br>Input</p><blockquote><p>Input contains multiple test cases. each case contains two integers N, M( 1 &lt;= N, M &lt;= 1000000000).input ends with N = M = 0.</p></blockquote><p>Output</p><blockquote><p>For each test case, print all the possible sub-sequence that its sum is M.The format is show in the sample below.print a blank line after each test case.</p></blockquote><p>Sample Input</p><blockquote><p>20 10<br>50 30<br>0 0</p></blockquote><p>Sample Output</p><blockquote><p>[1,4]<br>[10,10]<br>[4,8]<br>[6,9]<br>[9,11]<br>[30,30]</p></blockquote><p>Problem solving:<br>Sum Formula of Equal Difference Sequences.<br><img src="https://i.loli.net/2019/07/18/5d3012d17685519697.png" alt><br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,m;</span><br><span class="line">while(scanf(&quot;%d %d&quot;,&amp;n,&amp;m))</span><br><span class="line">&#123;</span><br><span class="line">if(m==0&amp;&amp;m==0)break;</span><br><span class="line">for(int i=sqrt(2*m);i&gt;=1;i--)</span><br><span class="line">&#123;</span><br><span class="line">int a=(m-i*(i-1)/2)/i;</span><br><span class="line">if((a*i)+i*(i-1)/2==m)</span><br><span class="line">printf(&quot;[%d,%d]\n&quot;,a,a+i-1);</span><br><span class="line">&#125;</span><br><span class="line">puts(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天主要学习了sort，结构体的sort。&lt;br&gt;第一天算是结束了，还是有点累的，但是也很有收获，趁着这些题还都勉强能做出来，赶紧多写点吧.
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="Algorithm" scheme="https://cndrew.cn/blog/tags/Algorithm/"/>
    
      <category term="c/c++" scheme="https://cndrew.cn/blog/tags/c-c/"/>
    
      <category term="Thinking" scheme="https://cndrew.cn/blog/tags/Thinking/"/>
    
      <category term="CodeForces" scheme="https://cndrew.cn/blog/tags/CodeForces/"/>
    
      <category term="HDU" scheme="https://cndrew.cn/blog/tags/HDU/"/>
    
      <category term="STL" scheme="https://cndrew.cn/blog/tags/STL/"/>
    
      <category term="math" scheme="https://cndrew.cn/blog/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>HPU Summer Training Day 1（河南理工大学暑期第一天）</title>
    <link href="https://cndrew.cn/blog/2019/07/17/d1/"/>
    <id>https://cndrew.cn/blog/2019/07/17/d1/</id>
    <published>2019-07-17T13:15:48.143Z</published>
    <updated>2019-07-18T14:59:25.089Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>盼望着，盼望着，暑假集训来了，希望集训完自己能变的厉害点吧。不然这丢失的40天左右的假期还真是浪费了啊。</p><p><img src="https://i.loli.net/2019/07/17/5d2f23940943935724.jpeg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="Algorithm" scheme="https://cndrew.cn/blog/tags/Algorithm/"/>
    
      <category term="c/c++" scheme="https://cndrew.cn/blog/tags/c-c/"/>
    
      <category term="life" scheme="https://cndrew.cn/blog/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round 572 (Div. 2)</title>
    <link href="https://cndrew.cn/blog/2019/07/06/Codeforces-572/"/>
    <id>https://cndrew.cn/blog/2019/07/06/Codeforces-572/</id>
    <published>2019-07-06T02:43:24.682Z</published>
    <updated>2019-07-06T02:50:58.793Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>About this match,I have no idea about how to describe my thought,so I just paste my passed code here.<a id="more"></a><br>Link: <a href="https://codeforces.com/contest/1189" target="_blank" rel="noopener">Codeforces Round 572</a></p><p><center>A Keanu Reeves</center><br>Description:<br>After playing Neo in the legendary &quot;Matrix&quot; trilogy, Keanu Reeves started doubting himself: maybe we really live in virtual reality? To find if this is true, he needs to solve the following problem.</p><p>Let&#39;s call a string consisting of only zeroes and ones good if it contains different numbers of zeroes and ones. For example, 1, 101, 0000 are good, while 01, 1001, and 111000 are not good.</p><p>We are given a string s of length n consisting of only zeroes and ones. We need to cut s into minimal possible number of substrings s1,s2,…,sk such that all of them are good. More formally, we have to find minimal by number of strings sequence of good strings s1,s2,…,sk such that their concatenation (joining) equals s, i.e. s1+s2+⋯+sk=s.</p><p>For example, cuttings 110010 into 110 and 010 or into 11 and 0010 are valid, as 110, 010, 11, 0010 are all good, and we can&#39;t cut 110010 to the smaller number of substrings as 110010 isn&#39;t good itself. At the same time, cutting of 110010 into 1100 and 10 isn&#39;t valid as both strings aren&#39;t good. Also, cutting of 110010 into 1, 1, 0010 isn&#39;t valid, as it isn&#39;t minimal, even though all 3 strings are good.</p><p>Can you help Keanu? We can show that the solution always exists. If there are multiple optimal answers, print any.</p><p>Input<br>The first line of the input contains a single integer n (1≤n≤100) — the length of the string s.</p><p>The second line contains the string s of length n consisting only from zeros and ones.</p><p>Output<br>In the first line, output a single integer k (1≤k) — a minimal number of strings you have cut s into.</p><p>In the second line, output k strings s1,s2,…,sk separated with spaces. The length of each string has to be positive. Their concatenation has to be equal to s and all of them have to be good.</p><p>If there are multiple answers, print any.</p><p>Examples<br>input</p><blockquote><p>1<br>1</p></blockquote><p>output</p><blockquote><p>1<br>1</p></blockquote><p>input</p><blockquote><p>2<br>10</p></blockquote><p>output</p><blockquote><p>2<br>1 0</p></blockquote><p>input</p><blockquote><p>6<br>100011</p></blockquote><p>output</p><blockquote><p>2<br>100 011</p></blockquote><p>Note</p><blockquote><p>In the first example, the string 1 wasn&#39;t cut at all. As it is good, the condition is satisfied.<br>In the second example, 1 and 0 both are good. As 10 isn&#39;t good, the answer is indeed minimal.<br>In the third example, 100 and 011 both are good. As 100011 isn&#39;t good, the answer is indeed minimal.</p></blockquote><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int o[105], z[105];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int    n, a, b;</span><br><span class="line">    a = b = 0;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line">    for (int i = 0; i &lt; s.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (s[i] == &apos;1&apos;)</span><br><span class="line">            a++;</span><br><span class="line">        if (s[i] == &apos;0&apos;)</span><br><span class="line">            b++;</span><br><span class="line">        o[i] = a;</span><br><span class="line">        z[i] = b;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    if (a != b)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;1\n&quot; &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;2\n&quot;;</span><br><span class="line">        for (int i = 0; i &lt; s.size()-1; i++)</span><br><span class="line">            cout &lt;&lt; s[i];</span><br><span class="line">        cout &lt;&lt; &quot; &quot; &lt;&lt; s[s.size() - 1] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><center>B Number Circle</center><br>Description:<br>You are given n numbers a1,a2,…,an. Is it possible to arrange them in a circle in such a way that every number is strictly less than the sum of its neighbors?</p><p>For example, for the array [1,4,5,6,7,8], the arrangement on the left is valid, while arrangement on the right is not, as 5≥4+1 and 8&gt;1+6.<br><a href="https://i.loli.net/2019/07/06/5d200c3a6304b24782.png" target="_blank" rel="noopener">https://i.loli.net/2019/07/06/5d200c3a6304b24782.png</a><br>Input<br>The first line contains a single integer n (3≤n≤105) — the number of numbers.</p><p>The second line contains n integers a1,a2,…,an (1≤ai≤109) — the numbers. The given numbers are not necessarily distinct (i.e. duplicates are allowed).</p><p>Output<br>If there is no solution, output &quot;NO&quot; in the first line.</p><p>If there is a solution, output &quot;YES&quot; in the first line. In the second line output n numbers — elements of the array in the order they will stay in the circle. The first and the last element you output are considered neighbors in the circle. If there are multiple solutions, output any of them. You can print the circle starting with any element.</p><p>Examples<br>input</p><blockquote><p>3<br>2 4 3</p></blockquote><p>output</p><blockquote><p>YES<br>4 2 3</p></blockquote><p>input</p><blockquote><p>5<br>1 2 3 4 4</p></blockquote><p>output</p><blockquote><p>YES<br>4 4 2 1 3</p></blockquote><p>input</p><blockquote><p>3<br>13 8 5</p></blockquote><p>output</p><blockquote><p>NO</p></blockquote><p>input</p><blockquote><p>4<br>1 10 100 1000</p></blockquote><p>output</p><blockquote><p>NO</p></blockquote><p>Note</p><blockquote><p>One of the possible arrangements is shown in the first example:<br>4&lt;2+3;<br>2&lt;4+3;<br>3&lt;4+2.<br>One of the possible arrangements is shown in the second example.<br>No matter how we arrange 13,8,5 in a circle in the third example, 13 will have 8 and 5 as neighbors, but 13≥8+5.<br>There is no solution in the fourth example.</p></blockquote><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e5 + 10;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll        a[maxn];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    queue&lt;ll&gt; f;</span><br><span class="line">    stack&lt;ll&gt; e;</span><br><span class="line">    ll        n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for (ll i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a, a + n);</span><br><span class="line">    if (a[n - 1] &gt;= (a[n - 3] + a[n - 2]))</span><br><span class="line">    &#123;</span><br><span class="line">        puts(&quot;NO&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    puts(&quot;YES&quot;);</span><br><span class="line">    int flag = 1;</span><br><span class="line">    for (int i = n - 1; i &gt;= 0; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        if (flag)</span><br><span class="line">        &#123;</span><br><span class="line">            f.push(a[i]);</span><br><span class="line">            if (a[i - 1] != a[i])</span><br><span class="line">                flag = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            e.push(a[i]);</span><br><span class="line">            if (a[i - 1] != a[i])</span><br><span class="line">                flag = 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while (!f.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; f.front() &lt;&lt; &quot; &quot;;</span><br><span class="line">        f.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    while (!e.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; e.top() &lt;&lt; &quot; &quot;;</span><br><span class="line">        e.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;About this match,I have no idea about how to describe my thought,so I just paste my passed code here.
    
    </summary>
    
      <category term="c/c++" scheme="https://cndrew.cn/blog/categories/c-c/"/>
    
    
      <category term="c/c++" scheme="https://cndrew.cn/blog/tags/c-c/"/>
    
      <category term="Thinking" scheme="https://cndrew.cn/blog/tags/Thinking/"/>
    
      <category term="CodeForces" scheme="https://cndrew.cn/blog/tags/CodeForces/"/>
    
  </entry>
  
  <entry>
    <title>筱玛爱地理</title>
    <link href="https://cndrew.cn/blog/2019/07/06/nowcoder-946-A/"/>
    <id>https://cndrew.cn/blog/2019/07/06/nowcoder-946-A/</id>
    <published>2019-07-06T02:13:59.989Z</published>
    <updated>2019-07-06T02:41:18.927Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>I have heared Inverse-modulo(逆元) before,I can&#39;t understand it clearly that time till I met this problem yesterday.<a id="more"></a></p><p><center> nowcoder-946-A 筱玛爱地理</center><br>Link: <a href="https://ac.nowcoder.com/acm/contest/946/A" target="_blank" rel="noopener">nowcoder-946-A</a><br>Description:<br>筱玛是一个热爱地理的好筱玛。最近，在《地理II》作业本上，筱玛学到了“贝塔指数”的概念：</p><blockquote><p>在经济地理学中，交通的联结度表示交通网络的发达程度，通常用贝塔指数来计算与比较。若用<br>V表示一个交通网络中结点的数量，用<br>E表示边的数量，则贝塔指数的计算方式为：β=E/V。</p></blockquote><p>“实践是检验真理的唯一标准”。作为一个热爱地理的好筱玛，她马上就把新学的知识应用到实践当中去。筱玛一口气出了n张交通网络规划图，其中第i张交通网络Gi有Vi个结点和Ei条边。筱玛一眼就看出了哪张图好、哪张图坏。但是作为一个负责任的好筱玛，她必须带领同学们一起进步。因此，她需要你将所有的n张图按照贝塔指数排序，并求出它们各自的贝塔指数在模1e9+7意义下的值。</p><p>输入描述:<br>第一行一个整数n，表示交通网络规划图的数量。</p><p>接下来n行，每行两个整数Vi和Ei，分别表示图Gi中的结点数量和边的数量。</p><p>输出描述:<br>输出共n行，每行一个数，表示贝塔指数第i大的交通网络的贝塔指数在模1e9+7意义下的值。<br>如果不能整除，输出分数取模后的结果。<br>示例1<br>输入</p><blockquote><p>1<br>1 3</p></blockquote><p>输出</p><blockquote><p>3</p></blockquote><p>说明</p><blockquote><p>显然此时<br>β=E/V=3。</p></blockquote><p>备注:</p><blockquote><p>对于100%的数据，保证<br>1≤n≤2×1e5，<br>1≤Vi,Ei≤1e9。</p></blockquote><p>Problem solving:<br>Obviously,we can solve this problem through sort.But there has a unusual situation is fractional modulo.So we use Inverse-modulo(逆元) here.</p><p><details><br>  <summary><font color="red">Click to see Chinese Intentional analysis</font></summary>显然是一个sort就可以解决的问题，但是更难得在于要对分数取模，这个时候就会用到逆元。<br></details><br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn = 1e9 + 7;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    ll     x, y;</span><br><span class="line">    double z;</span><br><span class="line">&#125; a[200005];</span><br><span class="line">bool cmp(node x, node y)</span><br><span class="line">&#123;</span><br><span class="line">    return x.z &lt; y.z;</span><br><span class="line">&#125;</span><br><span class="line">const int mod = 1e9 + 7;</span><br><span class="line">long long quickpow(long long a, long long b)</span><br><span class="line">&#123;</span><br><span class="line">    if (b &lt; 0)</span><br><span class="line">        return 0;</span><br><span class="line">    long long ret = 1;</span><br><span class="line">    a %= mod;</span><br><span class="line">    while (b)</span><br><span class="line">    &#123;</span><br><span class="line">        if (b &amp; 1)</span><br><span class="line">            ret = (ret * a) % mod;</span><br><span class="line">        b &gt;&gt;= 1;</span><br><span class="line">        a   = (a * a) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line">long long inv(long long a)</span><br><span class="line">&#123;</span><br><span class="line">    return quickpow(a, mod - 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for (ll i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i].x &gt;&gt; a[i].y;</span><br><span class="line">        a[i].z = a[i].y * 1.0 / a[i].x;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a, a + n, cmp);</span><br><span class="line">    for (ll i = n - 1; i &gt;= 0; i--)</span><br><span class="line">        cout &lt;&lt;a[i].y * inv(a[i].x) % maxn &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><center>About  Inverse-modulo(逆元)</center><br>There are many ways to find it.But I love this way,it&#39;s easy to understand and remember.That is <a href="https://zh.wikipedia.org/zh-hans/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86" target="_blank" rel="noopener">Fermat&#39;s little theorem</a>,we can ues this when the mode is a prime number.<br>The Inverse-modulo(逆元) of a in mode p is<code>a ^ (p-2)</code>.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const int mod = 1e9 + 7;</span><br><span class="line">long long quickpow(long long a, long long b)</span><br><span class="line">&#123;</span><br><span class="line">    if (b &lt; 0)</span><br><span class="line">        return 0;</span><br><span class="line">    long long ret = 1;</span><br><span class="line">    a %= mod;</span><br><span class="line">    while (b)</span><br><span class="line">    &#123;</span><br><span class="line">        if (b &amp; 1)</span><br><span class="line">            ret = (ret * a) % mod;</span><br><span class="line">        b &gt;&gt;= 1;</span><br><span class="line">        a   = (a * a) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line">long long inv(long long a)</span><br><span class="line">&#123;</span><br><span class="line">    return quickpow(a, mod - 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><font color="red">So (a/b)%p=a*inv(b)%p.</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;I have heared Inverse-modulo(逆元) before,I can&amp;#39;t understand it clearly that time till I met this problem yesterday.
    
    </summary>
    
      <category term="Algorithm" scheme="https://cndrew.cn/blog/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://cndrew.cn/blog/tags/Algorithm/"/>
    
      <category term="c/c++" scheme="https://cndrew.cn/blog/tags/c-c/"/>
    
      <category term="nowcoder" scheme="https://cndrew.cn/blog/tags/nowcoder/"/>
    
      <category term="inverse-modulo" scheme="https://cndrew.cn/blog/tags/inverse-modulo/"/>
    
  </entry>
  
  <entry>
    <title>Past About</title>
    <link href="https://cndrew.cn/blog/2019/07/04/oldabout/"/>
    <id>https://cndrew.cn/blog/2019/07/04/oldabout/</id>
    <published>2019-07-04T03:14:16.395Z</published>
    <updated>2019-07-04T03:23:58.950Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>I find my old about page is not so serious these days,so I will make a new about page and the old page will paste on here.<a id="more"></a></p><h1 id="My-blog"><a href="#My-blog" class="headerlink" title=" My blog"></a><font> My blog</font></h1><font><br>Purpose：<br><br>1.It is to record what i have learned, and it is convenient to go back to review.<br><br>2.Get to know more friends through this exploration.<br><br>3.Enhance your hands-on ability, language organization skills, etc.<br></font><h1 id="Contact-me"><a href="#Contact-me" class="headerlink" title="Contact me"></a><font>Contact me</font></h1><font><br>qq: 1120437716<br><br>G-mial: <a href="mailto:miaodrew@gmail.com" target="_blank" rel="noopener">miaodrew@gmail.com</a><br></font><!-- # <font color=green><center>Uncle_drew——Kyrie Irving</font><video poster="https://i.loli.net/2019/04/24/5cbfe870ab5df.jpg" src="http://cndrew.oss-cn-beijing.aliyuncs.com/DLDS%20BD_Trim.mp4?Expires=1556797279&OSSAccessKeyId=TMP.AgGrsBlrr7wyRY2eNLMPVJBpZWXPEh0ijJyum9uPzwXMY5zZpJwKbs9oDg_3ADAtAhQfBbYsXegEID7fRFYP75aPc4vAsQIVALvgj5FULPk_DxHxdlG7tUe7yHLF&Signature=FXoaWI8EWBw5n5rdQuy5FHOH8Js%3D" style="max-height :100%; max-width: 100%; display: block; margin-left: auto; margin-right: auto;" controls="controls" loop="loop" preload="meta">Your browser does not support the video tag.</video> --><h1 id="Some-sharing-of-Baiduyun"><a href="#Some-sharing-of-Baiduyun" class="headerlink" title="Some sharing of Baiduyun"></a><font><center>Some sharing of Baiduyun</center></font></h1><font><br><em> <a href="https://pan.baidu.com/s/1fazrwAR31I3va5okG3R_Mw" target="_blank" rel="noopener">c++API帮助文档</a><br>提取码：hyco<br></em> <a href="https://pan.baidu.com/s/1vVrI4Qmhw_YXwsIPjf7fRA" target="_blank" rel="noopener">python学习参考资料</a><br>提取码：2k84 <br><br><center>Continuous update...<br></center></font><h1 id="My-favorite-music"><a href="#My-favorite-music" class="headerlink" title="My favorite music"></a><font><center>My favorite music</center></font></h1><p><div class="aplayer" data-id="2005855998&userid=1305878902" data-server="netease" data-type="playlist" data-mode="random"></div></p><h1 id="Relax-for-a-moment丷"><a href="#Relax-for-a-moment丷" class="headerlink" title="Relax for a moment丷"></a><font>Relax for a moment丷</font></h1><h2 id="泰戈尔"><a href="#泰戈尔" class="headerlink" title="泰戈尔"></a><font>泰戈尔</font></h2><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180124/c87253f017d447419c45728c72899c6b.jpeg" alt></p><h3 id="生如夏花"><a href="#生如夏花" class="headerlink" title="生如夏花"></a><font color="#292421" size="10"><center>生如夏花</center></font></h3><font><br><center><br>我听见回声，来自山谷和心间<br><br>以寂寞的镰刀收割空旷的灵魂<br><br>不断地重复决绝，又重复幸福<br><br>终有绿洲摇曳在沙漠<br><br>我相信自己<br><br>生来如同璀璨的夏日之花<br><br>不凋不败，妖治如火<br><br>承受心跳的负荷和呼吸的累赘<br><br>乐此不疲<br><br>我听见音乐，来自月光和胴体<br><br>辅极端的诱饵捕获飘渺的唯美<br><br>一生充盈着激烈，又充盈着纯然<br><br>总有回忆贯穿于世间<br><br>我相信自己<br><br>死时如同静美的秋日落叶<br><br>不盛不乱，姿态如烟<br><br>即便枯萎也保留丰肌清骨的傲然<br><br>玄之又玄<br><br>我听见爱情，我相信爱情<br><br>爱情是一潭挣扎的蓝藻<br><br>如同一阵凄微的风<br><br>穿过我失血的静脉<br><br>驻守岁月的信念<br><br>我相信一切能够听见<br><br>甚至预见离散，遇见另一个自己<br><br>而有些瞬间无法把握<br><br>任凭东走西顾，逝去的必然不返<br><br>请看我头置簪花，<br><br>一路走来一路盛开<br><br>频频遗漏一些，<br><br>又深陷风霜雨雪的感动<br><br>般若波罗蜜，一声一声<br><br>生如夏花，死如秋叶<br><br>还在乎拥有什么<br><br><br></center></font><h3 id="当时光已逝"><a href="#当时光已逝" class="headerlink" title="当时光已逝"></a><font color="#292421" size="10"><center>当时光已逝</center></font></h3><font><br><center><br>假如时光已逝，<br><br>鸟儿不再歌唱，<br><br>风儿也吹倦了，<br><br>那就用黑暗的厚幕把我盖上，<br><br>如同黄昏时节你用睡眠的衾被裹住大地，<br><br>又轻轻合上睡莲的花瓣。<br><br>路途未完，行囊已空,<br><br>衣裳破裂污损，人已精疲力竭。<br><br>你驱散了旅客的羞愧和困窘，<br><br>使他在你仁慈的夜幕下，<br><br>如花朵般焕发生机。<br><br>在你慈爱的夜幕下苏醒。<br><br><br></center></font><h3 id="不要不辞而别，我爱"><a href="#不要不辞而别，我爱" class="headerlink" title="不要不辞而别，我爱"></a><font color="#292421" size="10"><center>不要不辞而别，我爱</center></font></h3><font><br><center><br>不要不辞而别，我爱。<br><br>我看望了一夜，现在我脸上睡意重重。<br><br>只恐我在睡中把你丢失了。<br><br>不要不辞而别，我爱。<br><br>我惊起伸出双手去摸触你，<br><br>我问自己说：“这是一个梦么？”<br><br>但愿我能用我的心系住你的双足，紧抱在胸前！<br><br>不要不辞而别，我爱。<br><br><br></center></font><h3 id="永恒的爱情"><a href="#永恒的爱情" class="headerlink" title="永恒的爱情"></a><font color="#292421" size="10"><center><center>永恒的爱情</center></center></font></h3><font><center><br><center><br>我以数不清的方式爱你<br><br>我的痴心永远为你编织歌之花环<br><br>亲爱的，接受我的奉献<br><br>世世代代以各种方式挂在你的胸前<br><br>我听过的许多古老爱情的故事<br><br>充满聚首的欢乐和离别的悲郁<br><br>纵观无始的往昔<br><br>我看见你像永世难忘的北斗<br><br>穿透岁月的黑暗<br><br>姗姗来到我的面前<br><br>从洪荒时代的心源出发<br><br>你我泛舟顺流而下<br><br>你我在亿万爱侣中间嬉戏<br><br>分离时辛酸的眼泪和团圆时甜蜜的羞涩里<br><br>古老的爱情孕育了新意<br><br>陈腐的爱情而今化为你脚下的灰尘<br><br>一切心灵的爱欲、悲喜<br><br>一切爱情传说，历史诗人写的恋歌歌词<br><br>全部融合在你我新型的爱情里<br><br><br></center></center></font><h2 id="林徽因"><a href="#林徽因" class="headerlink" title="林徽因"></a><font>林徽因</font></h2><p><img src="http://photocdn.sohu.com/20130315/Img368991812.jpg" alt></p><h3 id="深夜里听到乐声"><a href="#深夜里听到乐声" class="headerlink" title="深夜里听到乐声"></a><font color="#292421" size="10"><center>深夜里听到乐声</center></font></h3><font><br><center><br>这一定又是你的手指，<br>轻弹着，<br>在这深夜，稠密的悲思；<br><br>我不禁颊边泛上了红，<br>静听着，<br>这深夜里弦子的生动。<br><br>一声听从我心底穿过，<br>忒凄凉<br>我懂得，但我怎能应和？<br><br>生命早描定她的式样，<br>太薄弱<br>是人们的美丽的想象。<br><br>除非在梦里有这么一天，<br>你和我<br>同来攀动那根希望的弦。<br><br>选自《新月诗选》（1931年9月）<br><br><br></center></font><h3 id="山中一个夏夜"><a href="#山中一个夏夜" class="headerlink" title="山中一个夏夜"></a><font color="#292421" size="10"><center>山中一个夏夜</center></font></h3><font><br><center><br>山中一个夏夜，深得<br><br>象没有底一样；<br><br>黑影，松林密密的；<br><br>周围没有点光亮。<br><br>对山闪着只一盏灯———两盏<br><br>象夜的眼，夜的眼在看！<br><br>满山的风全蹑着脚<br><br>象是走路一样；<br><br>躲过了各处的枝叶<br><br>各处的草，不响。<br><br>单是流水，不断的在山谷上<br><br>石头的心，石头的口在唱。<br><br>均匀的一片静，罩下<br><br>象张软垂的幔帐。<br><br>疑问不见了，四角里<br><br>模糊，是梦在窥探？<br><br>夜象在祈祷，无声的在期望<br><br>幽郁的虔诚在无声里布漫。<br><br><p align="right">选自《新月》四卷七期（1933年6月）</p><br><br><br></center></font><h3 id="那一晚"><a href="#那一晚" class="headerlink" title="那一晚"></a><font color="#292421" size="10"><center>那一晚</center></font></h3><font><br><center><br>那一晚我的船推出了河心，<br><br>澄蓝的天上托着密密的星。<br><br>那一晚你的手牵着我的手，<br><br>迷惘的星夜封锁起重愁。<br><br>那一晚你和我分定了方向，<br><br>两人各认取个生活的模样。<br><br>到如今我的船仍然在海面飘，<br><br>细弱的桅杆常在风涛里摇。<br><br>到如今太阳只在我背后徘徊，<br><br>层层的阴影留守在我周围。<br><br>到如今我还记着那一晚的天，<br><br>星光、眼泪、白茫茫的江边！<br><br>到如今我还想念你岸上的耕种：<br><br>红花儿黄花儿朵朵的生动。<br><br>那一天我希望要走到了顶层，<br><br>蜜一般酿出那记忆的滋润。<br><br>那一天我要跨上带羽翼的箭，<br><br>望着你花园里射一个满弦。<br><br>那一天你要听到鸟般的歌唱，<br><br>那便是我静候着你的赞赏。<br><br>那一天你要看到零乱的花影，<br><br>那便是我私闯入当年的边境！<br></center></font><h2 id="六毛"><a href="#六毛" class="headerlink" title="六毛"></a><font>六毛</font></h2><h3 id="纠纷"><a href="#纠纷" class="headerlink" title="纠纷"></a><font color="#292421" size="10"><center>纠纷</center></font></h3><font><br><center><br>数不清的繁星点亮<br><br>勾勒出，你的脸庞<br><br>你是我的繁星<br><br>在无尽的黑夜发光<br><br>数不清的鲜花绽放<br><br>显现出，我的念想<br><br>你是我的鲜花<br><br>在我的心中为王。<br><br>但<br><br>我知道，我只是一片最普通，<br><br>最平凡的土壤<br><br>配不上任何一朵花的芳香<br><br>我知道，我只是一片虚无<br><br>与黑暗相随<br><br>不值得任何繁星点亮。<br><br>你不必反复强调我们的关系，<br>我只会与你保持应有的距离。<br></center></font><h3 id="鹰的独白Ⅰ——古寺·远方"><a href="#鹰的独白Ⅰ——古寺·远方" class="headerlink" title="鹰的独白Ⅰ——古寺·远方"></a><font color="#292421" size="10"><center>鹰的独白Ⅰ——古寺·远方</center></font></h3><font><br><center><br>我曾经 是只雄鹰<br>如今 失去了翅膀<br>慵懒的<br>如古寺中的老僧<br>唯一的消遣<br>是抬头看看太阳<br>我梳理着身上的羽毛<br>回忆着它疯狂拼搏的曾经<br>厌倦着<br>它如今的闪闪发光<br><br>我是一只雄鹰<br>却渴望在远方<br>有种宝藏 叫翅膀<br>我曾经知道努力<br>懂得疯狂<br>待尘埃落尽 换回的却是<br>百孔千疮<br>蹒跚着 我走向那远方<br>没有意料中的翅膀<br>只有一种力量助我飞翔<br>叫 坚强！<br></center></font><h3 id="鹰的独白Ⅱ——沉思"><a href="#鹰的独白Ⅱ——沉思" class="headerlink" title="鹰的独白Ⅱ——沉思"></a><font color="#292421" size="10"><center>鹰的独白Ⅱ——沉思</center></font></h3><font><br><center><br>我再次获得了<br>飞翔的力量<br>我拼命煽动着这双<br>不会感到疲惫的翅膀<br>无翼的牢笼不在束缚着我<br>取而代之的是 古寺<br>让我牵挂<br>无奈<br>我是一只多情的鹰<br>纵然飞了起来<br>也只是换了一个地方 晒晒太阳<br><br>我最终选择了离去<br>来到异地他乡<br>这里的新奇模样<br>让我忘却了忧伤<br>可这并不长久<br>我思念起了古寺<br>想起故乡<br>沉默<br>我看着自己的翅膀<br>怀念那时<br>纵然不会飞时的 四处游荡<br>我渴望回到过去<br>即使不再可以<br>飞翔<br></center></font><h3 id="鹰的独白Ⅲ——终篇·轮回"><a href="#鹰的独白Ⅲ——终篇·轮回" class="headerlink" title="鹰的独白Ⅲ——终篇·轮回"></a><font color="#292421" size="10"><center>鹰的独白Ⅲ——终篇·轮回</center></font></h3><font><br><center><br>我回到了这里<br>我朝思暮想的地方<br>美人鱼失去声音<br>换来幸福<br>我失去了翅膀与记忆<br>换来轮回<br>无穷无尽<br><br>我在这世间游荡<br>古寺<br>远方<br>我都曾有印象<br>我不敢继续回想<br>只是害怕<br>发现无法发承受的真相<br><br>我是一只雄鹰<br>我失去过翅膀<br><br>我是一只雄鹰<br>曾经也可以自由自在的翱翔<br>因为轮回<br>我忘却了一切<br>脑海中唯一留下的是<br>我是一只雄鹰<br>古寺<br>远方<br>永远都是我的信仰<br><br><p align="right">2017</p><br></center></font><h3 id="无题"><a href="#无题" class="headerlink" title="无题"></a><font color="#292421" size="10"><center>无题</center></font></h3><font><br><center><br>独自<br>在街头散步<br>昏黄的灯光<br>照亮前方的路<br><br>是否有人<br>在梅花盛开之际<br>陪我一起守候<br>看灯火通明<br><br>无奈<br>无人伴我左右<br>盛开的梅花<br>凋零以久<br><br>孤守<br>黑暗的阁楼<br>凄凉的月光<br>照进我的心头<br><br>彷徨<br>在无人的山头<br>观望<br>梅花依旧<br><br>起身<br>醉吟梦回沙场战争<br>彼此<br>挥刀舞剑<br>只为去留<br><br>大雨<br>留下漫天印记<br>阴沉的乌云<br>遮蔽万丈晴空<br><br>自以为是<br>斑出一副小丑<br>阿谀奉承<br>未讨倾心却痛了心头<br><br>悲痛<br>不知结局已定<br>心中的纠结<br>像尘埃一样充满在空中<br><br>仿佛<br>一切的源头<br>都来自<br>似血般浓稠的朋友<br><br>却问<br>如何继续伪装<br>翅膀早已鲜血淋淋<br>再无法飞上天际消解心中的痛<br><br>俯身<br>抚摸自己的影子<br>到底该如何决定<br>是去是留<br><br><br>缠绵<br>在悲伤的季节<br>仰望天空<br>浑然只剩悲愁<br><br>牵手<br>好像无法跨越的壕沟<br>只有望洋兴叹<br>看落英近在崖口<br><br>枯树<br>逢春便萌发<br>生命强劲<br>不知<br>春早不如旧<br><br>转身<br>看人海茫茫<br>寻一人<br>天长地久<br><br>再次<br>贸然决定<br>还是停留<br><br><p align="right">2015.1.29</p><br></center></font><h2 id="好友投稿专区"><a href="#好友投稿专区" class="headerlink" title="好友投稿专区"></a><font>好友投稿专区</font></h2><h3 id="QQQiang"><a href="#QQQiang" class="headerlink" title="QQQiang."></a><font>QQQiang.</font></h3><font><br>那些毫不留情告诉你不可能的女孩子，上辈子一定是天使，才会如此善良。虽然当时她像是用一颗铁钉将你穿破，其实后来想起，还有美好的回忆，还能记起曾喜欢过的感觉，甚至还要谢谢她，那么绝情，那么美。<br><br>那些在你准备离去的时候假装热情的女孩子，用一种名为“希望”的泡沫，在你的心上划下了一刀又一刀，放空了你心里所有的温柔，落得满是伤痕，千疮百孔。回忆起来，竟然只剩下憎恨，憎恨她，憎恨喜欢她的自己。<br><br>年少的时候，喜欢来了，你就欢喜，你就庆幸，然后你才苦恼，你才纠结。<br><br>年长了以后，喜欢来了，你先否定，你先假设，然后你才承认，你才相信。<br><br>这世界上不是每个人都值得我们温柔以待。<br><br>这个世界上却还有一些人让我愿意满腔温柔。<br><br>愿你遇见那个，会对你的温柔回报以歌的女孩。想必她在你眼里，耀眼得像颗恒星。<br><br>编辑于 2018-06-22<br><p align="right">文章来源于知乎@柒岁安</p><br></font><h3 id="程阳"><a href="#程阳" class="headerlink" title="程阳"></a><font>程阳</font></h3><font><br><center>你不是赵雷的南方姑娘<br>不是马頓的傲雪<br>不是宋冬野的董小姐<br>不是李志的港岛妹妹<br>不是海龟的玛卡瑞纳<br>不是二百的玫瑰<br>不是尧十三的北方女王<br>不是花粥的良人<br>不是低苦艾的小花花<br>不是陈粒的祝星<br>你是青岛春天的海<br>你是南京路边的梧桐<br>你是苏州水摊上的姑娘<br>你是武汉长江上的船<br>你是郑州夜晚的孩子<br>你是太原路上的琴声<br>你是我失去的爱人</center><br><br><p align="right">摘自：酷狗音乐《北方女王》热评</p><br></font><font><br><center>四景浩荡录<br>我题诗中乾坤 白日犹见月，<br>闲游青川走马 使我不收砚<br>三山五岳 纵巍峨绝险 不过在人间<br>四景天河浩荡 尽在我画卷<br>我行江湖沧浪 独揽寒山月<br>兴来足点竹稍 我便似神仙<br>鸟鸣花间 纵千里不绝 不过此山间<br>天下清风雨露 皆为我拭剑<br><br>以江作镜自照 拂拭天地变<br>笑我收剑平事 出剑慨世间<br>挥毫江山 落笔回春野 悬砚为风月<br>四景天河浩荡 尽在我画卷<br>同行江湖沧浪 诗酒书一篇<br>逐松风且放歌 再吹绿山野<br>以笔作剑 开星与点月 踏遍扬州雪<br>四景天河浩荡 皆共我揽结<br><br>题诗中乾坤 行江湖沧浪<br>16岁的仙生日快乐！@流仙</center></font>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;I find my old about page is not so serious these days,so I will make a new about page and the old page will paste on here.
    
    </summary>
    
      <category term="Notes" scheme="https://cndrew.cn/blog/categories/Notes/"/>
    
    
      <category term="life" scheme="https://cndrew.cn/blog/tags/life/"/>
    
      <category term="Poetry" scheme="https://cndrew.cn/blog/tags/Poetry/"/>
    
      <category term="Music" scheme="https://cndrew.cn/blog/tags/Music/"/>
    
  </entry>
  
  <entry>
    <title>A 3D-Album</title>
    <link href="https://cndrew.cn/blog/2019/07/02/three/"/>
    <id>https://cndrew.cn/blog/2019/07/02/three/</id>
    <published>2019-07-02T11:07:02.060Z</published>
    <updated>2019-07-19T12:14:49.937Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Html is amazing.<a id="more"></a><br>Demo: <a href="https://cndrew.cn/blog/photos">3D-Album</a><br>Reprinted on: <a href="https://blog.csdn.net/u014346301/article/details/53447712" target="_blank" rel="noopener">https://blog.csdn.net/u014346301/article/details/53447712</a><br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;3D相册&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .container&#123;</span><br><span class="line">            width:800px;</span><br><span class="line">            height: 400px;</span><br><span class="line">            margin:0 auto;</span><br><span class="line">            perspective: 1000px;</span><br><span class="line">        &#125;</span><br><span class="line">        .box&#123;</span><br><span class="line">            position: relative;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 100%;</span><br><span class="line">            -webkit-transform-style: preserve-3d;</span><br><span class="line">            -moz-transform-style: preserve-3d;</span><br><span class="line">            -ms-transform-style: preserve-3d;</span><br><span class="line">            transform-style: preserve-3d;</span><br><span class="line">            -webkit-animation:animate 12s linear infinite;</span><br><span class="line">            -o-animation:animate 12s linear infinite;</span><br><span class="line">            animation:animate 12s linear infinite;</span><br><span class="line">        &#125;</span><br><span class="line">        .img&#123;</span><br><span class="line">            position: absolute;</span><br><span class="line">            width:300px;</span><br><span class="line">            height: 200px;</span><br><span class="line">            background: #8959a8;</span><br><span class="line">            top: 100px;</span><br><span class="line">            left:250px;</span><br><span class="line">            box-shadow: inset 0 0 5px #bbbbbb;</span><br><span class="line">        &#125;</span><br><span class="line">        .img1&#123;</span><br><span class="line">            background: url(&quot;../img/1.jpg&quot;) no-repeat;</span><br><span class="line">            -webkit-background-size:cover;</span><br><span class="line">            background-size:cover;</span><br><span class="line">            transform: rotateY(0deg) translateZ(300px);</span><br><span class="line">        &#125;</span><br><span class="line">        .img2&#123;</span><br><span class="line">            background: url(&quot;../img/2.jpg&quot;) no-repeat;</span><br><span class="line">            -webkit-background-size:cover;</span><br><span class="line">            background-size:cover;</span><br><span class="line">            transform: rotateY(60deg) translateZ(300px);</span><br><span class="line">        &#125;</span><br><span class="line">        .img3&#123;</span><br><span class="line">            background: url(&quot;../img/3.jpg&quot;) no-repeat;</span><br><span class="line">            -webkit-background-size:cover;</span><br><span class="line">            background-size:cover;</span><br><span class="line">            transform: rotateY(120deg) translateZ(300px);</span><br><span class="line">        &#125;</span><br><span class="line">        .img4&#123;</span><br><span class="line">            background: url(&quot;../img/4.jpg&quot;) no-repeat;</span><br><span class="line">            -webkit-background-size:cover;</span><br><span class="line">            background-size:cover;</span><br><span class="line">            transform: rotateY(180deg) translateZ(300px);</span><br><span class="line">        &#125;</span><br><span class="line">        .img5&#123;</span><br><span class="line">            background: url(&quot;../img/5.jpg&quot;) no-repeat;</span><br><span class="line">            -webkit-background-size:cover;</span><br><span class="line">            background-size:cover;</span><br><span class="line">            transform: rotateY(240deg) translateZ(300px);</span><br><span class="line">        &#125;</span><br><span class="line">        .img6&#123;</span><br><span class="line">            background: url(&quot;../img/6.jpg&quot;) no-repeat;</span><br><span class="line">            -webkit-background-size:cover;</span><br><span class="line">            background-size:cover;</span><br><span class="line">            transform: rotateY(300deg) translateZ(300px);</span><br><span class="line">        &#125;</span><br><span class="line">        @keyframes animate &#123;</span><br><span class="line">            0%&#123;</span><br><span class="line">                transform: rotateY(0deg);</span><br><span class="line">            &#125;</span><br><span class="line">            100%&#123;</span><br><span class="line">                transform: rotateY(360deg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot; id=&quot;box&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;img img1&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;img img2&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;img img3&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;img img4&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;img img5&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;img img6&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Html is amazing.
    
    </summary>
    
      <category term="Tutorial" scheme="https://cndrew.cn/blog/categories/Tutorial/"/>
    
    
      <category term="html" scheme="https://cndrew.cn/blog/tags/html/"/>
    
      <category term="Tutorial" scheme="https://cndrew.cn/blog/tags/Tutorial/"/>
    
      <category term="Useful" scheme="https://cndrew.cn/blog/tags/Useful/"/>
    
  </entry>
  
  <entry>
    <title>How to use rss.</title>
    <link href="https://cndrew.cn/blog/2019/06/29/rss/"/>
    <id>https://cndrew.cn/blog/2019/06/29/rss/</id>
    <published>2019-06-29T08:44:26.441Z</published>
    <updated>2019-06-29T08:54:25.553Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>The first time I knew that rss was building a blog in a fool-like way.I didn&#39;t know what rss was for at the time, but just generated it with the tutorial.I learned about these days, I also searched the Internet, found a very useful article about rss, and found a favorite rss reader for myself.<a id="more"></a></p><h3 id="如何使用RSS"><a href="#如何使用RSS" class="headerlink" title="如何使用RSS"></a>如何使用RSS</h3><p>作者： 阮一峰<br>日期： 2006年1月 8日</p><p>一、</p><p>自从我发现很多人不知道什么是RSS以后，我就一直想向大家介绍它，因为它太有用了，将来会和电子邮件一样重要。不懂得RSS，上网的效率和乐趣都要大打折扣。<br>我在网上找不到简明易懂的介绍文章，只好下决心自己来写。虽然我不是这方面的专业人士，但是我相信你只要耐心读完这篇文章，你就会基本搞懂RSS以及它的使用方法。</p><p>二、</p><p>在解释RSS是什么之前，让我先来打一个比方。</p><p>读大学的时候，我有个习惯，就是每天要去看食堂后面的海报栏。在那里，会贴出各种各样最新的消息，比如哪个系要开讲座了、星期二晚上的电影放什么、二手货转让等等。只要看一下海报栏，就会对学校的各种活动心中有数。</p><p>如果没有海报栏的话，要想知道这些消息就会很麻烦。讲座消息会贴在各个系自己的公告栏里，电影排片表是贴在电影院里的，二手货消息则会贴在各幢宿舍的楼道里。我所在的大学有20几个系，一万多人，要想知道所有这些消息的话，即使是可能的话，也会相当的麻烦。</p><p>从这个例子出发，让我们来考虑一下互联网。</p><p>互联网是什么？最直观的说，就是一个杂乱无章的巨大信息源，其丰富和杂乱的程度，不仅是巨大的，而且几乎是无限的。</p><p>一个使用者，要想及时掌握的互联网上出现的最新信息，有办法吗？</p><p>答案是没有办法，他只有一个网站一个网站的打开，去看有什么最新内容，就好比每天都必须去每一个系里走一遍，看有什么最新讲座。如果是几个网站，哪倒也不难，都去看一遍也花不了多少时间。但是随着你关注的网站数量上升，这项工作会迅速的变为&quot;Mission Impossible&quot;。想象一下，如果你每天关注几十个、甚至几百个网站，会是怎样的情景。光是打开它们的首页，就要花费多少时间啊，更别说浏览花去的时间了。</p><p>也许有人会说，普通人的话，谁会关心那么多网站啊？</p><p>我要说，哪怕你只是一个网络的初级或最单纯的使用者，与你发生关系的网站数量也在急剧增加，因为Blog出现了。越来越多的人开始写作网络日志（Blog），把自己的想法和生活在网上展示，其中也必然包括你的朋友，或者其他你感兴趣的人。你想知道他/她的最新动向，就势必要留心他/她的Blog。所以，你的网站浏览清单总有一天会和你的电话本、MSN Message好友列表一样多，甚至更多。</p><p>那时，你会发现浏览网站会变成一种困难和低效率的行为。</p><p>有没有办法找到互联网上的&quot;海报栏&quot;，只去一个地方就知道你所想知道的所有最新内容？</p><p>有，那就是RSS。</p><p>三</p><p>准确的说，RSS就像一个网站的海报，里面包括这个网站的最新内容，会自动更新。所以，我们只要订阅了RSS，就不会错过自己喜欢的网站的更新了。</p><p>但是光有海报还不行，还必须有海报栏，也就是说必须有RSS阅读器才行。因为RSS只是数据源，它本身是写给程序看的，必须经过阅读器转换，才能成为可以浏览的格式。</p><p>RSS阅读器多种多样，大致分为两种，一种是桌面型的，需要安装；另一种是在线型，直接使用浏览器进行阅读。</p><p>四</p><p>在浏览器中订阅RSS，就必须先知道RSS的地址。一般来说，各个网站的首页都会用显著位置标明。名称可能会有些不同，比如RSS、XML、FEED，大家知道它们指的都是同样的东西就可以了。有时RSS后面还会带有版本号，比如2.0、1.0，甚至0.92，这个不必理会，它们只是内部格式不同，内容都是一样。</p><p>将RSS地址复制下来以后，你就可以在在线阅读器中添加。</p><p>以后，只用打开这一个网页，就可以看到所有你喜欢的网站的最新内容了。</p><p>（完）</p><p>Reprinted on: <a href="http://www.ruanyifeng.com/blog/2006/01/rss.html?20190629083248#comment-text" target="_blank" rel="noopener">阮一峰的网络日志</a></p><h3 id="A-rss-reader-Newsflow"><a href="#A-rss-reader-Newsflow" class="headerlink" title="A rss reader--Newsflow."></a>A rss reader--Newsflow.</h3><p>You can download it and use it to achieve rss subscription locally.I will not make a specific introduction.If you are interested, you can explore it yourself.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;The first time I knew that rss was building a blog in a fool-like way.I didn&amp;#39;t know what rss was for at the time, but just generated it with the tutorial.I learned about these days, I also searched the Internet, found a very useful article about rss, and found a favorite rss reader for myself.
    
    </summary>
    
      <category term="Tutorial" scheme="https://cndrew.cn/blog/categories/Tutorial/"/>
    
    
      <category term="life" scheme="https://cndrew.cn/blog/tags/life/"/>
    
      <category term="Tutorial" scheme="https://cndrew.cn/blog/tags/Tutorial/"/>
    
      <category term="hexo" scheme="https://cndrew.cn/blog/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>How to download images on instagram</title>
    <link href="https://cndrew.cn/blog/2019/06/29/instagram/"/>
    <id>https://cndrew.cn/blog/2019/06/29/instagram/</id>
    <published>2019-06-29T08:14:13.572Z</published>
    <updated>2019-06-29T08:41:15.672Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>I have been on the ins for a long time these day.<a id="more"></a><br>As we all know,there are many high quality images on the instagram.But saving the image directly is forbidden.As the saying goes,there must be a road before the car goes to the mountain.There have been many ways to download images on instagram.Such as a plugin or a WeChat public number.I tried all these methods, but the results did not satisfy me.And then I found a easy and useful way.</p><p>Such as,we are willing to download this image.<br><img src="https://i.loli.net/2019/06/29/5d1721329ff8d14481.png" alt><br>First,right click to find this option - view the page source code.<br><img src="https://i.loli.net/2019/06/29/5d172188012ab48353.png" alt><br>After you click in,you may be scared by a lot of things you don&#39;t understand.Calm down,use the shortcut key <code>Ctrl+u</code> to bring up the search box.<br><img src="https://i.loli.net/2019/06/29/5d17224e8ba1e58016.png" alt><br>And then input <code>jpg</code>,the first result of the search results is the url of the image we are looking for(Look at where I draw).<br><img src="https://i.loli.net/2019/06/29/5d1722749ccd939771.png" alt><br>So now we know the url of this image is:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://scontent-nrt1-1.cdninstagram.com/vp/ff449eed1ee7a9806334532d0e3dcbb9/5DA3D2C0/t51.2885-15/e35/58721835_156199248745005_4328502816718543045_n.jpg?_nc_ht=scontent-nrt1-1.cdninstagram.com</span><br></pre></td></tr></table></figure></p><p>Copy this url to the address box of the browser,then you can Right click -&gt; Save as image.</p><p>Finally,I want to share a very interesting thing with you.When I was in high school, I learned a star online and found a beautiful photo of her, but when I wanted to see it again these two days, I found out that I couldn’t find it. I suddenly thought of ins and turned over about 500 photos,then I found this and I am very happy.Here is the photo<br><img src="https://i.loli.net/2019/06/29/5d1724276b49788414.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;I have been on the ins for a long time these day.
    
    </summary>
    
      <category term="Tutorial" scheme="https://cndrew.cn/blog/categories/Tutorial/"/>
    
    
      <category term="Tutorial" scheme="https://cndrew.cn/blog/tags/Tutorial/"/>
    
      <category term="instagram" scheme="https://cndrew.cn/blog/tags/instagram/"/>
    
  </entry>
  
</feed>
