<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Uncle_drew</title>
  
  <subtitle>Hand down,man down</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://cndrew.cn/blog/"/>
  <updated>2019-07-30T14:11:59.586Z</updated>
  <id>https://cndrew.cn/blog/</id>
  
  <author>
    <name>Uncle_drew</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HPU Summer Day 14(河南理工大学暑期第十四天)</title>
    <link href="https://cndrew.cn/blog/2019/07/30/d14/"/>
    <id>https://cndrew.cn/blog/2019/07/30/d14/</id>
    <published>2019-07-30T14:08:53.537Z</published>
    <updated>2019-07-30T14:11:59.586Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天讲了记忆化搜索，拉的题emm真让人自闭啊。<a id="more"></a></p><h3 id="Function-Run-Fun"><a href="#Function-Run-Fun" class="headerlink" title="Function Run Fun"></a>Function Run Fun</h3><p>Description:<br>We all love recursion! Don&#39;t we?</p><p>Consider a three-parameter recursive function w(a, b, c):</p><p>if a &lt;= 0 or b &lt;= 0 or c &lt;= 0, then w(a, b, c) returns:<br>1</p><p>if a &gt; 20 or b &gt; 20 or c &gt; 20, then w(a, b, c) returns:<br>w(20, 20, 20)</p><p>if a &lt; b and b &lt; c, then w(a, b, c) returns:<br>w(a, b, c-1) + w(a, b-1, c-1) - w(a, b-1, c)</p><p>otherwise it returns:<br>w(a-1, b, c) + w(a-1, b-1, c) + w(a-1, b, c-1) - w(a-1, b-1, c-1)</p><p>This is an easy function to implement. The problem is, if implemented directly, for moderate values of a, b and c (for example, a = 15, b = 15, c = 15), the program takes hours to run because of the massive recursion.<br>Input</p><blockquote><p>The input for your program will be a series of integer triples, one per line, until the end-of-file flag of -1 -1 -1. Using the above technique, you are to calculate w(a, b, c) efficiently and print the result.</p></blockquote><p>Output</p><blockquote><p>Print the value for w(a,b,c) for each triple.</p></blockquote><p>Sample Input</p><blockquote><p>1 1 1<br>2 2 2<br>10 4 6<br>50 50 50<br>-1 7 18<br>-1 -1 -1</p></blockquote><p>Sample Output</p><blockquote><p>w(1, 1, 1) = 2<br>w(2, 2, 2) = 4<br>w(10, 4, 6) = 523<br>w(50, 50, 50) = 1048576<br>w(-1, 7, 18) = 1</p></blockquote><p>Problem solving:<br>这道题没什么好说的，按照题目上的要求来写一个递归就行了，因为是多组输入，所以要用到记忆化搜索。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll a,b,c,dp[21][21][21];</span><br><span class="line">ll dfs(ll m,ll t,ll x)</span><br><span class="line">&#123;</span><br><span class="line">if(m&lt;=0||t&lt;=0||x&lt;=0)</span><br><span class="line">return 1;</span><br><span class="line">if(m&gt;20||t&gt;20||x&gt;20)</span><br><span class="line">returndfs(20,20,20);</span><br><span class="line">if(dp[m][t][x])return dp[m][t][x];</span><br><span class="line">if(m&lt;t&amp;&amp;t&lt;x)</span><br><span class="line">return dp[m][t][x]=dfs(m,t,x-1)+dfs(m,t-1,x-1)-dfs(m,t-1,x);</span><br><span class="line">else</span><br><span class="line">return dp[m][t][x]=dfs(m-1,t,x)+dfs(m-1,t-1,x)+dfs(m-1,t,x-1)-dfs(m-1,t-1,x-1);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c)</span><br><span class="line">&#123;</span><br><span class="line">if(a==-1&amp;&amp;b==-1&amp;&amp;c==-1)</span><br><span class="line">break;</span><br><span class="line">printf(&quot;w(%lld, %lld, %lld) = %lld\n&quot;,a,b,c,dfs(a,b,c));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="滑雪"><a href="#滑雪" class="headerlink" title="滑雪"></a>滑雪</h3><p>Description:<br>Glory非常喜欢玩滑滑梯游戏，下面给出了一个n,m的滑道，其中的数字表示滑道的高度。Glory可以从一个点出发向下滑行，每次只能滑行到相邻的位置(上下左右)中高度严格低于当前高度的地方，不能重复划行已经滑行过的地方，但他希望在这个滑道上滑行尽量远的距离，也即是找一条最长的滑道。</p><p>Input</p><blockquote><p>第一行输入两个数n,m代表滑梯范围行n和列m(1 &lt;= n,m &lt;= 100)。下面是n行，每行有m个整数，代表高度h，(0&lt;=h&lt;=20000)</p></blockquote><p>Output</p><blockquote><p>输出一个值，代表Glory能够在滑滑梯上面滑行的最长长度是多少</p></blockquote><p>Sample Input</p><blockquote><p>3 3<br>9 1 2<br>5 6 7<br>8 4 3</p></blockquote><p>Sample Output</p><blockquote><p>4</p></blockquote><p>Sample Input</p><blockquote><p>4 7<br>7 6 5 4 3 2 1<br>1 5 1 1 1 1 1<br>1 4 3 1 1 1 1<br>1 5 6 7 8 1 1</p></blockquote><p>Sample Output</p><blockquote><p>7</p></blockquote><p>hint</p><blockquote><p>样例1：7-&gt;6-&gt;4-&gt;3 长度为4</p></blockquote><p>Problem solving:<br>四个方向搜索就行了。记忆化搜索要用上，不然会超时。<br>ma[dx][dy]与ma[x][y]的大小关系判断的时候大于小于都是可以的，这个还是很好理解的吧，降序反过来就是升序。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m,ma[105][105],dp[105][105];</span><br><span class="line">int d[4][2]=&#123;1,0,0,1,0,-1,-1,0&#125;;</span><br><span class="line">int dfs(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">int mid=1;</span><br><span class="line">if(dp[x][y])return dp[x][y];</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">int dx=x+d[i][0];</span><br><span class="line">int dy=y+d[i][1];</span><br><span class="line">if(dx&gt;=0&amp;&amp;dx&lt;n&amp;&amp;dy&gt;=0&amp;&amp;dy&lt;m&amp;&amp;ma[dx][dy]&lt;ma[x][y])</span><br><span class="line">&#123;</span><br><span class="line">mid=max(mid,dfs(dx,dy)+1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return dp[x][y]=mid;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">for(int j=0;j&lt;m;j++)</span><br><span class="line">cin&gt;&gt;ma[i][j];</span><br><span class="line">int ans=0;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">for(int j=0;j&lt;m;j++)</span><br><span class="line">ans=max(ans,dfs(i,j));</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="漫步校园"><a href="#漫步校园" class="headerlink" title="漫步校园"></a>漫步校园</h3><p>LL最近沉迷于AC不能自拔，每天寝室、机房两点一线。由于长时间坐在电脑边，缺乏运动。他决定充分利用每次从寝室到机房的时间，在校园里散散步。整个HDU校园呈方形布局，可划分为n*n个小方格，代表各个区域。例如LL居住的18号宿舍位于校园的西北角，即方格(1,1)代表的地方，而机房所在的第三实验楼处于东南端的(n,n)。因有多条路线可以选择，LL希望每次的散步路线都不一样。另外，他考虑从A区域到B区域仅当存在一条从B到机房的路线比任何一条从A到机房的路线更近(否则可能永远都到不了机房了…)。现在他想知道的是，所有满足要求的路线一共有多少条。你能告诉他吗?<br>Input</p><blockquote><p>每组测试数据的第一行为n(2=&lt;n&lt;=50)，接下来的n行每行有n个数，代表经过每个区域所花的时间t(0&lt;t&lt;=50)(由于寝室与机房均在三楼，故起点与终点也得费时)。</p></blockquote><p>Output</p><blockquote><p>针对每组测试数据，输出总的路线数(小于2^63)。</p></blockquote><p>Sample Input</p><blockquote><p>3<br>1 2 3<br>1 2 3<br>1 2 3<br>3<br>1 1 1<br>1 1 1<br>1 1 1</p></blockquote><p>Sample Output</p><blockquote><p>1<br>6</p></blockquote><p>Problem solving:<br>这道题的题意也太难懂了。。。<br>让你求最短路的条数，所以我们需要先求出最短路然后再求条数。<br>先用bfs求出每个点到终点的最短距离然后进行记忆化搜索。<br>（如果阁下真的是在看我的题解，当你看到这的时候，我衷心的给你道个歉，这道题为了你好还是百度吧</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int n;</span><br><span class="line">struct node&#123;</span><br><span class="line">int x,y,c;</span><br><span class="line">bool friend operator &lt;(node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">return a.c&gt;b.c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;r,w;</span><br><span class="line">ll ma[305][305],vis[305][305],dis[305][305],dp[305][305];</span><br><span class="line">int d[4][2]=&#123;0,1,1,0,-1,0,0,-1&#125;;</span><br><span class="line">void bfs()</span><br><span class="line">&#123;</span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line">r.x=n-1,r.y=n-1;r.c=ma[n-1][n-1];</span><br><span class="line">dis[n-1][n-1]=ma[n-1][n-1];</span><br><span class="line">vis[n-1][n-1]=1;</span><br><span class="line">q.push(r);</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">r=q.top();</span><br><span class="line">q.pop();</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">int dx=r.x+d[i][0];</span><br><span class="line">int dy=r.y+d[i][1];</span><br><span class="line">if(dx&lt;0||dy&lt;0||dx&gt;=n||dy&gt;=n||vis[dx][dy])continue;</span><br><span class="line">w.x=dx,w.y=dy,w.c=r.c+ma[dx][dy];</span><br><span class="line">vis[dx][dy]=1;</span><br><span class="line">q.push(w);</span><br><span class="line">dis[dx][dy]=w.c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll dfs(ll x,ll y)</span><br><span class="line">&#123;</span><br><span class="line">if(x==n-1&amp;&amp;y==n-1)return 1;</span><br><span class="line">if(dp[x][y]!=-1)return dp[x][y];</span><br><span class="line">dp[x][y]=0;</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">int dx=x+d[i][0];</span><br><span class="line">int dy=y+d[i][1];</span><br><span class="line">if(dx&lt;0||dy&lt;0||dx&gt;=n||dy&gt;=n||dis[dx][dy]&gt;=dis[x][y])continue;</span><br><span class="line">dp[x][y]+=dfs(dx,dy);</span><br><span class="line">&#125;</span><br><span class="line">return dp[x][y];</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(cin&gt;&gt;n)</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">for(int j=0;j&lt;n;j++)</span><br><span class="line">cin&gt;&gt;ma[i][j];</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">memset(dp,-1,sizeof(dp));</span><br><span class="line">bfs();</span><br><span class="line">cout&lt;&lt;dfs(0,0)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Free-Candies"><a href="#Free-Candies" class="headerlink" title="Free Candies"></a>Free Candies</h3><p>Description:<br>PDF题面:<a href="https://uva.onlinejudge.org/external/101/p10118.pdf" target="_blank" rel="noopener">戳我戳我</a><br><img src="http://drew.todest.cn/Description.png" alt><br>输入<br><img src="http://drew.todest.cn/f8bc32f9c3ed521ffc13c93ad058101e714e8250.png" alt><br>输出<br><img src="http://drew.todest.cn/b2047ac146b5704d62c2c5a4274ff76ea8c1b57b.png" alt><br>Problem solving:<br>题意就是有4个盒子，每个盒子里面都放着糖果，有个最多能放5个糖果的袋子，每次只能取盒子最上面的那个糖果，如果袋子里面有两个颜色相同的糖果可以自己拿走（这道题用数字代表颜色），问你最优情况下能拿走几对糖果，注意是对（2个算一对）。<br>我们这里可以用一个四维数组表示分别从四堆糖果中取出不同个数的糖果的时候的最优解，用一个now数组代表此时在第i堆数组拿到了第now[i]个糖果，用一个flag数组表示这个颜色的糖果是否在袋子里出现过。然后进行dfs查找，注意这里用到了很多回溯，还有记忆化搜索。可以看一下代码注释了解一下具体的dfs过程。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int dp[45][45][45][45],n,ma[4][45];</span><br><span class="line">int now[4],flag[45];</span><br><span class="line">int dfs(int x)//x代表的就是当前袋子里放入的糖果个数</span><br><span class="line">&#123;</span><br><span class="line">int ans=0;//初始化为0</span><br><span class="line">if(dp[now[0]][now[1]][now[2]][now[3]]!=-1)//记忆化搜索</span><br><span class="line">return dp[now[0]][now[1]][now[2]][now[3]];</span><br><span class="line">if(x==5)return 0;//袋子里有5个糖果了，不能放入更多，所以return 0</span><br><span class="line">for(int i=0;i&lt;4;i++)//四堆糖果</span><br><span class="line">&#123;</span><br><span class="line">if(now[i]==n)continue;//在这一堆如果已经取到了第n个，即最后一个，就结束这一堆糖果中的查找</span><br><span class="line">int mid=ma[i][now[i]];//代表的是当前取出的糖果的颜色</span><br><span class="line">now[i]++;//下一次要放入的糖果的颜色</span><br><span class="line">if(flag[mid])//如果现在要放入袋子里的糖果的颜色在袋子里已经存在</span><br><span class="line">&#123;</span><br><span class="line">flag[mid]=0;//把袋子里的颜色相同的那个糖果取出来</span><br><span class="line">ans=max(ans,dfs(x-1)+1);//当前的最优值更新一下，dfs(x-1)即取出颜色相同得糖果之后的最优解，加上的1就是取出的糖果和本来准备放进袋子却没放的糖果这一对</span><br><span class="line">flag[mid]=1;//回溯，把从袋子里取出的糖果再放回去</span><br><span class="line">&#125;</span><br><span class="line">else//现在要放入袋子里的糖果的颜色在袋子里不存在</span><br><span class="line">&#123;</span><br><span class="line">flag[mid]=1;//把这个糖果放进去</span><br><span class="line">ans=max(dfs(x+1),ans);//此时袋子里的糖果数加一</span><br><span class="line">flag[mid]=0;//回溯，把放进去的再取出来</span><br><span class="line">&#125;</span><br><span class="line">now[i]--;//回溯，考虑不放这一个糖果的情况</span><br><span class="line">&#125;</span><br><span class="line">return dp[now[0]][now[1]][now[2]][now[3]]=ans;//记忆化</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(cin&gt;&gt;n&amp;&amp;n)</span><br><span class="line">&#123;</span><br><span class="line">memset(dp,-1,sizeof(dp));</span><br><span class="line">memset(now,0,sizeof(now));</span><br><span class="line">memset(flag,0,sizeof(flag));</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">for(int j=0;j&lt;4;j++)</span><br><span class="line">cin&gt;&gt;ma[j][i];</span><br><span class="line">cout&lt;&lt;dfs(0)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Zipper"><a href="#Zipper" class="headerlink" title="Zipper"></a>Zipper</h3><p>Description:<br>Given three strings, you are to determine whether the third string can be formed by combining the characters in the first two strings. The first two strings can be mixed arbitrarily, but each must stay in its original order.</p><p>For example, consider forming &quot;tcraete&quot; from &quot;cat&quot; and &quot;tree&quot;:</p><p>String A: cat<br>String B: tree<br>String C: tcraete</p><p>As you can see, we can form the third string by alternating characters from the two strings. As a second example, consider forming &quot;catrtee&quot; from &quot;cat&quot; and &quot;tree&quot;:</p><p>String A: cat<br>String B: tree<br>String C: catrtee</p><p>Finally, notice that it is impossible to form &quot;cttaree&quot; from &quot;cat&quot; and &quot;tree&quot;.<br>Input</p><blockquote><p>The first line of input contains a single positive integer from 1 through 1000. It represents the number of data sets to follow. The processing for each data set is identical. The data sets appear on the following lines, one data set per line.<br>For each data set, the line of input consists of three strings, separated by a single space. All strings are composed of upper and lower case letters only. The length of the third string is always the sum of the lengths of the first two strings. The first two strings will have lengths between 1 and 200 characters, inclusive.</p></blockquote><p>Output</p><blockquote><p>For each data set, print:<br>Data set n: yes<br>if the third string can be formed from the first two, or<br>Data set n: no<br>if it cannot. Of course n should be replaced by the data set number. See the sample output below for an example.</p></blockquote><p>Sample Input</p><blockquote><p>3<br>cat tree tcraete<br>cat tree catrtee<br>cat tree cttaree</p></blockquote><p>Sample Output</p><blockquote><p>Data set 1: yes<br>Data set 2: yes<br>Data set 3: no</p></blockquote><p>Problem solving:<br>匹配的时候只会有两种情况</p><ol><li>第一个字符串当前位置的字符与第三个字符串当前位置的字符相等。</li><li>第二个字符串当前位置的字符与第三个字符串当前位置的字符相等。<br>只有这两种情况，所以我们可以直接用dfs进行暴搜。但是这道题需要用到记忆化搜索，用一个二维的标记数组即可。每次查找完当前的一对位置就标记起来，下次遇见的时候就不需要再查找了。</li></ol><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">string a,b,c;</span><br><span class="line">int vis[205][205],flag;</span><br><span class="line">void dfs(int x,int y,int z)</span><br><span class="line">&#123;</span><br><span class="line">if(flag)return ;</span><br><span class="line">if(z==c.size())</span><br><span class="line">&#123;</span><br><span class="line">flag=1;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">if(vis[x][y])return ;</span><br><span class="line">vis[x][y]=1;</span><br><span class="line">if(a[x]==c[z])dfs(x+1,y,z+1);</span><br><span class="line">if(b[y]==c[z])dfs(x,y+1,z+1);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,now=0;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">while(n--)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">flag=0;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">cout&lt;&lt;&quot;Data set &quot;&lt;&lt;++now&lt;&lt;&quot;: &quot;;</span><br><span class="line">dfs(0,0,0);</span><br><span class="line">if(flag)puts(&quot;yes&quot;);</span><br><span class="line">elseputs(&quot;no&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Bone-Collector"><a href="#Bone-Collector" class="headerlink" title="Bone Collector"></a>Bone Collector</h3><p>Description:<br>Many years ago , in Teddy’s hometown there was a man who was called “Bone Collector”. This man like to collect varies of bones , such as dog’s , cow’s , also he went to the grave …<br>The bone collector had a big bag with a volume of V ,and along his trip of collecting there are a lot of bones , obviously , different bone has different value and different volume, now given the each bone’s value along his trip , can you calculate out the maximum of the total value the bone collector can get ?<br><img src="http://drew.todest.cn/bone.png" alt><br>Input</p><blockquote><p>The first line contain a integer T , the number of cases.<br>Followed by T cases , each case three lines , the first line contain two integer N , V, (N &lt;= 1000 , V &lt;= 1000 )representing the number of bones and the volume of his bag. And the second line contain N integers representing the value of each bone. The third line contain N integers representing the volume of each bone.</p></blockquote><p>Output</p><blockquote><p>One integer per line representing the maximum of the total value (this number will be less than 2 31).</p></blockquote><p>Sample Input</p><blockquote><p>1<br>5 10<br>1 2 3 4 5<br>5 4 3 2 1</p></blockquote><p>Sample Output</p><blockquote><p>14</p></blockquote><p>Problem solving:<br>这就是一道背包问题，但是换了描述。<br>背包问题dp得写法我们还没学，今天学到的是用记忆化搜索解决的背包问题。<br>具体的解释请看代码注释</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m,a[1050],b[1050],dp[1050][1050];</span><br><span class="line">int dfs(int x,int y)//x代表的是收集到的骨头的个数</span><br><span class="line">&#123;//y代表的是当前背包剩余容量</span><br><span class="line">if(x==n)return 0;//没有更多骨头可供收集了</span><br><span class="line">if(dp[x][y])return dp[x][y];//已经搜索过一次了，直接调用</span><br><span class="line">int ans;</span><br><span class="line">if(y&lt;b[x])ans=dfs(x+1,y);//当前骨头所占体积大于背包所剩体积，放不进去了，直接跳过</span><br><span class="line">elseans=max(dfs(x+1,y),dfs(x+1,y-b[x])+a[x]);//能放进去，要分两种情况，放或不放，取最大值</span><br><span class="line">return dp[x][y]=ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">memset(dp,0,sizeof(dp));</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">for(int i=0;i&lt;n;i++)cin&gt;&gt;a[i];</span><br><span class="line">for(int i=0;i&lt;n;i++)cin&gt;&gt;b[i];</span><br><span class="line">cout&lt;&lt;dfs(0,m)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="FatMouse-and-Cheese"><a href="#FatMouse-and-Cheese" class="headerlink" title="FatMouse and Cheese"></a>FatMouse and Cheese</h3><p>Description:<br>有一种游戏是的玩法是这样的：<br>有一个n*n的格子,每个格子有一个数字。<br>遵循以下规则:</p><ol><li>玩家每次可以由所在格子向上下左右四个方向进行直线移动，每次移动的距离不得超过m</li><li>玩家一开始在第一行第一列，并且已经获得该格子的分值</li><li>玩家获得每一次移动到的格子的分值</li><li>玩家下一次移动到达的格子的分值要比当前玩家所在的格子的分值要大。</li><li>游戏所有数字加起来也不大，保证所有数字的和不会超过int型整数的范围</li><li>玩家仅能在n*n的格子内移动，超出格子边界属于非法操作</li><li>当玩家不能再次移动时，游戏结束<br>现在问你，玩家所能获得的最大得分是多少？</li></ol><p>Input</p><blockquote><p>有多组测试数据<br>每组测试样例第一行是两个整数n,m (1≤n≤100)(1≤m≤100),当n和m都是-1时为程序结束标志，直接退出即可<br>之后n行，每行n个数字，描述n*n的格子里的数字</p></blockquote><p>Output</p><blockquote><p>对于每组测试数据输出一行，这一行仅有一个整数，代表玩家所能获得的最高得分</p></blockquote><p>Sample Input</p><blockquote><p>3 1<br>1 2 5<br>10 11 6<br>12 12 7<br>-1 -1</p></blockquote><p>Sample Output</p><blockquote><p>37</p></blockquote><p>Problem solving:<br>这道题跟滑雪那道题差不多，有一点不一样的就是这道题里面每次走的步数可以是不一样的并且范围给了我们。这样的话，仍然暴力搜索就行了。把每种步数都考虑进去可以这样实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int d[4][2]=&#123;0,1,1,0,0,-1,-1,0&#125;;</span><br><span class="line">for(int i=0;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=1;j&lt;=m;j++)</span><br><span class="line">    &#123;</span><br><span class="line">    int dx=x+d[i][0]*j;</span><br><span class="line">        int dy=y+d[i][1]*j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后就跟滑雪那道题一样了。<br>主要要用到记忆化搜索，不然会TLE</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m,ma[105][105],dp[105][105];</span><br><span class="line">int d[4][2]=&#123;1,0,0,1,-1,0,0,-1&#125;;</span><br><span class="line">int dfs(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">if(dp[x][y])return dp[x][y];</span><br><span class="line">int ans=0;</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=1;j&lt;=m;j++)</span><br><span class="line">&#123;</span><br><span class="line">int dx=x+d[i][0]*j;</span><br><span class="line">int dy=y+d[i][1]*j;</span><br><span class="line">if(dx&gt;=0&amp;&amp;dy&gt;=0&amp;&amp;dx&lt;n&amp;&amp;dy&lt;n&amp;&amp;ma[dx][dy]&gt;ma[x][y])</span><br><span class="line">&#123;</span><br><span class="line">ans=max(ans,dfs(dx,dy));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return dp[x][y]=ans+ma[x][y];</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(cin&gt;&gt;n&gt;&gt;m&amp;&amp;n!=-1&amp;&amp;m!=-1)</span><br><span class="line">&#123;</span><br><span class="line">memset(dp,0,sizeof(dp));</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">for(int j=0;j&lt;n;j++)</span><br><span class="line">cin&gt;&gt;ma[i][j];</span><br><span class="line">cout&lt;&lt;dfs(0,0)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天讲了记忆化搜索，拉的题emm真让人自闭啊。
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="Algorithm" scheme="https://cndrew.cn/blog/tags/Algorithm/"/>
    
      <category term="c/c++" scheme="https://cndrew.cn/blog/tags/c-c/"/>
    
      <category term="UVA" scheme="https://cndrew.cn/blog/tags/UVA/"/>
    
      <category term="dp" scheme="https://cndrew.cn/blog/tags/dp/"/>
    
      <category term="dfs" scheme="https://cndrew.cn/blog/tags/dfs/"/>
    
      <category term="记忆化搜索" scheme="https://cndrew.cn/blog/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"/>
    
      <category term="hdu" scheme="https://cndrew.cn/blog/tags/hdu/"/>
    
  </entry>
  
  <entry>
    <title>HPU Summer Day 13(河南理工大学暑期第十三天)</title>
    <link href="https://cndrew.cn/blog/2019/07/29/d13/"/>
    <id>https://cndrew.cn/blog/2019/07/29/d13/</id>
    <published>2019-07-29T14:19:00.228Z</published>
    <updated>2019-07-29T14:19:27.029Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天讲了一点关于DP的知识和几道例题，据说这样就算是入门了。今天的题怎么说呢？亏是之前做过，要是之前没做过，还真不知道该怎么写。dp就是玄学？<a id="more"></a><br>今天的题很多都是需要灵光一现（或者百度解题的。具体的我也说不清，自己体会吧。（怎么能告诉你是因为我不会呢？</p><h3 id="The-King’s-Ups-and-Downs"><a href="#The-King’s-Ups-and-Downs" class="headerlink" title="The King’s Ups and Downs"></a>The King’s Ups and Downs</h3><p>Description:<br>The king has guards of all different heights. Rather than line them up in increasing or decreasing height order, he wants to line them up so each guard is either shorter than the guards next to him or taller than the guards next to him (so the heights go up and down along the line). For example, seven guards of heights 160, 162, 164, 166, 168, 170 and 172 cm. could be arranged as:<br><img src="http://drew.todest.cn/YI$DPR%28_8~4%5DN$A2%5BLT%28%7DVU.png" alt><br>or perhaps:<br><img src="http://drew.todest.cn/YI$DPR%28_8~4%5DN$A2%5BLT%28%7DVU.png" alt><br>The king wants to know how many guards he needs so he can have a different up and down order at each changing of the guard for rest of his reign. To be able to do this, he needs to know for a given number of guards, n, how many different up and down orders there are:</p><p>For example, if there are four guards: 1, 2, 3,4 can be arrange as:</p><p>1324, 2143, 3142, 2314, 3412, 4231, 4132, 2413, 3241, 1423</p><p>For this problem, you will write a program that takes as input a positive integer n, the number of guards and returns the number of up and down orders for n guards of differing heights.</p><p>Input</p><blockquote><p>The first line of input contains a single integer P, (1 &lt;= P &lt;= 1000), which is the number of data sets that follow. Each data set consists of single line of input containing two integers. The first integer, D is the data set number. The second integer, n (1 &lt;= n &lt;= 20), is the number of guards of differing heights.</p></blockquote><p>Output</p><blockquote><p>For each data set there is one line of output. It contains the data set number (D) followed by a single space, followed by the number of up and down orders for the n guards.</p></blockquote><p>Sample Input</p><blockquote><p>4<br>1 1<br>2 3<br>3 4<br>4 20</p></blockquote><p>Sample Output</p><blockquote><p>1 1<br>2 4<br>3 10<br>4 740742376475050</p></blockquote><p>Problem solving:<br>这道题我是真的懵逼了。。。<br>看这个大佬的解释吧:<a href="https://blog.csdn.net/niuox/article/details/8866907" target="_blank" rel="noopener">niuox</a><br>题意是求1-n 的全排列中有多少呈现高低高低高低或者地高低高形式排列的个数。</p><p>这种排列叫做：alternating permutations 或者 Extremal Permutations 。</p><p>可以用DP做。</p><p>dp(n,k)表示：长度为n，最后一个数为k，最后两个数是递增的  排列的个数;</p><p>dp2(n,k)表示：长度为n,最后一个数为k,最后两个数是递减的 排列的个数;</p><p>那么：</p><p>dp(n,k) = dp2(n,n+1-k) ;</p><p>很好理解吧，比如说132(低高低)等价于312(高低高)，相对的位置加起来等于4.</p><p>那么我们针对dp[n][k]的最后一位进行如下考虑：</p><p>最后一位是k，因为dp[n][k]最后两个数字是递增的，所以第n-1位的最大值是k-1。那么我们很容易推导出DP方程：<br><img src="http://drew.todest.cn/W6@LCEF1Z61%60%5DGPX%25Y%60_J$Q.hc" alt></p><p>又</p><p><img src="http://drew.todest.cn/68AW~3D2%7BH%25LMQ2Z140E3~R.hc" alt></p><p>所以：dp(n,k) = dp(n-1,n+1-k) + dp(n,k-1)；<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=25;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll dp[maxn][maxn],ans[maxn];</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">dp[1][1]=1;ans[1]=1;</span><br><span class="line">for(int i=2;i&lt;=20;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int k=2;k&lt;=i;k++)</span><br><span class="line">&#123;</span><br><span class="line">dp[i][k]=dp[i-1][i+1-k]+dp[i][k-1];</span><br><span class="line">ans[i]+=dp[i][k];</span><br><span class="line">&#125;</span><br><span class="line">ans[i]*=2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">init();</span><br><span class="line">int p,m,n;</span><br><span class="line">cin&gt;&gt;p;</span><br><span class="line">while(p--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">cout&lt;&lt;m&lt;&lt;&quot; &quot;&lt;&lt;ans[n]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="数塔"><a href="#数塔" class="headerlink" title="数塔"></a>数塔</h3><p>Description:<br>在讲述DP算法的时候，一个经典的例子就是数塔问题，它是这样描述的：</p><p>有如下所示的数塔，要求从顶层走到底层，若每一步只能走到相邻的结点，则经过的结点的数字之和最大是多少？<br><img src="http://drew.todest.cn/P40515CDJA5N%5B8NG5%2965K%287.png" alt><br>已经告诉你了，这是个DP的题目，你能AC吗?</p><p>Input</p><blockquote><p>输入数据首先包括一个整数C,表示测试实例的个数，每个测试实例的第一行是一个整数N(1 &lt;= N &lt;= 100)，表示数塔的高度，接下来用N行数字表示数塔，其中第i行有个i个整数，且所有的整数均在区间[0,99]内。</p></blockquote><p>Output</p><blockquote><p>对于每个测试实例，输出可能得到的最大和，每个实例的输出占一行。</p></blockquote><p>Sample Input</p><blockquote><p>1<br>5<br>7<br>3 8<br>8 1 0<br>2 7 4 4<br>4 5 2 6 5</p></blockquote><p>Sample Output</p><blockquote><p>30</p></blockquote><p>Problem solving:<br>挺简单的一道经典的dp的题。这道题我们可以倒着推，状态转移方程就是<br><code>a[i][j]=max(a[i+1][j],a[i+1][j+1])+a[i][j]</code><br>按照这个处理完之后直接输出a[1][1]即可</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 105;</span><br><span class="line">int c,n,a[maxn][maxn],ans[maxn][maxn];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;c;</span><br><span class="line">while(c--)</span><br><span class="line">&#123;</span><br><span class="line">memset(ans,0,sizeof(ans));</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=1;j&lt;=i;j++)</span><br><span class="line">cin&gt;&gt;a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">for(int i=n-1;i&gt;=1;i--)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=1;j&lt;=i;j++)</span><br><span class="line">&#123;</span><br><span class="line">a[i][j]=max(a[i+1][j],a[i+1][j+1])+a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;a[1][1]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="母牛的故事"><a href="#母牛的故事" class="headerlink" title="母牛的故事"></a>母牛的故事</h3><p>Description:<br>有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛。请编程实现在第n年的时候，共有多少头母牛？<br>Input</p><blockquote><p>输入数据由多个测试实例组成，每个测试实例占一行，包括一个整数n(0&lt;n&lt;55)，n的含义如题目中描述。<br>n=0表示输入数据的结束，不做处理。</p></blockquote><p>Output</p><blockquote><p>对于每个测试实例，输出在第n年的时候母牛的数量。<br>每个输出占一行。</p></blockquote><p>Sample Input</p><blockquote><p>2<br>4<br>5<br>0</p></blockquote><p>Sample Output</p><blockquote><p>2<br>4<br>6</p></blockquote><p>Problem solving:<br>经典题。每头小母牛从第四年开始就可以每年生一头小牛，所以第n年牛的个数即为<br><code>a[n]=a[n-1]+a[n-3]</code><br>即状态转移方程。a[n-1]代表的是上一年所有的母牛，a[n-3]代表的是上一年所有的母牛能生出来的小牛的个数。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll ans[60];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">ans[0]=0;ans[1]=1;ans[2]=2;ans[3]=3;ans[4]=4;</span><br><span class="line">for(int i=5;i&lt;60;i++)</span><br><span class="line">ans[i]=ans[i-1]+ans[i-3];</span><br><span class="line">int n;</span><br><span class="line">while(cin&gt;&gt;n&amp;&amp;n)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;ans[n]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="一只小蜜蜂"><a href="#一只小蜜蜂" class="headerlink" title="一只小蜜蜂..."></a>一只小蜜蜂...</h3><p>Description:<br>有一只经过训练的蜜蜂只能爬向右侧相邻的蜂房，不能反向爬行。请编程计算蜜蜂从蜂房a爬到蜂房b的可能路线数。<br>其中，蜂房的结构如下所示。<br><img src="http://drew.todest.cn/Z8H9%5B%60GY5~TQ_$GQL%25U%7B1HX.png" alt><br>Input</p><blockquote><p>输入数据的第一行是一个整数N,表示测试实例的个数，然后是N 行数据，每行包含两个整数a和b(0&lt;a&lt;b&lt;50)。</p></blockquote><p>Output</p><blockquote><p>对于每个测试实例，请输出蜜蜂从蜂房a爬到蜂房b的可能路线数，每个实例的输出占一行。</p></blockquote><p>Sample Input</p><blockquote><p>2<br>1 2<br>3 6</p></blockquote><p>Sample Output</p><blockquote><p>1<br>3</p></blockquote><p>Problem solving:<br>状态转移方程<br>ans[i]=ans[i-1]+ans[i-2]</p><p>要到达一个蜂房，如果这个蜂房在第一排，只能从它左边的蜂房或者左下方的蜂房过来；如果这个蜂房在第二排，只能从它左边的蜂房或者左上方的蜂房过来。（摘自<a href="https://blog.csdn.net/Artprog/article/details/69832070" target="_blank" rel="noopener">csdn</a>）</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll ans[55];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,a,b;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">ans[1]=1,ans[2]=1,ans[3]=2;</span><br><span class="line">for(int i=4;i&lt;50;i++)</span><br><span class="line">ans[i]=ans[i-1]+ans[i-2];</span><br><span class="line">while(n--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">cout&lt;&lt;ans[b-a+1]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="超级楼梯"><a href="#超级楼梯" class="headerlink" title="超级楼梯"></a>超级楼梯</h3><p>Description:<br>有一楼梯共M级，刚开始时你在第一级，若每次只能跨上一级或二级，要走上第M级，共有多少种走法？<br>Input</p><blockquote><p>输入数据首先包含一个整数N，表示测试实例的个数，然后是N行数据，每行包含一个整数M（1&lt;=M&lt;=40）,表示楼梯的级数。</p></blockquote><p>Output</p><blockquote><p>对于每个测试实例，请输出不同走法的数量</p></blockquote><p>Sample Input</p><blockquote><p>2<br>2<br>3</p></blockquote><p>Sample Output</p><blockquote><p>1<br>2</p></blockquote><p>Problem solving:<br>每次能走一级台阶或者两级台阶。所以状态转移方程就是<br>ans[i]=ans[i-1]+ans[i-2]</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll ans[45];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">ans[1]=0;</span><br><span class="line">ans[2]=1;</span><br><span class="line">ans[3]=2;</span><br><span class="line">for(int i=4;i&lt;=40;i++)</span><br><span class="line">ans[i]=ans[i-1]+ans[i-2];</span><br><span class="line">int n,m;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">while(n--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;m;</span><br><span class="line">cout&lt;&lt;ans[m]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Tickets"><a href="#Tickets" class="headerlink" title="Tickets"></a>Tickets</h3><p>Description:<br>现在有n个人要买电影票，如果知道每个人单独买票花费的时间，还有和前一个人一起买花费的时间，问最少花多长时间可以全部买完票。<br>Input</p><blockquote><p>给出 N(1&lt;=N&lt;=10)，表示有N组样例 　　　　给出K (1&lt;=K&lt;=2000)，表示有K个人买票.. 　　　　给出K个数表示这个人单独买票会花的时间..保证每个数 (0s&lt;=Si&lt;=25s) 　　　　给出K-1个数，表示这个人和前面那个人一起买票会花的时间..保证每个数 (0s&lt;=Si&lt;=50s)</p></blockquote><p>Output</p><blockquote><p>对于每一组数据，你需要给出电影院售票结束的时间，售票开始的时间为 08:00:00 am. 时间格式为： HH:MM:SS am|pm. 具体看样例输出</p></blockquote><p>Sample Input</p><blockquote><p>2<br>2<br>20 25<br>40<br>1<br>8</p></blockquote><p>Sample Output</p><blockquote><p>08:00:40 am<br>08:00:08 am<br>Problem solving:<br>这道题也是只要找到状态转移方程就行。状态转移方程<br>ans[i]=min(ans[i-1]+s[i],ans[i-2]+d[i]);<br>s[i]是一个人单独买票用的时间，d[i]是两个人一起买票用的时间</p></blockquote><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=2005;</span><br><span class="line">int s[maxn],d[maxn],ans[maxn];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,k;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">while(n--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;k;</span><br><span class="line">for(int i=1;i&lt;=k;i++)cin&gt;&gt;s[i];</span><br><span class="line">for(int j=2;j&lt;=k;j++)cin&gt;&gt;d[j];</span><br><span class="line">ans[1]=s[1];</span><br><span class="line">for(int i=2;i&lt;=k;i++)</span><br><span class="line">&#123;</span><br><span class="line">ans[i]=min(ans[i-1]+s[i],ans[i-2]+d[i]);</span><br><span class="line">&#125;</span><br><span class="line">int time=ans[k];int h,m,s;</span><br><span class="line">h=time/3600;</span><br><span class="line">m=time%3600/60;</span><br><span class="line">s=time%3600%60;</span><br><span class="line">h+=8;</span><br><span class="line">if(h&lt;=12)</span><br><span class="line">printf(&quot;%02d:%02d:%02d am\n&quot;,h,m,s);</span><br><span class="line">else</span><br><span class="line">printf(&quot;%02d:%02d:%02d pm\n&quot;,h-12,m,s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="钱币兑换问题"><a href="#钱币兑换问题" class="headerlink" title="钱币兑换问题"></a>钱币兑换问题</h3><p>Description:<br>在一个国家仅有1分，2分，3分硬币，将钱N兑换成硬币有很多种兑法。请你编程序计算出共有多少种兑法。<br>Input</p><blockquote><p>每行只有一个正整数N，N小于32768。</p></blockquote><p>Output</p><blockquote><p>对应每个输入，输出兑换方法数。</p></blockquote><p>Sample Input</p><blockquote><p>2934<br>12553</p></blockquote><p>Sample Output</p><blockquote><p>718831<br>13137761</p></blockquote><p>Problem solving:<br>emm，这道题我之前在牛客上面遇见过一道类似的题。只不过那道题里面硬币的个数比这个多。直接套着板子写了、、、</p><p>这是个很基础的背包问题，怎么解释交给时间吧，等我理解了就把这个坑填上。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn=35000;</span><br><span class="line">ll ans[maxn];</span><br><span class="line">ll co[4]=&#123;1,2,3&#125;;</span><br><span class="line">ll solve(ll x)</span><br><span class="line">&#123;</span><br><span class="line">ans[0]=1;</span><br><span class="line">for(int i=0;i&lt;3;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=co[i];j&lt;=x;j++)</span><br><span class="line">&#123;</span><br><span class="line">ans[j]=(ans[j]+ans[j-co[i]]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return ans[x];</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">ll n;</span><br><span class="line">while(cin&gt;&gt;n)</span><br><span class="line">&#123;</span><br><span class="line">memset(ans,0,sizeof(ans));</span><br><span class="line">cout&lt;&lt;solve(n)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Ignatius-and-the-Princess-IV"><a href="#Ignatius-and-the-Princess-IV" class="headerlink" title="Ignatius and the Princess IV"></a>Ignatius and the Princess IV</h3><p>Description:<br>给你n个数字，请你找出出现至少(n+1)/2次的数字。<br>输入</p><blockquote><p>本题包含多组数据，请处理到EOF：<br>每组数据包含两行。<br>第一行一个数字N(1&lt;=N&lt;=999999) ，保证N为奇数。<br>第二行为N个用空格隔开的整数。</p></blockquote><p>输出</p><blockquote><p>对于每组数据，输出一行，表示要求找到的那个数</p></blockquote><p>样例输入</p><blockquote><p>5<br>1 3 2 3 3<br>11<br>1 1 1 1 1 5 5 5 5 5 5<br>7<br>1 1 1 1 1 1 1</p></blockquote><p>样例输出</p><blockquote><p>3<br>5<br>1</p></blockquote><p>Problem solving:<br>这道题没啥说的，找就完了，可以边输入边查找。<br>还有很多办法，比如说直接排序。还有dp的方法。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,flag[1000000];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(cin&gt;&gt;n)</span><br><span class="line">&#123;</span><br><span class="line">int ans,a;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a;</span><br><span class="line">flag[a]++;</span><br><span class="line">if(flag[a]&gt;=(n+1)/2)</span><br><span class="line">ans=a;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="最少拦截系统"><a href="#最少拦截系统" class="headerlink" title="最少拦截系统"></a>最少拦截系统</h3><p>Description:<br>某国为了防御敌国的导弹袭击,发展出一种导弹拦截系统.但是这种导弹拦截系统有一个缺陷:虽然它的第一发炮弹能够到达任意的高度,但是以后每一发炮弹都不能超过前一发的高度.某天,雷达捕捉到敌国的导弹来袭.由于该系统还在试用阶段,所以只有一套系统,因此有可能不能拦截所有的导弹.<br>怎么办呢?多搞几套系统呗!你说说倒蛮容易,成本呢?成本是个大问题啊.所以俺就到这里来求救了,请帮助计算一下最少需要多少套拦截系统.<br>Input</p><blockquote><p>输入若干组数据.每组数据包括:导弹总个数(正整数),导弹依此飞来的高度(雷达给出的高度数据是不大于30000的正整数,用空格分隔)</p></blockquote><p>Output</p><blockquote><p>对应每组数据输出拦截所有导弹最少要配备多少套这种导弹拦截系统.</p></blockquote><p>Sample Input</p><blockquote><p>8 389 207 155 300 299 170 158 65</p></blockquote><p>Sample Output</p><blockquote><p>2</p></blockquote><p>Problem solving:<br>这个题我一开始就没读懂。。。<br>以后每一发炮弹都不能超过前一发的高度，所以这个就是求最大上升子序列的长度。<br>给定排好序的一堆数列中，求其的LIS长度。它的LIS长度就是它非上升子序列的个数。<br>我比较喜欢用这种nlog(n)的写法</p><p>这道题还有一个坑点就是<br>如果此时一个数大于它前面那个数，那么拦截系统就要加一，但是并不代表前面那个系统就没用了。这样说比较抽象，举个栗子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100 60 80 20 50</span><br></pre></td></tr></table></figure></p><p>我们来看一下，一开始我们选择100，大于60，换成了60，然后我们遇到了80，此时就需要一个新的系统了，然后现在是80，我们接着往下看遇到了20，再换成20，然后遇到了50，现在的50是大于20没错，但是上一个变成60的系统还可以使用，所以答案是2.</p><p>也就是因为这个所以不可以直接查找遇见大于前面那个数的情况就加一，这也是这个LIS以及dp的巧妙之处！</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e5+10;</span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line">int a[maxn],dp[maxn],n;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int pos;</span><br><span class="line">while(cin&gt;&gt;pos)</span><br><span class="line">&#123;</span><br><span class="line">fill(dp,dp+pos,INF);</span><br><span class="line">for(int i=0;i&lt;pos;i++)cin&gt;&gt;a[i];</span><br><span class="line">for(int i=0;i&lt;pos;i++)</span><br><span class="line">&#123;</span><br><span class="line">*lower_bound(dp,dp+pos,a[i])=a[i];</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;lower_bound(dp,dp+pos,INF)-dp&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天讲了一点关于DP的知识和几道例题，据说这样就算是入门了。今天的题怎么说呢？亏是之前做过，要是之前没做过，还真不知道该怎么写。dp就是玄学？
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="Algorithm" scheme="https://cndrew.cn/blog/tags/Algorithm/"/>
    
      <category term="c/c++" scheme="https://cndrew.cn/blog/tags/c-c/"/>
    
      <category term="DP" scheme="https://cndrew.cn/blog/tags/DP/"/>
    
      <category term="HDU" scheme="https://cndrew.cn/blog/tags/HDU/"/>
    
      <category term="poj" scheme="https://cndrew.cn/blog/tags/poj/"/>
    
  </entry>
  
  <entry>
    <title>HPU Summer Day 12(河南理工大学暑期第十二天)</title>
    <link href="https://cndrew.cn/blog/2019/07/28/d12/"/>
    <id>https://cndrew.cn/blog/2019/07/28/d12/</id>
    <published>2019-07-28T11:30:22.600Z</published>
    <updated>2019-07-28T12:41:35.380Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天休息一天，但是经过了昨天的自闭，我还是选择了在机房坐了大半天，写了不少水题，记录一下几道给我很大感触的题。<a id="more"></a></p><h3 id="烤面包片"><a href="#烤面包片" class="headerlink" title="烤面包片"></a>烤面包片</h3><p>Description:<br>鸡尾酒最喜欢吃东北的烤面包片了。每次到东北地区的区域赛或者是秦皇岛的wannafly camp，鸡尾酒都会吃很多的烤面包片，即使比赛打铁也觉得不枉此行。</p><p>“我想吃烤面包片！！！”这不，半年没吃烤面包片的鸡尾酒看到大家都聚集在秦皇岛参加暑假camp，羡慕地发出了想要的声音。</p><p>当鸡尾酒“想要”的时候，他说的话会带三个感叹号来表示非常“想要”。至于有多“想要”，他给了你一个算式让你来体会。</p><p>给你两个整数 nn 和 modmod，输出 n!!!n!!! 对 modmod 求余的结果（每个!! 都代表一个阶乘符号）</p><p>输入描述</p><blockquote><p>输入共一行包含两个整数依序为 n 和 mod，意义如题面所示。（0≤n≤1e9，1≤mod≤1e9）</p></blockquote><p>输出描述</p><blockquote><p>输出一个小于 mod的非负整数表示答案。</p></blockquote><p>样例输入 1</p><blockquote><p>2 6324</p></blockquote><p>样例输出 1</p><blockquote><p>2</p></blockquote><p>样例输入 2</p><blockquote><p>3 999999999</p></blockquote><p>样例输出 2</p><blockquote><p>731393874</p></blockquote><p>提示</p><blockquote><p>在第一个样例中，由于 2! = 22!=2，所以 2!!! = (((2!)!)!) = ((2!)!) = (2!) = 22!!!=(((2!)!)!)=((2!)!)=(2!)=2。2模了6324还是2！所以答案为2。</p></blockquote><p>Problem solving:<br>这道题一看就吓着我了，阶乘的阶乘的阶乘，这个数可以很大的。我已开始甚至想到了大数打表，但是那样的话时间复杂度也很不乐观，可是这道题过的人还那么多。</p><p>在我的师父——著名acmer——cc的讲解下我知道了这道题的解法。</p><p>如果n是1，或者是2，那么他们阶乘的阶乘就是本身。可以直接输出它本身对mod取模。n是0的情况跟n为1是一样的，因为0的阶乘是1嘛。<br>如果n是3，按照题目中的方式计算即可。<br>如果n&gt;=4,就会出现一个很nb的现象，4!!!是大于1e9很多的，也就是说此时的答案为0.为什么为0呢，因为n大于1e9，mod最大才是1e9，n的阶乘算的过程中一定会乘到一个跟mod相等的数，相等的数取模为0,0乘任何数都为0，所以答案是0.</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll n,mod,nn=720;</span><br><span class="line">ll solve()</span><br><span class="line">&#123;</span><br><span class="line">  if(n==0||n==1)return 1%mod;</span><br><span class="line">  if(n==2)return 2%mod;</span><br><span class="line">  if(n&gt;3)return 0;</span><br><span class="line">ll mid=1;</span><br><span class="line">for(ll i=1;i&lt;=nn;i++)</span><br><span class="line">&#123;</span><br><span class="line">mid*=i;</span><br><span class="line">mid%=mod;</span><br><span class="line">&#125;</span><br><span class="line">return mid;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;mod;</span><br><span class="line">n=solve();</span><br><span class="line">cout&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="幂次方"><a href="#幂次方" class="headerlink" title="幂次方"></a>幂次方</h3><p>Description:<br>任何一个正整数都可以用2的幂次方表示。例如：<br>137=2^7+2^3+2^0<br>同时约定方次用括号来表示，即ab可表示为a（b）。<br>由此可知，137可表示为：<br>2（7）+2（3）+2（0）<br>进一步：7=2^2+2+2^0（2^1用2表示）<br>3=2+2^0<br>所以最后137可表示为：<br>2（2（2）+2+2（0））+2（2+2（0））+2（0）<br>又如：<br>1315=2^10+2^8+2^5+2+1<br>所以1315最后可表示为：<br>2（2（2+2（0））+2）+2（2（2+2（0）））+2（2（2）+2（0））+2+2（0）</p><p>输入描述:</p><blockquote><p>正整数（n ≤ 20000）</p></blockquote><p>输出描述:</p><blockquote><p>符合约定的n的0，2表示（在表示中不能有空格）</p></blockquote><p>示例1<br>输入</p><blockquote><p>1315</p></blockquote><p>输出</p><blockquote><p>2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)</p></blockquote><p>Problem solving:<br>一开始想着用二进制形式表示，然后通过一些特殊的手段一直找1的位置，可以用bitset来实现，可是没写出来，希望如果有大佬会写的话教一下我，感激不尽。</p><p>然后我去百度了一下这道题，就被这道题巧妙地思路给震撼到了。通过递归实现。<br>思路大概就是先找到小于当前数的最大的2的次方数，然后查找下一个2的次方数，这道题用到了递归，就会很抽象一项（像某fs一样令人脱发。不太好理解，多看看代码吧。<br>说实话我也没很懂，啧啧啧</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void solve(int n)</span><br><span class="line">&#123;</span><br><span class="line">if(n&gt;4)</span><br><span class="line">&#123;</span><br><span class="line">int t=1;</span><br><span class="line">while(pow(2,t)&lt;=n)t++;</span><br><span class="line">cout&lt;&lt;&quot;2(&quot;;</span><br><span class="line">solve(t-1);</span><br><span class="line">cout&lt;&lt;&quot;)&quot;;</span><br><span class="line">if(n!=pow(2,t-1))cout&lt;&lt;&quot;+&quot;;</span><br><span class="line">solve(n-pow(2,t-1));</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">switch(n)</span><br><span class="line">&#123;</span><br><span class="line">case 0:return ;</span><br><span class="line">case 1:cout&lt;&lt;&quot;2(0)&quot;; break;</span><br><span class="line">case 2:cout&lt;&lt;&quot;2&quot;; break;</span><br><span class="line">case 3:cout&lt;&lt;&quot;2+2(0)&quot;;break;</span><br><span class="line">case 4:cout&lt;&lt;&quot;2(2)&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">solve(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天休息一天，但是经过了昨天的自闭，我还是选择了在机房坐了大半天，写了不少水题，记录一下几道给我很大感触的题。
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="c/c++" scheme="https://cndrew.cn/blog/tags/c-c/"/>
    
      <category term="nowcoder" scheme="https://cndrew.cn/blog/tags/nowcoder/"/>
    
      <category term="Thinking " scheme="https://cndrew.cn/blog/tags/Thinking/"/>
    
      <category term="comet oj" scheme="https://cndrew.cn/blog/tags/comet-oj/"/>
    
  </entry>
  
  <entry>
    <title>河南理工大学算法协会暑期集训积分赛（二）</title>
    <link href="https://cndrew.cn/blog/2019/07/27/jifen2/"/>
    <id>https://cndrew.cn/blog/2019/07/27/jifen2/</id>
    <published>2019-07-27T14:39:20.785Z</published>
    <updated>2019-07-28T12:32:09.853Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>积分赛，被打爆的积分赛（music<a id="more"></a></p><p>欢迎访问我校oj：<a href="https://hpuoj.com/" target="_blank" rel="noopener">hpuoj</a><br>本场积分赛传送门: <a href="https://hpuoj.com/contest/23/" target="_blank" rel="noopener">Uncle_drew is so handsome</a></p><h3 id="再战斐波那契"><a href="#再战斐波那契" class="headerlink" title="再战斐波那契"></a>再战斐波那契</h3><p>Description:<br>小z 学会了斐波那契和 gcd 后，老师又给他出了个难题，求第N个和第M个斐波那契数的最大公约数，这可难倒了小z ，不过在小z 的再三请求下，老师又告诉他了个条件，gcd(N,M)∈[1,90]。<br>可是，笨拙的小z 还是不会，于是请求你帮他解答这个问题。</p><p>已知:<br><img src="https://i.loli.net/2019/07/27/5d3c2bc9c780064614.png" alt></p><p>输入格式<br>输入包括 T 组，T∈[1,10].<br>接下来 T 行,每行两个整数 N,M, 表示斐波那契的第 N 项和第 M 项，(N,M∈[1,1e18]).</p><p>输出格式<br>输出包含 T 行,每行输出一个整数.</p><p>样例<br>input</p><blockquote><p>3<br>1 2<br>2 3<br>3 4</p></blockquote><p>output</p><blockquote><p>1<br>1<br>1</p></blockquote><p>Problem solving:<br>神tm签到题。。。<br>这道题主要是有个规律斐波那契数列第M项和第N项的gcd就是斐波那契数列第gcd（m,n）项的值。即：<br>gcd(f(m),f(n)) = f(gcd(m,n))<br>顺便记一下<br>long long可以存到大概第92项斐波那契数，unsigned一下会再多一项。Ps：我之前一直以为50项就爆long long了。。。如果知道这个92，那猜这个规律应该就挺简单了吧。<br>而我是跑了N个循环找到的当时并不确定的规律。。。</p><p>Code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">unsigned long long a[100],x,y;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">a[0]=0,a[1]=1;</span><br><span class="line">for(int i=2;i&lt;=100;i++)</span><br><span class="line">&#123;a[i]=a[i-1]+a[i-2];</span><br><span class="line">&#125;</span><br><span class="line">int t;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">cout&lt;&lt;a[__gcd(x,y)]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="恐怖的怪物"><a href="#恐怖的怪物" class="headerlink" title="恐怖的怪物"></a>恐怖的怪物</h3><p>Description:<br>一天早上，Dicer一觉醒来，发现自己来到了MineCraft的世界里面，身为MineCraft游戏爱好者的他欣喜不已，于是他在地下挖了一片长方体的空间作为秘密基地，可是他发现光照亮度小于等于7时，会有恐怖的怪物出现，并且他通过查阅资料发现光源方块产生光照每一米（方格）衰减1光照等级。</p><p>此规律在坐标轴的3个方向上（东西、南北、上下）均成立。换句话来说，对角线方向的光照衰减依照“曼哈顿距离”（两个点在坐标系上的绝对轴距总和）计算。这意味着，假如地上插着一支火把（光照等级14），则在水平面上与火把相邻的4个方向的方格上光照等级均为13，而在水平面上与火把对角的4个方格上光照等级均为12（譬如，西北方格的光照等级为14-向西1级-向北1级）。</p><p>上述这种衰减特性会在光源周围产生菱形的照明。该效果会在光源周围的光源扩散呈钻石状。如果被不透明方块阻挡，光照也可以沿着复杂而弯曲的路径扩散。</p><p>如下图所示，红色为光源（亮度等级为14）,黑色为秘密物品，其余各个位置光照强度如图所示。<br><img src="https://i.loli.net/2019/07/27/5d3c2c66da7fa16367.png" alt></p><p>秘密基地为N∗M的空间，不考虑高度，初始地面光照强度为0。为了不生成恐怖的怪物，Dicer布置了一些光源，但他不知道是否仍会生成怪物，现在请你帮助Dicer判断。</p><p>注：光源及秘密物品均为不透明方块，且其上方均不会生成怪物。</p><p>输入格式<br>第一行是一个T。（1≤T≤100）<br>接下来有T组数据，每一组第一行是N,M,（1≤N,M≤1000）,接下来有N行，每行M个字符，代表秘密基地地面放置的方块，0代表空气，#代表秘密物品，Y代表萤石(光照等级为15)，H代表火把(光照等级为14)，F代表附魔台(光照等级为12)，R代表激活的红石火把(光照等级为7)。</p><p>输出格式<br>输出包含T行，每行如果仍会生成怪物，输出”Yes”,否则输出”No”。</p><p>样例<br>input</p><blockquote><p>2<br>2 3<br>0Y0<br>00#<br>3 4<br>R00#<br>00R0<br>0R00</p></blockquote><p>output</p><blockquote><p>No<br>Yes</p></blockquote><p>input</p><blockquote><p>2<br>1 5<br>0Y0R0<br>2 4<br>Y#0R<br>0000</p></blockquote><p>output</p><blockquote><p>Yes<br>No</p></blockquote><p>input</p><blockquote><p>1<br>5 4<br>Y0F0<br>0000<br>0000<br>0000<br>0000</p></blockquote><p>output</p><blockquote><p>No</p></blockquote><p>Problem solving:<br>简单？的bfs问题。就是条件有点多。。。比赛的时候写炸了</p><p>这道题给了5s，按理说只要查找写的对，就不会超时。我想了一下我的方法，应该是里面出现了死循环，咳咳。</p><p>这道题的难点就是每个点的亮度有可能源于两个点，而你肯定要取最大值。但是怎么取？我一开始直接用了max，然后就是一直tle，因为这样会出现死循环的情况，就是满足不了return的情况。后来看了学长的代码，吃了一惊，原来还可以这样写。</p><p>开三个队列，分别存储出现Y，H，F的位置。然后从存着Y的队列开始进行bfs，如果当前亮度是到了14，就把装有H的队列中的元素放入第一个队列继续bfs，12也是同理。这一点还挺好理解的。这样操作的话，每个点自然就是可以达到尽可能大的亮度。最后在判断有没有小于等于7的空地存在即可。</p><p>在今天之前我还一直以为我的bfs挺不错的。现在我觉得我连mc的资深玩家都不配当了。<br>Code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn=1010;</span><br><span class="line">int t,n,m,l[maxn][maxn];</span><br><span class="line">char s[maxn][maxn];</span><br><span class="line">int d[4][2]=&#123;1,0,0,1,-1,0,0,-1&#125;;</span><br><span class="line">struct node&#123;</span><br><span class="line">int x,y;</span><br><span class="line">&#125;;</span><br><span class="line">queue&lt;node&gt; wo,yao,meizi;</span><br><span class="line">bool bfs()</span><br><span class="line">&#123;</span><br><span class="line">while(!wo.empty())</span><br><span class="line">&#123;</span><br><span class="line">int x=wo.front().x;</span><br><span class="line">int y=wo.front().y;</span><br><span class="line">wo.pop();</span><br><span class="line">if(l[x][y]==8)break;</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">int dx=x+d[i][0];</span><br><span class="line">int dy=y+d[i][1];</span><br><span class="line">if(dx&lt;0||dx&gt;=n||dy&lt;0||dy&gt;=m||s[dx][dy]!=&apos;0&apos;||l[dx][dy])</span><br><span class="line">continue;</span><br><span class="line">l[dx][dy]=l[x][y]-1;</span><br><span class="line">wo.push(&#123;dx,dy&#125;);</span><br><span class="line">while(l[dx][dy]==14&amp;&amp;(!yao.empty()))</span><br><span class="line">&#123;</span><br><span class="line">wo.push(yao.front());</span><br><span class="line">yao.pop();</span><br><span class="line">&#125;</span><br><span class="line">while(l[dx][dy]==12&amp;&amp;(!meizi.empty()))</span><br><span class="line">&#123;</span><br><span class="line">wo.push(meizi.front());</span><br><span class="line">meizi.pop();</span><br><span class="line">&#125;</span><br><span class="line">//cout&lt;&lt;l[dx][dy]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">for(int j=0;j&lt;m;j++)</span><br><span class="line">if(l[i][j]&lt;=7&amp;&amp;s[i][j]==&apos;0&apos;)return 0;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">while(!wo.empty())wo.pop();</span><br><span class="line">while(!yao.empty())yao.pop();</span><br><span class="line">while(!meizi.empty())meizi.pop();</span><br><span class="line">memset(l,0,sizeof(l));</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;m;j++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;s[i][j];</span><br><span class="line">if(s[i][j]==&apos;Y&apos;)wo.push(&#123;i,j&#125;),l[i][j]=15;</span><br><span class="line">if(s[i][j]==&apos;H&apos;)yao.push(&#123;i,j&#125;),l[i][j]=14;</span><br><span class="line">if(s[i][j]==&apos;F&apos;)meizi.push(&#123;i,j&#125;),l[i][j]=12;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(bfs())puts(&quot;No&quot;);</span><br><span class="line">elseputs(&quot;Yes&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="连连看"><a href="#连连看" class="headerlink" title="连连看"></a>连连看</h3><p>Description:<br>众所周知，《连连看》是一个老少皆宜的游戏。<br>《连连看》是由黄兴武创作的一款PC端益智类游戏，只要将相同的两张牌用三根以内的线段连在一起就可以消除，规则简单容易上手。</p><p>现在呢，Boctorio学长突然想玩连连看了，但不是单纯的玩游戏，他想自己出一局连连看。<br>由于Boctorio学长是一个蒟蒻，他不知道自己出的连连看是否符合能够通过多次操作将其全部消除，所以想要你帮他检查一下他出的连连看是否符合规则。</p><p>输入格式<br>第一行输入个T,表示T组数据（1≤t≤100）<br>每组数据第一行两个数 n,m ,表示连连看棋盘的长和宽（1≤n,m≤100）<br>接下来 n 行，每行输入 m 个正整数aij，表示 m 个棋子 (1≤aij≤n∗m)。</p><p>每种棋子只会出现一对，因此数据保证只有一种有效结果。</p><p>输出格式<br>每组数据输出一行。<br>如果棋盘符合规定，输出”Yes”，否则，输出”No”（不包括引号）。</p><p>样例<br>input</p><blockquote><p>3<br>2 2<br>1 2<br>2 1<br>3 4<br>1 6 2 3<br>4 5 3 1<br>4 2 6 5<br>4 4<br>1 2 3 6<br>8 4 7 8<br>5 6 5 7<br>1 2 3 4</p></blockquote><p>output</p><blockquote><p>No<br>No<br>Yes</p></blockquote><p>Problem solving:<br>暂无(毫无思路题)</p><p>Code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *　　　　　　　　┏┓　　 　┏┓</span><br><span class="line"> * 　　　　　　　┏┛┗━━━━━━━┛┗━━━┓</span><br><span class="line"> * 　　　　　　　┃　　　　　　　┃ 　</span><br><span class="line"> * 　　　　　　　┃　　　━　　 　┃</span><br><span class="line"> * 　　　　　　　┃　＞　　　＜　┃</span><br><span class="line"> * 　　　　　　　┃　　　　　　　┃</span><br><span class="line"> * 　　　　　　　┃...　⌒　... 　┃</span><br><span class="line"> * 　　　　　　　┃　　　　　　　┃</span><br><span class="line"> * 　　　　　　　┗━┓　　　┏━┛</span><br><span class="line"> * 　　　　　　　　　┃　　　┃　Code is far away from bug with the animal protecting　　　　　　　　　　</span><br><span class="line"> * 　　　　　　　　　┃　　　┃   神兽保佑,代码无bug</span><br><span class="line"> * 　　　　　　　　　┃　　　┃　　　　　　　　　　　</span><br><span class="line"> * 　　　　　　　　　┃　　　┃  　　　　　　</span><br><span class="line"> * 　　　　　　　　　┃　　　┃</span><br><span class="line"> * 　　　　　　　　　┃　　　┃　　　　　　　　　　　</span><br><span class="line"> * 　　　　　　　　　┃　　　┗━━━┓</span><br><span class="line"> * 　　　　　　　　　┃　　　　　　　┣┓</span><br><span class="line"> * 　　　　　　　　　┃　　　　　　　┏┛</span><br><span class="line"> * 　　　　　　　　　┗┓┓┏━┳┓┏┛</span><br><span class="line"> * 　　　　　　　　　　┃┫┫　┃┫┫</span><br><span class="line"> * 　　　　　　　　　　┗┻┛　┗┻┛</span><br><span class="line"> */</span><br><span class="line">// warm heart, wagging tail,and a smile just for you!</span><br><span class="line">//</span><br><span class="line">//                            _ooOoo_</span><br><span class="line">//                           o8888888o</span><br><span class="line">//                           88&quot; . &quot;88</span><br><span class="line">//                           (| -_- |)</span><br><span class="line">//                           O\  =  /O</span><br><span class="line">//                        ____/`---&apos;\____</span><br><span class="line">//                      .&apos;  \|     |//  `.</span><br><span class="line">//                     /  \|||  :  |||//  \</span><br><span class="line">//                    /  _||||| -:- |||||-  \</span><br><span class="line">//                    |   | \\  -  /// |   |</span><br><span class="line">//                    | \_|  &apos;&apos;\---/&apos;&apos;  |   |</span><br><span class="line">//                    \  .-\__  `-`  ___/-. /</span><br><span class="line">//                  ___`. .&apos;  /--.--\  `. . __</span><br><span class="line">//               .&quot;&quot; &apos;&lt;  `.___\_&lt;|&gt;_/___.&apos;  &gt;&apos;&quot;&quot;.</span><br><span class="line">//              | | :  `- \`.;`\ _ /`;.`/ - ` : | |</span><br><span class="line">//              \  \ `-.   \_ __\ /__ _/   .-` /  /</span><br><span class="line">//         ======`-.____`-.___\_____/___.-`____.-&apos;======</span><br><span class="line">//                            `=---=&apos;</span><br><span class="line">//        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class="line">//</span><br></pre></td></tr></table></figure></p><h3 id="Points-in-rectangle"><a href="#Points-in-rectangle" class="headerlink" title="Points in rectangle"></a>Points in rectangle</h3><p>Description:<br>在二维平面中有一个矩形，它的四个坐标点分别为(0,a),(a,0),(n,n−a),(n−a,n)。你现在有m个点，现在你想知道有多少个点是在这个矩形内的(边上的也算)。</p><p>输入格式<br>第一行输入n,a(1≤a\&lt;n≤1e3)。<br>第二行一个正整数m(1≤m≤1e3),代表你拥有的点的个数，接下来m行，每行一个点的坐标xi,yi(1≤xi,yi≤1e3)。</p><p>输出格式<br>第一行输出在矩形内的点的个数，然后输出在矩形内点的坐标，横坐标大的优先，如果横坐标相同，则纵坐标大的优先。如果没有，输出−1。</p><p>样例<br>input</p><blockquote><p>6 1<br>5<br>1 2<br>1 3<br>2 3<br>3 4<br>4 5</p></blockquote><p>output</p><blockquote><p>4<br>4 5<br>3 4<br>2 3<br>1 2</p></blockquote><p>Problem solving:<br>也算是一道签到了吧，就是不太好想，不画一下的话。<br>我的思路是把四条边的表达式写出来，对每个输入的x找出y的边界值然后进行比较。</p><p>如图所示，将图分为三部分，然后我们可以这样判断<br>1.如果x，y中有一个大于n的，就说明这个点不会在矩形中<br>2.x\&lt;a的时候，根据x的值求出直线表达式y1,y2所对应的值，此时y1的值就是下界，y2的值就是上界，如果y在y1和y2中间就说明这个点在矩阵中。<br>3.x&gt;n-a的时候，跟上面一样不过此时上下界对应的值是y2和y4<br>4.x&gt;a &amp;&amp; x\&lt;n-a的时候，上下界对应的值是y3和y4</p><p>关于y1，y2,y3,y4的表达式<br>本题中这个还是很好求得的<br>y1=-x+a                y2=x+a<br>y3=-x+2*n-a            y4=x-a</p><p><img src="https://i.loli.net/2019/07/27/5d3c08180ef1c91534.png" alt></p><p>判断完用结构体排一下序输出即可。</p><p>Code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">int x,y;</span><br><span class="line">&#125;p[1005];</span><br><span class="line">bool cmp(node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">if(a.x==b.x)return a.y&gt;b.y;</span><br><span class="line">return a.x&gt;b.x;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,a,m,x,y,pos=0;</span><br><span class="line">double s,k,sx,sy;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;a&gt;&gt;m;</span><br><span class="line">for(int i=0;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">if(x&gt;n||y&gt;n)continue;</span><br><span class="line">if(x&gt;=a&amp;&amp;x&lt;=n-a)</span><br><span class="line">&#123;</span><br><span class="line">if(y&gt;x+a||y&lt;x-a)continue;</span><br><span class="line">&#125;</span><br><span class="line">if(x&lt;a)</span><br><span class="line">&#123;</span><br><span class="line">if(y&gt;x+a||y&lt;-x+a)continue;</span><br><span class="line">&#125;</span><br><span class="line">if(x&gt;n-a)</span><br><span class="line">&#123;</span><br><span class="line">if(y&lt;x-a||y&gt;-x+2*n-a)continue;</span><br><span class="line">&#125;</span><br><span class="line">p[pos].x=x,p[pos].y=y;</span><br><span class="line">pos++;</span><br><span class="line">&#125;</span><br><span class="line">if(pos==0)</span><br><span class="line">puts(&quot;-1&quot;);</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;pos&lt;&lt;endl;</span><br><span class="line">sort(p,p+pos,cmp);</span><br><span class="line">for(int i=0;i&lt;pos;i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;p[i].x&lt;&lt;&apos; &apos;&lt;&lt;p[i].y&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Numbers-of-interval"><a href="#Numbers-of-interval" class="headerlink" title="Numbers of interval"></a>Numbers of interval</h3><p>Description:<br><img src="https://i.loli.net/2019/07/27/5d3c2d6a4a45986514.png" alt></p><p>输入格式<br>第一行输入n,k(1≤n,k≤1e6).<br>接下来输入n个数，第i个数为ai(1≤ai≤1e3).</p><p>输出格式<br>输出满足条件的区间个数</p><p>样例<br>input<br>3 5<br>2 3 5<br>output<br>4</p><p>Problem solving:<br>这道题做出来的人很多，我忘了lower_bound，用一个前缀和数组就行了。注意这道题的ans会爆int。<br>这道题看了学长的题解和标程之后觉得自己明白的很透彻。然后跟一个同学交流这道题的时候发现自己也是没那么明白。不过现在还是很透彻的，记录一下。</p><p>主要需要理解的就是在你构造的前缀和数组中第n项到第m项的和为<br>sum[m]-sum[n-1](注意是n-1，如果是n的话，那表示的就是第n+1项到第m项的和，因为你会把a[n]也减掉。</p><p>现在我们要查找区间和大于等于k的区间个数，因为是前缀和数组，所以构造出来的前缀和数组一定是有序的（升序。如果直接O(n*n)，1e6的数据范围肯定会超时。又正好看到数组是有序的，这时候就<del>~很自然</del>~的想到二分(虽然我并没有想到)。区间和大于等于k即a[m]-a[n-1]&gt;=k,所以我们先确定区间的左端点，然后二分查找到第一个使区间和大于等于k的右端点的值，此时我们找到的这个右端点的右面的每一个端点都可以跟那个确定的左端点组成一个区间和大于等于k的区间，查找所有点为左端点的情况，答案累加即可。<br>唯一有点绕的就是sum[n]-sum[m-1]&gt;=k换成了sum[m-1]+k&lt;=sum[n]<br>查找第一个符合要求的右端点可以这样写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lower_bound(sum+1,sum+n+1,k+a[i-1])-sum</span><br></pre></td></tr></table></figure></p><p>Code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[1000050],p[1000050];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,k;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">cin&gt;&gt;a[i],p[i]=p[i-1]+a[i];</span><br><span class="line">long long ans=0;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">int mid=lower_bound(p+1,p+1+n,p[i-1]+k)-p;</span><br><span class="line">ans+=(n-mid+1);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="剪纸"><a href="#剪纸" class="headerlink" title="剪纸"></a>剪纸</h3><p>Description:<br>中国剪纸是一种用剪刀或刻刀在纸上剪刻花纹，用于装点生活或配合其他民俗活动的民间艺术。在中国，剪纸具有广泛的群众基础，交融于各族人民的社会生活，是各种民俗活动的重要组成部分。其传承赓续的视觉形象和造型格式，蕴涵了丰富的文化历史信息，表达了广大民众的社会认以、道德观念、实践经验、生活理想和审美情趣，具有认知、教化、表意、抒情、娱乐、交往等多重社会价值。<br>2006年5月20日，剪纸艺术遗产经国务院批准列入第一批国家级非物质文化遗产名录 。2009年9月28日至10月2日举行的联合国教科文组织保护非物质文化遗产政府间委员会第四次会议上，中国申报的中国剪纸项目入选“人类非物质文化遗产代表作名录”。</p><p>剪窗花最基本的操作为将剪纸进行多次对折，然后对对折之后的纸进行裁剪，展开后就是一个精美的艺术品。现在我们对问题进行化简，我们利用如下方法将一张形状矩形的纸按照对阵轴进行对折：<br><img src="https://i.loli.net/2019/07/27/5d3c2d9aaf68a63353.png" alt><br>假设剪后的形状为一个三角形，则展开效果为：<br><img src="https://i.loli.net/2019/07/27/5d3c2d9abf77369575.png" alt><br>现在给你一个对折两次且剪切后的图形，请你给出展开的图形形状。</p><p>输入格式<br>多组输入，处理到文件结束。<br>每组输入第一行两个数字n,m（1≤n,m≤100)。<br>接下来n行，每行m个字符，表示对折且剪切后的图形。<br>保证输入字符只包含 ‘.’ 和 ‘*’ 。</p><p>输出格式<br>输出展开后的图形。</p><p>样例<br>input<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">**.</span><br><span class="line">*..</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>output<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">..**..</span><br><span class="line">.****.</span><br><span class="line">.****.</span><br><span class="line">..**..</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p><p>Problem solving:<br>签到题，搞清楚每个点的关系就行。（这个我写的可能是有点麻烦了，可以去看一下下面学长的标程</p><p>Code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m;</span><br><span class="line">char a[405][405];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;m))</span><br><span class="line">&#123;</span><br><span class="line">for(int i=n;i&lt;2*n;i++)</span><br><span class="line">for(int j=m;j&lt;2*m;j++)</span><br><span class="line">cin&gt;&gt;a[i][j];</span><br><span class="line">for(int i=n;i&lt;2*n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;m;j++)</span><br><span class="line">&#123;</span><br><span class="line">a[i][j]=a[i][2*m-j-1];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;m;j++)</span><br><span class="line">&#123;</span><br><span class="line">a[i][j]=a[2*n-i-1][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=m;j&lt;2*m;j++)</span><br><span class="line">&#123;</span><br><span class="line">a[i][j]=a[2*n-i-1][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;2*n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;2*m;j++)</span><br><span class="line">cout&lt;&lt;a[i][j];</span><br><span class="line">puts(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Fake-hpuoj-predictor"><a href="#Fake-hpuoj-predictor" class="headerlink" title="Fake hpuoj predictor"></a>Fake hpuoj predictor</h3><p>Description:<br>总所周知，HPU(Harmonious and Peaceful University) Online Judge具有一个强大的的rating(积分)系统，它采用的是国际上权威的ELO等级分制度(ELO Rating System)，LOL，守望先锋,codeforces,topcoder等知名游戏的排行均是采用此制度。<br>具体算法为：<br><img src="https://i.loli.net/2019/07/27/5d3c2e526bf6194074.png" alt><br>其中R(A)和R(B)为选手A和B初始的rating，那么E(A)和E(B)即为这两者进行对战后A和B各自获胜的期望。<br>本场比赛的积分公式即为<br><img src="https://i.loli.net/2019/07/27/5d3c2e5283b8097230.png" alt><br>RA代表上轮比赛结束后的积分。<br>K为积分系数,对于不同等级的选手的K是不同的。<br>SA代表比赛实际总得分，对于每局比赛来说，每赢一个人就会加1分,输了不扣分。<br>EAi代表A与第i个选手比赛获胜的期望。<br>对于HPU Online Judge，用户等级表为:<br><img src="https://i.loli.net/2019/07/27/5d3c2e528ee2a45133.png" alt><br>codancer有一个成为Grand Master的梦想，已知他的初始rating为0，他总共参加了m场比赛，对于每场比赛有一个榜单，对于codancer来说，排在他前面的人都打败了他，排在他后面的人都输给了他，因此你可以通过和每个参加比赛的选手比较计算出总得分SA和总期望∑EAi。<br>那么最终codancer打完本场比赛后的rating为<br><img src="https://i.loli.net/2019/07/27/5d3c2e529b1f973133.png" alt><br>现在他打完了这m场比赛后他迫切的想知道自己的rating变为了多少(因为管理员太懒了，已经鸽了m场的rating计算了)，现在他想让你帮他写一个预测器来预测一下。</p><p>输入格式<br>单组输入，第一行输入一个m(1≤m≤100)，代表codancer参加的比赛的数量。<br>接下来对于每场比赛：<br>第一行输入一个整数n代表有n(1≤n≤100)个人参加的比赛。<br>接下来n行每行输入一个字符串和数字，代表参赛选手的用户名和他的rating，codancer即为他自己的用户名(用户名长度不超过20)，假如输入的名字为codancer,则不用输入数字(其他参赛选手的rating是不会更新的，因为管理员太懒了)。</p><p>输出格式<br>输出codancer最终的rating，向上取整。</p><p>样例<br>input</p><blockquote><p>3<br>5<br>tourist 2000<br>capryang 1900<br>boctorio 1800<br>dicer 1800<br>codancer<br>2<br>codancer<br>rookie 200<br>2<br>wzy 1500<br>codancer</p></blockquote><p>output</p><blockquote><p>12</p></blockquote><p>提示<br>每计算完一场都需要向上取整，建议参与运算的变量都使用double。</p><p>Problem solving:<br>这道题的难点就是读题。读懂了之后直接模拟就行了。<br>学长说：写了就能过。。。<br>然后我无限wa。最后借了学长的代码看了一下。也没发现有啥不一样的，可能就是精度问题吧。</p><p>Code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">double find(double x)</span><br><span class="line">&#123;</span><br><span class="line">if(x&lt;=1349)return 15;</span><br><span class="line">if(x&lt;=1499)return 20;</span><br><span class="line">if(x&lt;=1599)return 25;</span><br><span class="line">if(x&lt;=1699)return 30;</span><br><span class="line">if(x&lt;=1799)return 35;</span><br><span class="line">return 50;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">string s;</span><br><span class="line">double ra=0,rb;</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">double ea=0,sum=0;</span><br><span class="line">double k=find(ra),sa=0;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">if(s==&quot;codancer&quot;)</span><br><span class="line">&#123;</span><br><span class="line">sa=n-i;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">cin&gt;&gt;rb;</span><br><span class="line">ea=1.0/(1+pow(10,(rb-ra)/400));</span><br><span class="line">sum+=ea;</span><br><span class="line">&#125;</span><br><span class="line">ra=ceil(ra+k*(sa-sum));</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%.0lf\n&quot;,ra);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="花花与三猫Catlive"><a href="#花花与三猫Catlive" class="headerlink" title="花花与三猫Catlive"></a>花花与三猫Catlive</h3><p>Description:<br>“大佬”中分和“呆B”李白正在玩一个游戏，游戏规则是这样的：</p><ol><li>游戏刚开始的时候，中分和李白相距L步，相对而望。</li><li>老父亲和老母亲手中各有一个M个面的均匀骰子。（也就是说可以随机生成[1,m]内的任意一个数字，且概率均等）</li><li>在每个回合开始的时候，老父亲和老母亲都会掷一下手中的骰子。</li><li>当老父亲的骰子掷到1的时候，中分可以向李白走一步。</li><li>当老母亲的骰子掷到m的时候，李白可以向中分走一步。</li><li>当中分和李白相遇的时候，游戏结束。</li></ol><p>可是老父亲和老母亲刚刚拍完新节目，他们太累了，不想做这个游戏，但是他们还很想知道，这个游戏平均需要多少次才能结束。聪明的你，能告诉他们吗？</p><p>结果是一个实数s，可以证明s能被表示成一个分数 qp，请输出q⋅p−1，其中q−1表示q在模109+7意义下的逆元。</p><p>输入格式<br>第一行是一个正整数 T(1≤T≤1000)，表示测试样例的组数。<br>接下来T行，每行两个正整数L,M(1≤L,M≤1000)，含义如题面描述。</p><p>输出格式<br>输出包括T行，每行一个答案。</p><p>样例<br>input</p><blockquote><p>2<br>1 2<br>2 1</p></blockquote><p>output</p><blockquote><p>1<br>1</p></blockquote><p>提示<br>2在模109+7意义下的逆元是500000004<br>Problem solving:<br>这道题比赛的时候嫌题面太长我就没看。后来发现这就是一道水题。。。题意就是两个人的距离给出了是L，用一个m面的骰子掷一下，如果是1或者m，就会有人走一步，不用管是谁走，效果都是一样的。所以每次有人走一步的概率就是2/m，总共要走l步，让输出的就是l/（2/m），即l*m/2<br>表面上这道题还让你求逆元，实际上这里我们用到的只有2的逆元，而且还给出了2在模1e9+7意义下的逆元。所以，是个水题。以后这种看见题面太长就不想看的坏毛病必须得改一下了。</p><p>Code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">long long n,m;</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">cout&lt;&lt;n*m*500000004%1000000007&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Same-String"><a href="#Same-String" class="headerlink" title="Same String"></a>Same String</h3><p>Description:<br>有两个只由小写字母组成的长度为n的字符串s1,s2和m组字母对应关系，每一组关系由两个字母c1和c2组成，代表c1可以直接变成c2,你需要判断s1是否可以通过这m组关系转换为s2。</p><p>输入格式<br>第一行输入一个n(1≤n≤100)，代表字符串的长度。<br>第二行和第三行输入两个字符串s1,s2。<br>第四行输入一个m(1≤m≤325)，代表有m组关系。<br>接下来m行，第i行两个字符ui,vi,代表ui可以直接变为vi。</p><p>输出格式<br>如果s1可以通过这些m组关系转化变为s2，输出”YES”，否则输出”NO”。</p><p>样例<br>input</p><blockquote><p>6<br>aabbcc<br>cdbcad<br>4<br>a c<br>c a<br>a d<br>b c</p></blockquote><p>output</p><blockquote><p>YES</p></blockquote><p>提示<br>可以转换多次，比如a可以转换为b，而b可以转换为c，则a可以转换为c。<br>样例一：aabbcc-&gt;cabbcc-&gt;cdbbcc-&gt;cdbccc-&gt;cdbcac-&gt;cdbcaa-&gt;cdbcad<br>Problem solving:<br>这道题我是用存图做的，跟昨天专练里面的一道题很像，就不详细讲了。<br>这道题还有另一种算法，可以看下面学长的标程<br>Code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int mmp[50][50],vis[50];</span><br><span class="line">bool bfs(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">q.push(x);vis[x]=1;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">x=q.front();q.pop();</span><br><span class="line">if(x==y)return 1;</span><br><span class="line">for(int i=0;i&lt;=26;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(mmp[x][i]&amp;&amp;vis[i]==0)</span><br><span class="line">&#123;</span><br><span class="line">q.push(i);</span><br><span class="line">vis[i]=1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,m;string a,b;</span><br><span class="line">char c,d;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;a&gt;&gt;b&gt;&gt;m;</span><br><span class="line">for(int i=0;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;c&gt;&gt;d;</span><br><span class="line">int x=c-&apos;a&apos;,y=d-&apos;a&apos;;</span><br><span class="line">mmp[x][y]=1;</span><br><span class="line">&#125;</span><br><span class="line">int flag=0;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">if(bfs(a[i]-&apos;a&apos;,b[i]-&apos;a&apos;)==0)</span><br><span class="line">&#123;</span><br><span class="line">flag=1;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(flag)puts(&quot;NO&quot;);</span><br><span class="line">elseputs(&quot;YES&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="学长标程和题解"><a href="#学长标程和题解" class="headerlink" title="学长标程和题解"></a>学长标程和题解</h3><h4 id="再战斐波那契-1"><a href="#再战斐波那契-1" class="headerlink" title="再战斐波那契"></a>再战斐波那契</h4><p>Problem solving:<br>打表找规律会发现GCD(F(N),F(M))=F(GCD(N,M))</p><p>Code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long</span><br><span class="line">ll f[10000];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">ll n,m;</span><br><span class="line">f[1]=f[2]=1;</span><br><span class="line">for(int i=3;i&lt;=100;i++) f[i]=f[i-1]+f[i-2];</span><br><span class="line">int t;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">while(t--)&#123;</span><br><span class="line">scanf(&quot;%lld %lld&quot;,&amp;n,&amp;m);</span><br><span class="line">printf(&quot;%lld\n&quot;,f[__gcd(n,m)]);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="恐怖的怪物-1"><a href="#恐怖的怪物-1" class="headerlink" title="恐怖的怪物"></a>恐怖的怪物</h4><p>Problem solving:<br>对于每个有光源的点暴力的BFS<br>每次BFS 更新各点光源的最大值<br>不透明方块不需要更新</p><p>Code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long</span><br><span class="line">#define pii pair&lt;int,int&gt;</span><br><span class="line">const int inf=0x3f3f3f3f;</span><br><span class="line">const ll INF=0x3f3f3f3f3f3f3f3f;</span><br><span class="line">const int maxn=1000+10;</span><br><span class="line"></span><br><span class="line">int t,n,m;</span><br><span class="line">char mp[maxn][maxn];</span><br><span class="line">int vis[maxn][maxn];</span><br><span class="line">int d[4][2]=&#123;1,0,-1,0,0,1,0,-1&#125;;</span><br><span class="line">queue&lt;pii&gt;H,F;</span><br><span class="line">queue&lt;pii&gt;que;</span><br><span class="line">void init()&#123;</span><br><span class="line">while(!que.empty()) que.pop();</span><br><span class="line">while(!H.empty()) H.pop();</span><br><span class="line">while(!F.empty()) F.pop();</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">for(int j=1;j&lt;=m;j++)</span><br><span class="line">vis[i][j]=0;</span><br><span class="line">&#125;</span><br><span class="line">bool BFS()&#123;</span><br><span class="line">while(!que.empty())&#123;</span><br><span class="line">int x=que.front().first;</span><br><span class="line">int y=que.front().second;</span><br><span class="line">que.pop();</span><br><span class="line">if(vis[x][y]==8) break;</span><br><span class="line">for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">int xx=x+d[i][0];</span><br><span class="line">int yy=y+d[i][1];</span><br><span class="line">if(xx&lt;=0 || xx&gt;n || yy&lt;=0 || yy&gt;m || vis[xx][yy] || mp[xx][yy]!=&apos;0&apos;) continue;</span><br><span class="line">vis[xx][yy]=vis[x][y]-1;</span><br><span class="line">que.push(pii(xx,yy));</span><br><span class="line">while(vis[xx][yy]==14 &amp;&amp; (!H.empty()))&#123;</span><br><span class="line">que.push(H.front());</span><br><span class="line">H.pop();</span><br><span class="line">&#125;</span><br><span class="line">while(vis[xx][yy]==12 &amp;&amp; (!F.empty()))&#123;</span><br><span class="line">que.push(F.front());</span><br><span class="line">F.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">for(int j=1;j&lt;=m;j++)</span><br><span class="line">if(vis[i][j]&lt;=7 &amp;&amp; mp[i][j]==&apos;0&apos;) return false;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">while(t--)&#123;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;n,&amp;m);</span><br><span class="line">init();</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">scanf(&quot;%s&quot;,mp[i]+1);</span><br><span class="line">for(int j=1;j&lt;=m;j++)&#123;</span><br><span class="line">if(mp[i][j]==&apos;Y&apos;) que.push(pii(i,j)),vis[i][j]=15 ;//15</span><br><span class="line">if(mp[i][j]==&apos;H&apos;) H.push(pii(i,j)),vis[i][j]=14;//14</span><br><span class="line">if(mp[i][j]==&apos;F&apos;) F.push(pii(i,j)),vis[i][j]=12;//12</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(BFS()) printf(&quot;No\n&quot;);</span><br><span class="line">else printf(&quot;Yes\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="连连看-1"><a href="#连连看-1" class="headerlink" title="连连看"></a>连连看</h4><p>Problem solving:<br>dfs 瞎胡找即可，保存上一步的位置，上一步的方向，上一<br>步为止的拐角数，然后处理一些复杂的情况可。<br>由于只有三个条直线，只能拐两个弯，dfs 能够剪枝至很低<br>的复杂度，标程大约为0.3s。<br>（由于年代久远，其实出题人也不太记得这个题是不是有什<br>么坑了。</p><p>Code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long</span><br><span class="line">int mp[200][200];</span><br><span class="line">int n,m;</span><br><span class="line">int sx,sy;</span><br><span class="line">int dir[4][2]=&#123;&#123;1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;;//分别对应下，右，左，上</span><br><span class="line">int check(int x,int y)&#123;</span><br><span class="line">if(x&lt;0 || x&gt;n+1 || y&lt;0 || y&gt;m+1)</span><br><span class="line">return 1;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool judge(int x,int y,int step,int pos)&#123;//pos表示上一步方向</span><br><span class="line">if(step&gt;3) return 0;//如果超过了三步，不符合规则</span><br><span class="line">if(mp[x][y]==mp[sx][sy] &amp;&amp; pos!=-1)&#123;//如果两个字符相等并且不是同一个（由于下面有方向限制，所以两个值不可能相等）</span><br><span class="line">mp[x][y]=0;//删去配对字符</span><br><span class="line">mp[sx][sy]=0;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">if(mp[x][y]!=0 &amp;&amp; pos!=-1) return 0;//如果不相等并且不是通路，不符合规则</span><br><span class="line">int i,x1,y1;</span><br><span class="line">for(i=0;i&lt;4;i++)&#123;</span><br><span class="line">if(i+pos==3) continue;//不能有正相反的方向 (0.下 3.上)   (1.右 2.左)</span><br><span class="line">x1=x+dir[i][0];</span><br><span class="line">y1=y+dir[i][1];</span><br><span class="line">if(check(x1,y1)) continue;//检查是否越界</span><br><span class="line">if(judge(x1,y1,step+(pos==i?0:1),i))&#123;//找到一个就返回</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t,times,sum;</span><br><span class="line">int i,j;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">while(t--)&#123;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;n,&amp;m);</span><br><span class="line">memset(mp,0,sizeof(mp));</span><br><span class="line">for(i=1;i&lt;=n;i++)&#123;</span><br><span class="line">for(j=1;j&lt;=m;j++)&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;mp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sum=0;</span><br><span class="line">times=0;//times表示查找的次数，大于等于n*m相当于查找一遍还没有找到</span><br><span class="line">i=j=1;</span><br><span class="line">while(sum&lt;n*m &amp;&amp; times&lt;n*m)&#123;</span><br><span class="line">for(i=1;i&lt;=n;i++)&#123;</span><br><span class="line">for(j=1;j&lt;=m;j++)&#123;</span><br><span class="line">times++;</span><br><span class="line">sx=i,sy=j;</span><br><span class="line">if(mp[i][j]!=0 &amp;&amp; judge(i,j,0,-1))&#123;</span><br><span class="line">sum+=2;</span><br><span class="line">times=0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(sum==n*m)&#123;</span><br><span class="line">printf(&quot;Yes\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">printf(&quot;No\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Points-in-rectangle-1"><a href="#Points-in-rectangle-1" class="headerlink" title="Points in rectangle"></a>Points in rectangle</h4><p>Problem solving:<br>对于给定的矩形，求出四个边的直线方程<br>对于给定的点判断和四条直线的关系即可O(1) 的判断是否<br>在矩形内<br>统计完直接排序即可</p><p>Code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 2e3+100;</span><br><span class="line">struct point&#123;</span><br><span class="line">long long x,y;</span><br><span class="line">bool friend operator&lt;(point a,point b)&#123;</span><br><span class="line">if(a.x==b.x) return a.y&gt;b.y;</span><br><span class="line">return a.x&gt;b.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;p[N];</span><br><span class="line">long long n,a;</span><br><span class="line">bool check(point P)&#123;</span><br><span class="line">return -P.x+a&lt;=P.y&amp;&amp;-P.x+2*n-a&gt;=P.y&amp;&amp;P.x-a&lt;=P.y&amp;&amp;P.x+a&gt;=P.y;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">//freopen(&quot;17.in&quot;,&quot;r&quot;,stdin);</span><br><span class="line">//freopen(&quot;17.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">vector&lt;point&gt; re;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;a;</span><br><span class="line">int m;</span><br><span class="line">cin&gt;&gt;m;</span><br><span class="line">for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">if(check(p[i])) re.push_back(p[i]);</span><br><span class="line">&#125;</span><br><span class="line">sort(re.begin(),re.end());</span><br><span class="line">if(re.empty())&#123;</span><br><span class="line">cout&lt;&lt;-1&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">cout&lt;&lt;re.size()&lt;&lt;endl;</span><br><span class="line">for(auto v:re) cout&lt;&lt;v.x&lt;&lt;&apos; &apos;&lt;&lt;v.y&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Numbers-of-interval-1"><a href="#Numbers-of-interval-1" class="headerlink" title="Numbers of interval"></a>Numbers of interval</h4><p>Problem solving:<br>构造前缀和数组sum<br>枚举l 然后二分最小的r，那么r 及其右边的都满足条件<br>线性枚举即可, 复杂度O(nlog(n))</p><p>Code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e6+100;</span><br><span class="line">typedef long long ll;</span><br><span class="line">long long a[N],sum[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">int n,k;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i],sum[i]=sum[i-1]+a[i];</span><br><span class="line">long long ans=0;</span><br><span class="line">for(int l=1;l&lt;=n;l++)&#123;</span><br><span class="line">int id=lower_bound(sum+1,sum+n+1,k+sum[l-1])-sum;</span><br><span class="line">ans+=(n-id+1);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="剪纸-1"><a href="#剪纸-1" class="headerlink" title="剪纸"></a>剪纸</h4><p>Problem solving:<br>开一个二维数组构造即可</p><p>Code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1000+10;</span><br><span class="line">int n,m,a;</span><br><span class="line">char str[1000+10][1000+10];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;m))&#123;</span><br><span class="line">for(int i=n;i&lt;n*2;i++)&#123;</span><br><span class="line">scanf(&quot;%s&quot;,str[i]+m);</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">for(int j=0;j&lt;m;j++)&#123;</span><br><span class="line">str[i][j]=str[n*2-1-i][j]=str[i][m*2-1-j]=str[n*2-1-i][m*2-1-j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;n*2;i++)&#123;</span><br><span class="line">for(int j=0;j&lt;m*2;j++)&#123;</span><br><span class="line">printf(&quot;%c&quot;,str[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Fake-hpuoj-predictor-1"><a href="#Fake-hpuoj-predictor-1" class="headerlink" title="Fake hpuoj predictor"></a>Fake hpuoj predictor</h4><p>Problem solving:<br>暴力算出codancer 实际的得分和期望得分<br>根据他当前的rating 使用不同的K 更新rating<br>每次更新完rating 向上取整</p><p>Code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1000+10;</span><br><span class="line">int n,m,a;</span><br><span class="line">struct node&#123;</span><br><span class="line">char name[30];</span><br><span class="line">double rating;</span><br><span class="line">&#125;p[maxn];</span><br><span class="line">double cal(double rating)&#123;</span><br><span class="line">if(rating&lt;1350) return 15.0;</span><br><span class="line">else if(rating&lt;1500) return 20.0;</span><br><span class="line">else if(rating&lt;1600) return 25.0;</span><br><span class="line">else if(rating&lt;1700) return 30.0;</span><br><span class="line">else if(rating&lt;1800) return 35.0;</span><br><span class="line">else return 50.0;</span><br><span class="line">&#125;</span><br><span class="line">double Rating(double rating)&#123;</span><br><span class="line">double k=cal(rating);</span><br><span class="line">double ea=0,sa=0;</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">if(strcmp(p[i].name,&quot;codancer&quot;)==0) continue;</span><br><span class="line">ea+=1.0/(1.0+pow(10,(p[i].rating-rating)/400.0));</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">if(strcmp(p[i].name,&quot;codancer&quot;)==0)&#123;</span><br><span class="line">sa=n-1-i;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">double now_rating=rating+k*(sa-ea);</span><br><span class="line">//return now_rating;</span><br><span class="line">return ceil(now_rating);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int m;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">double codancerNB_rating=0.0;</span><br><span class="line">while(m--)&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">scanf(&quot;%s&quot;,p[i].name);</span><br><span class="line">if(strcmp(p[i].name,&quot;codancer&quot;)==0)&#123;</span><br><span class="line">p[i].rating=codancerNB_rating;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">scanf(&quot;%lf&quot;,&amp;p[i].rating);</span><br><span class="line">&#125;</span><br><span class="line">codancerNB_rating=Rating(codancerNB_rating);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%.0lf\n&quot;,ceil(codancerNB_rating));</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="花花与三猫Catlive-1"><a href="#花花与三猫Catlive-1" class="headerlink" title="花花与三猫Catlive"></a>花花与三猫Catlive</h4><p>Problem solving:<br>每次每只猫能够向前走一步的概率为2/M<br>答案即为L/（2/m）= LM/2</p><p>Code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">const int MOD = 1e9 + 7;</span><br><span class="line">int qpow(int a, int b, int mod)&#123;</span><br><span class="line">    int res = 1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1) res = 1LL * res * a % mod;</span><br><span class="line">        a = 1LL * a * a % mod;</span><br><span class="line">        b &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int inv(int p, int mod)&#123;</span><br><span class="line">    return qpow(p, mod - 2, mod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    int L, M;</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        scanf(&quot;%d %d&quot;, &amp;L, &amp;M);</span><br><span class="line">        printf(&quot;%lld\n&quot;, 1LL * L * M * 500000004 % MOD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Same-String-1"><a href="#Same-String-1" class="headerlink" title="Same String"></a>Same String</h4><p>Problem solving:<br>解法一: 对于m 组关系建好图，每次判断某个字母可否到达<br>另一个字母<br>解法二: 利用Warshall 可以O(263) 求出传递闭包然后O(1<br>的判断可达性</p><p>Code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e6+100;</span><br><span class="line">typedef long long ll;</span><br><span class="line">bool f[26][26];</span><br><span class="line">int main()&#123;</span><br><span class="line">// for(int it=1;it&lt;=40;it++)&#123;</span><br><span class="line">// memset(f,0,sizeof(f));</span><br><span class="line">// Create_InFiles(it);</span><br><span class="line">// Create_OutFiles(it);</span><br><span class="line">int n,m;</span><br><span class="line">string s1,s2;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line">cin&gt;&gt;m;</span><br><span class="line">char u,v;</span><br><span class="line">for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">f[u-&apos;a&apos;][v-&apos;a&apos;]=1;</span><br><span class="line">&#125;</span><br><span class="line">for(int j=0;j&lt;26;j++)&#123;</span><br><span class="line">for(int i=0;i&lt;26;i++)&#123;</span><br><span class="line">for(int k=0;k&lt;26;k++)&#123;</span><br><span class="line">f[i][k]|=(f[i][j]&amp;f[j][k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bool check=0;</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">if(s1[i]!=s2[i])&#123;</span><br><span class="line">if(f[s1[i]-&apos;a&apos;][s2[i]-&apos;a&apos;]==0)&#123;</span><br><span class="line">check=1;break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(check)&#123;</span><br><span class="line">puts(&quot;NO&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else puts(&quot;YES&quot;);</span><br><span class="line">// &#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;积分赛，被打爆的积分赛（music
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="Algorithm" scheme="https://cndrew.cn/blog/tags/Algorithm/"/>
    
      <category term="greedy" scheme="https://cndrew.cn/blog/tags/greedy/"/>
    
      <category term="inverse-modulo" scheme="https://cndrew.cn/blog/tags/inverse-modulo/"/>
    
      <category term="BFS" scheme="https://cndrew.cn/blog/tags/BFS/"/>
    
      <category term="gcd" scheme="https://cndrew.cn/blog/tags/gcd/"/>
    
      <category term="前缀和" scheme="https://cndrew.cn/blog/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>HPU Summer Day 11(河南理工大学暑期第十一天)</title>
    <link href="https://cndrew.cn/blog/2019/07/27/d11/"/>
    <id>https://cndrew.cn/blog/2019/07/27/d11/</id>
    <published>2019-07-27T14:26:52.051Z</published>
    <updated>2019-07-27T14:29:09.675Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一不留神，暑期集训的三分之一就过去了。<a id="more"></a><br>开始集训的第十一天，举办了第二次积分赛，这次学长还开了网上的同步赛，打完也是挺自闭的。唉，好好学习，明天休息，收拾一下，没啥事还是敲代码吧。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一不留神，暑期集训的三分之一就过去了。
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="life" scheme="https://cndrew.cn/blog/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>HPU Summer Training Day 10(河南理工大学暑期第十天)</title>
    <link href="https://cndrew.cn/blog/2019/07/26/d10/"/>
    <id>https://cndrew.cn/blog/2019/07/26/d10/</id>
    <published>2019-07-26T14:20:54.177Z</published>
    <updated>2019-07-26T14:26:53.181Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天没讲题，加练，没啥好说的，除了脑仁疼就是脑仁疼。还有两道似乎是用到DFS的是真的写不出来了。慢慢补吧。<a id="more"></a></p><h3 id="Knight-Moves"><a href="#Knight-Moves" class="headerlink" title="Knight Moves"></a>Knight Moves</h3><p>Description:<br>Background<br>Mr Somurolov, fabulous chess-gamer indeed, asserts that no one else but him can move knights from one position to another so fast. Can you beat him?<br>The Problem<br>Your task is to write a program to calculate the minimum number of moves needed for a knight to reach one point from another, so that you have the chance to be faster than Somurolov.<br>For people not familiar with chess, the possible knight moves are shown in Figure 1.</p><p><img src="https://i.loli.net/2019/07/26/5d3af27255d1987680.png" alt></p><p>Input</p><blockquote><p>The input begins with the number n of scenarios on a single line by itself.<br>Next follow n scenarios. Each scenario consists of three lines containing integer numbers. The first line specifies the length l of a side of the chess board (4 &lt;= l &lt;= 300). The entire board has size l <em> l. The second and third line contain pair of integers {0, ..., l-1}\</em>{0, ..., l-1} specifying the starting and ending position of the knight on the board. The integers are separated by a single blank. You can assume that the positions are valid positions on the chess board of that scenario.</p></blockquote><p>Output</p><blockquote><p>For each scenario of the input you have to calculate the minimal amount of knight moves which are necessary to move from the starting point to the ending point. If starting point and ending point are equal,distance is zero. The distance must be written on a single line.</p></blockquote><p>Sample Input</p><blockquote><p>3<br>8<br>0 0<br>7 0<br>100<br>0 0<br>30 50<br>10<br>1 1<br>1 1</p></blockquote><p>Sample Output</p><blockquote><p>5<br>28<br>0</p></blockquote><p>Problem solving:<br>简单的BFS模板题，8个方向查找即可。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">int x,y;</span><br><span class="line">&#125;;</span><br><span class="line">const int maxn=305;</span><br><span class="line">int vis[maxn][maxn];</span><br><span class="line">int step[maxn][maxn];</span><br><span class="line">int n,m,sx,sy,ex,ey;</span><br><span class="line">int d[8][2]=&#123;2,1,1,2,-1,2,-2,1,-2,-1,-1,-2,1,-2,2,-1&#125;;</span><br><span class="line">void bfs()</span><br><span class="line">&#123;</span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line">node now,mid;</span><br><span class="line">vis[sx][sy]=1;</span><br><span class="line">now.x=sx,now.y=sy;</span><br><span class="line">q.push(now);</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">mid=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">for(int i = 0 ;i&lt;8;i++)</span><br><span class="line">&#123;</span><br><span class="line">now.x=mid.x+d[i][0];</span><br><span class="line">now.y=mid.y+d[i][1];</span><br><span class="line">if(now.x&lt;0||now.x&gt;=m||now.y&lt;0||now.y&gt;=m||vis[now.x][now.y])continue;</span><br><span class="line">vis[now.x][now.y]=1;</span><br><span class="line">step[now.x][now.y]=step[mid.x][mid.y]+1;</span><br><span class="line">q.push(now);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">while(n--)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">memset(step,0,sizeof(step));</span><br><span class="line">cin&gt;&gt;m&gt;&gt;sx&gt;&gt;sy&gt;&gt;ex&gt;&gt;ey;</span><br><span class="line">bfs();</span><br><span class="line">cout&lt;&lt;step[ex][ey]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="变形课"><a href="#变形课" class="headerlink" title="变形课"></a>变形课</h3><p>Description:<br>呃......变形课上Harry碰到了一点小麻烦,因为他并不像Hermione那样能够记住所有的咒语而随意的将一个棒球变成刺猬什么的,但是他发现了变形咒语的一个统一规律:如果咒语是以a开头b结尾的一个单词,那么它的作用就恰好是使A物体变成B物体.<br>Harry已经将他所会的所有咒语都列成了一个表,他想让你帮忙计算一下他是否能完成老师的作业,将一个B(ball)变成一个M(Mouse),你知道,如果他自己不能完成的话,他就只好向Hermione请教,并且被迫听一大堆好好学习的道理.<br>Input</p><blockquote><p>测试数据有多组。每组有多行，每行一个单词,仅包括小写字母,是Harry所会的所有咒语.数字0表示一组输入结束.</p></blockquote><p>Output</p><blockquote><p>如果Harry可以完成他的作业,就输出&quot;Yes.&quot;,否则就输出&quot;No.&quot;(不要忽略了句号)</p></blockquote><p>Sample Input</p><blockquote><p>so<br>soon<br>river<br>goes<br>them<br>got<br>moon<br>begin<br>big<br>0</p></blockquote><p>Sample Output</p><blockquote><p>Yes.</p></blockquote><p>Harry 可以念这个咒语:&quot;big-got-them&quot;.</p><p>Problem solving:<br>这道题我的想法是用邻接表存图，把输入的每一个单词的首字母与最后一个字母当成两个节点，并且是有向边，然后bfs以&#39;b&#39;为起点查找如果能找到&#39;m&#39;与它相连，就输出Yes，反之输出&#39;No&#39;.<br>这道题还有一个很难受的地方就是输入、、、多组套多组，里面的多组还有结束条件。不过写完这道题也算是学会了，这样写就行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while(cin&gt;&gt;s)</span><br><span class="line">&#123;</span><br><span class="line">while(s!=&apos;0&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int ma[100][100],vis[100];</span><br><span class="line">bool bfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">q.push(x);</span><br><span class="line">vis[x]=1;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">x=q.front();</span><br><span class="line">if(x==&apos;m&apos;-&apos;0&apos;)return 1;</span><br><span class="line">q.pop();</span><br><span class="line">for(int i=&apos;a&apos;-&apos;0&apos;;i&lt;=&apos;z&apos;-&apos;0&apos;;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(ma[x][i]==1&amp;&amp;!vis[i])</span><br><span class="line">&#123;</span><br><span class="line">vis[i]=1;</span><br><span class="line">//cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">//cout&lt;&lt;ma[x][i]&lt;&lt;&quot;?&quot;&lt;&lt;ma[i][x]&lt;&lt;endl;</span><br><span class="line">q.push(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">string s;</span><br><span class="line">while(cin&gt;&gt;s)</span><br><span class="line">&#123;</span><br><span class="line">memset(ma,0,sizeof(ma));</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">while(s!=&quot;0&quot;)</span><br><span class="line">&#123;</span><br><span class="line">char sx=s[0],ex=s[s.size()-1];</span><br><span class="line">//cout&lt;&lt;sx-&apos;0&apos;&lt;&lt;&quot; &quot;&lt;&lt;ex-&apos;0&apos;&lt;&lt;endl;</span><br><span class="line">ma[sx-&apos;0&apos;][ex-&apos;0&apos;]=1;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(bfs(&apos;b&apos;-&apos;0&apos;))puts(&quot;Yes.&quot;);</span><br><span class="line">else puts(&quot;No.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Pet"><a href="#Pet" class="headerlink" title="Pet"></a>Pet</h3><p>Description:<br>一天早上小明醒来时发现他的宠物仓鼠不见了。 他在房间寻找但是没找到仓鼠。 他想用奶酪诱饵去找回仓鼠。 他把奶酪诱饵放在房间并且等待了好几天。 但是可怜的小明除了老鼠和蟑螂没见到任何东西。 他找到学校的地图发现地图上没有环路，并且学校里的每个站点都可以从他的房间到达。 奶酪诱饵的手册提到在距离D之内宠物必定会被吸引回来. 你的任务是帮助小明从给定的地图中有多少可能的站点是仓鼠的藏身处. 假定仓鼠一直藏在学校的某个站点并且两个相邻站点间的距离都是1个单位。<br>Input</p><blockquote><p>输入包含多组数据。 第一行一个整数T (0&lt;T&lt;=10), 表示测试数据的组数。 每组数据, 第一行包含两个整数 N (0&lt;N&lt;=100000) 和 D(0&lt;D&lt;N). N 是学校里的站点数， D 是诱饵的影响距离。 下面 N-1行为地图描述, 每行一对 x 和 y(0&lt;=x,y&lt;N), 用一个空格隔开, 表示x和y两个站点是相邻的。小明的房间用0表示。</p></blockquote><p>Output</p><blockquote><p>对于每组数据，输出可能找到仓鼠的站点数。<br>Sample Input<br>1<br>10 2<br>0 1<br>0 2<br>0 3<br>1 4<br>1 5<br>2 6<br>3 7<br>4 8<br>6 9</p></blockquote><p>Sample Output</p><blockquote><p>2</p></blockquote><p>Problem solving:<br>题意还挺好理解的，就是问你一个图距离顶点距离大于某一值得点有多少个。构建一个图，因为现在已经知道了0是顶点，直接从0开始bfs查找，找出每个点距离0的最远距离，与给的定值进行比较即可。<br>注意多组输入每次需要初始化（我因为这个WA了一发。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e5+10;</span><br><span class="line">vector&lt;int&gt; v[maxn];</span><br><span class="line">int dis[maxn],vis[maxn],ans;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,d,t,x,y;</span><br><span class="line">void bfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">q.push(x);</span><br><span class="line">vis[x]=1;dis[x]=0;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">x=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">for(int i=0;i&lt;v[x].size();i++)</span><br><span class="line">&#123;</span><br><span class="line">if(v[x][i]&amp;&amp;!vis[v[x][i]])</span><br><span class="line">&#123;</span><br><span class="line">q.push(v[x][i]);</span><br><span class="line">vis[v[x][i]]=1;</span><br><span class="line">dis[v[x][i]]=dis[x]+1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">memset(dis,0,sizeof(dis));</span><br><span class="line">ans=0;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;n,&amp;d);</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">v[i].clear();</span><br><span class="line">for(int i=1;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;x,&amp;y);</span><br><span class="line">v[x].push_back(y);</span><br><span class="line">v[y].push_back(x);</span><br><span class="line">&#125;</span><br><span class="line">bfs(0);</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(dis[i]&gt;d)ans++;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d\n&quot;,ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="蜘蛛牌"><a href="#蜘蛛牌" class="headerlink" title="蜘蛛牌"></a>蜘蛛牌</h3><p>Description:<br>蜘蛛牌是windows xp操作系统自带的一款纸牌游戏，游戏规则是这样的：只能将牌拖到比她大一的牌上面（A最小，K最大），如果拖动的牌上有按顺序排好的牌时，那么这些牌也跟着一起移动，游戏的目的是将所有的牌按同一花色从小到大排好，为了简单起见，我们的游戏只有同一花色的10张牌，从A到10，且随机的在一行上展开，编号从1到10，把第i号上的牌移到第j号牌上，移动距离为abs(i-j)，现在你要做的是求出完成游戏的最小移动距离。<br>Input</p><blockquote><p>第一个输入数据是T，表示数据的组数。<br>每组数据有一行，10个输入数据，数据的范围是[1,10]，分别表示A到10，我们保证每组数据都是合法的。</p></blockquote><p>Output</p><blockquote><p>对应每组数据输出最小移动距离。</p></blockquote><p>Sample Input</p><blockquote><p>1<br>1 2 3 4 5 6 7 8 9 10</p></blockquote><p>Sample Output</p><blockquote><p>9</p></blockquote><p>Problem solving:<br>暂无（毫无思路题，据说是dfs）</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *　　　　　　　　┏┓　　 　┏┓</span><br><span class="line"> * 　　　　　　　┏┛┗━━━━━━━┛┗━━━┓</span><br><span class="line"> * 　　　　　　　┃　　　　　　　┃ 　</span><br><span class="line"> * 　　　　　　　┃　　　━　　 　┃</span><br><span class="line"> * 　　　　　　　┃　＞　　　＜　┃</span><br><span class="line"> * 　　　　　　　┃　　　　　　　┃</span><br><span class="line"> * 　　　　　　　┃...　⌒　... 　┃</span><br><span class="line"> * 　　　　　　　┃　　　　　　　┃</span><br><span class="line"> * 　　　　　　　┗━┓　　　┏━┛</span><br><span class="line"> * 　　　　　　　　　┃　　　┃　Code is far away from bug with the animal protecting　　　　　　　　　　</span><br><span class="line"> * 　　　　　　　　　┃　　　┃   神兽保佑,代码无bug</span><br><span class="line"> * 　　　　　　　　　┃　　　┃　　　　　　　　　　　</span><br><span class="line"> * 　　　　　　　　　┃　　　┃  　　　　　　</span><br><span class="line"> * 　　　　　　　　　┃　　　┃</span><br><span class="line"> * 　　　　　　　　　┃　　　┃　　　　　　　　　　　</span><br><span class="line"> * 　　　　　　　　　┃　　　┗━━━┓</span><br><span class="line"> * 　　　　　　　　　┃　　　　　　　┣┓</span><br><span class="line"> * 　　　　　　　　　┃　　　　　　　┏┛</span><br><span class="line"> * 　　　　　　　　　┗┓┓┏━┳┓┏┛</span><br><span class="line"> * 　　　　　　　　　　┃┫┫　┃┫┫</span><br><span class="line"> * 　　　　　　　　　　┗┻┛　┗┻┛</span><br><span class="line"> */</span><br><span class="line">// warm heart, wagging tail,and a smile just for you!</span><br><span class="line">//</span><br><span class="line">//                            _ooOoo_</span><br><span class="line">//                           o8888888o</span><br><span class="line">//                           88&quot; . &quot;88</span><br><span class="line">//                           (| -_- |)</span><br><span class="line">//                           O\  =  /O</span><br><span class="line">//                        ____/`---&apos;\____</span><br><span class="line">//                      .&apos;  \|     |//  `.</span><br><span class="line">//                     /  \|||  :  |||//  \</span><br><span class="line">//                    /  _||||| -:- |||||-  \</span><br><span class="line">//                    |   | \\  -  /// |   |</span><br><span class="line">//                    | \_|  &apos;&apos;\---/&apos;&apos;  |   |</span><br><span class="line">//                    \  .-\__  `-`  ___/-. /</span><br><span class="line">//                  ___`. .&apos;  /--.--\  `. . __</span><br><span class="line">//               .&quot;&quot; &apos;&lt;  `.___\_&lt;|&gt;_/___.&apos;  &gt;&apos;&quot;&quot;.</span><br><span class="line">//              | | :  `- \`.;`\ _ /`;.`/ - ` : | |</span><br><span class="line">//              \  \ `-.   \_ __\ /__ _/   .-` /  /</span><br><span class="line">//         ======`-.____`-.___\_____/___.-`____.-&apos;======</span><br><span class="line">//                            `=---=&apos;</span><br><span class="line">//        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class="line">//</span><br></pre></td></tr></table></figure></p><h3 id="逃离迷宫"><a href="#逃离迷宫" class="headerlink" title="逃离迷宫"></a>逃离迷宫</h3><p>Description:<br>给定一个m × n (m行, n列)的迷宫，迷宫中有两个位置，gloria想从迷宫的一个位置走到另外一个位置，当然迷宫中有些地方是空地，gloria可以穿越，有些地方是障碍，她必须绕行，从迷宫的一个位置，只能走到与它相邻的4个位置中,当然在行走过程中，gloria不能走到迷宫外面去。令人头痛的是，gloria是个没什么方向感的人，因此，她在行走过程中，不能转太多弯了，否则她会晕倒的。我们假定给定的两个位置都是空地，初始时，gloria所面向的方向未定，她可以选择4个方向的任何一个出发，而不算成一次转弯。gloria能从一个位置走到另外一个位置吗？<br>Input</p><blockquote><p>第1行为一个整数t (1 ≤ t ≤ 100),表示测试数据的个数，接下来为t组测试数据，每组测试数据中，<br>　　第1行为两个整数m, n (1 ≤ m, n ≤ 100),分别表示迷宫的行数和列数，接下来m行，每行包括n个字符，其中字符&#39;.&#39;表示该位置为空地，字符&#39;*&#39;表示该位置为障碍，输入数据中只有这两种字符，每组测试数据的最后一行为5个整数k, x 1, y 1, x 2, y 2 (1 ≤ k ≤ 10, 1 ≤ x 1, x 2 ≤ n, 1 ≤ y 1, y 2 ≤ m),其中k表示gloria最多能转的弯数，(x 1, y 1), (x 2, y 2)表示两个位置，其中x 1，x 2对应列，y 1, y 2对应行。</p></blockquote><p>Output</p><blockquote><p>　　每组测试数据对应为一行，若gloria能从一个位置走到另外一个位置，输出“yes”，否则输出“no”。</p></blockquote><p>Sample Input</p><blockquote><p>2<br>5 5<br>...<strong><br>*.</strong>.<br>.....<br>.....<br><em>....<br>1 1 1 1 3<br>5 5<br>...**</em>.*<em>.<br>.....<br>.....</em>....<br>2 1 1 1 3</p></blockquote><p>Sample Output</p><blockquote><p>no<br>yes</p></blockquote><p>Problem solving:<br>这也是一道查找的题，给了你起点和终点和最大拐弯次数，问你能不能从起点走到终点。我选择了bfs，其实是一道挺简单的题，难点就是如何得到当前转弯的次数。我一开始想着用x，y坐标的差值来表示，但是又麻烦又不好理解。然后我在网上看到了一种写法。就是在bfs的过程中，每选择了一个方向就按照这个方向一直走下去直到越界或者到了走不了的点。这一步描述的如果你不是很懂，可以参考一下下面代码我加上的注释。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m,t,sx,sy,ex,ey,k;</span><br><span class="line">char s[105][105];</span><br><span class="line">int vis[105][105];</span><br><span class="line">struct node&#123;</span><br><span class="line">int x,y,flag;//flag就是用来存当前的拐弯次数</span><br><span class="line">&#125;;</span><br><span class="line">int d[4][2]=&#123;1,0,0,1,0,-1,-1,0&#125;;</span><br><span class="line">bool bfs()</span><br><span class="line">&#123;</span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line">node now,mid;</span><br><span class="line">now.x=sx,now.y=sy,now.flag=-1;//初始的转弯次数设为-1是因为第一次走是不算入转弯次数的</span><br><span class="line">vis[sx][sy]=1;</span><br><span class="line">q.push(now);</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">//cout&lt;&lt;&quot;?&quot;;</span><br><span class="line">now=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">if(now.flag&gt;=k)continue;//如果此时转弯次数已经大于k了，就没有走下去的必要了。这一点在这种写法中很重要</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">mid.x=now.x+d[i][0];</span><br><span class="line">mid.y=now.y+d[i][1];</span><br><span class="line">mid.flag=now.flag+1;//此时你选择了一个方向</span><br><span class="line">while(1)//沿着这个方向一直走下去</span><br><span class="line">&#123;</span><br><span class="line">if(mid.x&lt;0||mid.x&gt;=n||mid.y&lt;0||mid.y&gt;=m||s[mid.x][mid.y]==&apos;*&apos;)break;//如果越界了或者不能走了，就说明沿着这个方向一直走走不下去了，break就行</span><br><span class="line">if(mid.x==ex&amp;&amp;mid.y==ey)return 1;//如果当前走到的点与终点相等，就说明可以走到，返回true</span><br><span class="line">if(vis[mid.x][mid.y]==0)</span><br><span class="line">&#123;</span><br><span class="line">vis[mid.x][mid.y]=1;</span><br><span class="line">q.push(mid);</span><br><span class="line">&#125;</span><br><span class="line">mid.x+=d[i][0];//沿着这个方向更新到下一个走到的点的x，y坐标</span><br><span class="line">mid.y+=d[i][1];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">cin&gt;&gt;s[i];</span><br><span class="line">cin&gt;&gt;k&gt;&gt;sy&gt;&gt;sx&gt;&gt;ey&gt;&gt;ex;//这有个坑，它先输入的是y的值</span><br><span class="line">sx--,sy--,ex--,ey--;</span><br><span class="line">if(bfs()) puts(&quot;yes&quot;);</span><br><span class="line">elseputs(&quot;no&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Kaitou-Kid-The-Phantom-Thief-2"><a href="#Kaitou-Kid-The-Phantom-Thief-2" class="headerlink" title="Kaitou Kid - The Phantom Thief (2)"></a>Kaitou Kid - The Phantom Thief (2)</h3><p>Description:<br>破解字迷之后，你得知Kid将会在展览开始后T分钟内盗取至少一颗宝石，并离开展馆。整个展馆呈矩形分布，划分为N*M个区域，有唯一的入口和出口（不能从出口进入，同样不能从入口出去）。由某个区域可直接移动至相邻四个区域中的一个，且最快需要一分钟。假设Kid进入放有宝石的区域即可盗取宝石，无需耗时。问至少要封锁几个区域（可以封锁放有宝石的区域，但不能封锁入口和出口）才能保证Kid无法完成任务。<br>Input</p><blockquote><p>输入的第一行有一个整数C，代表有C组测试数据。每组测试数据的第一行有三个整数N，M，T(2&lt;=N,M&lt;=8,T&gt;0)。接下来N行M列为展馆布置图，其中包括：<br>&#39;S&#39;：入口<br>&#39;E&#39;：出口<br>&#39;J&#39;：放有宝石的区域，至少出现一次<br>&#39;.&#39;：空白区域<br>&#39;#&#39;：墙</p></blockquote><p>Output</p><blockquote><p>对每组测试数据，输出至少要封锁的区域数。</p></blockquote><p>Sample Input</p><blockquote><p>2<br>5 5 5<br>SJJJJ<br>..##J<br>.JJJJ<br>.J...<br>EJ...<br>5 5 6<br>SJJJJ<br>..##J<br>.JJJJ<br>.J...<br>EJ...</p></blockquote><p>Sample Output</p><blockquote><p>0<br>2</p></blockquote><p>Problem solving:<br>暂无（据说是bfs+dfs）</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *　　　　　　　　┏┓　　 　┏┓</span><br><span class="line"> * 　　　　　　　┏┛┗━━━━━━━┛┗━━━┓</span><br><span class="line"> * 　　　　　　　┃　　　　　　　┃ 　</span><br><span class="line"> * 　　　　　　　┃　　　━　　 　┃</span><br><span class="line"> * 　　　　　　　┃　＞　　　＜　┃</span><br><span class="line"> * 　　　　　　　┃　　　　　　　┃</span><br><span class="line"> * 　　　　　　　┃...　⌒　... 　┃</span><br><span class="line"> * 　　　　　　　┃　　　　　　　┃</span><br><span class="line"> * 　　　　　　　┗━┓　　　┏━┛</span><br><span class="line"> * 　　　　　　　　　┃　　　┃　Code is far away from bug with the animal protecting　　　　　　　　　　</span><br><span class="line"> * 　　　　　　　　　┃　　　┃   神兽保佑,代码无bug</span><br><span class="line"> * 　　　　　　　　　┃　　　┃　　　　　　　　　　　</span><br><span class="line"> * 　　　　　　　　　┃　　　┃  　　　　　　</span><br><span class="line"> * 　　　　　　　　　┃　　　┃</span><br><span class="line"> * 　　　　　　　　　┃　　　┃　　　　　　　　　　　</span><br><span class="line"> * 　　　　　　　　　┃　　　┗━━━┓</span><br><span class="line"> * 　　　　　　　　　┃　　　　　　　┣┓</span><br><span class="line"> * 　　　　　　　　　┃　　　　　　　┏┛</span><br><span class="line"> * 　　　　　　　　　┗┓┓┏━┳┓┏┛</span><br><span class="line"> * 　　　　　　　　　　┃┫┫　┃┫┫</span><br><span class="line"> * 　　　　　　　　　　┗┻┛　┗┻┛</span><br><span class="line"> */</span><br><span class="line">// warm heart, wagging tail,and a smile just for you!</span><br><span class="line">//</span><br><span class="line">//                            _ooOoo_</span><br><span class="line">//                           o8888888o</span><br><span class="line">//                           88&quot; . &quot;88</span><br><span class="line">//                           (| -_- |)</span><br><span class="line">//                           O\  =  /O</span><br><span class="line">//                        ____/`---&apos;\____</span><br><span class="line">//                      .&apos;  \|     |//  `.</span><br><span class="line">//                     /  \|||  :  |||//  \</span><br><span class="line">//                    /  _||||| -:- |||||-  \</span><br><span class="line">//                    |   | \\  -  /// |   |</span><br><span class="line">//                    | \_|  &apos;&apos;\---/&apos;&apos;  |   |</span><br><span class="line">//                    \  .-\__  `-`  ___/-. /</span><br><span class="line">//                  ___`. .&apos;  /--.--\  `. . __</span><br><span class="line">//               .&quot;&quot; &apos;&lt;  `.___\_&lt;|&gt;_/___.&apos;  &gt;&apos;&quot;&quot;.</span><br><span class="line">//              | | :  `- \`.;`\ _ /`;.`/ - ` : | |</span><br><span class="line">//              \  \ `-.   \_ __\ /__ _/   .-` /  /</span><br><span class="line">//         ======`-.____`-.___\_____/___.-`____.-&apos;======</span><br><span class="line">//                            `=---=&apos;</span><br><span class="line">//        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class="line">//</span><br></pre></td></tr></table></figure></p><h3 id="A计划"><a href="#A计划" class="headerlink" title="A计划"></a>A计划</h3><p>Description:<br>可怜的公主在一次次被魔王掳走一次次被骑士们救回来之后，而今，不幸的她再一次面临生命的考验。魔王已经发出消息说将在T时刻吃掉公主，因为他听信谣言说吃公主的肉也能长生不老。年迈的国王正是心急如焚，告招天下勇士来拯救公主。不过公主早已习以为常，她深信智勇的骑士LJ肯定能将她救出。<br>现据密探所报，公主被关在一个两层的迷宫里，迷宫的入口是S（0，0，0），公主的位置用P表示，时空传输机用#表示，墙用*表示，平地用.表示。骑士们一进入时空传输机就会被转到另一层的相对位置，但如果被转到的位置是墙的话，那骑士们就会被撞死。骑士们在一层中只能前后左右移动，每移动一格花1时刻。层间的移动只能通过时空传输机，且不需要任何时间。<br>Input</p><blockquote><p>输入的第一行C表示共有C个测试数据，每个测试数据的前一行有三个整数N，M，T。 N，M迷宫的大小N<em>M（1 &lt;= N,M &lt;=10)。T如上所意。接下去的前N</em>M表示迷宫的第一层的布置情况，后N*M表示迷宫第二层的布置情况。</p></blockquote><p>Output</p><blockquote><p>如果骑士们能够在T时刻能找到公主就输出“YES”，否则输出“NO”。</p></blockquote><p>Sample Input</p><blockquote><p>1<br>5 5 14<br>S<em>#</em>.<br>.#...<br>.....<br><em>**</em>.<br>...#.<br>..*.P</p></blockquote><p>#.<em>..<br>**</em>..<br>...<em>.</em>.#..</p><p>Sample Output</p><blockquote><p>YES</p></blockquote><p>Problem solving:<br>哇，这道题坑的一批。最后玄学过题<br>就是个三维的bfs，而且给定了只有两层。<br>因为遇到传送门进行传送的时候是不需要耗费时间的，所以传送门那需要特殊处理一下（可以想一下，如果传送门传送过去的位置还是传送门，就成死循环了。如果传送门传送过去是墙，也可以直接看做这个传送门是一堵墙）</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int c,n,m,t;</span><br><span class="line">struct node&#123;</span><br><span class="line">int x,y,z,step;</span><br><span class="line">&#125;;</span><br><span class="line">int d[4][2]=&#123;1,0,0,1,0,-1,-1,0&#125;,vis[2][15][15],flag;</span><br><span class="line">char s[2][15][15];</span><br><span class="line">node now,mid,meizi;</span><br><span class="line">void bfs()</span><br><span class="line">&#123;</span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line">q.push(now);</span><br><span class="line">vis[now.x][now.y][now.z]=1;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">mid=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">if(s[mid.x][mid.y][mid.z]==&apos;P&apos;&amp;&amp;mid.step&lt;=t)</span><br><span class="line">&#123;</span><br><span class="line">flag=1;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">meizi=mid;</span><br><span class="line">meizi.y+=d[i][0];</span><br><span class="line">meizi.z+=d[i][1];</span><br><span class="line">meizi.step+=1;</span><br><span class="line">if(meizi.step&gt;t||meizi.y&lt;0||meizi.y&gt;=n||meizi.z&lt;0||meizi.z&gt;=m||vis[meizi.x][meizi.y][meizi.z]||s[meizi.x][meizi.y][meizi.z]==&apos;*&apos;)</span><br><span class="line">continue;</span><br><span class="line">vis[meizi.x][meizi.y][meizi.z]=1;</span><br><span class="line">if(s[meizi.x][meizi.y][meizi.z]==&apos;#&apos;&amp;&amp;s[(meizi.x+1)%2][meizi.y][meizi.z]!=&apos;*&apos;&amp;&amp;!vis[(meizi.x+1)%2][meizi.y][meizi.z])</span><br><span class="line">meizi.x=(meizi.x+1)%2;</span><br><span class="line">q.push(meizi);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;c;</span><br><span class="line">while(c--)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;t;</span><br><span class="line">for(int i=0;i&lt;2;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line">for(int k=0;k&lt;m;k++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;s[i][j][k];</span><br><span class="line">if(s[i][j][k]==&apos;S&apos;)</span><br><span class="line">&#123;</span><br><span class="line">now.x=i,now.y=j,now.z=k,now.step=0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(int j=0;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line">for(int k=0;k&lt;m;k++)</span><br><span class="line">&#123;</span><br><span class="line">if(s[0][j][k]==&apos;#&apos;&amp;&amp;s[1][j][k]==&apos;*&apos;)</span><br><span class="line">&#123;</span><br><span class="line">s[0][j][k]=s[1][j][k]=&apos;*&apos;;</span><br><span class="line">&#125;</span><br><span class="line">if(s[0][j][k]==&apos;*&apos;&amp;&amp;s[1][j][k]==&apos;#&apos;)</span><br><span class="line">&#123;</span><br><span class="line">s[0][j][k]=s[1][j][k]=&apos;*&apos;;</span><br><span class="line">&#125;</span><br><span class="line">if(s[0][j][k]==&apos;#&apos;&amp;&amp;s[1][j][k]==&apos;#&apos;)</span><br><span class="line">&#123;</span><br><span class="line">s[0][j][k]=s[1][j][k]=&apos;*&apos;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flag=0;</span><br><span class="line">bfs();</span><br><span class="line">if(flag)puts(&quot;YES&quot;);</span><br><span class="line">elseputs(&quot;NO&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Nightmare"><a href="#Nightmare" class="headerlink" title="Nightmare"></a>Nightmare</h3><p>Description:<br>Ignatius had a nightmare last night. He found himself in a labyrinth with a time bomb on him. The labyrinth has an exit, Ignatius should get out of the labyrinth before the bomb explodes. The initial exploding time of the bomb is set to 6 minutes. To prevent the bomb from exploding by shake, Ignatius had to move slowly, that is to move from one area to the nearest area(that is, if Ignatius stands on (x,y) now, he could only on (x+1,y), (x-1,y), (x,y+1), or (x,y-1) in the next minute) takes him 1 minute. Some area in the labyrinth contains a Bomb-Reset-Equipment. They could reset the exploding time to 6 minutes.</p><p>Given the layout of the labyrinth and Ignatius&#39; start position, please tell Ignatius whether he could get out of the labyrinth, if he could, output the minimum time that he has to use to find the exit of the labyrinth, else output -1.</p><p>Here are some rules:</p><ol><li>We can assume the labyrinth is a 2 array.</li><li>Each minute, Ignatius could only get to one of the nearest area, and he should not walk out of the border, of course he could not walk on a wall, too.</li><li>If Ignatius get to the exit when the exploding time turns to 0, he can&#39;t get out of the labyrinth.</li><li>If Ignatius get to the area which contains Bomb-Rest-Equipment when the exploding time turns to 0, he can&#39;t use the equipment to reset the bomb.</li><li>A Bomb-Reset-Equipment can be used as many times as you wish, if it is needed, Ignatius can get to any areas in the labyrinth as many times as you wish.</li><li>The time to reset the exploding time can be ignore, in other words, if Ignatius get to an area which contain Bomb-Rest-Equipment, and the exploding time is larger than 0, the exploding time would be reset to 6.<br>Input<blockquote><p>The input contains several test cases. The first line of the input is a single integer T which is the number of test cases. T test cases follow.<br>Each test case starts with two integers N and M(1&lt;=N,Mm=8) which indicate the size of the labyrinth. Then N lines follow, each line contains M integers. The array indicates the layout of the labyrinth.<br>There are five integers which indicate the different type of area in the labyrinth:<br>0: The area is a wall, Ignatius should not walk on it.<br>1: The area contains nothing, Ignatius can walk on it.<br>2: Ignatius&#39; start position, Ignatius starts his escape from this position.<br>3: The exit of the labyrinth, Ignatius&#39; target position.<br>4: The area contains a Bomb-Reset-Equipment, Ignatius can delay the exploding time by walking to these areas.</p></blockquote></li></ol><p>Output</p><blockquote><p>For each test case, if Ignatius can get out of the labyrinth, you should output the minimum time he needs, else you should just output -1.</p></blockquote><p>Sample Input</p><blockquote><p>3<br>3 3<br>2 1 1<br>1 1 0<br>1 1 3<br>4 8<br>2 1 1 0 1 1 1 0<br>1 0 4 1 1 0 4 1<br>1 0 0 0 0 0 0 1<br>1 1 1 4 1 1 1 3<br>5 8<br>1 2 1 1 1 1 1 4<br>1 0 0 0 1 0 0 1<br>1 4 1 0 1 1 0 1<br>1 0 0 0 0 3 0 1<br>1 1 4 1 1 1 1 1</p></blockquote><p>Sample Output</p><blockquote><p>4<br>-1<br>13</p></blockquote><p>Problem solving:<br>这道题我是用bfs来做的，跟一种题很像，就是给你规定一个时间看能否走出迷宫之类的问题。<br>但是这道题有一种新的规则，就是如果走到某些特殊的点。时间会更新一次。<br>0是墙，不可以走<br>1是路<br>2是起点<br>3是终点<br>4是可以重置时间的点<br>刚开始看到这里的时候我想着肯定要经过很负责的处理。但是后来发现其实我们只需要知道这两点就可以了。并且题目中规定如果时间为0就不能继续走下去了。</p><ol><li>每个点都是可以重复访问的</li><li>可以刷新时间的点我们只走一次<br>第一点到不需要怎么理解，就是第二点我们该如何理解呢？<br>如果同一个位置的炸弹你第二次走到了它上面就说明此时已经不是最优解了。所以每个刷新时间的点我们每次走完之后就把它存为0——即墙。</li></ol><p>关于第二点的理解还有另一种解释方式:<br>上同一位置是bomb离explode的时间长短来标记。简言之，如果第二次踏上一个位置，那么找出路已用的时间肯定是增加了，那为啥还要走上这条路呢？唯一的追求就是bomb离爆炸的时间增大了。所以可以利用这个条件来标记了。每次在入队前检查下爆炸时间是否比上次在同一位置的大，若是，则入队；反之，入队无意义了。从以上的分析中可以引出另一思路，也就是只要进入位置4，那么bomb就会延时到6分钟，最大的延时时间。换句话说，下次再进入该4位置，也不会获得更大的延时时间了。所以，只要访问过位置4了，就可以直接标记为0位置，表明下次不可在访问。详见代码二。<br>转载于：<a href="http://blog.sina.com.cn/s/blog_7f09a7160101sym7.html" target="_blank" rel="noopener">clouddyx</a></p><p>其实想一下也确实是，假设我们现在走到了一个可以重置时间的点，如果下次在走到这，是不是就一直循环下去了，所以按照这个理解也可以。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m,a[10][10];</span><br><span class="line">struct node&#123;</span><br><span class="line">int x,y,step,time;</span><br><span class="line">&#125;;</span><br><span class="line">int d[4][2]=&#123;1,0,0,1,0,-1,-1,0&#125;;</span><br><span class="line">int ans;</span><br><span class="line">node now,mid;</span><br><span class="line">void bfs()</span><br><span class="line">&#123;</span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line">q.push(now);</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">//cout&lt;&lt;&quot;?&quot;&lt;&lt;endl;</span><br><span class="line">now=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">if(now.time&lt;=0)continue;</span><br><span class="line">if(a[now.x][now.y]==3)</span><br><span class="line">&#123;</span><br><span class="line">ans=now.step;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">mid.x=now.x+d[i][0];</span><br><span class="line">mid.y=now.y+d[i][1];</span><br><span class="line">mid.step=now.step+1;</span><br><span class="line">mid.time=now.time-1;</span><br><span class="line">if(mid.x&lt;0||mid.x&gt;=n||mid.y&lt;0||mid.y&gt;=m||mid.time&lt;=0||a[mid.x][mid.y]==0)continue;</span><br><span class="line">if(a[mid.x][mid.y]==4)</span><br><span class="line">&#123;</span><br><span class="line">a[mid.x][mid.y]=0;</span><br><span class="line">mid.time=6;</span><br><span class="line">&#125;</span><br><span class="line">q.push(mid);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">ans=-1;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;m;j++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a[i][j];</span><br><span class="line">if(a[i][j]==2)</span><br><span class="line">&#123;</span><br><span class="line">now.x=i,now.y=j,now.step=0,now.time=6;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bfs();</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="胜利大逃亡"><a href="#胜利大逃亡" class="headerlink" title="胜利大逃亡"></a>胜利大逃亡</h3><p>Description:<br>Ignatius被魔王抓走了,有一天魔王出差去了,这可是Ignatius逃亡的好机会.</p><p>魔王住在一个城堡里,城堡是一个A<em>B</em>C的立方体,可以被表示成A个B*C的矩阵,刚开始Ignatius被关在(0,0,0)的位置,离开城堡的门在(A-1,B-1,C-1)的位置,现在知道魔王将在T分钟后回到城堡,Ignatius每分钟能从一个坐标走到相邻的六个坐标中的其中一个.现在给你城堡的地图,请你计算出Ignatius能否在魔王回来前离开城堡(只要走到出口就算离开城堡,如果走到出口的时候魔王刚好回来也算逃亡成功),如果可以请输出需要多少分钟才能离开,如果不能则输出-1.<br><img src="https://i.loli.net/2019/07/26/5d3af3fd5f8c290859.png" alt><br>Input</p><blockquote><p>输入数据的第一行是一个正整数K,表明测试数据的数量.每组测试数据的第一行是四个正整数A,B,C和T(1&lt;=A,B,C&lt;=50,1&lt;=T&lt;=1000),它们分别代表城堡的大小和魔王回来的时间.然后是A块输入数据(先是第0块,然后是第1块,第2块......),每块输入数据有B行,每行有C个正整数,代表迷宫的布局,其中0代表路,1代表墙.(如果对输入描述不清楚,可以参考Sample Input中的迷宫描述,它表示的就是上图中的迷宫)<br>特别注意:本题的测试数据非常大,请使用scanf输入,我不能保证使用cin能不超时.在本OJ上请使用Visual C++提交.</p></blockquote><p>Output</p><blockquote><p>对于每组测试数据,如果Ignatius能够在魔王回来前离开城堡,那么请输出他最少需要多少分钟,否则输出-1.</p></blockquote><p>Sample Input</p><blockquote><p>1<br>3 3 4 20<br>0 1 1 1<br>0 0 1 1<br>0 1 1 1<br>1 1 1 1<br>1 0 0 1<br>0 1 1 1<br>0 0 0 0<br>0 1 1 0<br>0 1 1 0</p></blockquote><p>Sample Output</p><blockquote><p>11</p></blockquote><p>Problem solving:<br>简单的三维bfs，直接写就行了，六个方向。注意多组输入需要初始化，我又是这WA了一次。。。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a,b,c,k;</span><br><span class="line">int s[51][51][51];</span><br><span class="line">int vis[51][51][51];</span><br><span class="line">struct node&#123;</span><br><span class="line">int x,y,z,step;</span><br><span class="line">&#125;;</span><br><span class="line">node mz,mid,ne;</span><br><span class="line">int d[6][3]=&#123;1,0,0, -1,0,0, 0,1,0, 0,-1,0, 0,0,1,0,0,-1&#125;,ans;</span><br><span class="line">void bfs()</span><br><span class="line">&#123;</span><br><span class="line">mz.x=mz.y=mz.z=mz.step=0;</span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line">q.push(mz);</span><br><span class="line">vis[0][0][0]=1;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">mid=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">if(mid.step&gt;k)</span><br><span class="line">&#123;</span><br><span class="line">return  ;</span><br><span class="line">&#125;</span><br><span class="line">if(mid.x==a-1&amp;&amp;mid.y==b-1&amp;&amp;mid.z==c-1&amp;&amp;mid.step&lt;=k)</span><br><span class="line">&#123;</span><br><span class="line">ans=mid.step;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;6;i++)</span><br><span class="line">&#123;</span><br><span class="line">ne.x=mid.x+d[i][0];</span><br><span class="line">ne.y=mid.y+d[i][1];</span><br><span class="line">ne.z=mid.z+d[i][2];</span><br><span class="line">if(ne.x&lt;0||ne.x&gt;=a||ne.y&lt;0||ne.y&gt;=b||ne.z&lt;0||ne.z&gt;=c||vis[ne.x][ne.y][ne.z]||s[ne.x][ne.y][ne.z]==1)</span><br><span class="line">continue;</span><br><span class="line">ne.step=mid.step+1;</span><br><span class="line">vis[ne.x][ne.y][ne.z]=1;</span><br><span class="line">q.push(ne);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t;scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">ans=-1;</span><br><span class="line">scanf(&quot;%d %d %d %d&quot;,&amp;a,&amp;b,&amp;c,&amp;k);</span><br><span class="line">for(int i=0;i&lt;a;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;b;j++)</span><br><span class="line">&#123;</span><br><span class="line">for(int k=0;k&lt;c;k++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%1d&quot;,&amp;s[i][j][k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bfs();</span><br><span class="line">printf(&quot;%d\n&quot;,ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="A-strange-lift"><a href="#A-strange-lift" class="headerlink" title="A strange lift"></a>A strange lift</h3><p>Description:<br>计院有一个bug电梯，可能是hyk造的，很多bug，电梯只有两个按钮，“上”和“下”，电梯每层都可以停，每层都有一个数字Ki（0&lt;=Ki&lt;=n），当你在一层楼，你按“上”键会到1+K1层，你按“下”键会到1-K1层。当然，电梯不能升到N以上，也不能降到1以下。例如，有一个五层楼的建筑，k1=3，k2=3，k3=1，k4=2，k5=5。从第一层开始，你可以按“上”按钮，然后你就上到第四层，如果在第一层按“下”按钮，电梯就不能做到，因为你知道它不能下到负二层。负二楼不存在。<br>那么，你想从A层到B层，你至少要按多少次“上”或“下”按钮呢？</p><p>Input</p><blockquote><p>输入由几个测试用例组成，每个测试用例包含两行。<br>第一行包含三个整数n，a，b（1&lt;=n，a，b&lt;=200），如上文所述，第二行包含n个整数k1，k2，….kn。<br>单个0表示输入的结束。</p></blockquote><p>Output</p><blockquote><p>对于每种情况下的输入输出一个整数，当你在A层，你必须按下按钮的最少次数，你想去B层。如果你不能到达B层，打印“-1”。</p></blockquote><p>Sample Input</p><blockquote><p>5 1 5<br>3 3 1 2 5<br>0</p></blockquote><p>Sample Output</p><blockquote><p>3</p></blockquote><p>Problem solving:<br>也是一道存图的题。每次存的时候注意判断第二个点与0跟n的大小关系。也是有向图。<br>注意初始化！！！又是这样WA了一次。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,a,b,meizi;</span><br><span class="line">int s[250][250],ans;</span><br><span class="line">int vis[250],step[250];</span><br><span class="line">void bfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">q.push(x);</span><br><span class="line">vis[x]=1,step[x]=0;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">int mid=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">//cout&lt;&lt;mid&lt;&lt;endl;</span><br><span class="line">if(mid==b)</span><br><span class="line">&#123;</span><br><span class="line">//cout&lt;&lt;&quot;?&quot;&lt;&lt;endl;</span><br><span class="line">ans=step[mid];</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">//cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;s[x][i]&lt;&lt;endl;</span><br><span class="line">if(s[mid][i]&amp;&amp;vis[i]==0)</span><br><span class="line">&#123;</span><br><span class="line">q.push(i);</span><br><span class="line">vis[i]=1;</span><br><span class="line">step[i]=step[mid]+1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(cin&gt;&gt;n&amp;&amp;n)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">memset(step,0,sizeof(step));</span><br><span class="line">memset(s,0,sizeof(s));</span><br><span class="line">ans=-1;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;meizi;</span><br><span class="line">if(i+meizi&gt;=1&amp;&amp;i+meizi&lt;=n)s[i][meizi+i]=1;</span><br><span class="line">if(i-meizi&gt;=1&amp;&amp;i-meizi&lt;=n)  s[i][i-meizi]=1;</span><br><span class="line">&#125;</span><br><span class="line">bfs(a);</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天没讲题，加练，没啥好说的，除了脑仁疼就是脑仁疼。还有两道似乎是用到DFS的是真的写不出来了。慢慢补吧。
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="Algorithm" scheme="https://cndrew.cn/blog/tags/Algorithm/"/>
    
      <category term="c/c++" scheme="https://cndrew.cn/blog/tags/c-c/"/>
    
      <category term="DFS" scheme="https://cndrew.cn/blog/tags/DFS/"/>
    
      <category term="HDU" scheme="https://cndrew.cn/blog/tags/HDU/"/>
    
      <category term="poj" scheme="https://cndrew.cn/blog/tags/poj/"/>
    
      <category term="STL" scheme="https://cndrew.cn/blog/tags/STL/"/>
    
      <category term="BFS" scheme="https://cndrew.cn/blog/tags/BFS/"/>
    
      <category term="邻接表" scheme="https://cndrew.cn/blog/tags/%E9%82%BB%E6%8E%A5%E8%A1%A8/"/>
    
      <category term="Queue" scheme="https://cndrew.cn/blog/tags/Queue/"/>
    
  </entry>
  
  <entry>
    <title>树的直径以及邻接表，链式前向星的存图</title>
    <link href="https://cndrew.cn/blog/2019/07/25/mapsave/"/>
    <id>https://cndrew.cn/blog/2019/07/25/mapsave/</id>
    <published>2019-07-25T14:23:57.943Z</published>
    <updated>2019-07-25T14:25:29.060Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天的学习及刷题的过程中遇到了一些新的知识——树的直径，和前几天学到但没使用过的邻接表存图以及链式前向星存图。内容也不少，所以特意新开一篇文章进行介绍。<a id="more"></a></p><p>先来了解一下什么是树：<br>树（tree）是包含n（n&gt;0）个结点的有穷集，其中：</p><ul><li>每个元素称为结点（node）；</li><li>有一个特定的结点被称为根结点或树根（root）；</li><li>除根结点之外的其余数据元素被分为m（m≥0）个互不相交<br>的集合T1，T2，…Tm-1，其中每一个集合Tm-1（1≤i≤m）<br>本身也是一棵树，被称作原树的子树（subtree）。</li></ul><p>树中距离最大的两个结点之间的距离称为树的直径。<br><img src="https://i.loli.net/2019/07/25/5d3959f00f0cf36997.png" alt></p><p>树的直径的求法：</p><p>两次dfs或bfs。第一次任意选一个点进行dfs(bfs)找到离它最远的<br>点，此点就是最长路的一个端点，再以此点进行dfs（bfs），找到<br>离它最远的点，此点就是最长路的另一个端点，于是就找到了树<br>的直径。</p><p>证明：<br>假设此树的最长路径是从s到t,我们选择的点为u。<br>反证法：假设搜到的点是v。<br>1、v在这条最长路径上，那么dis[u,v]&gt;dis[u,v]+dis[v,s],显然矛<br>盾。<br>2、v不在这条最长路径上，我们在最长路径上选择一个点为po，<br>则dis[u,v]&gt;dis[u,po]+dis[po,t]，那么有dis[s,v]=dis[s,po]+dis[po,u]<br>+dis[u,v]&gt;dis[s,po]+dis[po,t]=dis[s,t],即dis[s,v]&gt;dis[s,t],矛盾。<br>也许你想说u本身就在最长路径，或则其它的一些情况，但其实<br>都能用类似于上面的反证法来证明的。<br>综上所述，你两次dfs(bfs)就可以求出最长路径的两个端点和路<br>径长度。        以上内容参考与学长的PDF</p><p>其实证明看不太懂得话问题不大，就是随便找一个位置先进行dfs或者bfs到达一个端点，再以这个端点为起点dfs或者bfs到达另一个端点即可。</p><p>有的题它让你处理的就是字符串组成的图，但是有的题就不会这么好心了，他会给出你节点，边，甚至有的还会给你出权值。此时我们就需要自己存图。</p><p>说到存图，一般都有三种方法。</p><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>用二维数组进行存图，这个是最普通的办法，但是有一个致命的缺点就是当题目数据中的点比较多的时候有极高的空间复杂度，会爆内存。不过数据范围小的时候用二维数组来存图。还是很简单的。<br>举个栗子：<br>5个点 4条边<br>对每条边输入三个数，两个端点以及这条边的权值<br>1 2 2<br>2 3 4<br>4 5 1<br>1 4 2<br>1 5 3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">char s[maxn][maxn];</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y&gt;&gt;p;</span><br><span class="line">    s[x][y]=p;</span><br><span class="line">s[y][x]=p;//如果是有向图的话，就不需要这一句了    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>访问的时候直接s[i][j]就行了</p><h2 id="邻接表法"><a href="#邻接表法" class="headerlink" title="邻接表法"></a>邻接表法</h2><p>邻接表法就是用vector来进行存储，这个也挺好理解，跟二维数组可以一样的理解。<br>举个栗子：<br>5个点 4条边<br>对每条边输入三个数，两个端点以及这条边的权值<br>1 2 2<br>2 3 4<br>4 5 1<br>1 4 2<br>1 5 3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//无权值</span><br><span class="line">vector&lt;int&gt; v[maxn];</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    v[x].push_back(y);</span><br><span class="line">    v[y].push_back(x);//有向边的话不需要者一句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//有权值</span><br><span class="line">vector&lt;pair&lt;int,int&gt; &gt; v[maxn]；</span><br><span class="line">fot(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">    v[x].push_back(make_pair(y,z));</span><br><span class="line">    v[y].push_back(make_pair(x,z));//有向边的话不需要者一句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问每条边的时候需要这样写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;v[i].size();j++)</span><br><span class="line">    &#123;</span><br><span class="line">    cout&lt;&lt;v[i][j].first&lt;&lt;&quot;-&gt;&quot;&lt;&lt;v[i][j].second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h2><p>链式前向星是一种很巧妙地方法。<br>首先建立一个结构体<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Edge</span><br><span class="line">&#123;</span><br><span class="line">    int e;//表示第i条边的终点</span><br><span class="line">    int w;//权值</span><br><span class="line">    int next;//表示同起点的下一条边</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>加边<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cnt=0,head=-1;</span><br><span class="line">void add ( int u, int v, int w)</span><br><span class="line">&#123;</span><br><span class="line">edge [cnt ].w = w;</span><br><span class="line">edge [cnt ]. to = v;</span><br><span class="line">edge [cnt ]. next = head [u];</span><br><span class="line">head [u] = cnt ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>边的遍历<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (int i= head [u];~i;i= edge [i]. next )</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt;u&lt;&lt;&quot; -&gt;&quot; &lt;&lt;edge [i].e&lt;&lt; endl ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>链式前向星不会遍历到不存在的边。<br>内存利用率高，相比vector实现的邻接表而言，可以准确开辟最多边数的内存，不像vector实现的邻接表有爆内存的风险。</p><p>如果有兴趣深入理解存图的话可以参考一下这几篇博客：<a href="https://blog.csdn.net/acdreamers/article/details/16902023" target="_blank" rel="noopener">https://blog.csdn.net/acdreamers/article/details/16902023</a></p><p><a href="https://jzqt.github.io/2015/07/21/ACM%E5%9B%BE%E8%AE%BA%E4%B9%8B%E5%AD%98%E5%9B%BE%E6%96%B9%E5%BC%8F/" target="_blank" rel="noopener">https://jzqt.github.io/2015/07/21/ACM%E5%9B%BE%E8%AE%BA%E4%B9%8B%E5%AD%98%E5%9B%BE%E6%96%B9%E5%BC%8F/</a></p><p>三种存图方式的介绍就到这里了，我最喜欢用的是第二种，好理解又方便写，但是不得不承认链式前向星的优秀，还是应该会用的。</p><p>说完了存图，我还想说一下用邻接表存了图之后该如何进行搜索（这里以bfs为例）。</p><p>我们只需要对每个顶点进行搜索即可，即bfs传递的参数为邻接表中的第一个元素。<br>直接上代码吧<br>无权值得<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e5+10;</span><br><span class="line">int dis[maxn],ans,vis[maxn],n,a,b;</span><br><span class="line">vector&lt;int&gt; v[maxn];</span><br><span class="line">int bfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">memset(dis,0,sizeof(dis));</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">q.push(x);</span><br><span class="line">vis[x]=1,dis[x]=0;</span><br><span class="line">int point;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">x=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">if(dis[x]&gt;ans)</span><br><span class="line">&#123;</span><br><span class="line">ans=dis[x];</span><br><span class="line">point=x;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;v[x].size();i++)</span><br><span class="line">&#123;</span><br><span class="line">if(!vis[v[x][i]])</span><br><span class="line">&#123;</span><br><span class="line">vis[v[x][i]]=1;</span><br><span class="line">dis[v[x][i]]=dis[x]+1;</span><br><span class="line">q.push(v[x][i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return point;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i=1;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">v[a].push_back(b);</span><br><span class="line">v[b].push_back(a);</span><br><span class="line">&#125;</span><br><span class="line">ans=0;</span><br><span class="line">int point=bfs(1);</span><br><span class="line">ans=0;</span><br><span class="line">bfs(point);</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有权值的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a,b,c,ans;</span><br><span class="line">const int maxn = 1e5+10;</span><br><span class="line">int vis[maxn],dis[maxn];//dis数组储存的就是当前点能向一个确定的方向走的最大的距离。vis就是一个标记数组防止重复访问。</span><br><span class="line">vector&lt;pair&lt;int,int&gt; &gt; v[maxn]; //用来存图，可以看成是一个二维数组,因为是有权值的，所以在vector中套用了一个pair</span><br><span class="line">int bfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">    memset(vis,0,sizeof(vis));//因为要进行多次bfs，所以每次都要清空一下数组</span><br><span class="line">    memset(dis,0,sizeof(dis));</span><br><span class="line">    vis[x]=1;//已经访问过的节点标记为1</span><br><span class="line">    int point=0;//用来储存当前所能走到的最远的点</span><br><span class="line">    queue&lt;int&gt; q;//用来实现bfs的队列</span><br><span class="line">    q.push(x);</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        x=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        if(dis[x]&gt;ans)//如果当前点能走的最大的步数大于ans，ans初始为0，如果大于就更新ans和point的值</span><br><span class="line">        &#123;</span><br><span class="line">            ans=dis[x];</span><br><span class="line">            point=x;</span><br><span class="line">        &#125;</span><br><span class="line">        pair&lt;int,int&gt; mid;</span><br><span class="line">        for(int i=0;i&lt;v[x].size();i++)//对v[x]中的每一个元素进行bfs</span><br><span class="line">        &#123;</span><br><span class="line">            mid=v[x][i];</span><br><span class="line">            if(!vis[mid.first])//没访问过就继续</span><br><span class="line">            &#123;</span><br><span class="line">                vis[mid.first]=1;//标记成已经访问过的</span><br><span class="line">                dis[mid.first]=dis[x]+mid.second;//这个点的能走的最大的距离多了一个dis[x]</span><br><span class="line">                q.push(mid.first);//放进队列以进行bfs</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return point;//把当前走到的最远的点返回</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c)</span><br><span class="line">    &#123;</span><br><span class="line">        v[a].push_back(make_pair(b,c));//存图</span><br><span class="line">        v[b].push_back(make_pair(a,c));</span><br><span class="line">    &#125;</span><br><span class="line">    ans=0;//初始化</span><br><span class="line">    int point=bfs(1);</span><br><span class="line">    ans=0;</span><br><span class="line">    bfs(point);//第二次以某一端点位起点的bfs</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里只需要看一下对邻接表中vector下标的使用即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的学习及刷题的过程中遇到了一些新的知识——树的直径，和前几天学到但没使用过的邻接表存图以及链式前向星存图。内容也不少，所以特意新开一篇文章进行介绍。
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="Algorithm" scheme="https://cndrew.cn/blog/tags/Algorithm/"/>
    
      <category term="BFS" scheme="https://cndrew.cn/blog/tags/BFS/"/>
    
      <category term="树的直径" scheme="https://cndrew.cn/blog/tags/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"/>
    
      <category term="邻接表" scheme="https://cndrew.cn/blog/tags/%E9%82%BB%E6%8E%A5%E8%A1%A8/"/>
    
      <category term="“链式前向星”" scheme="https://cndrew.cn/blog/tags/%E2%80%9C%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F%E2%80%9D/"/>
    
  </entry>
  
  <entry>
    <title>HPU Summer Training Day 9（河南理工大学暑期第九天）</title>
    <link href="https://cndrew.cn/blog/2019/07/25/d9/"/>
    <id>https://cndrew.cn/blog/2019/07/25/d9/</id>
    <published>2019-07-25T14:21:15.879Z</published>
    <updated>2019-07-25T14:38:43.067Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天主要讲了树的直径，是用bfs和dfs实现的，但是我的dfs，emm，一言难尽，所以我只用了bfs。<a id="more"></a><br>关于今天刷题遇到的主要的知识，请去这里查看。</p><center><font color="red">-------------------------------------&gt;<a href="https://cndrew.cn/blog/2019/07/25/mapsave">戳这里</a>&lt;-------------------------------------</font></center><h3 id="Labyrinth"><a href="#Labyrinth" class="headerlink" title="Labyrinth"></a>Labyrinth</h3><p>Description:<br>The northern part of the Pyramid contains a very large and complicated labyrinth. The labyrinth is divided into square blocks, each of them either filled by rock, or free. There is also a little hook on the floor in the center of every free block. The ACM have found that two of the hooks must be connected by a rope that runs through the hooks in every block on the path between the connected ones. When the rope is fastened, a secret door opens. The problem is that we do not know which hooks to connect. That means also that the neccessary length of the rope is unknown. Your task is to determine the maximum length of the rope we could need for a given labyrinth.<br>Input</p><blockquote><p>The input consists of T test cases. The number of them (T) is given on the first line of the input file. Each test case begins with a line containing two integers C and R (3 &lt;= C,R &lt;= 1000) indicating the number of columns and rows. Then exactly R lines follow, each containing C characters. These characters specify the labyrinth. Each of them is either a hash mark (#) or a period (.). Hash marks represent rocks, periods are free blocks. It is possible to walk between neighbouring blocks only, where neighbouring blocks are blocks sharing a common side. We cannot walk diagonally and we cannot step out of the labyrinth.</p></blockquote><blockquote><p>The labyrinth is designed in such a way that there is exactly one path between any two free blocks. Consequently, if we find the proper hooks to connect, it is easy to find the right path connecting them.<br>Output<br>Your program must print exactly one line of output for each test case. The line must contain the sentence &quot;Maximum rope length is X.&quot; where Xis the length of the longest path between any two free blocks, measured in blocks.</p></blockquote><p>Sample Input</p><blockquote><p>2<br>3 3</p></blockquote><p>###</p><p>#.#</p><p>###<br>7 6</p><p>#######</p><p>#.#.###</p><p>#.#.###</p><p>#.#.#.#</p><p>#.....#</p><p>#######</p><p>Sample Output</p><blockquote><p>Maximum rope length is 0.<br>Maximum rope length is 8.</p></blockquote><p>Hint</p><blockquote><p>Huge input, scanf is recommended.<br>If you use recursion, maybe stack overflow. and now C++/c &#39;s stack size is larger than G++/gcc</p></blockquote><p>Problem solving:<br>这一题是最简单的求树的直径的题，bfs两次即可，注意虽然第一次开始查找的位置可以是任意的，但是第二次开始的位置应该是第一次查找到最后的那个位置，还有就是两个bfs之间不要忘了memset。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int dis[1005][1005];</span><br><span class="line">int vis[1005][1005];</span><br><span class="line">char s[1005][1005];</span><br><span class="line">int d[4][2]=&#123;1,0,0,1,-1,0,0,-1&#125;;</span><br><span class="line">struct node&#123;</span><br><span class="line">int x,y;</span><br><span class="line">&#125;;</span><br><span class="line">int n,c,r,sx,sy;</span><br><span class="line">int bfs(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">node now,mid;</span><br><span class="line">queue&lt;node&gt; que;</span><br><span class="line">now.x=x;now.y=y;</span><br><span class="line">que.push(now);</span><br><span class="line">vis[x][y]=1;dis[x][y]=0;</span><br><span class="line">while(!que.empty())</span><br><span class="line">&#123;</span><br><span class="line">now=que.front();</span><br><span class="line">que.pop();</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">mid.x=now.x+d[i][0];</span><br><span class="line">mid.y=now.y+d[i][1];</span><br><span class="line">if(mid.x&lt;0||mid.x&gt;=r||mid.y&lt;0||mid.y&gt;=c||s[mid.x][mid.y]==&apos;#&apos;||vis[mid.x][mid.y])continue;</span><br><span class="line">vis[mid.x][mid.y]=1;</span><br><span class="line">dis[mid.x][mid.y]=dis[now.x][now.y]+1;</span><br><span class="line">que.push(mid);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">while(n--)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">memset(dis,0,sizeof(dis));</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;c,&amp;r);</span><br><span class="line">int flag=0;</span><br><span class="line">for(int i=0;i&lt;r;i++)scanf(&quot;%s&quot;,s[i]);</span><br><span class="line">for(int i=0;i&lt;r;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;c;j++)</span><br><span class="line">&#123;</span><br><span class="line">if(s[i][j]==&apos;.&apos;)</span><br><span class="line">&#123;</span><br><span class="line">sx=i,sy=j;</span><br><span class="line">flag=1;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">if(flag)break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bfs(sx,sy);int px=0;</span><br><span class="line">for(int i=0;i&lt;r;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;c;j++)</span><br><span class="line">&#123;</span><br><span class="line">if(dis[i][j]&gt;px)</span><br><span class="line">&#123;</span><br><span class="line">sx=i;</span><br><span class="line">sy=j;</span><br><span class="line">px=dis[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">memset(dis,0,sizeof(dis));</span><br><span class="line">bfs(sx,sy);</span><br><span class="line">int ans=0;</span><br><span class="line">for(int i=0;i&lt;r;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;c;j++)</span><br><span class="line">&#123;</span><br><span class="line">ans=max(ans,dis[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;Maximum rope length is %d.\n&quot;,ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Cow-Marathon"><a href="#Cow-Marathon" class="headerlink" title="Cow Marathon"></a>Cow Marathon</h3><p>Description:<br>After hearing about the epidemic of obesity in the USA, Farmer John wants his cows to get more exercise, so he has committed to create a bovine marathon for his cows to run. The marathon route will include a pair of farms and a path comprised of a sequence of roads between them. Since FJ wants the cows to get as much exercise as possible he wants to find the two farms on his map that are the farthest apart from each other (distance being measured in terms of total length of road on the path between the two farms). Help him determine the distances between this farthest pair of farms.<br>有n个农田和m条路，以及每条路的方向（方向在这道题中没有用），求最长的一条路，也就是两点间的最大距离，即树的直径.<br>Input</p><blockquote><ul><li>Lines 1.....: Same input format as &quot;Navigation Nightmare&quot;.</li></ul></blockquote><p>Output</p><blockquote><ul><li>Line 1: An integer giving the distance between the farthest pair of farms.</li></ul></blockquote><p>Sample Input</p><blockquote><p>7 6<br>1 6 13 E<br>6 3 9 E<br>3 5 7 S<br>4 1 3 N<br>2 4 20 W<br>4 7 2 S</p></blockquote><p>Sample Output</p><blockquote><p>52</p></blockquote><p>Hint</p><blockquote><p>The longest marathon runs from farm 2 via roads 4, 1, 6 and 3 to farm 5 and is of length 20+3+13+9+7=52.</p></blockquote><p>Problem solving:<br>这道题就是一道带权的无向图求树的最大直径。<br>直接套模板即可。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a,b,c,ans,n,m;</span><br><span class="line">const int maxn = 1e5+10;</span><br><span class="line">int vis[maxn],dis[maxn];</span><br><span class="line">char s;</span><br><span class="line">vector&lt;pair&lt;int,int&gt; &gt; v[maxn];</span><br><span class="line">int bfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">memset(dis,0,sizeof(dis));</span><br><span class="line">vis[x]=1;</span><br><span class="line">int point=0;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">q.push(x);</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">x=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">if(dis[x]&gt;ans)</span><br><span class="line">&#123;</span><br><span class="line">ans=dis[x];</span><br><span class="line">point=x;</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;int,int&gt; mid;</span><br><span class="line">for(int i=0;i&lt;v[x].size();i++)</span><br><span class="line">&#123;</span><br><span class="line">mid=v[x][i];</span><br><span class="line">if(!vis[mid.first])</span><br><span class="line">&#123;</span><br><span class="line">vis[mid.first]=1;</span><br><span class="line">dis[mid.first]=dis[x]+mid.second;</span><br><span class="line">q.push(mid.first);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return point;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">while(m--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;s;</span><br><span class="line">v[a].push_back(make_pair(b,c));</span><br><span class="line">v[b].push_back(make_pair(a,c));</span><br><span class="line">&#125;</span><br><span class="line">ans=0;</span><br><span class="line">int point=bfs(1);</span><br><span class="line">ans=0;</span><br><span class="line">bfs(point);</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Roads-in-the-North"><a href="#Roads-in-the-North" class="headerlink" title="Roads in the North"></a>Roads in the North</h3><p>Description:<br>Building and maintaining roads among communities in the far North is an expensive business. With this in mind, the roads are build such that there is only one route from a village to a village that does not pass through some other village twice.<br>Given is an area in the far North comprising a number of villages and roads among them such that any village can be reached by road from any other village. Your job is to find the road distance between the two most remote villages in the area.</p><p>The area has up to 10,000 villages connected by road segments. The villages are numbered from 1.<br>Input</p><blockquote><p>Input to the problem is a sequence of lines, each containing three positive integers: the number of a village, the number of a different village, and the length of the road segment connecting the villages in kilometers. All road segments are two-way.</p></blockquote><p>Output</p><blockquote><p>You are to output a single integer: the road distance between the two most remote villages in the area.</p></blockquote><p>Sample Input</p><blockquote><p>5 1 6<br>1 4 5<br>6 3 9<br>2 6 8<br>6 1 7</p></blockquote><p>Sample Output</p><blockquote><p>22</p></blockquote><p>Problem solving:<br>同B，直接套模板即可。这里是输入组数不确定，所以直接while(cin)即可。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a,b,c,ans;</span><br><span class="line">const int maxn = 1e5+10;</span><br><span class="line">int vis[maxn],dis[maxn];</span><br><span class="line">vector&lt;pair&lt;int,int&gt; &gt; v[maxn];</span><br><span class="line">int bfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">memset(dis,0,sizeof(dis));</span><br><span class="line">vis[x]=1;</span><br><span class="line">int point=0;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">q.push(x);</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">x=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">if(dis[x]&gt;ans)</span><br><span class="line">&#123;</span><br><span class="line">ans=dis[x];</span><br><span class="line">point=x;</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;int,int&gt; mid;</span><br><span class="line">for(int i=0;i&lt;v[x].size();i++)</span><br><span class="line">&#123;</span><br><span class="line">mid=v[x][i];</span><br><span class="line">if(!vis[mid.first])</span><br><span class="line">&#123;</span><br><span class="line">vis[mid.first]=1;</span><br><span class="line">dis[mid.first]=dis[x]+mid.second;</span><br><span class="line">q.push(mid.first);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return point;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c)</span><br><span class="line">&#123;</span><br><span class="line">v[a].push_back(make_pair(b,c));</span><br><span class="line">v[b].push_back(make_pair(a,c));</span><br><span class="line">&#125;</span><br><span class="line">ans=0;</span><br><span class="line">int point=bfs(1);</span><br><span class="line">ans=0;</span><br><span class="line">bfs(point);</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Computer"><a href="#Computer" class="headerlink" title="Computer"></a>Computer</h3><p>Description:<br>一所学校不久前买了第一台电脑（所以这台电脑的ID是1）。近年来，学校购买了N-1新电脑。每台新电脑都连接到一台先前安装的电脑上。学校的管理人员担心网络运行缓慢，希望知道第i台计算机需要发送信号的最大距离si（即到最远计算机的电缆长度）。您需要提供此信息。<br><img src="https://i.loli.net/2019/07/25/5d3973a05d63146229.png" alt></p><p>提示：示例输入与此图对应。从图中，你可以看到计算机4离1最远，所以s1=3。计算机4和5是距离2最远的，所以s2=2。计算机5是离3最远的，所以s3=3。我们也得到了s4=4，s5=4。<br>输入</p><blockquote><p>输入文件包含多组测试样例。在每组样例中，第一行中都有自然数n（n&lt;=10000），然后是（n-1）行，其中包含对计算机的描述。第i行包含两个自然数-第i计算机所连接的计算机和用于连接的电缆长度。电缆总长度不超过1e9。输入行中的数字用空格分隔。</p></blockquote><p>输出</p><blockquote><p>对于每组样例，输出n行。第i行第i台计算机的到其他计算机的最大长度Si（1&lt;=i&lt;=n）。</p></blockquote><p>样例输入</p><blockquote><p>5<br>1 1<br>2 1<br>3 1<br>1 1</p></blockquote><p>样例输出</p><blockquote><p>3<br>2<br>3<br>4<br>4</p></blockquote><p>提示</p><blockquote><p>示例输入与此图对应。从图中，你可以看到计算机4离1最远，所以s1=3。计算机4和5是距离2最远的，所以s2=2。计算机5是离3最远的，所以s3=3。我们也得到了s4=4，s5=4。</p></blockquote><p>Problem solving:<br>这道题应该是今天最难的题了。一开始毫无思路，但是后来听了学长一句话。离某个点最远的一定是树的直径的端点。我们第一次bfs结束时的点是这个树的两个端点之一，再以这个端点就行bfs结束的时候就到了另外一个端点，而且我们在查找的过程中使用的dis数组就是当前位置距离将要到达的！！端点！！的距离，所以就在bfs一次，与上一次得到的距离去max最大值即可。总结一下就是三次bfs。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const long long maxn=1e5;</span><br><span class="line">long long n,a,b,ans;</span><br><span class="line">long long vis[maxn],dis[maxn],dis2[maxn];</span><br><span class="line">vector&lt;pair&lt;long long,long long&gt; &gt; v[maxn];</span><br><span class="line">long long bfs(long long x)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">memset(dis,0,sizeof(dis));</span><br><span class="line">ans=0;</span><br><span class="line">queue&lt;long long&gt; q;</span><br><span class="line">q.push(x);</span><br><span class="line">vis[x]=1;</span><br><span class="line">long long point;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">x=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">if(dis[x]&gt;ans)</span><br><span class="line">&#123;</span><br><span class="line">ans=dis[x];</span><br><span class="line">point=x;</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;long long,long long&gt; mid;</span><br><span class="line">for(long long i=0;i&lt;v[x].size();i++)</span><br><span class="line">&#123;</span><br><span class="line">mid=v[x][i];</span><br><span class="line">if(!vis[mid.first])</span><br><span class="line">&#123;</span><br><span class="line">vis[mid.first]=1;</span><br><span class="line">dis[mid.first]=dis[x]+mid.second;</span><br><span class="line">q.push(mid.first);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return point;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(cin&gt;&gt;n)</span><br><span class="line">&#123;</span><br><span class="line">memset(v,0,sizeof(v));</span><br><span class="line">for(long long i=2;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">v[a].push_back(make_pair(i,b));</span><br><span class="line">v[i].push_back(make_pair(a,b));</span><br><span class="line">&#125;</span><br><span class="line">long long point=bfs(1);</span><br><span class="line">long long next=bfs(point);</span><br><span class="line">for(long long i=1;i&lt;=n;i++)dis2[i]=dis[i];</span><br><span class="line">bfs(next);</span><br><span class="line">for(long long i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;max(dis2[i],dis[i])&lt;&lt;endl;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Farthest-Nodes-in-a-Tree"><a href="#Farthest-Nodes-in-a-Tree" class="headerlink" title="Farthest Nodes in a Tree"></a>Farthest Nodes in a Tree</h3><p>Description:<br>Given a tree (a connected graph with no cycles), you have to find the farthest nodes in the tree. The edges of the tree are weighted and undirected. That means you have to find two nodes in the tree whose distance is maximum amongst all nodes.</p><p>Input</p><blockquote><p>Input starts with an integer T (≤ 10), denoting the number of test cases.<br>Each case starts with an integer n (2 ≤ n ≤ 30000) denoting the total number of nodes in the tree. The nodes are numbered from 0 to n-1. Each of the next n-1 lines will contain three integers u v w (0 ≤ u, v &lt; n, u ≠ v, 1 ≤ w ≤ 10000) denoting that node u and v are connected by an edge whose weight is w. You can assume that the input will form a valid tree.</p></blockquote><p>Output</p><blockquote><p>For each case, print the case number and the maximum distance.</p></blockquote><p>Sample Input</p><blockquote><p>2<br>4<br>0 1 20<br>1 2 30<br>2 3 50<br>5<br>0 2 20<br>2 1 10<br>0 3 29<br>0 4 50</p></blockquote><p>Sample Output</p><blockquote><p>Case 1: 100<br>Case 2: 80</p></blockquote><p>Problem solving:<br>同BC，直接套模板就行。然后就是输出格式的控制</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">const int maxn= 1e5+10;</span><br><span class="line">using namespace std;</span><br><span class="line">int dis[maxn],ans;</span><br><span class="line">bool vis[maxn];</span><br><span class="line">vector&lt;pair&lt;int,int&gt; &gt; v[maxn];</span><br><span class="line">int bfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">memset(dis,0,sizeof(dis));</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">queue&lt;int&gt; que;</span><br><span class="line">que.push(x);vis[x]=1;</span><br><span class="line">int point=0;</span><br><span class="line">while(!que.empty())</span><br><span class="line">&#123;</span><br><span class="line">int f=que.front();</span><br><span class="line">que.pop();</span><br><span class="line">if(dis[f]&gt;ans)</span><br><span class="line">&#123;</span><br><span class="line">ans=dis[f];</span><br><span class="line">point=f;</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;int,int&gt; t;</span><br><span class="line">for(int i=0;i&lt;v[f].size();i++)</span><br><span class="line">&#123;</span><br><span class="line">t=v[f][i];</span><br><span class="line">if(vis[t.first]==0)</span><br><span class="line">&#123;</span><br><span class="line">vis[t.first]=1;</span><br><span class="line">dis[t.first]=dis[f]+t.second;</span><br><span class="line">que.push(t.first);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return point;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,m,x,y,z,flag=0;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">while(n--)</span><br><span class="line">&#123;</span><br><span class="line">memset(v,0,sizeof(v));</span><br><span class="line">cin&gt;&gt;m;</span><br><span class="line">for(int i=1;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">v[x].push_back(make_pair(y,z));</span><br><span class="line">v[y].push_back(make_pair(x,z));</span><br><span class="line">&#125;</span><br><span class="line">ans=0;</span><br><span class="line">int point=bfs(1);</span><br><span class="line">ans=0;</span><br><span class="line">bfs(point);</span><br><span class="line">printf(&quot;Case %d: %d\n&quot;,++flag,ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="51nod-2602-树的直径"><a href="#51nod-2602-树的直径" class="headerlink" title="51nod 2602 树的直径"></a>51nod 2602 树的直径</h3><p>Description:<br>一棵树的直径就是这棵树上存在的最长路径。现在有一棵n个节点的树，现在想知道这棵树的直径包含的边的个数是多少？<br><img src="https://i.loli.net/2019/07/25/5d3973771759017661.png" alt></p><p>如图所示的数据，这棵树的直径为(1-2-3-6-9)这条路径，包含的边的个数为4，所以答案是4。</p><p>输入</p><blockquote><p>第1行：一个整数n，表示树上的节点个数。(1&lt;=n&lt;=100000)<br>第2-n行：每行有两个整数u,v,表示u与v之间有一条路径。(1&lt;=u,v&lt;=n)</p></blockquote><p>输出</p><blockquote><p>输出一个整数，表示这棵树直径所包含的边的个数。</p></blockquote><p>输入样例</p><blockquote><p>10<br>1 2<br>2 3<br>3 4<br>3 5<br>3 6<br>3 7<br>3 10<br>6 8<br>6 9</p></blockquote><p>输出样例</p><blockquote><p>4</p></blockquote><p>Problem solving:<br>求树的直径的模板题。不过无权值。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e5+10;</span><br><span class="line">int dis[maxn],ans,vis[maxn],n,a,b;</span><br><span class="line">vector&lt;int&gt; v[maxn];</span><br><span class="line">int bfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">memset(dis,0,sizeof(dis));</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">q.push(x);</span><br><span class="line">vis[x]=1,dis[x]=0;</span><br><span class="line">int point;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">x=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">if(dis[x]&gt;ans)</span><br><span class="line">&#123;</span><br><span class="line">ans=dis[x];</span><br><span class="line">point=x;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;v[x].size();i++)</span><br><span class="line">&#123;</span><br><span class="line">if(!vis[v[x][i]])</span><br><span class="line">&#123;</span><br><span class="line">vis[v[x][i]]=1;</span><br><span class="line">dis[v[x][i]]=dis[x]+1;</span><br><span class="line">q.push(v[x][i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return point;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i=1;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">v[a].push_back(b);</span><br><span class="line">v[b].push_back(a);</span><br><span class="line">&#125;</span><br><span class="line">ans=0;</span><br><span class="line">int point=bfs(1);</span><br><span class="line">ans=0;</span><br><span class="line">bfs(point);</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>上面有三道题我都直接说得套模板。那么求树的直径的模板是什么呢？这里只写上带权的吧，不带权的可以类比得出。或者去这里看：<center><font color="red">------------------------------&gt;<a href="https://cndrew.cn/blog/2019/07/25/mapsave">戳这里</a>&lt;------------------------------</font></center></p><p>在这里我结合代码想详细的分析一下这个模板。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a,b,c,ans;</span><br><span class="line">const int maxn = 1e5+10;</span><br><span class="line">int vis[maxn],dis[maxn];//dis数组储存的就是当前点能向一个确定的方向走的最大的距离。vis就是一个标记数组防止重复访问。</span><br><span class="line">vector&lt;pair&lt;int,int&gt; &gt; v[maxn]; //用来存图，可以看成是一个二维数组,因为是有权值的，所以在vector中套用了一个pair</span><br><span class="line">int bfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">    memset(vis,0,sizeof(vis));//因为要进行多次bfs，所以每次都要清空一下数组</span><br><span class="line">    memset(dis,0,sizeof(dis));</span><br><span class="line">    vis[x]=1;//已经访问过的节点标记为1</span><br><span class="line">    int point=0;//用来储存当前所能走到的最远的点</span><br><span class="line">    queue&lt;int&gt; q;//用来实现bfs的队列</span><br><span class="line">    q.push(x);</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        x=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        if(dis[x]&gt;ans)//如果当前点能走的最大的步数大于ans，ans初始为0，如果大于就更新ans和point的值</span><br><span class="line">        &#123;</span><br><span class="line">            ans=dis[x];</span><br><span class="line">            point=x;</span><br><span class="line">        &#125;</span><br><span class="line">        pair&lt;int,int&gt; mid;</span><br><span class="line">        for(int i=0;i&lt;v[x].size();i++)//对v[x]中的每一个元素进行bfs</span><br><span class="line">        &#123;</span><br><span class="line">            mid=v[x][i];</span><br><span class="line">            if(!vis[mid.first])//没访问过就继续</span><br><span class="line">            &#123;</span><br><span class="line">                vis[mid.first]=1;//标记成已经访问过的</span><br><span class="line">                dis[mid.first]=dis[x]+mid.second;//这个点的能走的最大的距离多了一个dis[x]</span><br><span class="line">                q.push(mid.first);//放进队列以进行bfs</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return point;//把当前走到的最远的点返回</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c)</span><br><span class="line">    &#123;</span><br><span class="line">        v[a].push_back(make_pair(b,c));//存图</span><br><span class="line">        v[b].push_back(make_pair(a,c));</span><br><span class="line">    &#125;</span><br><span class="line">    ans=0;//初始化</span><br><span class="line">    int point=bfs(1);</span><br><span class="line">    ans=0;</span><br><span class="line">    bfs(point);//第二次以某一端点位起点的bfs</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="学长标程"><a href="#学长标程" class="headerlink" title="学长标程"></a>学长标程</h3><p>学长写的代码比我的好看多了。。。贴一下</p><h4 id="Labyrinth-1"><a href="#Labyrinth-1" class="headerlink" title="Labyrinth"></a>Labyrinth</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int N,M,u,v,ans;</span><br><span class="line">int dir[4][2]=&#123;1,0,0,1,-1,0,0,-1&#125;;</span><br><span class="line">char MAP[1200][1200];</span><br><span class="line">bool vis[1200][1200];</span><br><span class="line">void dfs(int x,int y,int res)&#123;</span><br><span class="line">for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">int nx=dir[i][0]+x;</span><br><span class="line">int ny=dir[i][1]+y;</span><br><span class="line">if(nx&gt;=0&amp;&amp;nx&lt;N&amp;&amp;ny&gt;=0&amp;&amp;ny&lt;M&amp;&amp;vis[nx][ny]==0&amp;&amp;MAP[nx][ny]==&apos;.&apos;)&#123;</span><br><span class="line">vis[nx][ny]=1;</span><br><span class="line">dfs(nx,ny,res+1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(res&gt;=ans)&#123;</span><br><span class="line">u=x;v=y;ans=res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">int T;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;T);</span><br><span class="line">while(T--)&#123;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;M,&amp;N);</span><br><span class="line">for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">scanf(&quot;%s&quot;,&amp;MAP[i]);</span><br><span class="line">&#125;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">ans=0;</span><br><span class="line">for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">for(int j=0;j&lt;M;j++)&#123;</span><br><span class="line">if(MAP[i][j]==&apos;.&apos;)&#123;</span><br><span class="line">dfs(i,j,0);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">dfs(u,v,0);</span><br><span class="line">cout&lt;&lt;&quot;Maximum rope length is &quot;&lt;&lt;ans&lt;&lt;&apos;.&apos;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Cow-Marathon-1"><a href="#Cow-Marathon-1" class="headerlink" title="Cow Marathon"></a>Cow Marathon</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int N,M,X,Y,Z,ans;</span><br><span class="line">int dis[40020];</span><br><span class="line">bool vis[40020];</span><br><span class="line">vector&lt;pair&lt;int,int&gt; &gt;V[40020];</span><br><span class="line">int bfs(int n)&#123;</span><br><span class="line">memset(dis,0,sizeof(dis));</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">queue&lt;int&gt;Q;</span><br><span class="line">Q.push(n);</span><br><span class="line">vis[n]=1;</span><br><span class="line">ans=0;</span><br><span class="line">int point=0,t;</span><br><span class="line">while(!Q.empty())&#123;</span><br><span class="line">t=Q.front();</span><br><span class="line">Q.pop();</span><br><span class="line">if(dis[t]&gt;ans)&#123;</span><br><span class="line">ans=dis[t];</span><br><span class="line">point=t;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;V[t].size();i++)&#123;</span><br><span class="line">if(vis[V[t][i].first]==0)&#123;</span><br><span class="line">vis[V[t][i].first]=1;</span><br><span class="line">dis[V[t][i].first]=dis[t]+V[t][i].second;</span><br><span class="line">Q.push(V[t][i].first);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return point;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;N,&amp;M);</span><br><span class="line">for(int i=0;i&lt;M;i++)&#123;</span><br><span class="line">scanf(&quot;%d%d%d %*c&quot;,&amp;X,&amp;Y,&amp;Z);</span><br><span class="line">V[X].push_back(make_pair(Y,Z));</span><br><span class="line">V[Y].push_back(make_pair(X,Z));</span><br><span class="line">&#125;</span><br><span class="line">bfs(bfs(1));</span><br><span class="line">printf(&quot;%d\n&quot;,ans);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Roads-in-the-North-1"><a href="#Roads-in-the-North-1" class="headerlink" title="Roads in the North"></a>Roads in the North</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int N,M,X,Y,Z,ans;</span><br><span class="line">int dis[40020];</span><br><span class="line">bool vis[40020];</span><br><span class="line">vector&lt;pair&lt;int,int&gt; &gt;V[40020];</span><br><span class="line">int bfs(int n)&#123;</span><br><span class="line">memset(dis,0,sizeof(dis));</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">queue&lt;int&gt;Q;</span><br><span class="line">Q.push(n);</span><br><span class="line">vis[n]=1;</span><br><span class="line">ans=0;</span><br><span class="line">int point=0,t;</span><br><span class="line">while(!Q.empty())&#123;</span><br><span class="line">t=Q.front();</span><br><span class="line">Q.pop();</span><br><span class="line">if(dis[t]&gt;ans)&#123;</span><br><span class="line">ans=dis[t];</span><br><span class="line">point=t;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;V[t].size();i++)&#123;</span><br><span class="line">if(vis[V[t][i].first]==0)&#123;</span><br><span class="line">vis[V[t][i].first]=1;</span><br><span class="line">dis[V[t][i].first]=dis[t]+V[t][i].second;</span><br><span class="line">Q.push(V[t][i].first);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return point;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">while(scanf(&quot;%d%d%d&quot;,&amp;X,&amp;Y,&amp;Z)!=EOF)&#123;</span><br><span class="line">V[X].push_back(make_pair(Y,Z));</span><br><span class="line">V[Y].push_back(make_pair(X,Z));</span><br><span class="line">&#125;</span><br><span class="line">bfs(bfs(1));</span><br><span class="line">printf(&quot;%d\n&quot;,ans);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Computer-1"><a href="#Computer-1" class="headerlink" title="Computer"></a>Computer</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int N,M,X,Y,Z,ans;</span><br><span class="line">int dis[40020];</span><br><span class="line">int diss[40020];</span><br><span class="line">bool vis[40020];</span><br><span class="line">vector&lt;pair&lt;int,int&gt; &gt;V[40020];</span><br><span class="line">int bfs(int n)&#123;</span><br><span class="line">memset(dis,0,sizeof(dis));</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">queue&lt;int&gt;Q;</span><br><span class="line">Q.push(n);</span><br><span class="line">vis[n]=1;</span><br><span class="line">ans=0;</span><br><span class="line">int point,t;</span><br><span class="line">while(!Q.empty())&#123;</span><br><span class="line">t=Q.front();</span><br><span class="line">Q.pop();</span><br><span class="line">if(dis[t]&gt;ans)&#123;</span><br><span class="line">ans=dis[t];</span><br><span class="line">point=t;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;V[t].size();i++)&#123;</span><br><span class="line">if(vis[V[t][i].first]==0)&#123;</span><br><span class="line">vis[V[t][i].first]=1;</span><br><span class="line">dis[V[t][i].first]=dis[t]+V[t][i].second;</span><br><span class="line">Q.push(V[t][i].first);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return point;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">while(scanf(&quot;%d&quot;,&amp;N)!=EOF)&#123;</span><br><span class="line">for(int i=0;i&lt;=N;i++)V[i].clear();</span><br><span class="line">for(int i=1;i&lt;N;i++)&#123;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;X,&amp;Z);</span><br><span class="line">V[i+1].push_back(make_pair(X,Z));</span><br><span class="line">V[X].push_back(make_pair(i+1,Z));</span><br><span class="line">&#125;</span><br><span class="line">int point=bfs(bfs(1));</span><br><span class="line">for(int i=1;i&lt;=N;i++)&#123;</span><br><span class="line">diss[i]=dis[i];</span><br><span class="line">&#125;</span><br><span class="line">bfs(point);</span><br><span class="line">for(int i=1;i&lt;=N;i++)&#123;</span><br><span class="line">printf(&quot;%d\n&quot;,max(dis[i],diss[i]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Farthest-Nodes-in-a-Tree-1"><a href="#Farthest-Nodes-in-a-Tree-1" class="headerlink" title="Farthest Nodes in a Tree"></a>Farthest Nodes in a Tree</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int N,M,X,Y,Z,ans;</span><br><span class="line">int dis[40020];</span><br><span class="line">bool vis[40020];</span><br><span class="line">vector&lt;pair&lt;int,int&gt; &gt;V[40020];</span><br><span class="line">int bfs(int n)&#123;</span><br><span class="line">memset(dis,0,sizeof(dis));</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">queue&lt;int&gt;Q;</span><br><span class="line">Q.push(n);</span><br><span class="line">vis[n]=1;</span><br><span class="line">ans=0;</span><br><span class="line">int point,t;</span><br><span class="line">while(!Q.empty())&#123;</span><br><span class="line">t=Q.front();</span><br><span class="line">Q.pop();</span><br><span class="line">if(dis[t]&gt;ans)&#123;</span><br><span class="line">ans=dis[t];</span><br><span class="line">point=t;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;V[t].size();i++)&#123;</span><br><span class="line">if(vis[V[t][i].first]==0)&#123;</span><br><span class="line">vis[V[t][i].first]=1;</span><br><span class="line">dis[V[t][i].first]=dis[t]+V[t][i].second;</span><br><span class="line">Q.push(V[t][i].first);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return point;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">int T,Case=1;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;T);</span><br><span class="line">while(T--)&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;N);</span><br><span class="line">for(int i=0;i&lt;N;i++)V[i].clear();</span><br><span class="line">for(int i=1;i&lt;N;i++)&#123;</span><br><span class="line">scanf(&quot;%d%d%d&quot;,&amp;X,&amp;Y,&amp;Z);</span><br><span class="line">V[X].push_back(make_pair(Y,Z));</span><br><span class="line">V[Y].push_back(make_pair(X,Z));</span><br><span class="line">&#125;</span><br><span class="line">bfs(bfs(0));</span><br><span class="line">printf(&quot;Case %d: %d\n&quot;,Case++,ans);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int N,M,X,Y,Z,ans;</span><br><span class="line">int dis[100020];</span><br><span class="line">bool vis[100020];</span><br><span class="line">vector&lt;pair&lt;int,int&gt; &gt;V[100020];</span><br><span class="line">int bfs(int n)&#123;</span><br><span class="line">memset(dis,0,sizeof(dis));</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">queue&lt;int&gt;Q;</span><br><span class="line">Q.push(n);</span><br><span class="line">vis[n]=1;</span><br><span class="line">ans=0;</span><br><span class="line">int point,t;</span><br><span class="line">while(!Q.empty())&#123;</span><br><span class="line">t=Q.front();</span><br><span class="line">Q.pop();</span><br><span class="line">if(dis[t]&gt;ans)&#123;</span><br><span class="line">ans=dis[t];</span><br><span class="line">point=t;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;V[t].size();i++)&#123;</span><br><span class="line">if(vis[V[t][i].first]==0)&#123;</span><br><span class="line">vis[V[t][i].first]=1;</span><br><span class="line">dis[V[t][i].first]=dis[t]+V[t][i].second;</span><br><span class="line">Q.push(V[t][i].first);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return point;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;N);</span><br><span class="line">for(int i=1;i&lt;N;i++)&#123;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;X,&amp;Y);</span><br><span class="line">V[X].push_back(make_pair(Y,1));</span><br><span class="line">V[Y].push_back(make_pair(X,1));</span><br><span class="line">&#125;</span><br><span class="line">bfs(bfs(1));</span><br><span class="line">printf(&quot;%d\n&quot;,ans);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天主要讲了树的直径，是用bfs和dfs实现的，但是我的dfs，emm，一言难尽，所以我只用了bfs。
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="Algorithm" scheme="https://cndrew.cn/blog/tags/Algorithm/"/>
    
      <category term="HDU" scheme="https://cndrew.cn/blog/tags/HDU/"/>
    
      <category term="51nod" scheme="https://cndrew.cn/blog/tags/51nod/"/>
    
      <category term="poj" scheme="https://cndrew.cn/blog/tags/poj/"/>
    
      <category term="BFS" scheme="https://cndrew.cn/blog/tags/BFS/"/>
    
      <category term="树的直径" scheme="https://cndrew.cn/blog/tags/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>HPU Summer Training Day 8（河南理工大学暑期第八天）</title>
    <link href="https://cndrew.cn/blog/2019/07/24/d8/"/>
    <id>https://cndrew.cn/blog/2019/07/24/d8/</id>
    <published>2019-07-24T14:11:20.567Z</published>
    <updated>2019-07-24T14:17:56.359Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天主要讲的是递归和DFS，因为涉及到递归，很抽象，所以比较难理解。题也很难做。<a id="more"></a></p><h3 id="Oil-Deposits"><a href="#Oil-Deposits" class="headerlink" title="Oil Deposits"></a>Oil Deposits</h3><p>Description：<br>The GeoSurvComp geologic survey company is responsible for detecting underground oil deposits. GeoSurvComp works with one large rectangular region of land at a time, and creates a grid that divides the land into numerous square plots. It then analyzes each plot separately, using sensing equipment to determine whether or not the plot contains oil. A plot containing oil is called a pocket. If two pockets are adjacent, then they are part of the same oil deposit. Oil deposits can be quite large and may contain numerous pockets. Your job is to determine how many different oil deposits are contained in a grid.<br>Input<br>The input file contains one or more grids. Each grid begins with a line containing m and n, the number of rows and columns in the grid, separated by a single space. If m = 0 it signals the end of the input; otherwise 1 &lt;= m &lt;= 100 and 1 &lt;= n &lt;= 100. Following this are m lines of n characters each (not counting the end-of-line characters). Each character corresponds to one plot, and is either `*&#39;, representing the absence of oil, or `@&#39;, representing an oil pocket.</p><p>Output</p><blockquote><p>For each grid, output the number of distinct oil deposits. Two different pockets are part of the same oil deposit if they are adjacent horizontally, vertically, or diagonally. An oil deposit will not contain more than 100 pockets.</p></blockquote><p>Sample Input<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1 1</span><br><span class="line">*</span><br><span class="line">3 5</span><br><span class="line">*@*@*</span><br><span class="line">**@**</span><br><span class="line">*@*@*</span><br><span class="line">1 8</span><br><span class="line">@@****@*</span><br><span class="line">5 5</span><br><span class="line">****@</span><br><span class="line">*@@*@</span><br><span class="line">*@**@</span><br><span class="line">@@@*@</span><br><span class="line">@@**@</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure></p><p>Sample Output</p><blockquote><p>0<br>1<br>2<br>2</p></blockquote><p>Problem solving:<br>简单题，输入一个图，@表示油田，*表示没有油田，@只要是相邻的都可以算成是一个，所以就是八个方向上dfs就行，访问过的@就换成*或者其他的字符就行只要不是@.(如果这样写的话其实就不需要标记数组了)</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">char s[105][105];</span><br><span class="line">int vis[105][105];</span><br><span class="line">int m,n,ans;</span><br><span class="line">int d[8][2]=&#123;1,0,0,1,0,-1,-1,0,1,1,1,-1,-1,-1,-1,1&#125;;</span><br><span class="line">void dfs(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">vis[x][y]=1;</span><br><span class="line">if(x&lt;0||x&gt;=m||y&lt;0||y&gt;=n)return ;</span><br><span class="line">for(int i=0;i&lt;8;i++)</span><br><span class="line">&#123;</span><br><span class="line">int dx=x+d[i][0];</span><br><span class="line">int dy=y+d[i][1];</span><br><span class="line">if(dx&gt;=0&amp;&amp;dx&lt;m&amp;&amp;dy&gt;=0&amp;&amp;dy&lt;n&amp;&amp;!vis[dx][dy]&amp;&amp;s[dx][dy]==&apos;@&apos;)</span><br><span class="line">&#123;</span><br><span class="line">s[dx][dy]=&apos;*&apos;;</span><br><span class="line">dfs(dx,dy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(cin&gt;&gt;m&gt;&gt;n&amp;&amp;m)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">ans=0;</span><br><span class="line">for(int i=0;i&lt;m;i++)cin&gt;&gt;s[i];</span><br><span class="line">for(int i=0;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line">if(s[i][j]==&apos;@&apos;)</span><br><span class="line">&#123;</span><br><span class="line">dfs(i,j);</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="How-Many-Equations-Can-You-Find"><a href="#How-Many-Equations-Can-You-Find" class="headerlink" title="How Many Equations Can You Find"></a>How Many Equations Can You Find</h3><p>Description：<br>Now give you an string which only contains 0, 1 ,2 ,3 ,4 ,5 ,6 ,7 ,8 ,9.You are asked to add the sign ‘+’ or ’-’ between the characters. Just like give you a string “12345”, you can work out a string “123+4-5”. Now give you an integer N, please tell me how many ways can you find to make the result of the string equal to N .You can only choose at most one sign between two adjacent characters.<br>Input</p><blockquote><p>Each case contains a string s and a number N . You may be sure the length of the string will not exceed 12 and the absolute value of N will not exceed 999999999999.</p></blockquote><p>Output</p><blockquote><p>The output contains one line for each data set : the number of ways you can find to make the equation.</p></blockquote><p>Sample Input</p><blockquote><p>123456789 3<br>21 1</p></blockquote><p>Sample Output</p><blockquote><p>18<br>1</p></blockquote><p>Problem solving:<br>每两个数中间都有两种可能，一种是加号一种是减号，并且能放入操作符的位置我们也是知道的，所以只需要查找每个位置放上不同的运算符之后得到的所有结果，看有几个与n相等即可。查找的过程用dfs来实现。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">string s;int n,ans;</span><br><span class="line">void dfs(int x,int now)//x代表的是当前要进行操作的位置，now代表当前得到的值</span><br><span class="line">&#123;</span><br><span class="line">if(x==s.size())//如果x已经跟字符串的长度相等说明这一次遍历已经结束了</span><br><span class="line">&#123;</span><br><span class="line">if(now==n)ans++;//如果得到的值跟n相等，答案就加一</span><br><span class="line">//cout&lt;&lt;now&lt;&lt;endl;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=x;i&lt;s.size();i++)</span><br><span class="line">&#123;</span><br><span class="line">int mid=0;</span><br><span class="line">for(int j=x;j&lt;=i;j++)</span><br><span class="line">&#123;</span><br><span class="line">mid=mid*10+s[j]-&apos;0&apos;;//得到运算符左边字符串所代表数的大小</span><br><span class="line">//cout&lt;&lt;mid&lt;&lt;&quot;?&quot;&lt;&lt;now&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">dfs(i+1,now+mid);//去访问下一个位置，并且此时的值加上上面得到的运算符左边字符串所代表的数</span><br><span class="line">if(x)dfs(i+1,now-mid);//减号不能放在最前面，所以要有一个x不为0的判断</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(cin&gt;&gt;s&gt;&gt;n)</span><br><span class="line">&#123;</span><br><span class="line">ans=0;</span><br><span class="line">dfs(0,0);//从s[0]开始，当前值为0</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h3><p>Description：<br>在N*N的方格棋盘放置了N个皇后，使得它们不相互攻击（即任意2个皇后不允许处在同一排，同一列，也不允许处在与棋盘边框成45角的斜线上。<br>你的任务是，对于给定的N，求出有多少种合法的放置方法。</p><p>Input</p><blockquote><p>共有若干行，每行一个正整数N≤10，表示棋盘和皇后的数量；如果N=0，表示结束。</p></blockquote><p>Output</p><blockquote><p>共有若干行，每行一个正整数，表示对应输入行的皇后的不同放置数量。</p></blockquote><p>Sample Input</p><blockquote><p>1<br>8<br>5<br>0</p></blockquote><p>Sample Output</p><blockquote><p>1<br>92<br>10</p></blockquote><p>Problem solving:<br>从第一行开始放，然后放下一行，如果出现了在同一行的或者同一列的或者同一条斜线上的就return，如果放进去的个数等于n，答案就加一。这道题N虽然小于等于10，但是是多组输入，如果每次输入都计算一次并且输入数据很多的话，肯定会TLE。所以需要打表，就是如果这个计算过了就把它的结果记录下来，如果下次又要求这个的结果直接调用就行。也可以直接从输入前就先计算好存进数组。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,mid;</span><br><span class="line">int ans[12],mmp[12];</span><br><span class="line">void dfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">if(x==n+1)</span><br><span class="line">&#123;</span><br><span class="line">mid++;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">int flag=1;</span><br><span class="line">mmp[x]=i;</span><br><span class="line">for(int j=1;j&lt;x;j++)</span><br><span class="line">&#123;</span><br><span class="line">if(mmp[j]==i||(abs(j-x)==abs(mmp[j]-mmp[x])))</span><br><span class="line">&#123;</span><br><span class="line">flag=0;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(flag)dfs(x+1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">for(n=1;n&lt;=10;n++)</span><br><span class="line">&#123;</span><br><span class="line">mid=0;</span><br><span class="line">dfs(1);</span><br><span class="line">ans[n]=mid;</span><br><span class="line">&#125;</span><br><span class="line">int t;</span><br><span class="line">while(cin&gt;&gt;t&amp;&amp;t)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;ans[t]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Fox-And-Two-Dots"><a href="#Fox-And-Two-Dots" class="headerlink" title="Fox And Two Dots"></a>Fox And Two Dots</h3><p>Description：<br>Fox Ciel is playing a mobile puzzle game called &quot;Two Dots&quot;. The basic levels are played on a board of size n × m cells, like this:</p><p><center><img src="https://i.loli.net/2019/07/24/5d3816e429b0036148.png" alt></center><br>Each cell contains a dot that has some color. We will use different uppercase Latin characters to express different colors.</p><p>The key of this game is to find a cycle that contain dots of same color. Consider 4 blue dots on the picture forming a circle as an example. Formally, we call a sequence of dots d1, d2, ..., dk a cycle if and only if it meets the following condition:</p><ol><li>These k dots are different: if i ≠ j then di is different from dj.</li><li>k is at least 4.</li><li>All dots belong to the same color.</li><li>For all 1 ≤ i ≤ k - 1: di and di + 1 are adjacent. Also, dk and d1 should also be adjacent. Cells x and y are called adjacent if they share an edge.</li></ol><p>Determine if there exists a cycle on the field.<br>Input</p><blockquote><p>The first line contains two integers n and m (2 ≤ n, m ≤ 50): the number of rows and columns of the board.<br>Then n lines follow, each line contains a string consisting of m characters, expressing colors of dots in each line. Each character is an uppercase Latin letter.</p></blockquote><p>Output</p><blockquote><p>Output &quot;Yes&quot; if there exists a cycle, and &quot;No&quot; otherwise.</p></blockquote><p>Examples<br>Input</p><blockquote><p>3 4<br>AAAA<br>ABCA<br>AAAA</p></blockquote><p>Output</p><blockquote><p>Yes</p></blockquote><p>Input</p><blockquote><p>3 4<br>AAAA<br>ABCA<br>AADA</p></blockquote><p>Output</p><blockquote><p>No</p></blockquote><p>Input</p><blockquote><p>4 4<br>YYYR<br>BYBY<br>BBBY<br>BBBY</p></blockquote><p>Output</p><blockquote><p>Yes</p></blockquote><p>Input</p><blockquote><p>7 6<br>AAAAAB<br>ABBBAB<br>ABAAAB<br>ABABBB<br>ABAAAB<br>ABBBAB<br>AAAAAB</p></blockquote><p>Output</p><blockquote><p>Yes</p></blockquote><p>Input</p><blockquote><p>2 13<br>ABCDEFGHIJKLM<br>NOPQRSTUVWXYZ</p></blockquote><p>Output</p><blockquote><p>No</p></blockquote><p>Note<br>In first sample test all &#39;A&#39; form a cycle.</p><p>In second sample there is no such cycle.</p><p>The third sample is displayed on the picture above (&#39;Y&#39; = Yellow, &#39;B&#39; = Blue, &#39;R&#39; = Red).<br>Problem solving:<br>这道题的意思就是输入一个由大写字母组成的图，如果相同的字母可以组成一个环，就输出Yes，否则输出No。<br>这道题跟昨天的那个机器人有点类似，不过那个机器人每次走的方向是定的，而这个是可以随意走的。<br>所以如何进行判断会不会有环的存在呢？<br>我们只需要在每次进行dfs的查找之前把最初的初始位置记录一下，然后开始dfs查找，上下左右四个方向，遇到与当前字母一样的字母就以这个为初始位置继续dfs，并且记录下来当前走的步数。如果在dfs结束之前遇到了一个(dx,dy)与我们记录的最初始的初始位置相等并且步数大于等于4的情况，就说明存在环，输出&#39;Yes&#39;即可，反之输出&#39;No&#39;。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">char s[60][60];</span><br><span class="line">int vis[60][60],flag,n,m,sx,sy;</span><br><span class="line">int d[4][2]=&#123;1,0,0,1,-1,0,0,-1&#125;;</span><br><span class="line">void dfs(int x,int y,int step)</span><br><span class="line">&#123;</span><br><span class="line">if(flag)return ;</span><br><span class="line">vis[x][y]=1;</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">int dx=x+d[i][0];</span><br><span class="line">int dy=y+d[i][1];</span><br><span class="line">if(dx==sx&amp;&amp;dy==sy&amp;&amp;step&gt;=4)</span><br><span class="line">&#123;</span><br><span class="line">flag=1;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">if(dx&gt;=0&amp;&amp;dx&lt;n&amp;&amp;dy&gt;=0&amp;&amp;dy&lt;m&amp;&amp;!vis[dx][dy]&amp;&amp;s[dx][dy]==s[x][y])</span><br><span class="line">&#123;</span><br><span class="line">dfs(dx,dy,step+1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">for(int i=0;i&lt;n;i++)cin&gt;&gt;s[i];</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;m;j++)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">sx=i,sy=j;</span><br><span class="line">dfs(sx,sy,1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(flag)puts(&quot;Yes&quot;);</span><br><span class="line">elseputs(&quot;No&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="棋盘问题"><a href="#棋盘问题" class="headerlink" title="棋盘问题"></a>棋盘问题</h3><p>Description：<br>在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。<br>Input</p><blockquote><p>输入含有多组测试数据。<br>每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n &lt;= 8 , k &lt;= n<br>当为-1 -1时表示输入结束。<br>随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。</p></blockquote><p>Output</p><blockquote><p>对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C\&lt;2^31）。</p></blockquote><p>Sample Input<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2 1</span><br><span class="line">#.</span><br><span class="line">.#</span><br><span class="line">4 4</span><br><span class="line">...#</span><br><span class="line">..#.</span><br><span class="line">.#..</span><br><span class="line">#...</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure></p><p>Sample Output</p><blockquote><p>2<br>1</p></blockquote><p>Problem solving:<br>跟n皇后很像的一个问题。判断条件还少了一个。注意回溯就行。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,k,vis[10],ans,now;</span><br><span class="line">char s[10][10];</span><br><span class="line">void dfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">if(now==k)</span><br><span class="line">&#123;</span><br><span class="line">ans++;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">if(x&gt;=n)return ;</span><br><span class="line">for(int j=0;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line">if(!vis[j]&amp;&amp;s[x][j]==&apos;#&apos;)</span><br><span class="line">&#123;</span><br><span class="line">vis[j]=1;</span><br><span class="line">now++;</span><br><span class="line">dfs(x+1);</span><br><span class="line">now--;</span><br><span class="line">vis[j]=0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dfs(x+1);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(scanf(&quot;%d %d&quot;,&amp;n,&amp;k)&amp;&amp;n!=-1&amp;&amp;k!=-1)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">for(int i=0;i&lt;n;i++)cin&gt;&gt;s[i];</span><br><span class="line">ans=0,now=0;</span><br><span class="line">dfs(0);</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Sudoku"><a href="#Sudoku" class="headerlink" title="Sudoku"></a>Sudoku</h3><p>Description：<br>Sudoku is a very simple task. A square table with 9 rows and 9 columns is divided to 9 smaller squares 3x3 as shown on the Figure. In some of the cells are written decimal digits from 1 to 9. The other cells are empty. The goal is to fill the empty cells with decimal digits from 1 to 9, one digit per cell, in such way that in each row, in each column and in each marked 3x3 subsquare, all the digits from 1 to 9 to appear. Write a program to solve a given Sudoku-task.</p><p><img src="https://i.loli.net/2019/07/24/5d3817f744d8511698.png" alt="JUT0QY($RVW[_(1EGZ@@)PK.png" title="JUT0QY($RVW[_(1EGZ@@)PK.png"></p><p>Input</p><blockquote><p>The input data will start with the number of the test cases. For each test case, 9 lines follow, corresponding to the rows of the table. On each line a string of exactly 9 decimal digits is given, corresponding to the cells in this line. If a cell is empty it is represented by 0.</p></blockquote><p>Output</p><blockquote><p>For each test case your program should print the solution in the same format as the input data. The empty cells have to be filled according to the rules. If solutions is not unique, then the program may print any one of them.</p></blockquote><p>Sample Input</p><blockquote><p>1<br>103000509<br>002109400<br>000704000<br>300502006<br>060000050<br>700803004<br>000401000<br>009205800<br>804000107</p></blockquote><p>Sample Output</p><blockquote><p>143628579<br>572139468<br>986754231<br>391542786<br>468917352<br>725863914<br>237481695<br>619275843<br>854396127</p></blockquote><p>Problem solving:<br>这道题的处理方式很巧妙。dfs中的参数只设置一个n(n就是代表着这是第几个数)就够了，就是当前的位置，在dfs中每次加一，如果当前位置不为0，就直接查找下一个位置。否则就从1～9中选一个数放进去，看同一行同一列以及同一小方格的同一行同一列有没有与之相同的，如果没有，就将当前位置的数更新成这个没有重复出现过的数。知道查找到n&gt;=81的时候，即每个位置都查找完了，结束查找输出即可。注意在查找的过程中需要用到回溯，因为如果这一条路行不通而返回上一条路的时候，此时当前位置还应该是0.<br>思路还是很清晰的，难点主要有两个</p><ol><li>如何用n来表示当前的位置</li><li>如何判断同一行同一列以及同一小方格的同一行同一列有没有与之相同的数</li></ol><p>n/9代表的就是当前位置的行，n%9代表的就是当前位置的列。<br>n/9/3*3表示的就是当前位置在小方格里的行，n%9/3*3代表的就是当前位置在小方格里的列。</p><p>位置都能表示出来了，那么判断也就简单了。<br>分别确定二维数组的第一个和第二个坐标进行判断就行了。这一点可能说的不是很好理解，可以看看代码，还是很好理解的。</p><p>这里还用到了一个很巧妙的输入<code>scanf(&quot;%1d&quot;,&amp;a)</code>;这样的话就不用输入字符再转换成整型了。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[10][10],flag;</span><br><span class="line">bool check(int n,int now)</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;9;i++)</span><br><span class="line">&#123;</span><br><span class="line">int j=n%9;</span><br><span class="line">if(a[i][j]==now)</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">    for(int j=0;j&lt;9;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        int i=n/9;</span><br><span class="line">        if(a[i][j]==now)</span><br><span class="line">            return 0;</span><br><span class="line">    &#125;</span><br><span class="line">int di=n/9/3*3;</span><br><span class="line">int dj=n%9/3*3;</span><br><span class="line">for(int i =di;i&lt;di+3;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=dj;j&lt;dj+3;j++)</span><br><span class="line">&#123;</span><br><span class="line">if(a[i][j]==now)return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">int dfs(int n)</span><br><span class="line">&#123;</span><br><span class="line">if(n&gt;=81)</span><br><span class="line">&#123;</span><br><span class="line">flag=1;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">if(a[n/9][n%9]!=0)dfs(n+1);</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">for(int i=1;i&lt;=9;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(check(n,i)==1)</span><br><span class="line">&#123;</span><br><span class="line">a[n/9][n%9]=i;</span><br><span class="line">dfs(n+1);</span><br><span class="line">if(flag==1)</span><br><span class="line">return 0;</span><br><span class="line">a[n/9][n%9]=0;//回溯</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//cout&lt;&lt;&quot;?&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">flag=0;</span><br><span class="line">for(int i=0;i&lt;9;i++)</span><br><span class="line">for(int j=0;j&lt;9;j++)</span><br><span class="line">scanf(&quot;%1d&quot;,&amp;a[i][j]);</span><br><span class="line">dfs(0);</span><br><span class="line">for(int i=0;i&lt;9;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;9;j++)</span><br><span class="line">printf(&quot;%d&quot;,a[i][j]);</span><br><span class="line">puts(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="放苹果"><a href="#放苹果" class="headerlink" title="放苹果"></a>放苹果</h3><p>Description：<br>把M个同样的苹果放在N个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？（用K表示）5，1，1和1，5，1 是同一种分法。<br>Input</p><blockquote><p>第一行是测试数据的数目t（0 &lt;= t &lt;= 20）。以下每行均包含二个整数M和N，以空格分开。1&lt;=M，N&lt;=10。</p></blockquote><p>Output</p><blockquote><p>对输入的每组数据M和N，用一行输出相应的K。</p></blockquote><p>Sample Input</p><blockquote><p>1<br>7 3</p></blockquote><p>Sample Output</p><blockquote><p>8</p></blockquote><p>Problem solving:<br>思维题。(让我说也说不清，还是借用一下大佬的解释吧)<br>设f(m,n) 为m个苹果，n个盘子的放法数目，则先对n作讨论，<br>        当n&gt;m：必定有n-m个盘子永远空着，去掉它们对摆放苹果方法数目不产生影响。即if(n&gt;m) f(m,n) = f(m,m)　　<br>        当n&lt;=m：不同的放法可以分成两类：<br>        1、有至少一个盘子空着，即相当于f(m,n) = f(m,n-1);<br>        2、所有盘子都有苹果，相当于可以从每个盘子中拿掉一个苹果，不影响不同放法的数目，即f(m,n) = f(m-n,n).<br>        而总的放苹果的放法数目等于两者的和，即 f(m,n) =f(m,n-1)+f(m-n,n) </p><p> 递归出口条件说明：<br>        当n=1时，所有苹果都必须放在一个盘子里，所以返回１；<br>        当没有苹果可放时，定义为１种放法；<br>        递归的两条路，第一条n会逐渐减少，终会到达出口n==1;<br>        第二条m会逐渐减少，因为n&gt;m时，我们会return f(m,m)　所以终会到达出口m==0．<br>此解释源于：<a href="https://blog.csdn.net/jason0539/article/details/12183817" target="_blank" rel="noopener">https://blog.csdn.net/jason0539/article/details/12183817</a></p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int t,n,m,ans;</span><br><span class="line">int dfs(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">if(x==0||y==1)&#123;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">else if(x&lt;y)return dfs(x,x);</span><br><span class="line">return dfs(x,y-1)+dfs(x-y,y);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">cout&lt;&lt;dfs(m,n)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Tempter-of-the-Bone"><a href="#Tempter-of-the-Bone" class="headerlink" title="Tempter of the Bone"></a>Tempter of the Bone</h3><p>Description：<br>小明做了一个很久很久的梦，醒来后他竟发现自己和朋友在一个摇摇欲坠的大棋盘上，他们必须得想尽一切办法逃离这里。<br>经过长时间的打探，小明发现，自己所在的棋盘格子上有个机关，上面写着“你只有一次机会，出发后t秒大门会为你敞开”，而他自己所在的棋盘是大小为 N*M 的长方形，他可以向上下左右四个方向移动（不可走有障碍点）。棋盘中有一扇门。根据机关的提示，小明顿时明白了，他和朋友必须在第 t 秒到门口。而这一切，没有回头路！因为一旦他移动了，他刚才所在的点就会消失，并且他不能在一个点上停留超过一秒，不然格子会爆炸。大逃亡开始了，请问小明和朋友能安全的逃出这奇怪的棋盘吗？</p><p>Input</p><blockquote><p>输入多组测试数据。每个测试用例的第一行包含三个整数 N、M 和 T ( 1 &lt; N , M &lt; 7 ; 0 &lt; T &lt; 50 )，分别表示棋盘的大小和门打开的时间。接下来的N行给出棋盘布局，每一行包含M个字符。其中<br>&quot;.&quot;: 无障碍点<br>&quot;X&quot;: 障碍点<br>&quot;S&quot;: 起点<br>&quot;D&quot;: 门<br>输入以 3 个 0 结束。这个测试用例不需要处理。<br>输入数据中的空格有些问题，请不要使用getchar()，如果一定要用可以选择scanf(&quot;%s&quot;,) 自动忽略空格</p></blockquote><p>Output</p><blockquote><p>对于每组样例输出一行。<br>如果小明能够安全逃出，输出 &quot;YES&quot; ，否则输出 &quot;NO&quot;。</p></blockquote><p>Sample Input<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">4 4 5</span><br><span class="line">S.X.</span><br><span class="line">..X.</span><br><span class="line">..XD</span><br><span class="line">....</span><br><span class="line">3 4 5</span><br><span class="line">S.X.</span><br><span class="line">..X.</span><br><span class="line">...D</span><br><span class="line">0 0 0</span><br></pre></td></tr></table></figure></p><p>Sample Output</p><blockquote><p>NO<br>YES</p></blockquote><p>Problem solving:<br>注意题目中要求的是当你走到D的时候你走的步数与它开门的时间即T相等，所以需要用DFS查找每一条到达D的路，看与T相等的值是否存在。<br>因为要查询到每一条路，这道题可能会超时。所以会用到一种很神奇的剪枝——<a href="https://baike.baidu.com/item/%E5%A5%87%E5%81%B6%E5%89%AA%E6%9E%9D" target="_blank" rel="noopener">奇偶剪枝</a><br>除去这个剪枝的难度的话这道题就很简单了。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m,t,sx,sy,ex,ey,ti,flag;</span><br><span class="line">char s[10][10];</span><br><span class="line">int vis[10][10];</span><br><span class="line">int d[4][2]=&#123;0,1,0,-1,1,0,-1,0&#125;;</span><br><span class="line">void dfs(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">if(x&lt;0||x&gt;=n||y&lt;0||y&gt;=m||ti&gt;t)return ;</span><br><span class="line">if(flag)return ;</span><br><span class="line">if(s[x][y]==&apos;D&apos;&amp;&amp;ti==t)</span><br><span class="line">&#123;</span><br><span class="line">//cout&lt;&lt;ti&lt;&lt;endl;</span><br><span class="line">flag=1;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int temp1 = abs(ex-x) + abs(ey-y);</span><br><span class="line">int temp2 = abs(t-ti);</span><br><span class="line">int temp = abs(temp1-temp2);</span><br><span class="line">if(temp%2!=0)return ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vis[x][y]=1;</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">int dx=x+d[i][0];</span><br><span class="line">int dy=y+d[i][1];</span><br><span class="line">if(dx&gt;=0&amp;&amp;dx&lt;n&amp;&amp;dy&gt;=0&amp;&amp;dy&lt;m&amp;&amp;!vis[dx][dy]&amp;&amp;s[dx][dy]!=&apos;X&apos;)</span><br><span class="line">&#123;</span><br><span class="line">//cout&lt;&lt;ti&lt;&lt;&quot;--&gt;&quot;&lt;&lt;dx&lt;&lt;&quot; --&gt;&quot;&lt;&lt;dy&lt;&lt;&quot;\n&quot;;</span><br><span class="line">ti++;</span><br><span class="line">dfs(dx,dy);</span><br><span class="line">vis[dx][dy]=0;</span><br><span class="line">ti--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">        ios::sync_with_stdio(0);</span><br><span class="line">while(cin&gt;&gt;n&gt;&gt;m&gt;&gt;t)</span><br><span class="line">&#123;</span><br><span class="line">if(n==0&amp;&amp;m==0&amp;&amp;t==0)break;</span><br><span class="line">flag=0,ti=0;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">for(int i=0;i&lt;n;i++)cin&gt;&gt;s[i];</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">for(int j=0;j&lt;m;j++)</span><br><span class="line">if(s[i][j]==&apos;S&apos;)</span><br><span class="line">&#123;</span><br><span class="line">sx=i,sy=j;</span><br><span class="line">&#125;</span><br><span class="line">else if(s[i][j]==&apos;D&apos;)</span><br><span class="line">&#123;</span><br><span class="line">ex=i,ey=j;</span><br><span class="line">&#125;</span><br><span class="line">dfs(sx,sy);</span><br><span class="line">if(flag)puts(&quot;YES&quot;);</span><br><span class="line">elseputs(&quot;NO&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Red-and-Black"><a href="#Red-and-Black" class="headerlink" title="Red and Black"></a>Red and Black</h3><p>Description：<br>There is a rectangular room, covered with square tiles. Each tile is colored either red or black. A man is standing on a black tile. From a tile, he can move to one of four adjacent tiles. But he can&#39;t move on red tiles, he can move only on black tiles.</p><p>Write a program to count the number of black tiles which he can reach by repeating the moves described above.<br>Input</p><blockquote><p>The input consists of multiple data sets. A data set starts with a line containing two positive integers W and H; W and H are the numbers of tiles in the x- and y- directions, respectively. W and H are not more than 20.<br>There are H more lines in the data set, each of which includes W characters. Each character represents the color of a tile as follows.<br>&#39;.&#39; - a black tile<br>&#39;#&#39; - a red tile<br>&#39;@&#39; - a man on a black tile(appears exactly once in a data set)</p></blockquote><p>Output</p><blockquote><p>For each data set, your program should output a line which contains the number of tiles he can reach from the initial tile (including itself).</p></blockquote><p>Sample Input<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">6 9</span><br><span class="line">....#.</span><br><span class="line">.....#</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">#@...#</span><br><span class="line">.#..#.</span><br><span class="line">11 9</span><br><span class="line">.#.........</span><br><span class="line">.#.#######.</span><br><span class="line">.#.#.....#.</span><br><span class="line">.#.#.###.#.</span><br><span class="line">.#.#..@#.#.</span><br><span class="line">.#.#####.#.</span><br><span class="line">.#.......#.</span><br><span class="line">.#########.</span><br><span class="line">...........</span><br><span class="line">11 6</span><br><span class="line">..#..#..#..</span><br><span class="line">..#..#..#..</span><br><span class="line">..#..#..###</span><br><span class="line">..#..#..#@.</span><br><span class="line">..#..#..#..</span><br><span class="line">..#..#..#..</span><br><span class="line">7 7</span><br><span class="line">..#.#..</span><br><span class="line">..#.#..</span><br><span class="line">###.###</span><br><span class="line">...@...</span><br><span class="line">###.###</span><br><span class="line">..#.#..</span><br><span class="line">..#.#..</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure></p><p>Sample Output</p><blockquote><p>45<br>59<br>6<br>13</p></blockquote><p>Problem solving:<br>对没错就是昨天那道题，用bfs可以写，用dfs也可以写。太强了。只要下一个还是可以走得就一直dfs查找下去就行。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">char s[25][25];</span><br><span class="line">int vis[25][25];</span><br><span class="line">int a,b,ans;</span><br><span class="line">int d[4][2]=&#123;1,0,0,1,0,-1,-1,0&#125;;</span><br><span class="line">void dfs(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">vis[x][y]=1;</span><br><span class="line">if(x&lt;0||x&gt;=b||y&lt;0||y&gt;=a)return ;</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">int dx=x+d[i][0];</span><br><span class="line">int dy=y+d[i][1];</span><br><span class="line">if(dx&gt;=0&amp;&amp;dx&lt;b&amp;&amp;dy&gt;=0&amp;&amp;dy&lt;a&amp;&amp;!vis[dx][dy]&amp;&amp;s[dx][dy]!=&apos;#&apos;)</span><br><span class="line">&#123;</span><br><span class="line">ans++;</span><br><span class="line">dfs(dx,dy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(cin&gt;&gt;a&gt;&gt;b)</span><br><span class="line">&#123;</span><br><span class="line">if(a==0&amp;&amp;b==0)break;</span><br><span class="line">ans=1;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">for(int i=0;i&lt;b;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;a;j++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;s[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        for(int i=0;i&lt;b;i++)</span><br><span class="line">for(int j=0;j&lt;a;j++)</span><br><span class="line">&#123;</span><br><span class="line">if(s[i][j]==&apos;@&apos;)dfs(i,j);</span><br><span class="line">&#125;        </span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天主要讲的是递归和DFS，因为涉及到递归，很抽象，所以比较难理解。题也很难做。
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="Algorithm" scheme="https://cndrew.cn/blog/tags/Algorithm/"/>
    
      <category term="c/c++" scheme="https://cndrew.cn/blog/tags/c-c/"/>
    
      <category term="HDU" scheme="https://cndrew.cn/blog/tags/HDU/"/>
    
      <category term="CodeForces" scheme="https://cndrew.cn/blog/tags/CodeForces/"/>
    
      <category term="poj" scheme="https://cndrew.cn/blog/tags/poj/"/>
    
      <category term="STL" scheme="https://cndrew.cn/blog/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>HPU Summer Training Day 7（河南理工大学暑期第七天）</title>
    <link href="https://cndrew.cn/blog/2019/07/23/d7/"/>
    <id>https://cndrew.cn/blog/2019/07/23/d7/</id>
    <published>2019-07-23T14:38:28.576Z</published>
    <updated>2019-07-23T14:49:03.567Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天主要讲了BFS和DFS，还有存图和链式前向星，后面这两个在今天刷题的过程中还没有遇到，晚会把他们加到我的模板里面。<a id="more"></a></p><h3 id="Rescue"><a href="#Rescue" class="headerlink" title="Rescue"></a>Rescue</h3><p>Description:<br>Angel was caught by the MOLIGPY! He was put in prison by Moligpy. The prison is described as a N * M (N, M &lt;= 200) matrix. There are WALLs, ROADs, and GUARDs in the prison.</p><p>Angel&#39;s friends want to save Angel. Their task is: approach Angel. We assume that &quot;approach Angel&quot; is to get to the position where Angel stays. When there&#39;s a guard in the grid, we must kill him (or her?) to move into the grid. We assume that we moving up, down, right, left takes us 1 unit time, and killing a guard takes 1 unit time, too. And we are strong enough to kill all the guards.</p><p>You have to calculate the minimal time to approach Angel. (We can move only UP, DOWN, LEFT and RIGHT, to the neighbor grid within bound, of course.)<br>Input</p><blockquote><p>First line contains two integers stand for N and M.<br>Then N lines follows, every line has M characters. &quot;.&quot; stands for road, &quot;a&quot; stands for Angel, and &quot;r&quot; stands for each of Angel&#39;s friend.<br>Process to the end of the file.</p></blockquote><p>Output</p><blockquote><p>For each test case, your program should output a single integer, standing for the minimal time needed. If such a number does no exist, you should output a line containing &quot;Poor ANGEL has to stay in the prison all his life.&quot;</p></blockquote><p>Sample Input<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">7 8</span><br><span class="line">#.#####.</span><br><span class="line">#.a#..r.</span><br><span class="line">#..#x...</span><br><span class="line">..#..#.#</span><br><span class="line">#...##..</span><br><span class="line">.#......</span><br><span class="line">........</span><br></pre></td></tr></table></figure></p><p>Sample Output</p><blockquote><p>13</p></blockquote><p>Problem solving:<br>注意是多组输入，这里用到了运算符重载和优先队列，这两个东西最近在刷题的过程中出现的频率很高。<br>因为这道题中r可能有多个所以我们用a去寻找r，用结构体存点的坐标，用优先队列存结构体实现BFS，先定义一个ans变量用来存放答案，初始化为-1，如果可以找到符合条件的点就更新ans的值并结束查找。查找结束之后，如果ans仍是-1，那么输出<code>Poor ANGEL has to stay in the prison all his life.</code>，否则就输出ans的值，查找过程就是bfs的模板，但是用的是优先队列。我们遇到X的时候只需要+2即可。其他的判断条件都挺好理解，可以直接看代码。</p><p>结构体如果想套到优先队列中就需要运算符重载。运算符重载的方法有好几种，这里我就会这一种。</p><p>Code<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">char s[205][205];</span><br><span class="line">int d[4][2]=&#123;-1,0,0,1,1,0,0,-1&#125;;</span><br><span class="line">struct node&#123;</span><br><span class="line">int x,y,step;</span><br><span class="line">friend bool operator &lt; (node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">return a.step&gt;b.step;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int n,m;</span><br><span class="line">int vis[205][205];</span><br><span class="line">void bfs(int x,int y,int xx,int yy)</span><br><span class="line">&#123;</span><br><span class="line">int ans=-1;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line">node mid,mmp;</span><br><span class="line">mid.x=x,mid.y=y,mid.step=0;</span><br><span class="line">vis[x][y]=1;</span><br><span class="line">q.push(mid);</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">mid=q.top();</span><br><span class="line">q.pop();</span><br><span class="line">if(mid.x==xx&amp;&amp;mid.y==yy)</span><br><span class="line">&#123;</span><br><span class="line">ans=mid.step;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">mmp.x=mid.x+d[i][0];</span><br><span class="line">mmp.y=mid.y+d[i][1];</span><br><span class="line">if(mmp.x&lt;0||mmp.x&gt;=n||mmp.y&lt;0||mmp.y&gt;=m||vis[mmp.x][mmp.y]==1||s[mmp.x][mmp.y]==&apos;#&apos;)continue;</span><br><span class="line">if(s[mmp.x][mmp.y]==&apos;x&apos;)mmp.step=mid.step+2;</span><br><span class="line">elsemmp.step=mid.step+1;</span><br><span class="line">q.push(mmp);</span><br><span class="line">vis[mmp.x][mmp.y]=1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(ans==-1)puts(&quot;Poor ANGEL has to stay in the prison all his life.&quot;);</span><br><span class="line">elsecout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int sx,sy,ex,ey;</span><br><span class="line">while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;m))</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;m;j++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;s[i][j];</span><br><span class="line">if(s[i][j]==&apos;a&apos;)</span><br><span class="line">&#123;</span><br><span class="line">sx=i;</span><br><span class="line">sy=j;</span><br><span class="line">&#125;</span><br><span class="line">if(s[i][j]==&apos;r&apos;)</span><br><span class="line">&#123;</span><br><span class="line">ex=i;</span><br><span class="line">ey=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bfs(sx,sy,ex,ey);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Red-and-Black"><a href="#Red-and-Black" class="headerlink" title="Red and Black"></a>Red and Black</h3><p>Description:<br>There is a rectangular room, covered with square tiles. Each tile is colored either red or black. A man is standing on a black tile. From a tile, he can move to one of four adjacent tiles. But he can&#39;t move on red tiles, he can move only on black tiles.</p><p>Write a program to count the number of black tiles which he can reach by repeating the moves described above.<br>Input</p><blockquote><p>The input consists of multiple data sets. A data set starts with a line containing two positive integers W and H; W and H are the numbers of tiles in the x- and y- directions, respectively. W and H are not more than 20.<br>There are H more lines in the data set, each of which includes W characters. Each character represents the color of a tile as follows.<br>&#39;.&#39; - a black tile<br>&#39;#&#39; - a red tile<br>&#39;@&#39; - a man on a black tile(appears exactly once in a data set)</p></blockquote><p>Output</p><blockquote><p>For each data set, your program should output a line which contains the number of tiles he can reach from the initial tile (including itself).</p></blockquote><p>Sample Input<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">6 9</span><br><span class="line">....#.</span><br><span class="line">.....#</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">#@...#</span><br><span class="line">.#..#.</span><br><span class="line">11 9</span><br><span class="line">.#.........</span><br><span class="line">.#.#######.</span><br><span class="line">.#.#.....#.</span><br><span class="line">.#.#.###.#.</span><br><span class="line">.#.#..@#.#.</span><br><span class="line">.#.#####.#.</span><br><span class="line">.#.......#.</span><br><span class="line">.#########.</span><br><span class="line">...........</span><br><span class="line">11 6</span><br><span class="line">..#..#..#..</span><br><span class="line">..#..#..#..</span><br><span class="line">..#..#..###</span><br><span class="line">..#..#..#@.</span><br><span class="line">..#..#..#..</span><br><span class="line">..#..#..#..</span><br><span class="line">7 7</span><br><span class="line">..#.#..</span><br><span class="line">..#.#..</span><br><span class="line">###.###</span><br><span class="line">...@...</span><br><span class="line">###.###</span><br><span class="line">..#.#..</span><br><span class="line">..#.#..</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure></p><p>Sample Output</p><blockquote><p>45<br>59<br>6<br>13</p></blockquote><p>Problem solving:<br>简单的BFS模板题，注意答案要加上一开始所处位置的点。</p><p>Code<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">char s[25][25];</span><br><span class="line">int vis[25][25];</span><br><span class="line">int d[4][2]=&#123;1,0,0,1,0,-1,-1,0&#125;;</span><br><span class="line">struct node&#123;</span><br><span class="line">int x,y;</span><br><span class="line">&#125;;</span><br><span class="line">int w,h;</span><br><span class="line">queue&lt;node&gt; que;</span><br><span class="line">void bfs(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">node mid,now,mmp;</span><br><span class="line">int ans=0;</span><br><span class="line">mid.x=x;</span><br><span class="line">mid.y=y;</span><br><span class="line">vis[x][y]=1;</span><br><span class="line">que.push(mid);</span><br><span class="line">while(!que.empty())</span><br><span class="line">&#123;</span><br><span class="line">now=que.front();</span><br><span class="line">que.pop();</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">mmp.x=now.x+d[i][0];</span><br><span class="line">mmp.y=now.y+d[i][1];</span><br><span class="line">if(mmp.x&lt;0||mmp.x&gt;=h||mmp.y&lt;0||mmp.y&gt;=w||vis[mmp.x][mmp.y]==1||s[mmp.x][mmp.y]==&apos;#&apos;)continue;</span><br><span class="line">ans++;</span><br><span class="line">vis[mmp.x][mmp.y]=1;</span><br><span class="line">que.push(mmp);</span><br><span class="line">s[mmp.x][mmp.y]=&apos;?&apos;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans+1&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int sx,sy;</span><br><span class="line">while(scanf(&quot;%d %d&quot;,&amp;w,&amp;h)&amp;&amp;w&amp;&amp;h)</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;h;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;w;j++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;s[i][j];</span><br><span class="line">if(s[i][j]==&apos;@&apos;)</span><br><span class="line">&#123;</span><br><span class="line">sx=i;</span><br><span class="line">sy=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//cout&lt;&lt;sx&lt;&lt;&quot; &quot;&lt;&lt;sy&lt;&lt;endl;</span><br><span class="line">bfs(sx,sy);</span><br><span class="line">//for(int i=0;i&lt;h;i++)</span><br><span class="line">//&#123;</span><br><span class="line">//for(int j=0;j&lt;w;j++)</span><br><span class="line">//&#123;</span><br><span class="line">//cout&lt;&lt;s[i][j];</span><br><span class="line">//&#125;</span><br><span class="line">//puts(&quot;&quot;);</span><br><span class="line">//&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Battle-City"><a href="#Battle-City" class="headerlink" title="Battle City"></a>Battle City</h3><p>Description:<br>Many of us had played the game &quot;Battle city&quot; in our childhood, and some people (like me) even often play it on computer now.<br><img src="https://i.loli.net/2019/07/23/5d36d872067fb73590.png" alt><br>What we are discussing is a simple edition of this game. Given a map that consists of empty spaces, rivers, steel walls and brick walls only. Your task is to get a bonus as soon as possible suppose that no enemies will disturb you (See the following picture).<br><img src="https://i.loli.net/2019/07/23/5d36d8964beff99419.png" alt><br>Your tank can&#39;t move through rivers or walls, but it can destroy brick walls by shooting. A brick wall will be turned into empty spaces when you hit it, however, if your shot hit a steel wall, there will be no damage to the wall. In each of your turns, you can choose to move to a neighboring (4 directions, not 8) empty space, or shoot in one of the four directions without a move. The shot will go ahead in that direction, until it go out of the map or hit a wall. If the shot hits a brick wall, the wall will disappear (i.e., in this turn). Well, given the description of a map, the positions of your tank and the target, how many turns will you take at least to arrive there?</p><p>Input</p><blockquote><p>The input consists of several test cases. The first line of each test case contains two integers M and N (2 &lt;= M, N &lt;= 300). Each of the following M lines contains N uppercase letters, each of which is one of &#39;Y&#39; (you), &#39;T&#39; (target), &#39;S&#39; (steel wall), &#39;B&#39; (brick wall), &#39;R&#39; (river) and &#39;E&#39; (empty space). Both &#39;Y&#39; and &#39;T&#39; appear only once. A test case of M = N = 0 indicates the end of input, and should not be processed.</p></blockquote><p>Output</p><blockquote><p>For each test case, please output the turns you take at least in a separate line. If you can&#39;t arrive at the target, output &quot;-1&quot; instead.</p></blockquote><p>Sample Input</p><blockquote><p>3 4<br>YBEB<br>EERE<br>SSTE<br>0 0</p></blockquote><p>Sample Output</p><blockquote><p>8</p></blockquote><p>Problem solving:<br>这道题跟A很像。用优先队列进行BFS查找。判断条件也很简单。不懂的话，可以直接看代码</p><p>Code<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int m,n;</span><br><span class="line">char s[305][305];</span><br><span class="line">int vis[305][305];</span><br><span class="line">struct node&#123;</span><br><span class="line">int x,y,step;</span><br><span class="line">friend bool operator &lt; (node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">return a.step&gt;b.step;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int d[4][2]=&#123;1,0,0,1,-1,0,0,-1&#125;;</span><br><span class="line">void bfs(int x,int y,int xx,int yy)</span><br><span class="line">&#123;</span><br><span class="line">int ans=-1;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">node mid,now;</span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line">mid.x=x;mid.y=y;mid.step=0;</span><br><span class="line">q.push(mid);</span><br><span class="line">vis[x][y]=1;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">mid=q.top();</span><br><span class="line">if(mid.x==xx&amp;&amp;mid.y==yy)</span><br><span class="line">&#123;</span><br><span class="line">//cout&lt;&lt;mid.x&lt;&lt;&quot; &quot;&lt;&lt;mid.y&lt;&lt;endl;</span><br><span class="line">ans=mid.step;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">q.pop();</span><br><span class="line">for(int i=0;i&lt;8;i++)</span><br><span class="line">&#123;</span><br><span class="line">now.x=mid.x+d[i][0];</span><br><span class="line">now.y=mid.y+d[i][1];</span><br><span class="line">if(now.x&lt;0||now.x&gt;=m||now.y&lt;0||now.y&gt;=n||s[now.x][now.y]==&apos;S&apos;||s[now.x][now.y]==&apos;R&apos;||vis[now.x][now.y]==1)continue;</span><br><span class="line">if(s[now.x][now.y]==&apos;B&apos;)now.step=mid.step+2;</span><br><span class="line">elsenow.step=mid.step+1;</span><br><span class="line">vis[now.x][now.y]=1;</span><br><span class="line">s[now.x][now.y]=now.step+&apos;0&apos;;</span><br><span class="line">q.push(now);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int sx,sy,ex,ey;</span><br><span class="line">while(scanf(&quot;%d %d&quot;,&amp;m,&amp;n)&amp;&amp;m&amp;&amp;n)</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;s[i][j];</span><br><span class="line">if(s[i][j]==&apos;Y&apos;)</span><br><span class="line">&#123;</span><br><span class="line">sx=i;</span><br><span class="line">sy=j;</span><br><span class="line">&#125;</span><br><span class="line">if(s[i][j]==&apos;T&apos;)</span><br><span class="line">&#123;</span><br><span class="line">ex=i;</span><br><span class="line">ey=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bfs(sx,sy,ex,ey);</span><br><span class="line">//for(int i=0;i&lt;m;i++)</span><br><span class="line">//&#123;</span><br><span class="line">//for(int j=0;j&lt;n;j++)</span><br><span class="line">//&#123;</span><br><span class="line">//cout&lt;&lt;s[i][j];</span><br><span class="line">//&#125;</span><br><span class="line">//puts(&quot;&quot;);</span><br><span class="line">//&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Catch-That-Cow"><a href="#Catch-That-Cow" class="headerlink" title="Catch That Cow"></a>Catch That Cow</h3><p>Description:<br>农夫知道一头牛的位置，想要抓住它。农夫和牛都于数轴上 ，农夫起始位于点 N(0&lt;=N&lt;=100000) ，牛位于点 K(0&lt;=K&lt;=100000) 。农夫有两种移动方式： 1、从 X移动到 X-1或X+1 ，每次移动花费一分钟 2、从 X移动到 2\X ，每次移动花费一分钟 假设牛没有意识到农夫的行动，站在原地不。最少要花多少时间才能抓住牛？<br>Input<br>一行: 以空格分隔的两个字母: N 和 K<br>Output<br>一行: 农夫抓住牛需要的最少时间，单位分钟<br>Sample Input</p><blockquote><p>5 17</p></blockquote><p>Sample Output</p><blockquote><p>4</p></blockquote><p>Hint<br>农夫使用最短时间抓住牛的方案如下: 5-10-9-18-17, 需要4分钟.</p><p>Problem solving:<br>经典的BFS例题。每次往下扩展队列的时候只有3种情况。就像是经常在图里面用到的四个方向一样。判断条件中要有一个最大值，不然就有可能会一直查找下去。</p><p>Code<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int vis[1000000];</span><br><span class="line">int step[1000000];</span><br><span class="line">void bfs(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">q.push(x);</span><br><span class="line">step[x]=0;</span><br><span class="line">vis[x]=1;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">int mid=q.front(),mmp;</span><br><span class="line">q.pop();</span><br><span class="line">if(mid==y)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;step[y]&lt;&lt;endl;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;3;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(i==0)mmp=mid-1;</span><br><span class="line">if(i==1)mmp=mid+1;</span><br><span class="line">if(i==2)mmp=mid*2;</span><br><span class="line">if(mmp&gt;=0&amp;&amp;mmp&lt;1000000&amp;&amp;vis[mmp]==0)</span><br><span class="line">&#123;</span><br><span class="line">q.push(mmp);</span><br><span class="line">step[mmp]=step[mid]+1;</span><br><span class="line">vis[mmp]=1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,k;</span><br><span class="line">while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;k))</span><br><span class="line">&#123;</span><br><span class="line">if(n&gt;=k)cout&lt;&lt;n-k&lt;&lt;endl;</span><br><span class="line">elsebfs(n,k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Dungeon-Master"><a href="#Dungeon-Master" class="headerlink" title="Dungeon Master"></a>Dungeon Master</h3><p>Description:<br>[NWUACM]<br>你被困在一个三维的空间中,现在要寻找最短路径逃生！<br>空间由立方体单位构成<br>你每次向上下前后左右移动一个单位需要一分钟<br>你不能对角线移动并且四周封闭<br>是否存在逃出生天的可能性？如果存在，则需要多少时间？</p><p>Input<br>输入第一行是一个数表示空间的数量。<br>每个空间的描述的第一行为L，R和C（皆不超过30）。<br>L表示空间的高度。<br>R和C分别表示每层空间的行与列的大小。<br>随后L层地牢，每层R行，每行C个字符。<br>每个字符表示空间的一个单元。&#39;#&#39;表示不可通过单元，&#39;.&#39;表示空白单元。你的起始位置在&#39;S&#39;，出口为&#39;E&#39;。<br>每层空间后都有一个空行。L，R和C均为0时输入结束。</p><p>Output - 输出<br>每个空间对应一行输出。<br>如果可以逃生，则输出如下<br>Escaped in x minute(s).<br>x为最短脱离时间。<br>如果无法逃生，则输出如下<br>Trapped!</p><p>Sample Input<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">3 4 5</span><br><span class="line">S....</span><br><span class="line">.###.</span><br><span class="line">.##..</span><br><span class="line">###.#</span><br><span class="line"></span><br><span class="line">#####</span><br><span class="line">#####</span><br><span class="line">##.##</span><br><span class="line">##...</span><br><span class="line"></span><br><span class="line">#####</span><br><span class="line">#####</span><br><span class="line">#.###</span><br><span class="line">####E</span><br><span class="line"></span><br><span class="line">1 3 3</span><br><span class="line">S##</span><br><span class="line">#E#</span><br><span class="line">###</span><br><span class="line"></span><br><span class="line">0 0 0</span><br></pre></td></tr></table></figure></p><p>Sample Output</p><blockquote><p>Escaped in 11 minute(s).<br>Trapped!</p></blockquote><p>Problem solving:<br>三维中的BFS，跟平常用到的差不多。不过是6个方向，上下左右前后，然后开三位数组进行BFS就好了</p><p>Code<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">char map[30][30][30];        </span><br><span class="line">int sta[30][30][30];        </span><br><span class="line">int base[6][3] = &#123; &#123;-1,0,0&#125;,&#123;1,0,0&#125;,&#123;0,-1,0&#125;,&#123;0,1,0&#125;,&#123;0,0,-1&#125;,&#123;0,0,1&#125; &#125;;</span><br><span class="line">int L, R, C;</span><br><span class="line">struct Piont</span><br><span class="line">&#123;</span><br><span class="line">    int x, y, z;            </span><br><span class="line">    int step;                </span><br><span class="line">&#125;;</span><br><span class="line">struct Piont s;               </span><br><span class="line">struct Piont e;               </span><br><span class="line">struct Piont curp;            </span><br><span class="line"></span><br><span class="line">bool success(struct Piont cur)</span><br><span class="line">&#123;</span><br><span class="line">    if (cur.x == e.x &amp;&amp; cur.y == e.y &amp;&amp; cur.z == e.z)</span><br><span class="line">        return true;</span><br><span class="line">    else</span><br><span class="line">        return false;</span><br><span class="line">&#125;</span><br><span class="line">bool check(int x, int y, int z)</span><br><span class="line">&#123;</span><br><span class="line">    if ((x &gt;= 0) &amp;&amp; (x &lt; L) &amp;&amp; (y &gt;= 0) &amp;&amp; (y &lt; R) &amp;&amp; (z &gt;= 0) &amp;&amp; (z &lt; C) &amp;&amp; (!sta[x][y][z]) &amp;&amp; (map[x][y][z] == &apos;.&apos; || map[x][y][z] == &apos;E&apos;))</span><br><span class="line">        return true;</span><br><span class="line">    else</span><br><span class="line">        return false;</span><br><span class="line">&#125;</span><br><span class="line">void bfs()</span><br><span class="line">&#123;</span><br><span class="line">    struct Piont next;</span><br><span class="line">    queue&lt;Piont&gt;q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    while (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        curp = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        if (success(curp))</span><br><span class="line">            return;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            sta[curp.x][curp.y][curp.z] = 1;</span><br><span class="line">            for (int i = 0; i &lt; 6; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                next.x = curp.x + base[i][0];</span><br><span class="line">                next.y = curp.y + base[i][1];</span><br><span class="line">                next.z = curp.z + base[i][2];</span><br><span class="line">                if (check(next.x, next.y, next.z))        </span><br><span class="line">                &#123;</span><br><span class="line">                    next.step = curp.step + 1;</span><br><span class="line">                    sta[next.x][next.y][next.z] = 1;</span><br><span class="line">                    q.push(next);</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while (scanf(&quot;%d%d%d&quot;, &amp;L, &amp;R, &amp;C))</span><br><span class="line">    &#123;</span><br><span class="line">        if((L == 0) &amp;&amp; (R == 0) &amp;&amp; (C == 0))</span><br><span class="line">            break;</span><br><span class="line">        memset(sta, 0, sizeof(sta));</span><br><span class="line">        for (int i = 0; i &lt; L; i++) &#123;</span><br><span class="line">            getchar();</span><br><span class="line">            for (int j = 0; j &lt; R; j++) &#123;</span><br><span class="line">                for (int k = 0; k &lt; C; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    scanf(&quot;%c&quot;, &amp;map[i][j][k]);</span><br><span class="line">                    if (map[i][j][k] == &apos;S&apos;) &#123;</span><br><span class="line">                        s.x = i;</span><br><span class="line">                        s.y = j;</span><br><span class="line">                        s.z = k;</span><br><span class="line">                        s.step = 0;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if (map[i][j][k] == &apos;E&apos;)</span><br><span class="line">                    &#123;</span><br><span class="line">                        e.x = i;</span><br><span class="line">                        e.y = j;</span><br><span class="line">                        e.z = k;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                getchar();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bfs();</span><br><span class="line">        if (curp.x == e.x &amp;&amp; curp.y == e.y &amp;&amp; curp.z == e.z)</span><br><span class="line">            printf(&quot;Escaped in %d minute(s).\n&quot;, curp.step);</span><br><span class="line">        else</span><br><span class="line">            printf(&quot;Trapped!\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Robot-Motion"><a href="#Robot-Motion" class="headerlink" title="Robot Motion"></a>Robot Motion</h3><p>Description:<br><img src="https://i.loli.net/2019/07/23/5d36d9a28aa0831996.png" alt><br>A robot has been programmed to follow the instructions in its path. Instructions for the next direction the robot is to move are laid down in a grid. The possible instructions are</p><p>N north (up the page)<br>S south (down the page)<br>E east (to the right on the page)<br>W west (to the left on the page)</p><p>For example, suppose the robot starts on the north (top) side of Grid 1 and starts south (down). The path the robot follows is shown. The robot goes through 10 instructions in the grid before leaving the grid.</p><p>Compare what happens in Grid 2: the robot goes through 3 instructions only once, and then starts a loop through 8 instructions, and never exits.</p><p>You are to write a program that determines how long it takes a robot to get out of the grid or how the robot loops around.<br>Input</p><blockquote><p>There will be one or more grids for robots to navigate. The data for each is in the following form. On the first line are three integers separated by blanks: the number of rows in the grid, the number of columns in the grid, and the number of the column in which the robot enters from the north. The possible entry columns are numbered starting with one at the left. Then come the rows of the direction instructions. Each grid will have at least one and at most 10 rows and columns of instructions. The lines of instructions contain only the characters N, S, E, or W with no blanks. The end of input is indicated by a row containing 0 0 0.</p></blockquote><p>Output</p><blockquote><p>For each grid in the input there is one line of output. Either the robot follows a certain number of instructions and exits the grid on any one the four sides or else the robot follows the instructions on a certain number of locations once, and then the instructions on some number of locations repeatedly. The sample input below corresponds to the two grids above and illustrates the two forms of output. The word &quot;step&quot; is always immediately followed by &quot;(s)&quot; whether or not the number before it is 1.</p></blockquote><p>Sample Input</p><blockquote><p>3 6 5<br>NEESWE<br>WWWESS<br>SNWWWW<br>4 5 1<br>SESWE<br>EESNW<br>NWEEN<br>EWSEN<br>0 0 0</p></blockquote><p>Sample Output</p><blockquote><p>10 step(s) to exit<br>3 step(s) before a loop of 8 step(s)</p></blockquote><p>Problem solving:<br>这道题我是CSDN上搜的，一开始有思路不知道怎么实现。<br>但是我们可以发现这个里面每个点就会决定自己下一步是往哪里走，所以情况是唯一的。可以直接模拟。<br>这个模拟方式很巧妙地就是标记了走到任意一个位置需要的步数，如果是走出去了，直接调用中间用来存放步数的变量的值进行输出就行。如果在循环的过程中发现下一个要去到的点对应的步数的数组已经有值了就说明此时是在里面刚好转了一圈了。而转圈之前走的步数正好是从开始走走到这个点用到的步数减一，<br>每次转圈的长度就可以用存放步数的变量的值减去到达转圈的第一个点所需要的步数来得到（可以看着代码理解，模拟一下。</p><p>Code<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">char s[12][12];</span><br><span class="line">int vis[12][12];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a,b,c;</span><br><span class="line">while(scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c))</span><br><span class="line">&#123;</span><br><span class="line">if(a==0&amp;&amp;b==0&amp;&amp;c==0)break;</span><br><span class="line">for(int i=0;i&lt;a;i++)</span><br><span class="line">for(int j=0;j&lt;b;j++)</span><br><span class="line">cin&gt;&gt;s[i][j];</span><br><span class="line">int x=0,y=c-1,step=0;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">while(true)</span><br><span class="line">&#123;</span><br><span class="line">step++;</span><br><span class="line">if(s[x][y]==&apos;N&apos;&amp;&amp;!vis[x][y])</span><br><span class="line">&#123;</span><br><span class="line">vis[x][y]=step;</span><br><span class="line">x--;</span><br><span class="line">&#125;</span><br><span class="line">else if(s[x][y]==&apos;S&apos;&amp;&amp;!vis[x][y])</span><br><span class="line">&#123;</span><br><span class="line">vis[x][y]=step;</span><br><span class="line">x++;</span><br><span class="line">&#125;</span><br><span class="line">else if(s[x][y]==&apos;W&apos;&amp;&amp;!vis[x][y])</span><br><span class="line">&#123;</span><br><span class="line">vis[x][y]=step;</span><br><span class="line">y--;</span><br><span class="line">&#125;</span><br><span class="line">else if(s[x][y]==&apos;E&apos;&amp;&amp;!vis[x][y])</span><br><span class="line">&#123;</span><br><span class="line">vis[x][y]=step;</span><br><span class="line">y++;</span><br><span class="line">&#125;</span><br><span class="line">if(x&lt;0||x==a||y&lt;0||y==b)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d step(s) to exit\n&quot;,step);break;</span><br><span class="line">&#125;</span><br><span class="line">else if(vis[x][y])</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d step(s) before a loop of %d step(s)\n&quot;,vis[x][y]-1,step+1-vis[x][y]);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Number-Transformation"><a href="#Number-Transformation" class="headerlink" title="Number Transformation"></a>Number Transformation</h3><p>Description:<br>In this problem, you are given an integer number s. You can transform any integer number A to another integer number B by adding x to A. This x is an integer number which is a prime factor of A (please note that 1 and A are not being considered as a factor of A). Now, your task is to find the minimum number of transformations required to transform s to another integer number t.</p><p>Input</p><blockquote><p>Input starts with an integer T (≤ 500), denoting the number of test cases.<br>Each case contains two integers: s (1 ≤ s ≤ 100) and t (1 ≤ t ≤ 1000).</p></blockquote><p>Output</p><blockquote><p>For each case, print the case number and the minimum number of transformations needed. If it&#39;s impossible, then print -1.</p></blockquote><p>Sample Input</p><blockquote><p>2<br>6 12<br>6 13</p></blockquote><p>Sample Output</p><blockquote><p>Case 1: 2<br>Case 2: -1</p></blockquote><p>Problem solving:<br>暴力解决就行，数据范围很小。<br>先对素数打表，然后再进行BFS查找即可。<br>BFS中扩展队列的方式<br>对输入的s，求出s的每个质因子加上它本身之后放进队列，如果出现了与t相同的情况，退出查找即可。关于特殊情况的判定我们还用A题的方式，定义一个ans变量初始值设为-1，如果出现了相等的就对ans进行更新即可。注意，如果在扩展队列的过程中遇到了之前已经出现过的数或者这个数已经大于了t，就不需要再把这个数放进队列了。</p><p>Code<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 2005;</span><br><span class="line">int p[2005];</span><br><span class="line">int vis[2005];</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">p[1]=p[0]=1;</span><br><span class="line">for(int i=2;i&lt;sqrt(maxn);i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=i*2;j&lt;maxn;j+=i)</span><br><span class="line">p[j]=1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">struct node&#123;</span><br><span class="line">int x,step;</span><br><span class="line">&#125;;</span><br><span class="line">int flag;</span><br><span class="line">void bfs(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">flag=-1;</span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line">node now,mid;</span><br><span class="line">now.x=x;now.step=0;</span><br><span class="line">vis[x]=1;</span><br><span class="line">q.push(now);</span><br><span class="line">int ans=-1;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">now=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">for(int i=2;i&lt;now.x;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(now.x%i==0&amp;&amp;!p[i])</span><br><span class="line">&#123;</span><br><span class="line">mid.x=now.x+i;</span><br><span class="line">if(vis[mid.x]||mid.x&gt;y)continue;</span><br><span class="line">vis[mid.x]=1;</span><br><span class="line">mid.step=now.step+1;</span><br><span class="line">if(mid.x==y)</span><br><span class="line">&#123;</span><br><span class="line">flag=mid.step;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">q.push(mid);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,a,b;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">init();</span><br><span class="line">int cnt=1;</span><br><span class="line">while(n--)</span><br><span class="line">&#123;</span><br><span class="line">int a,b;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">cout&lt;&lt;&quot;Case &quot;&lt;&lt;cnt++&lt;&lt;&quot;: &quot;;</span><br><span class="line">if(a==b)</span><br><span class="line">&#123;</span><br><span class="line">puts(&quot;0&quot;);</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">bfs(a,b);</span><br><span class="line">cout&lt;&lt;flag&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Knight-Moves"><a href="#Knight-Moves" class="headerlink" title="Knight Moves"></a>Knight Moves</h3><p>Description:<br>A friend of you is doing research on the Traveling Knight Problem (TKP) where you are to find the shortest closed tour of knight moves that visits each square of a given set of n squares on a chessboard exactly once. He thinks that the most difficult part of the problem is determining the smallest number of knight moves between two given squares and that, once you have accomplished this, finding the tour would be easy.<br>Of course you know that it is vice versa. So you offer him to write a program that solves the &quot;difficult&quot; part.</p><p>Your job is to write a program that takes two squares a and b as input and then determines the number of knight moves on a shortest route from a to b.<br>Input</p><blockquote><p>The input file will contain one or more test cases. Each test case consists of one line containing two squares separated by one space. A square is a string consisting of a letter (a-h) representing the column and a digit (1-8) representing the row on the chessboard.</p></blockquote><p>Output</p><blockquote><p>For each test case, print one line saying &quot;To get from xx to yy takes n knight moves.&quot;.</p></blockquote><p>Sample Input</p><blockquote><p>e2 e4<br>a1 b2<br>b2 c3<br>a1 h8<br>a1 h7<br>h8 a1<br>b1 c3<br>f6 f6</p></blockquote><p>Sample Output</p><blockquote><p>To get from e2 to e4 takes 2 knight moves.<br>To get from a1 to b2 takes 4 knight moves.<br>To get from b2 to c3 takes 2 knight moves.<br>To get from a1 to h8 takes 6 knight moves.<br>To get from a1 to h7 takes 5 knight moves.<br>To get from h8 to a1 takes 6 knight moves.<br>To get from b1 to c3 takes 1 knight moves.<br>To get from f6 to f6 takes 0 knight moves.</p></blockquote><p>Problem solving:<br>这道题就是一道简单的BFS模板题，只不过题不太好懂，这里我找到一张图可以参考一下。<br><img src="https://i.loli.net/2019/07/23/5d36d61f72c1f58484.png" alt><br>就是马走日的问题，分8个方向进行查找即可。从图上就可以以看出输入的字符串如何处理成坐标的形式。即<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while(~scanf(&quot;%s %s&quot;,a,b))</span><br><span class="line">&#123;</span><br><span class="line">sx=a[0]-&apos;a&apos;+1;sy=a[1]-&apos;0&apos;;ex=b[0]-&apos;a&apos;+1;ey=b[1]-&apos;0&apos;;</span><br></pre></td></tr></table></figure></p><p>Code<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int vis[10][10],sx,sy,ex,ey;</span><br><span class="line">struct node&#123;</span><br><span class="line">int x,y,step;</span><br><span class="line">&#125;;</span><br><span class="line">int d[8][2]=&#123;-2,-1, -1,-2, 1,-2, 2,-1, 2,1, 1,2, -1,2, -2,1&#125;;</span><br><span class="line">int bfs(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">queue&lt;node&gt; que;</span><br><span class="line">vis[x][y]=1;</span><br><span class="line">node now,mid;</span><br><span class="line">now.x=x;now.y=y;now.step=0;</span><br><span class="line">que.push(now);</span><br><span class="line">while(!que.empty())</span><br><span class="line">&#123;</span><br><span class="line">now=que.front();que.pop();</span><br><span class="line">if(now.x==ex&amp;&amp;now.y==ey)</span><br><span class="line">&#123;</span><br><span class="line">return now.step;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;8;i++)</span><br><span class="line">&#123;</span><br><span class="line">mid.x=now.x+d[i][0];</span><br><span class="line">mid.y=now.y+d[i][1];</span><br><span class="line">if(mid.x&lt;=0||mid.x&gt;8||mid.y&lt;=0||mid.y&gt;8||vis[mid.x][mid.y])continue;</span><br><span class="line">vis[mid.x][mid.y]=1;</span><br><span class="line">mid.step=now.step+1;</span><br><span class="line">que.push(mid);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">char a[3],b[3];</span><br><span class="line">while(~scanf(&quot;%s %s&quot;,a,b))</span><br><span class="line">&#123;</span><br><span class="line">int m;</span><br><span class="line">sx=a[0]-&apos;a&apos;+1;sy=a[1]-&apos;0&apos;;ex=b[0]-&apos;a&apos;+1;ey=b[1]-&apos;0&apos;;</span><br><span class="line">//cout&lt;&lt;sx&lt;&lt;sy&lt;&lt;ex&lt;&lt;ey&lt;&lt;endl;</span><br><span class="line">m=bfs(sx,sy);</span><br><span class="line">cout&lt;&lt;&quot;To get from &quot;&lt;&lt;a&lt;&lt;&quot; to &quot;&lt;&lt;b&lt;&lt;&quot; takes &quot;&lt;&lt;m&lt;&lt;&quot; knight moves.&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//To get from e2 to e4 takes 2 knight moves.</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天主要讲了BFS和DFS，还有存图和链式前向星，后面这两个在今天刷题的过程中还没有遇到，晚会把他们加到我的模板里面。
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="Algorithm" scheme="https://cndrew.cn/blog/tags/Algorithm/"/>
    
      <category term="Thinking" scheme="https://cndrew.cn/blog/tags/Thinking/"/>
    
      <category term="DFS" scheme="https://cndrew.cn/blog/tags/DFS/"/>
    
      <category term="Simulation" scheme="https://cndrew.cn/blog/tags/Simulation/"/>
    
      <category term="BFS" scheme="https://cndrew.cn/blog/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>HPU Summer Training Day 6（河南理工大学暑期第六天）</title>
    <link href="https://cndrew.cn/blog/2019/07/22/d6/"/>
    <id>https://cndrew.cn/blog/2019/07/22/d6/</id>
    <published>2019-07-22T14:19:00.504Z</published>
    <updated>2019-07-24T14:10:32.356Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天主要讲的是二分和贪心，题有点难。已经开始了不能写完题的日子了<a id="more"></a></p><h3 id="Pie"><a href="#Pie" class="headerlink" title="Pie"></a>Pie</h3><p>Description:<br>My birthday is coming up and traditionally I&#39;m serving pie. Not just one pie, no, I have a number N of them, of various tastes and of various sizes. F of my friends are coming to my party and each of them gets a piece of pie. This should be one piece of one pie, not several small pieces since that looks messy. This piece can be one whole pie though.</p><p>My friends are very annoying and if one of them gets a bigger piece than the others, they start complaining. Therefore all of them should get equally sized (but not necessarily equally shaped) pieces, even if this leads to some pie getting spoiled (which is better than spoiling the party). Of course, I want a piece of pie for myself too, and that piece should also be of the same size.</p><p>What is the largest possible piece size all of us can get? All the pies are cylindrical in shape and they all have the same height 1, but the radii of the pies can be different.<br>Input<br>One line with a positive integer: the number of test cases. Then for each test case:<br>---One line with two integers N and F with 1 &lt;= N, F &lt;= 10 000: the number of pies and the number of friends.<br>---One line with N integers ri with 1 &lt;= ri &lt;= 10 000: the radii of the pies.<br>Output<br>For each test case, output one line with the largest possible volume V such that me and my friends can all get a pie piece of size V. The answer should be given as a floating point number with an absolute error of at most 10^(-3).<br>Sample Input</p><blockquote><p>3<br>3 3<br>4 3 3<br>1 24<br>5<br>10 5<br>1 4 2 3 4 5 6 5 4 2</p></blockquote><p>Sample Output</p><blockquote><p>25.1327<br>3.1416<br>50.2655</p></blockquote><p>Problem solving:<br>注意到人数也得算得上自己，然后因为每个人分到的pie必须是一块（所以不可以平均分），这个时候就用到二分答案了。<br>二分中检测是否满足题意的判断方法是，用一个for循环计算出以每人分到mid面积时可以分给多少人，跟需要分到的人数进行比较就行了。<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const double pi = acos(-1.0);</span><br><span class="line">double       s[10005];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    while (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        int a, b, x; double sum = 0, pm = 0;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        b += 1;</span><br><span class="line">        for (int i = 0; i &lt; a; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            s[i] = x * x * pi;</span><br><span class="line">            sum += s[i];</span><br><span class="line">            pm   = max(pm, s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        double l = 0, r = sum / b, mid;</span><br><span class="line">        while (r - l &gt; 0.000001)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (r + l) / 2;</span><br><span class="line">            int now = 0;</span><br><span class="line">            for (int i = 0; i &lt; a; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                now += int(s[i] / mid);</span><br><span class="line">            &#125;</span><br><span class="line">            if (now &lt; b)</span><br><span class="line">                r = mid;</span><br><span class="line">            else</span><br><span class="line">                l = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%.4lf\n&quot;, mid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Best-Cow-Line"><a href="#Best-Cow-Line" class="headerlink" title="Best Cow Line"></a>Best Cow Line</h3><p>Description:<br>FJ is about to take his N (1 ≤ N ≤ 2,000) cows to the annual&quot;Farmer of the Year&quot; competition. In this contest every farmer arranges his cows in a line and herds them past the judges.</p><p>The contest organizers adopted a new registration scheme this year: simply register the initial letter of every cow in the order they will appear (i.e., If FJ takes Bessie, Sylvia, and Dora in that order he just registers BSD). After the registration phase ends, every group is judged in increasing lexicographic order according to the string of the initials of the cows&#39; names.</p><p>FJ is very busy this year and has to hurry back to his farm, so he wants to be judged as early as possible. He decides to rearrange his cows, who have already lined up, before registering them.</p><p>FJ marks a location for a new line of the competing cows. He then proceeds to marshal the cows from the old line to the new one by repeatedly sending either the first or last cow in the (remainder of the) original line to the end of the new line. When he&#39;s finished, FJ takes his cows for registration in this new order.</p><p>Given the initial order of his cows, determine the least lexicographic string of initials he can make this way.</p><p>Input</p><ul><li>Line 1: A single integer: N</li><li>Lines 2: N+1: Line i+1 contains a single initial (&#39;A&#39;..&#39;Z&#39;) of the cow in the ith position in the original line</li></ul><p>Output<br>The least lexicographic string he can make. Every line (except perhaps the last one) contains the initials of 80 cows (&#39;A&#39;..&#39;Z&#39;) in the new line.</p><p>Sample Input</p><blockquote><p>6<br>A<br>C<br>D<br>B<br>C<br>B</p></blockquote><p>Sample Output</p><blockquote><p>ABCBCD</p></blockquote><p>Problem solving:<br>白书原题，经典贪心问题。先比较当前的第一个和最后一个字符，如果想等就比较第二个和倒数第二个字符，以此找到前后字符的大小关系，然后进行删除和添加的操作就行了。具体看代码。<br>注意，每输出80个字符就得换行！！！</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n;</span><br><span class="line">char a[2005];</span><br><span class="line">void solve()</span><br><span class="line">&#123;</span><br><span class="line">int p=0,x=0,b=n-1;</span><br><span class="line">while(x&lt;=b)</span><br><span class="line">&#123;</span><br><span class="line">int flag=0;</span><br><span class="line">for(int i=0;x+i&lt;=b;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(a[x+i]&lt;a[b-i])</span><br><span class="line">&#123;</span><br><span class="line">flag=1;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">else if(a[x+i]&gt;a[b-i])</span><br><span class="line">&#123;</span><br><span class="line">flag=0;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(flag)putchar(a[x++]);</span><br><span class="line">elseputchar(a[b--]);</span><br><span class="line">p++;</span><br><span class="line">if(p%80==0)puts(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">puts(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i=0;i&lt;n;i++)cin&gt;&gt;a[i];</span><br><span class="line">solve();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Trailing-Zeroes-III"><a href="#Trailing-Zeroes-III" class="headerlink" title="Trailing Zeroes (III)"></a>Trailing Zeroes (III)</h3><p>Description:<br>You task is to find minimal natural number N, so that N! contains exactly Q zeroes on the trail in decimal notation. As you know N! = 1<em>2</em>...*N. For example, 5! = 120, 120 contains one zero on the trail.</p><p>Input<br>Input starts with an integer T (≤ 10000), denoting the number of test cases.</p><p>Each case contains an integer Q (1 ≤ Q ≤ 1e8) in a line.</p><p>Output<br>For each case, print the case number and N. If no solution is found then print &#39;impossible&#39;.</p><p>Sample Input</p><blockquote><p>3<br>1<br>2<br>5</p></blockquote><p>Sample Output</p><blockquote><p>Case 1: 5<br>Case 2: 10<br>Case 3: impossible</p></blockquote><p>Problem solving:<br>求n的阶乘的0的个数，只需要求得n中5得个数即可。因为只有2*5=10，所以每一个0都对应着一个2和一个5，而二的个数多于5，所以我们只要找到5得个数就是0得个数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">\\找5得个数得方法</span><br><span class="line">long long co(long long x)</span><br><span class="line">&#123;</span><br><span class="line">    long long ans = 0;</span><br><span class="line">    while (x)</span><br><span class="line">    &#123;</span><br><span class="line">        ans += x / 5;</span><br><span class="line"></span><br><span class="line">        x /= 5;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>剩下的就是二分答案。注意这道题存在着“impossible”得情况，所以在二分得过程中如果遇到了满足题意得mid，一定要记录下来。方便后面判断。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">long long co(long long x)</span><br><span class="line">&#123;</span><br><span class="line">    long long ans = 0;</span><br><span class="line">    while (x)</span><br><span class="line">    &#123;</span><br><span class="line">        ans += x / 5;</span><br><span class="line"></span><br><span class="line">        x /= 5;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    long long t, q;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    long long cas = 1;</span><br><span class="line">    while (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; q; long long flag = 0;</span><br><span class="line">        long long           l = 1, r = 1000000000000, mid;</span><br><span class="line">        while (l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (l + r) / 2;</span><br><span class="line">            if (co(mid) == q)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = mid;</span><br><span class="line">                r    = mid - 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (co(mid) &gt; q)</span><br><span class="line">                r = mid - 1;</span><br><span class="line">            else</span><br><span class="line">                l = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (flag)</span><br><span class="line">            cout &lt;&lt; &quot;Case &quot; &lt;&lt; cas++ &lt;&lt; &quot;: &quot; &lt;&lt; flag &lt;&lt; endl;</span><br><span class="line">        else</span><br><span class="line">            cout &lt;&lt; &quot;Case &quot; &lt;&lt; cas++ &lt;&lt; &quot;: &quot; &lt;&lt; &quot;impossible&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="The-Frog-39-s-Games"><a href="#The-Frog-39-s-Games" class="headerlink" title="The Frog&#39;s Games"></a>The Frog&#39;s Games</h3><p>Description:<br>The annual Games in frogs&#39; kingdom started again. The most famous game is the Ironfrog Triathlon. One test in the Ironfrog Triathlon is jumping. This project requires the frog athletes to jump over the river. The width of the river is L (1&lt;= L &lt;= 1000000000). There are n (0&lt;= n &lt;= 500000) stones lined up in a straight line from one side to the other side of the river. The frogs can only jump through the river, but they can land on the stones. If they fall into the river, they<br>are out. The frogs was asked to jump at most m (1&lt;= m &lt;= n+1) times. Now the frogs want to know if they want to jump across the river, at least what ability should they have. (That is the frog&#39;s longest jump distance).<br>Input<br>The input contains several cases. The first line of each case contains three positive integer L, n, and m.<br>Then n lines follow. Each stands for the distance from the starting banks to the nth stone, two stone appear in one place is impossible.<br>Output<br>For each case, output a integer standing for the frog&#39;s ability at least they should have.<br>Sample Input</p><blockquote><p>6 1 2<br>2<br>25 3 3<br>11<br>2<br>18</p></blockquote><p>Sample Output</p><blockquote><p>4<br>11</p></blockquote><p>Problem solving:<br>题意就是让你找到青蛙得最大的最小弹跳力，即每次可以跳的最远距离。<br>左边界时每个石头间距的最大值，右边界是河的宽度，然后进行二分。每次二分的时候，找到处于当前位置位置的青蛙跳一次mid的距离刚好最小到达的点，然后进行下一次循环（具体看代码吧）<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=500005;</span><br><span class="line">int a[maxn];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int i,L,n,m;</span><br><span class="line">while(scanf(&quot;%d%d%d&quot;,&amp;L,&amp;n,&amp;m)!=EOF)</span><br><span class="line">&#123;</span><br><span class="line">memset(a,0,sizeof(a));</span><br><span class="line">for(i=1;i&lt;=n;i++)</span><br><span class="line">scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">a[n+1]=L;</span><br><span class="line">sort(a+1,a+n+2);</span><br><span class="line">int maxx=0;</span><br><span class="line">for(i=1;i&lt;=n+1;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(a[i]-a[i-1]&gt;maxx)</span><br><span class="line">maxx=a[i]-a[i-1];</span><br><span class="line">&#125;</span><br><span class="line">int l=maxx,r=L;</span><br><span class="line">while(l&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line">int ans=0,pos=0;</span><br><span class="line">int mid=(l+r)/2;</span><br><span class="line">for(i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(a[i]-a[pos]&lt;=mid&amp;&amp;a[i+1]-a[pos]&gt;mid)//i即为青蛙跳一次之后到达的最远的石头</span><br><span class="line">&#123;</span><br><span class="line">pos=i;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans++;</span><br><span class="line">if(ans&lt;=m)r=mid-1;</span><br><span class="line">elsel=mid+1;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d\n&quot;,l);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="湫湫系列故事——消灭兔子"><a href="#湫湫系列故事——消灭兔子" class="headerlink" title="湫湫系列故事——消灭兔子"></a>湫湫系列故事——消灭兔子</h3><p>Description:<br>湫湫减肥<br>　　越减越肥！<br>　　<br>　　最近，减肥失败的湫湫为发泄心中郁闷，在玩一个消灭免子的游戏。<br>　　游戏规则很简单，用箭杀死免子即可。<br>　　箭是一种消耗品，已知有M种不同类型的箭可以选择，并且每种箭都会对兔子造成伤害，对应的伤害值分别为Di（1 &lt;= i &lt;= M），每种箭需要一定的QQ币购买。<br>　　假设每种箭只能使用一次，每只免子也只能被射一次，请计算要消灭地图上的所有兔子最少需要的QQ币。<br>Input<br>输入数据有多组，每组数据有四行；<br>第一行有两个整数N，M（1 &lt;= N, M &lt;= 100000），分别表示兔子的个数和箭的种类；<br>第二行有N个正整数，分别表示兔子的血量Bi（1 &lt;= i &lt;= N）；<br>第三行有M个正整数，表示每把箭所能造成的伤害值Di（1 &lt;= i &lt;= M）；<br>第四行有M个正整数，表示每把箭需要花费的QQ币Pi（1 &lt;= i &lt;= M）。</p><p>特别说明：<br>1、当箭的伤害值大于等于兔子的血量时，就能将兔子杀死；<br>2、血量Bi，箭的伤害值Di，箭的价格Pi，均小于等于100000。<br>Output<br>如果不能杀死所有兔子，请输出”No”，否则，请输出最少的QQ币数，每组输出一行。<br>Sample Input</p><blockquote><p>3 3<br>1 2 3<br>2 3 4<br>1 2 3<br>3 4<br>1 2 3<br>1 2 3 4<br>1 2 3 1</p></blockquote><p>Sample Output</p><blockquote><p>6<br>4</p></blockquote><p>Problem solving:<br>将兔子的血量进行降序排序，然后将剑按照攻击力降序排列，如果攻击力相等就按照qq币的花费降序排列。<br>要用到优先队列，对降序排列的兔子，找到攻击力大于它的剑，放进优先队列，直到攻击力小于兔子的血量，然后答案加上优先队列顶部的qq消费。如果兔子还没杀完队列就为空了，就输出no。贪心的思想。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e5+10;</span><br><span class="line">struct node&#123;</span><br><span class="line">int d,p;</span><br><span class="line">friend bool operator &lt; (node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">return a.p&gt;b.p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;x[maxn];</span><br><span class="line">int b[maxn];</span><br><span class="line">bool cmp2(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">return x&gt;y;</span><br><span class="line">&#125;</span><br><span class="line">bool cmp(node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">if(a.d==b.d)return a.p&gt;b.p;</span><br><span class="line">return a.d&gt;b.d;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,m;</span><br><span class="line">while(cin&gt;&gt;n&gt;&gt;m)</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;n;i++)cin&gt;&gt;b[i];</span><br><span class="line">sort(b,b+n,cmp2);</span><br><span class="line">for(int i=0;i&lt;m;i++)cin&gt;&gt;x[i].d;</span><br><span class="line">for(int i=0;i&lt;m;i++)cin&gt;&gt;x[i].p;</span><br><span class="line">sort(x,x+m,cmp);</span><br><span class="line">priority_queue&lt;node&gt; sta;</span><br><span class="line">int pos=0;</span><br><span class="line">long long ans=0;</span><br><span class="line">int flag=0;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">while(x[pos].d&gt;=b[i]&amp;&amp;pos&lt;m)</span><br><span class="line">&#123;</span><br><span class="line">sta.push(x[pos]);</span><br><span class="line">//cout&lt;&lt;x[pos].d&lt;&lt;&quot; &quot;&lt;&lt;x[pos].p&lt;&lt;endl;</span><br><span class="line">pos++;</span><br><span class="line">&#125;</span><br><span class="line">if(sta.empty())</span><br><span class="line">&#123;</span><br><span class="line">flag=1;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">//cout&lt;&lt;sta.top().p&lt;&lt;&quot;?\n&quot;;</span><br><span class="line">ans+=sta.top().p;</span><br><span class="line">sta.pop();</span><br><span class="line">&#125;</span><br><span class="line">if(flag)puts(&quot;No&quot;);</span><br><span class="line">elsecout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Strange-fuction"><a href="#Strange-fuction" class="headerlink" title="Strange fuction"></a>Strange fuction</h3><p>Description:<br>Now, here is a fuction:<br>  F(x) = 6 <em> x^7+8</em>x^6+7<em>x^3+5</em>x^2-y*x (0 &lt;= x &lt;=100)<br>Can you find the minimum value when x is between 0 and 100.<br>Input<br>The first line of the input contains an integer T(1&lt;=T&lt;=100) which means the number of test cases. Then T lines follow, each line has only one real numbers Y.(0 &lt; Y &lt;1e10)<br>Output<br>Just the minimum value (accurate up to 4 decimal places),when x is between 0 and 100.<br>Sample Input</p><blockquote><p>2<br>100<br>200</p></blockquote><p>Sample Output</p><blockquote><p>-74.4291<br>-178.8534</p></blockquote><p>Problem solving:<br>简单的数学题，求函数极值，对函数求一阶导，另它为0即可，因为本题中二次导之后函数恒大于0所以一阶导为0求出来的极值就是极小值。确定x的值得时候用二分确定</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int    t;</span><br><span class="line">    double y;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; y;</span><br><span class="line">        double l = 0, r = 100, x;</span><br><span class="line">        while (r - l &gt; 0.000001)</span><br><span class="line">        &#123;</span><br><span class="line">            x = (l + r) / 2;</span><br><span class="line">            double mmp;</span><br><span class="line">            mmp = 42 * pow(x, 6) + 48 * pow(x, 5) + 21 * pow(x, 2) + 10 * x;</span><br><span class="line">            if (mmp &lt; y)</span><br><span class="line">                l = x;</span><br><span class="line">            else</span><br><span class="line">                r = x;</span><br><span class="line">        &#125;</span><br><span class="line">        double ans = 6 * pow(x, 7) + 8 * pow(x, 6) + 7 * pow(x, 3) + 5 * x * x - y * x;</span><br><span class="line">        printf(&quot;%.4lf\n&quot;, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Can-you-find-it"><a href="#Can-you-find-it" class="headerlink" title="Can you find it?"></a>Can you find it?</h3><p>Description:<br>Give you three sequences of numbers A, B, C, then we give you a number X. Now you need to calculate if you can find the three numbers Ai, Bj, Ck, which satisfy the formula Ai+Bj+Ck = X.<br>Input<br>There are many cases. Every data case is described as followed: In the first line there are three integers L, N, M, in the second line there are L integers represent the sequence A, in the third line there are N integers represent the sequences B, in the forth line there are M integers represent the sequence C. In the fifth line there is an integer S represents there are S integers X to be calculated. 1&lt;=L, N, M&lt;=500, 1&lt;=S&lt;=1000. all the integers are 32-integers.<br>Output<br>For each case, firstly you have to print the case number as the form &quot;Case d:&quot;, then for the S queries, you calculate if the formula can be satisfied or not. If satisfied, you print &quot;YES&quot;, otherwise print &quot;NO&quot;.<br>Sample Input</p><blockquote><p>3 3 3<br>1 2 3<br>1 2 3<br>1 2 3<br>3<br>1<br>4<br>10</p></blockquote><p>Sample Output</p><blockquote><p>Case 1:<br>NO<br>YES<br>NO</p></blockquote><p>Problem solving:<br>优雅的暴力之后再二分查找。<br>把前两个数组可以组成的所有的和用一个数组存下来（这一步最坏的情况的复杂度也才O（2e5），显然不会超时。然后对接下来输入的需要判断的每个值进行查找，对第三个数组中的每一个数<br>使用二分查找去找两者的差值再上一步得到的新数组中有没有存在。有即YES，否则就是NO。<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 505;</span><br><span class="line">int       a[maxn], b[maxn], c[maxn], d[250005];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int l, n, m, cas = 0;</span><br><span class="line">    while (~scanf(&quot;%d %d %d&quot;, &amp;l, &amp;n, &amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i &lt; l; i++)</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        for (int j = 0; j &lt; n; j++)</span><br><span class="line">            cin &gt;&gt; b[j];</span><br><span class="line">        for (int k = 0; k &lt; m; k++)</span><br><span class="line">            cin &gt;&gt; c[k];</span><br><span class="line">        int pos = 0;</span><br><span class="line">        sort(a, a + l); sort(b, b + n);</span><br><span class="line">        for (int i = 0; i &lt; l; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j = 0; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                d[pos++] = a[i] + b[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(d, d + pos); sort(c, c + m);</span><br><span class="line">        cout &lt;&lt; &quot;Case &quot; &lt;&lt; ++cas &lt;&lt; &quot;:\n&quot;;</span><br><span class="line">        int p, mid;</span><br><span class="line">        cin &gt;&gt; p;</span><br><span class="line">        while (p--)</span><br><span class="line">        &#123;</span><br><span class="line">            int flag = 0;</span><br><span class="line">            cin &gt;&gt; mid;</span><br><span class="line">            for (int i = 0; i &lt; m; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if (binary_search(d, d + pos, mid - c[i]))</span><br><span class="line">                &#123;</span><br><span class="line">                    flag = 1;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (flag)</span><br><span class="line">                puts(&quot;YES&quot;);</span><br><span class="line">            else</span><br><span class="line">                puts(&quot;NO&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="pairs"><a href="#pairs" class="headerlink" title="pairs"></a>pairs</h3><p>Description:<br>John has n points on the X axis, and their coordinates are (x[i],0),(i=0,1,2,…,n−1). He wants to know how many pairs&lt;a,b&gt; that |x[b]−x[a]|≤k.(a&lt;b)<br>Input<br>The first line contains a single integer T (about 5), indicating the number of cases.<br>Each test case begins with two integers n,k(1≤n≤100000,1≤k≤1e9).<br>Next n lines contain an integer xi(−1e9≤x[i]≤1e9), means the X coordinates.<br>Output<br>For each case, output an integer means how many pairs&lt;a,b&gt; that |x[b]−x[a]|≤k.<br>Sample Input</p><blockquote><p>2<br>5 5<br>-100<br>0<br>100<br>101<br>102<br>5 300<br>-100<br>0<br>100<br>101<br>102</p></blockquote><p>Sample Output</p><blockquote><p>3<br>10</p></blockquote><p>Problem solving:<br>排序之后直接进行二分查找，用lower_bound()或者手写也行，复杂度是O(N)</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const long long maxn=1e5+7;</span><br><span class="line">long long p[maxn];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">long long t,a,b;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">for(long long i=0;i&lt;a;i++)cin&gt;&gt;p[i];</span><br><span class="line">sort(p,p+a);</span><br><span class="line">long long ans=0,pos=0;</span><br><span class="line">for(long long i=0;i&lt;a;i++)</span><br><span class="line">&#123;</span><br><span class="line">while(p[pos]-p[i]&lt;=b&amp;&amp;pos&lt;a)pos++;</span><br><span class="line">ans+=pos-i-1;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Radar-Installation"><a href="#Radar-Installation" class="headerlink" title="Radar Installation"></a>Radar Installation</h3><p>Description:<br>Assume the coasting is an infinite straight line. Land is in one side of coasting, sea in the other. Each small island is a point locating in the sea side. And any radar installation, locating on the coasting, can only cover d distance, so an island in the sea can be covered by a radius installation, if the distance between them is at most d.</p><p>We use Cartesian coordinate system, defining the coasting is the x-axis. The sea side is above x-axis, and the land side below. Given the position of each island in the sea, and given the distance of the coverage of the radar installation, your task is to write a program to find the minimal number of radar installations to cover all the islands. Note that the position of an island is represented by its x-y coordinates.</p><p>Figure A Sample Input of Radar Installations<br><img src="https://i.loli.net/2019/07/23/5d35de6bd0a7a22502.png" alt></p><p>Input<br>The input consists of several test cases. The first line of each case contains two integers n (1&lt;=n&lt;=1000) and d, where n is the number of islands in the sea and d is the distance of coverage of the radar installation. This is followed by n lines each containing two integers representing the coordinate of the position of each island. Then a blank line follows to separate the cases.</p><p>The input is terminated by a line containing pair of zeros<br>Output<br>For each test case output one line consisting of the test case number followed by the minimal number of radar installations needed. &quot;-1&quot; installation means no solution for that case.<br>Sample Input</p><blockquote><p>3 2<br>1 2<br>-3 1<br>2 1<br>1 2<br>0 2<br>0 0</p></blockquote><p>Sample Output</p><blockquote><p>Case 1: 2<br>Case 2: 1</p></blockquote><p>Problem solving:<br>这道题跟暑假不AC很像（在前几天的训练中做过），对每个岛的坐标求出来以它为圆心，雷达探测半径为半径的圆与x的两个交点，然后对得到的每组左右端点进行贪心。（我的代码这里写的有点麻烦了，直接输入求交点就行，不用存岛的坐标）。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">int x,y;</span><br><span class="line">double l,r;</span><br><span class="line">&#125;p[1005];</span><br><span class="line">bool cmp(node x,node y)</span><br><span class="line">&#123;</span><br><span class="line">if(x.r==y.r)return x.l&gt;y.l;</span><br><span class="line">return x.r&lt;y.r;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,d,i=0;</span><br><span class="line">while(scanf(&quot;%d %d&quot;,&amp;n,&amp;d)&amp;&amp;n&amp;&amp;d)</span><br><span class="line">&#123;</span><br><span class="line">int flag=0;</span><br><span class="line">for(int i=0;i&lt;n;i++)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(p[i].y&gt;d)</span><br><span class="line">&#123;</span><br><span class="line">flag=1;</span><br><span class="line">&#125;</span><br><span class="line">double mid;</span><br><span class="line">mid=sqrt(d*d-p[i].y*p[i].y);</span><br><span class="line">p[i].l=p[i].x-mid;</span><br><span class="line">p[i].r=p[i].x+mid;</span><br><span class="line">&#125;</span><br><span class="line">if(flag)cout&lt;&lt;&quot;Case &quot;&lt;&lt;++i&lt;&lt;&quot;: -1&quot;&lt;&lt;endl;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">sort(p,p+n,cmp);</span><br><span class="line">int ans=1;double ri=p[0].r;</span><br><span class="line">for(int i=1;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(p[i].l&gt;ri)</span><br><span class="line">&#123;</span><br><span class="line">ans++;</span><br><span class="line">ri=p[i].r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;&quot;Case &quot;&lt;&lt;++i&lt;&lt;&quot;: &quot;&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Aggressive-cows"><a href="#Aggressive-cows" class="headerlink" title="Aggressive cows"></a>Aggressive cows</h3><p>Description:<br>Farmer John has built a new long barn, with N (2 &lt;= N &lt;= 100,000) stalls. The stalls are located along a straight line at positions x1,...,xN (0 &lt;= xi &lt;= 1,000,000,000).</p><p>His C (2 &lt;= C &lt;= N) cows don&#39;t like this barn layout and become aggressive towards each other once put into a stall. To prevent the cows from hurting each other, FJ want to assign the cows to the stalls, such that the minimum distance between any two of them is as large as possible. What is the largest minimum distance?<br>Input</p><ul><li><p>Line 1: Two space-separated integers: N and C</p></li><li><p>Lines 2..N+1: Line i+1 contains an integer stall location, xi<br>Output</p></li><li>Line 1: One integer: the largest minimum distance</li></ul><p>Sample Input</p><blockquote><p>5 3<br>1<br>2<br>8<br>4<br>9</p></blockquote><p>Sample Output</p><blockquote><p>3</p></blockquote><p>Hint<br>OUTPUT DETAILS:</p><p>FJ can put his 3 cows in the stalls at positions 1, 4 and 8, resulting in a minimum distance of 3.</p><p>Huge input data,scanf is recommended.</p><p>Problem solving:<br>白书原题，经典二分题，二分答案，对mid的检测方法是看它能不能满足以mid为最小的距离时能住下的牛的个数大于等于要求的个数。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll n,c;</span><br><span class="line">ll a[100005];</span><br><span class="line">bool check(ll x)</span><br><span class="line">&#123;</span><br><span class="line">ll mmp=0;</span><br><span class="line">for(int i=1;i&lt;c;i++)</span><br><span class="line">&#123;</span><br><span class="line">ll mid=mmp+1;</span><br><span class="line">while(mid&lt;n&amp;&amp;a[mid]-a[mmp]&lt;x)</span><br><span class="line">&#123;</span><br><span class="line">mid++;</span><br><span class="line">&#125;</span><br><span class="line">if(mid==n)return 0;</span><br><span class="line">mmp=mid;</span><br><span class="line">&#125;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%lld %lld&quot;,&amp;n,&amp;c);</span><br><span class="line">for(ll i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%lld&quot;,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line">sort(a,a+n);</span><br><span class="line">ll l=0,r=1e18,mid;</span><br><span class="line">while(r-l&gt;1)</span><br><span class="line">&#123;</span><br><span class="line">mid=(l+r)/2;</span><br><span class="line">if(check(mid))</span><br><span class="line">&#123;</span><br><span class="line">l=mid;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">r=mid;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%lld\n&quot;,l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="River-Hopscotch"><a href="#River-Hopscotch" class="headerlink" title="River Hopscotch"></a>River Hopscotch</h3><p>Description:<br>Every year the cows hold an event featuring a peculiar version of hopscotch that involves carefully jumping from rock to rock in a river. The excitement takes place on a long, straight river with a rock at the start and another rock at the end, L units away from the start (1 ≤ L ≤ 1,000,000,000). Along the river between the starting and ending rocks, N (0 ≤ N ≤ 50,000) more rocks appear, each at an integral distance Di from the start (0 &lt; Di &lt; L).</p><p>To play the game, each cow in turn starts at the starting rock and tries to reach the finish at the ending rock, jumping only from rock to rock. Of course, less agile cows never make it to the final rock, ending up instead in the river.</p><p>Farmer John is proud of his cows and watches this event each year. But as time goes by, he tires of watching the timid cows of the other farmers limp across the short distances between rocks placed too closely together. He plans to remove several rocks in order to increase the shortest distance a cow will have to jump to reach the end. He knows he cannot remove the starting and ending rocks, but he calculates that he has enough resources to remove up to M rocks (0 ≤ M ≤ N).</p><p>FJ wants to know exactly how much he can increase the shortest distance <em>before</em> he starts removing the rocks. Help Farmer John determine the greatest possible shortest distance a cow has to jump after removing the optimal set of M rocks.</p><p>Input<br>Line 1: Three space-separated integers: L, N, and M<br>Lines 2.. N+1: Each line contains a single integer indicating how far some rock is away from the starting rock. No two rocks share the same position.<br>Output<br>Line 1: A single integer that is the maximum of the shortest distance a cow has to jump after removing M rocks<br>Sample Input</p><blockquote><p>25 5 2<br>2<br>14<br>11<br>21<br>17</p></blockquote><p>Sample Output</p><blockquote><p>4</p></blockquote><p>Hint<br>Before removing any rocks, the shortest jump was a jump of 2 from 0 (the start) to 2. After removing the rocks at 2 and 14, the shortest required jump is a jump of 4 (from 17 to 21 or from 21 to 25).</p><p>Problem solving:<br>一开始以为这道题用贪心，但是涉及到删除这个操作就很烦。<br>后来发现者就是一道二分答案的题，套板子就行。<br>check函数里面判断的条件就是当最小距离已知时，求出它对应的需要拿走石头的值，与输入的进行比较。（一开始直接循环判断样例都不过，后来才想到不能直接判断，因为有可能一次跳两个石头。所以需要这样写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int mid=0,pos=0;</span><br><span class="line">for(int i=1;i&lt;=n+1;i++)</span><br><span class="line">&#123;</span><br><span class="line">    if(a[i]-a[pos]&lt;x)</span><br><span class="line">        mid++;</span><br><span class="line">    else</span><br><span class="line">        pos=i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>mid即为当前假设的最小距离所对应的需要拿走的石头个数，然后二分答案就行了。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=50005;</span><br><span class="line">int a[maxn];</span><br><span class="line">int l,n,m;</span><br><span class="line">bool check(int x)</span><br><span class="line">&#123;</span><br><span class="line">int mid=0,pos=0;</span><br><span class="line">for(int i=1;i&lt;=n+1;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(a[i]-a[pos]&lt;x)</span><br><span class="line">mid++;</span><br><span class="line">else</span><br><span class="line">pos=i;</span><br><span class="line">&#125;</span><br><span class="line">if(mid&gt;m)return 0;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;l&gt;&gt;n&gt;&gt;m;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line">sort(a+1,a+n+1);</span><br><span class="line">a[n+1]=l,a[0]=0;</span><br><span class="line">int l=0,r=1e9,mid;</span><br><span class="line">while(l&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line">mid=(l+r)/2;</span><br><span class="line">if(check(mid))l=mid+1;</span><br><span class="line">else r=mid-1;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;l-1&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天主要讲的是二分和贪心，题有点难。已经开始了不能写完题的日子了
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="Algorithm" scheme="https://cndrew.cn/blog/tags/Algorithm/"/>
    
      <category term="Greedy" scheme="https://cndrew.cn/blog/tags/Greedy/"/>
    
      <category term="STL" scheme="https://cndrew.cn/blog/tags/STL/"/>
    
      <category term="Binary" scheme="https://cndrew.cn/blog/tags/Binary/"/>
    
  </entry>
  
  <entry>
    <title>HPU Summer Training Day 5（河南理工大学暑期第五天）</title>
    <link href="https://cndrew.cn/blog/2019/07/21/d5/"/>
    <id>https://cndrew.cn/blog/2019/07/21/d5/</id>
    <published>2019-07-21T09:32:00.890Z</published>
    <updated>2019-07-21T09:42:10.922Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>昨天积分赛的结束给今天带来了一天的休息，虽然机房开放而且好多同学都在刻苦学习，但是我以为放假就应该休息（其实就是懒<a id="more"></a><br>跟几个玩的不错的朋友去看了银河补习班，一开始朋友邀请我去看的时候我是拒绝的，但一听说是邓超演的我就同意了，还是很喜欢邓超的。这个电影看之前就听说让自备纸巾，还是很有自信心的。一开始演的还不错，影片就是讲述了一个成功的儿子是如何在爸爸的帮助下变得成功的。看到后来有些无聊，不过还是很值的去看的，虽然我自己带的纸巾也没用上，主要是我泪点高？<br>没有刷题的一天，按理说应该挺开心的，但是看到旁边的人都在刷题，唉，这可能就是我菜的原因吧Orz。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天积分赛的结束给今天带来了一天的休息，虽然机房开放而且好多同学都在刻苦学习，但是我以为放假就应该休息（其实就是懒
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="life" scheme="https://cndrew.cn/blog/tags/life/"/>
    
      <category term="movie" scheme="https://cndrew.cn/blog/tags/movie/"/>
    
  </entry>
  
  <entry>
    <title>HPU Summer Training Day 4（河南理工大学暑期第四天）</title>
    <link href="https://cndrew.cn/blog/2019/07/20/d4/"/>
    <id>https://cndrew.cn/blog/2019/07/20/d4/</id>
    <published>2019-07-20T14:07:04.105Z</published>
    <updated>2019-07-20T14:15:44.257Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>第四天啦。<a id="more"></a><br>又是自闭的一天，第一次积分赛暗淡收场，这种被打爆的感觉没人会喜欢的吧，好好补题，好好学习。<br>刷题日记：<a href="http://blog.cndrew.cn/blog/2019/07/20/jifen/" target="_blank" rel="noopener">http://blog.cndrew.cn/blog/2019/07/20/jifen/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第四天啦。
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="Algorithm" scheme="https://cndrew.cn/blog/tags/Algorithm/"/>
    
      <category term="c/c++" scheme="https://cndrew.cn/blog/tags/c-c/"/>
    
      <category term="life" scheme="https://cndrew.cn/blog/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>河南理工大学算法协会暑期集训积分赛（一）</title>
    <link href="https://cndrew.cn/blog/2019/07/20/jifen/"/>
    <id>https://cndrew.cn/blog/2019/07/20/jifen/</id>
    <published>2019-07-20T13:59:45.104Z</published>
    <updated>2019-07-21T00:46:51.892Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>积分赛，被打爆的积分赛（music<a id="more"></a></p><h3 id="Nth-power-of-n"><a href="#Nth-power-of-n" class="headerlink" title="Nth power of n"></a>Nth power of n</h3><p>Descripition:<br>求 nn 的个位数。</p><p>输入格式<br>多组输入，处理到文件结束。<br>每组数据输入一个 n。(1≤n≤1e9)</p><p>输出格式<br>输出 nn 的个位数。</p><p>样例<br>input<br>1<br>2<br>3<br>output<br>1<br>4<br>7<br>Problem solving:<br>快速幂的板子题，对10取模即可。<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll poww(ll x,ll y)</span><br><span class="line">&#123;</span><br><span class="line">ll ans=1;</span><br><span class="line">while(y)</span><br><span class="line">&#123;</span><br><span class="line">if(y&amp;1)ans=ans*x%10;</span><br><span class="line">x=x*x%10;</span><br><span class="line">y/=2;</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">ll n;</span><br><span class="line">while(~scanf(&quot;%lld&quot;,&amp;n))</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;poww(n,n)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="复读机的力量"><a href="#复读机的力量" class="headerlink" title="复读机的力量"></a>复读机的力量</h3><p>Descripition:<br>Codancer: “我好菜啊！”<br>Dicer: “我好菜啊！”<br>Todest: “我好菜啊！”<br>CaprYang: “我好菜啊！”<br>…<br>大佬们又开始装弱了，真正的菜鸡瑟瑟发抖不敢说话。</p><p>我们规定一个人是复读机当且仅当他说的每一句话都是复读前一个人说的话。<br>我们规定一个人是复读机当且仅当他说的每一句话都是复读前一个人说的话。<br>我们规定一个人是复读机当且仅当他说的每一句话都是复读前一个人说的话。<br>规定一个复读机的熟练度为复读数量的多少。现在给你一段聊天记录，请你找出其中的复读机们。<br>规定一个复读机的熟练度为复读数量的多少。现在给你一段聊天记录，请你找出其中的复读机们。<br>规定一个复读机的熟练度为复读数量的多少。现在给你一段聊天记录，请你找出其中的复读机们。</p><p>输入格式<br>输入T组,(1≤T≤10)<br>每组第一行输入一个正整数N,表示聊天记录的长度（1≤N≤10000）。<br>接下来N行，每行两个字符串，前一个字符串为姓名，后一个字符为聊天记录。<br>保证所有字符串长度不超过50，保证所有字符串只包含小写字母.</p><p>输出格式<br>如果没有复读机，输出 “Unbelievable!”(不包含引号）<br>否则按照熟练度从大到小输出所有的复读机，如果熟练度相同，按照字典序从小到大输出。</p><p>样例<br>input<br>1<br>4<br>codancer iamsovegetable<br>dicer iamsovegetable<br>todest iamsovegetable<br>capryang iamsovegetable<br>output<br>capryang<br>dicer<br>todest<br>提示<br>数据保证上面大佬们说的话都是瞎话。</p><p>Problem solving:<br>不难，但是是一道送命题。需要注意的是当一个人说的每一句话都是复读的上一个人说的话的时候他才能算得上是复读机。然后就是map，结构体，set之类的使用。具体可以看代码</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">string x,y;</span><br><span class="line">&#125;p[10005];</span><br><span class="line">struct nod&#123;</span><br><span class="line">string na;</span><br><span class="line">int fo;</span><br><span class="line">&#125;pp[10005];</span><br><span class="line">bool cmp(nod m,nod n)</span><br><span class="line">&#123;</span><br><span class="line">if(m.fo==n.fo)return m.na&lt;n.na;</span><br><span class="line">return m.fo&gt;n.fo;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t,n;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">string x,y;</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">set&lt;string&gt; se;</span><br><span class="line">map&lt;string,int&gt; ma;</span><br><span class="line">map&lt;string,int&gt; mp;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">se.insert(p[i].x);</span><br><span class="line">ma[p[i].x]=1;</span><br><span class="line">&#125;</span><br><span class="line">ma[p[0].x]=0;</span><br><span class="line">for(int i=1;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(p[i].y==p[i-1].y)</span><br><span class="line">mp[p[i].x]++;</span><br><span class="line">if(p[i].y!=p[i-1].y)</span><br><span class="line">ma[p[i].x]=0;</span><br><span class="line">&#125;</span><br><span class="line">int pos=0;</span><br><span class="line">for(set&lt;string&gt;::iterator it=se.begin();it!=se.end();it++)</span><br><span class="line">&#123;</span><br><span class="line">if(ma[*it])</span><br><span class="line">&#123;</span><br><span class="line">pp[pos].na=*it;</span><br><span class="line">pp[pos].fo=mp[*it];</span><br><span class="line">pos++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(pos==0) puts(&quot;Unbelievable!&quot;);</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">sort(pp,pp+pos,cmp);</span><br><span class="line">for(int i=0;i&lt;pos;i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;pp[i].na&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="无穷的小数"><a href="#无穷的小数" class="headerlink" title="无穷的小数"></a>无穷的小数</h3><p>Descripition:<br>在十进制下，我们能够很轻易地判断一个小数的位数是有穷的或无穷的，但是把这个小数用二进制表示出的情况下其有穷性和无穷性就会发生改变，比如</p><p>十进制下的 0.5 ,在二进制下的值为 0.1 ；<br>十进制下的 0.75 ,在二进制下的值为 0.11 ；<br>十进制下的 0.6 ,在二进制下的值为 0.1001100......</p><p>给你一个十进制的小数，判断其在二进制表示下小数位数是否无穷。</p><p>输入格式<br>多组输入，处理到文件结束<br>每组数据输入一个六位的小数 n.(0≤n\&lt;1)</p><p>输出格式<br>如果在二进制下小数位数是有穷的，输出”YES”,否则输出”NO”.</p><p>样例<br>input<br>0.500000<br>0.600000<br>0.750000<br>output<br>YES<br>NO<br>YES</p><p>Problem solving:<br>我拿了一血，主要是一开始大佬们没有注意到这个水题233.<br>模拟就行了，小数转换成二进制就是每次乘以2直到等于1.如果一个小数在二进制表示下小数位数是无穷的，意思就是无论它承几次2，都不会正好等于1。我们只需要乘以2一定的次数，如果出现1，就不是无穷的，反之即无穷的。这个次数我写的时候用的100，后来结束后各种测试发现最小改成6也能过Orz。<br>官方题解里面说会有精度问题，但是我没遇到哈，double过了。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">double s;</span><br><span class="line">while(~scanf(&quot;%lf&quot;,&amp;s))</span><br><span class="line">&#123;</span><br><span class="line">int i=0,flag=0;</span><br><span class="line">while(i&lt;=6)</span><br><span class="line">&#123;</span><br><span class="line">s*=2;</span><br><span class="line">if(s==int(s))flag=1;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">if(!flag)cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">elseputs(&quot;YES&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Special-String"><a href="#Special-String" class="headerlink" title="Special String"></a>Special String</h3><p>Descripition:<br>我们定义一个字符串S为Special String只要这个字符串满足下面这些条件:<br>1.这个串是回文的，即把这个字符串正着读和反着读相同，如abba和aca，而ba和abca则不是。<br>2.26个小写字母必须全部出现<br>3.这个串的长度为偶数。<br>对于给定的S,判断它是否是Special String.</p><p>输入格式<br>输入一个只由小写字母组成的字符串S。(1≤|S|≤1e5)</p><p>输出格式<br>如果这个字符串是Special String，输出”YE5”,否则输出”N0”</p><p>样例<br>input<br>aaaa<br>output<br>N0<br>input<br>abcdefghijklmnopqrstuvwxyzzyxwvutsrqponmlkjihgfedcba<br>output<br>YE5</p><p>Problem solving:<br>这道题，很厉害，很难！<br>三个条件的判断：<br>回文串的判断可以通过可以翻转之后比较或者比较对称位置上的字符是否相等来实现<br>26个字母都必须出现的判断，因为保证输入是小写字母，用一个set就行，最后看set的大小是否为26.<br>长度为偶数这个就不用说了。</p><p>最难的地方来了，<font color="red">是&#39;YE5&#39;和&#39;N0&#39;，不是&#39;YES&#39;和&#39;NO&#39;。。。学长tql。</font></p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">string s,mid;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">set&lt;char&gt; se;</span><br><span class="line">int flag=0,len=s.size();</span><br><span class="line">if(len%2==0)flag++;</span><br><span class="line">for(int i=0;i&lt;len;i++)se.insert(s[i]);</span><br><span class="line">if(se.size()==26)flag++;</span><br><span class="line">mid=s;</span><br><span class="line">reverse(s.begin(),s.end());</span><br><span class="line">if(mid==s)flag++;</span><br><span class="line">if(flag==3)puts(&quot;YE5&quot;);</span><br><span class="line">else puts(&quot;N0&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Max-Gcd"><a href="#Max-Gcd" class="headerlink" title="Max Gcd"></a>Max Gcd</h3><p>Descripition:<br>一个数组a，现在你需要删除某一项使得它们的gcd最大，求出这个最大值。</p><p>输入格式<br>第一行输入一个正整数n，表示数组的大小，接下来一行n个数，第i个数为ai。(2≤n≤1e5,1≤ai≤1e9)</p><p>输出格式<br>输出删除掉某个数以后的gcd的最大值。</p><p>样例<br>input<br>4<br>2 4 8 1<br>output<br>2<br>input<br>4<br>1 2 3 4<br>output<br>1<br>提示<br>样例一：删除第四个元素后，2,4,8的最大公因子为2。<br>样例二：无论删除哪一个，最大公因子都为1。</p><p>Problem solving:<br>比赛的时候这题毫无思路，，，<br>完了之后了解到，是使用了一个前缀gcd数组和一个后缀gcd数组来实现求去掉第I位数字之后剩余所有数字的gcd。<br>b为前缀gcd数组，c为后缀gcd数组<br>那么去点第I位的数字之后剩余所有数字的gcd就是<br>gcd（b[i-1],c[i+1]）<br>这种思想是真的巧妙。<br>我师父还想到了一种贪心的解法，但是我没听太懂233，总之很强就对了。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[200005];</span><br><span class="line">int b[200005];</span><br><span class="line">int c[200005];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i=0;i&lt;n;i++)cin&gt;&gt;a[i];</span><br><span class="line">b[0]=a[0];</span><br><span class="line">for(int i=1;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">b[i]=__gcd(b[i-1],a[i]);</span><br><span class="line">//cout&lt;&lt;b[i]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">c[0]=a[n-1];</span><br><span class="line">for(int i=n-1;i&gt;=0;i--)</span><br><span class="line">&#123;</span><br><span class="line">c[i]=__gcd(c[i+1],a[i]);</span><br><span class="line">&#125;</span><br><span class="line">int ans=0;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(i==0)ans=max(ans,c[1]);</span><br><span class="line">else if(i==n-1)ans=max(ans,b[n-2]);</span><br><span class="line">else ans=max(ans,__gcd(b[i-1],c[i+1]));</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Count-Prime-Pairs"><a href="#Count-Prime-Pairs" class="headerlink" title="Count Prime Pairs"></a>Count Prime Pairs</h3><p>Descripition:<br>对于数组a，如果i≠j并且ai+aj是一个质数，那么我们就称(i,j)为质数对，计算数组中质数对的个数。</p><p>输入格式<br>第一行输入一个n，表示数组的长度,接下来n个整数，第i个数代表ai。<br>(1≤n≤100000,0≤ai≤100)</p><p>输出格式<br>输出数组中质数对的个数。</p><p>样例<br>input<br>3<br>1 2 3<br>output<br>4<br>提示<br>样例说明：a1+a2,a2+a1,a2+a3,a3+a2都为质数，总共有四对。<br>Problem solving:<br>其实比赛的时候想到了这样去暴力，但是没实现。<br>题目中最大的素数是199，每个素数对所有出现过的数进行判断看差值是否出现过，就行了。<br>先来个素数打表，还有就是用map统计每个数出现的次数。<br>假设1出现了2次，2出现了2次，那么和为3的次数就是2*2=4次<br>假设1出现了4次，那么和为2出现的次数就是4*（4-1）/2=6次<br>按照这上面两种进行统计输出就行。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int t[205];</span><br><span class="line">int p[205];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">p[0]=p[1]=1;</span><br><span class="line">for(int i=2;i&lt;=205;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=i*2;j&lt;=205;j+=i)</span><br><span class="line">p[j]=1;</span><br><span class="line">&#125;</span><br><span class="line">int n,a;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">while(n--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a;</span><br><span class="line">t[a]++;</span><br><span class="line">&#125;</span><br><span class="line">int ans=0;</span><br><span class="line">for(int i=0;i&lt;=100;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=i+1;j&lt;=100;j++)</span><br><span class="line">&#123;</span><br><span class="line">if(i==j)continue;</span><br><span class="line">if(!p[i+j])</span><br><span class="line">&#123;</span><br><span class="line">ans+=t[i]*t[j];</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans*2+t[1]*(t[1]-1)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="平行线"><a href="#平行线" class="headerlink" title="平行线"></a>平行线</h3><p>Descripition:<br>“大猩猩为什么不喜欢平行线？”“因为平行线没有相交”<br>哈哈哈哈哈哈哈哈哈</p><p>为了管理动物园不听话的大猩猩们，动物管理员Boctorio 决定去远方的ACM之城找一些平行线，当他逛到一个神奇的店铺时，他发现了一副黑色的图，上面依稀可见一些白色的点。Boctorio 询问店铺老板这幅画是什么，老板说：“天机不可泄露”。等Boctorio仔细端详了一会这幅画后，他惊讶的发现其中所蕴含的奥秘。向店铺老板道谢后，他拿着刚买的这幅画，就连忙赶回动物园。</p><p>输入格式<br>输入一个数 n(1≤n≤1000)，表示点的个数。<br>接下来n行，每行两个整数 xi,yi(1≤xi,yi≤1e9),表示第i个点。<br>数据保证没有重复的点</p><p>输出格式<br>输出用这些点所能表示出来的平行线段的对数。（两条不同的线段重合也算为平行）</p><p>样例<br>input<br>6<br>0 0<br>1 0<br>1 1<br>3 1<br>3 3<br>5 4<br>output<br>10</p><p>Problem solving:<br>两线平行的条件就是斜率相等（也可以用向量做）统计每个斜率出现的次数即可<br>斜率不能直接用double存，会爆精度，可以用一个pair来存，但是注意，分数要进行约分，同时除以它们的gcd就行了</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1005;</span><br><span class="line">int x[maxn],y[maxn];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">set&lt;pair&lt;int,int&gt; &gt; se;</span><br><span class="line">map&lt;pair&lt;int,int&gt; ,int&gt; ma;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;x[i]&gt;&gt;y[i];</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=i+1;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line">int dx=x[j]-x[i];</span><br><span class="line">int dy=y[j]-y[i];</span><br><span class="line">int mid=__gcd(dx,dy);</span><br><span class="line">dx/=mid;</span><br><span class="line">dy/=mid;</span><br><span class="line">ma[&#123;dx,dy&#125;]++;</span><br><span class="line">se.insert(&#123;dx,dy&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int ans=0;</span><br><span class="line">for(set&lt;pair&lt;int,int&gt; &gt;::iterator it=se.begin();it!=se.end();it++)</span><br><span class="line">&#123;</span><br><span class="line">ans+=(ma[*it]*(ma[*it]-1))/2;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Area-of-polygons"><a href="#Area-of-polygons" class="headerlink" title="Area of polygons"></a>Area of polygons</h3><p>Descripition:<br>现在有a个边长为1的正方形，b个半径为1的圆，c个边长为1的等边三角形，现在你随机拿出一个图形，求这个图形面积的期望。</p><p>输入格式<br>第一行输入一个T,代表输入的组数。(1≤T≤100)<br>接下来T行，每行三个数字a,b,c(1≤a,b,c≤1000)。</p><p>输出格式<br>输出T行，对于每一组输入，输出面积的期望，小数点后保留三位小数。</p><p>样例<br>input<br>3<br>1 2 3<br>4 5 6<br>7 8 9<br>output<br>1.430<br>1.487<br>1.501<br>提示<br>圆周率为3.1415926535897</p><p>Problem solving:<br>简单数学题<br>期望即平均值</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define PI 3.1415926535897</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">double t,a,b,c;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">double sum=0;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">sum+=a+PI*b+sqrt(3)*c/4;</span><br><span class="line">printf(&quot;%.3lf\n&quot;,sum/(a+b+c));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="双色球"><a href="#双色球" class="headerlink" title="双色球"></a>双色球</h3><p>Descripition:<br>双色球投注区分为红色球号码区和蓝色球号码区，红色球号码区由1-33共三十三个号码组成，蓝色球号码区由1-16共十六个号码组成。投注时选择6个红色球号码和1个蓝色球号码组成一注进行单式投注。其中奖规则为：</p><p>一等奖（6+1）<br>二等奖（6+0）<br>三等奖（5+1）<br>四等奖（5+0、4+1）<br>五等奖（4+0、3+1）<br>六等奖（2+1、1+1、0+1）<br>其中(a+b)即为有a个红色球，b个蓝色球与开奖某个数字相同（只与数字有关，与位置无关）。<br>现在你有 n 张双色球彩票，以及本场彩票开奖结果，请你求出这 n 张彩票获得的最高奖。</p><p>输入格式<br>第一行输入一个 n ，表示 n 张彩票<br>接下来 n 行，每行 7 个数字，表示每张彩票的选号，其中前六个位红色球，后一个为蓝色球。<br>接下来一行，输入 7 个数字，表示开奖结果，其中前六个为红色球，后一个为蓝色球。</p><p>输出格式<br>输出所有彩票中能获得的最高等级奖，若无，则输出”0”。</p><p>样例<br>input<br>5<br>2 17 21 28 30 32 10<br>2 12 17 29 30 31 15<br>9 10 19 25 26 30 12<br>6 8 18 29 30 31 10<br>13 14 21 22 27 32 8<br>6 7 12 19 27 28 12<br>output<br>6<br>input<br>3<br>2 17 21 28 30 32 10<br>2 12 17 29 30 31 15<br>9 10 19 25 26 30 12<br>6 8 18 29 30 31 10<br>output<br>6<br>提示<br>彩票六个红色球数字均为从小到大排列<br>Problem solving:<br>看懂题意后直接暴力模拟就行</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">int ball[10];</span><br><span class="line">&#125;p[100];</span><br><span class="line">int re[10];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;7;j++)</span><br><span class="line">cin&gt;&gt;p[i].ball[j];</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;7;i++)cin&gt;&gt;re[i];</span><br><span class="line">int ans,mmp=7,mmm=7;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">ans=0;</span><br><span class="line">int flag=0;</span><br><span class="line">for(int j=0;j&lt;6;j++)</span><br><span class="line">&#123;</span><br><span class="line">if(binary_search(re,re+6,p[i].ball[j]))</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">if(p[i].ball[6]==re[6])flag=1;</span><br><span class="line">if(ans==1&amp;flag)mmm=6;</span><br><span class="line">else if(ans==0&amp;&amp;flag)mmm=6;</span><br><span class="line">else if(ans==2&amp;&amp;flag)mmm=6;</span><br><span class="line">else if(ans==3&amp;&amp;flag==1)mmm=5;</span><br><span class="line">else if(ans==4)</span><br><span class="line">&#123;</span><br><span class="line">if(!flag)mmm=5;</span><br><span class="line">elsemmm=4;</span><br><span class="line">&#125;</span><br><span class="line">else if(ans==5)</span><br><span class="line">&#123;</span><br><span class="line">if(!flag)mmm=4;</span><br><span class="line">elsemmm=3;</span><br><span class="line">&#125;</span><br><span class="line">else if(ans==6)</span><br><span class="line">&#123;</span><br><span class="line">if(!flag)mmm=2;</span><br><span class="line">elsemmm=1;</span><br><span class="line">&#125;</span><br><span class="line">mmp=min(mmm,mmp);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;mmp%7&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Remainder-Minimization-2019"><a href="#Remainder-Minimization-2019" class="headerlink" title="Remainder Minimization 2019"></a>Remainder Minimization 2019</h3><p>Descripition:<br>给你一个区间[L,R],在这个区间内找到两个不同的数字i,j，使得(i∗j)%2019的值最小。</p><p>输入格式<br>输入两个数 L,R,(1≤L\&lt;R≤1e9）</p><p>输出格式<br>如题</p><p>样例<br>input<br>4 5<br>output<br>20<br>input<br>2020 2040<br>output<br>2<br>Problem solving:<br>区间内只要出现2019的倍数，那么答案就是0。<br>所以我们只需要判断区间大小与2019的关系，如果大于2019，直接输出0就行，反之直接两个for循环就行，因为这时区间长度小于2019，时间复杂度也不高。注意要用long long。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a,b=input().split()</span><br><span class="line">a=eval(a)</span><br><span class="line">b=eval(b)</span><br><span class="line">ans=1111111111111</span><br><span class="line">for i in range(a,b):</span><br><span class="line">    for j in range(a+1,b+1):</span><br><span class="line">        mid = i*j % 2019</span><br><span class="line">        ans = min(ans,mid)</span><br><span class="line">        if ans==0:</span><br><span class="line">            break</span><br><span class="line">    if ans==0:</span><br><span class="line">            break</span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure></p><h3 id="学长标程-amp-amp-题解"><a href="#学长标程-amp-amp-题解" class="headerlink" title="学长标程 &amp;&amp; 题解"></a>学长标程 &amp;&amp; 题解</h3><p>我的代码会显得有点笨拙，因为还是不够熟练，所以把学长的代码也放在这里吧。</p><h4 id="B"><a href="#B" class="headerlink" title="B"></a>B</h4><ul><li>只要有一次某个人不是复读的就不是复读机</li><li>第一个人一定不是复读机</li><li>使用 map&lt;string,bool&gt; 判断这个人是否是复读机</li><li>使用 map&lt;string,int&gt; 记录这个人复读的次数</li><li>用结构体记录排序</li><li>复杂度 O(n∗log(n))</li></ul><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e6+100;</span><br><span class="line">struct peo&#123;</span><br><span class="line">string name;</span><br><span class="line">int num;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;peo&gt; all;</span><br><span class="line">map&lt;string,bool&gt; jud;</span><br><span class="line">map&lt;string,int&gt; num;</span><br><span class="line">string a[N],b[N];</span><br><span class="line">set&lt;string&gt; name;</span><br><span class="line">bool cmp(peo a,peo b)&#123;</span><br><span class="line">if(a.num==b.num) return a.name&lt;b.name;</span><br><span class="line">return a.num&gt;b.num;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">int T;</span><br><span class="line">cin&gt;&gt;T;</span><br><span class="line">while(T--)&#123;</span><br><span class="line">int n;</span><br><span class="line">jud.clear();num.clear();name.clear();all.clear();</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]&gt;&gt;b[i],jud[a[i]]=1,num[a[i]]=0,name.insert(a[i]);</span><br><span class="line">jud[a[1]]=0;</span><br><span class="line">for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">if(b[i]!=b[i-1])&#123;</span><br><span class="line">jud[a[i]]=0;</span><br><span class="line">&#125;</span><br><span class="line">num[a[i]]++;</span><br><span class="line">&#125;</span><br><span class="line">for(auto v:name)&#123;</span><br><span class="line">if(jud[v]) all.push_back(&#123;v,num[v]&#125;);</span><br><span class="line">&#125;</span><br><span class="line">sort(all.begin(),all.end(),cmp);</span><br><span class="line">if(all.size()==0)&#123;</span><br><span class="line">cout&lt;&lt;&quot;Unbelievable!&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">for(auto v:all) cout&lt;&lt;v.name&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="C"><a href="#C" class="headerlink" title="C"></a>C</h4><ul><li>由于只有后六位，先乘上 106 防止爆精度。</li><li>按照最普通的算法，每次乘以 2 再对 106 取余</li><li>当循环次数超过某一个值时，即可判定为无</li></ul><p>Code:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">double y;</span><br><span class="line">while(scanf(&quot;%lf&quot;,&amp;y)!=EOF)&#123;</span><br><span class="line">y*=10000000;</span><br><span class="line">bool flag=0;</span><br><span class="line">long long x=(long long)y;</span><br><span class="line">int num=0;</span><br><span class="line">while(1)&#123;</span><br><span class="line">    if(x==0) break;</span><br><span class="line">if(num&gt;=200)&#123;</span><br><span class="line">flag=1;break;</span><br><span class="line">&#125;</span><br><span class="line">num++;</span><br><span class="line">x=2*x;</span><br><span class="line">if(x&gt;=10000000) x-=10000000;</span><br><span class="line">if(x==0) break;</span><br><span class="line">&#125;</span><br><span class="line">if(flag) puts(&quot;NO&quot;);</span><br><span class="line">else puts(&quot;YES&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="D"><a href="#D" class="headerlink" title="D"></a>D</h4><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">bool check(string s)&#123;</span><br><span class="line">string c=s;</span><br><span class="line">reverse(c.begin(), c.end());</span><br><span class="line">return s==c;</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;int,int&gt; pii;</span><br><span class="line">int main()&#123;</span><br><span class="line">pii.first=1;</span><br><span class="line">pii.second=2;</span><br><span class="line">pii=make_pair(1,2);</span><br><span class="line">//cout&lt;&lt;pii.first&lt;&lt;&apos; &apos;&lt;&lt;pii.second&lt;&lt;endl;</span><br><span class="line">string s;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">bool flag=0;</span><br><span class="line">int l=s.length();</span><br><span class="line">if(l&amp;1) flag=1;</span><br><span class="line">if(!check(s)) flag=1;</span><br><span class="line">int num[27];</span><br><span class="line">memset(num,0,sizeof(num));</span><br><span class="line">for(int i=0;i&lt;l;i++)&#123;</span><br><span class="line">num[s[i]-&apos;a&apos;]++;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;26;i++)&#123;</span><br><span class="line">if(num[i]==0)&#123;</span><br><span class="line">flag=1;break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(flag) cout&lt;&lt;&quot;N0&quot;&lt;&lt;endl;</span><br><span class="line">else cout&lt;&lt;&quot;YE5&quot;&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="E"><a href="#E" class="headerlink" title="E"></a>E</h4><ul><li>维护前缀 gcd 数组 pre 和后缀 gcd 数组 od</li><li>删除第 i 个数之后剩余数的 gcd 即为 gcd(pre[i−1],od[i+1])</li><li>线性枚举即可, 复杂度 O(n)</li></ul><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">//前缀后缀解法</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e5+100;</span><br><span class="line">long long a[N];</span><br><span class="line">long long pre[N],sa[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">int n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">pre[1]=a[1];sa[n]=a[n];</span><br><span class="line">for(int i=2;i&lt;=n;i++) pre[i]=__gcd(pre[i-1],a[i]);</span><br><span class="line">for(int i=n-1;i&gt;=1;i--) sa[i]=__gcd(sa[i+1],a[i]);</span><br><span class="line">long long ans=max(sa[2],pre[n-1]);</span><br><span class="line">for(int i=2;i&lt;=n-1;i++) ans=max(ans,__gcd(pre[i-1],sa[i+1]));</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">//贪心解法</span><br><span class="line">//#include&lt;bits/stdc++.h&gt;</span><br><span class="line">//using namespace std;</span><br><span class="line">//const int maxn = 1e5 + 10;</span><br><span class="line">//int a[maxn];</span><br><span class="line">//bool cmp(int x,int y)</span><br><span class="line">//&#123;</span><br><span class="line">//return x &gt; y;</span><br><span class="line">//&#125;</span><br><span class="line">//int gcd(int a,int b)</span><br><span class="line">//&#123;</span><br><span class="line">//return b ? gcd(b,a % b) : a;</span><br><span class="line">//&#125;</span><br><span class="line">//int main()</span><br><span class="line">//&#123;</span><br><span class="line">//int n;</span><br><span class="line">//scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">//for (int i = 0;i &lt; n;i ++)</span><br><span class="line">//scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">//sort(a,a + n,cmp);</span><br><span class="line">//int ans = a[0],now = a[0];</span><br><span class="line">//for (int i = 1;i &lt; n;i ++)</span><br><span class="line">//&#123;</span><br><span class="line">//ans = max(gcd(ans,a[i]),now);</span><br><span class="line">//now = gcd(now,a[i]);</span><br><span class="line">//&#125;</span><br><span class="line">//printf(&quot;%d\n&quot;,ans);</span><br><span class="line">//return 0;</span><br><span class="line">//&#125;</span><br></pre></td></tr></table></figure></p><h4 id="F"><a href="#F" class="headerlink" title="F"></a>F</h4><ul><li>注意到 ai 的范围很小，我们可以先打出 [1,200] 以内的质数 表</li><li>O(n) 或 O(nlog(n)) 的统计每个数出现的次数</li><li>对于第 i 个质数 pi，和数组中第 j 个元素 aj，答案应该累加 上 pi−aj 出现的次数</li><li>注意 pi = 2∗aj 的情况，应该加上 aj 出现的次数减去 1</li></ul><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e6+100;</span><br><span class="line">bool check(int x)&#123;</span><br><span class="line">if(x==1) return 0;</span><br><span class="line">if(x==2) return 1;</span><br><span class="line">for(int i=2;i*i&lt;=x;i++)&#123;</span><br><span class="line">if(x%i==0) return 0;</span><br><span class="line">&#125;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;int&gt; pr;</span><br><span class="line">void init()&#123;</span><br><span class="line">for(int i=1;i&lt;=250;i++)&#123;</span><br><span class="line">if(check(i)) pr.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int a[N];</span><br><span class="line">int vis[300];</span><br><span class="line">int main()&#123;</span><br><span class="line">init();</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">long long ans=0;</span><br><span class="line">int n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i],vis[a[i]]++;</span><br><span class="line">for(int i=0;i&lt;(int)pr.size();i++)&#123;</span><br><span class="line">int now=pr[i];</span><br><span class="line">for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">if(now&gt;=a[j])&#123;</span><br><span class="line">if(now==(a[j]*2)) ans+=vis[a[j]]-1;</span><br><span class="line">else&#123;</span><br><span class="line"> if(vis[a[j]]&amp;&amp;vis[now-a[j]]) ans+=vis[now-a[j]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="G"><a href="#G" class="headerlink" title="G"></a>G</h4><ul><li>对 yi−yj/xi−xj 用 gcd 约分后用 pair 存储</li><li>利用 map 统计每个斜率的线段条数, 假设为 num, 那么斜率 k 的贡献即为 num∗(num−1)/2</li><li>累加不同的斜率的贡献即可 复杂度 O(n2log(n2))</li></ul><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 2000;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int x[N],y[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">int n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">map&lt;pair&lt;int,int&gt; ,int&gt; k;</span><br><span class="line">set&lt;pair&lt;long long,long long&gt;&gt; all;</span><br><span class="line">long long ans=0;</span><br><span class="line">for(int i=1;i&lt;=n;i++) cin&gt;&gt;x[i]&gt;&gt;y[i];</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">for(int j=i+1;j&lt;=n;j++)&#123;</span><br><span class="line">int dx=x[j]-x[i];</span><br><span class="line">int dy=y[j]-y[i];</span><br><span class="line">if(dx&lt;0&amp;&amp;dy&lt;0)&#123;</span><br><span class="line">dx=-dx;</span><br><span class="line">dy=-dy;</span><br><span class="line">&#125;</span><br><span class="line">long long gc=__gcd(dx,dy);</span><br><span class="line">dx/=gc;dy/=gc;</span><br><span class="line">k[&#123;dx,dy&#125;]++;</span><br><span class="line">all.insert(&#123;dx,dy&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(auto v:all)&#123;</span><br><span class="line">ans+=(k[v]*(k[v]-1)/2);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="H"><a href="#H" class="headerlink" title="H"></a>H</h4><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">int T;</span><br><span class="line">cin&gt;&gt;T;</span><br><span class="line">while(T--)&#123;</span><br><span class="line">double a,b,c;</span><br><span class="line">scanf(&quot;%lf %lf %lf&quot;,&amp;a,&amp;b,&amp;c);</span><br><span class="line">double all=(a+b+c);</span><br><span class="line">printf(&quot;%.3lf\n&quot;,(a+M_PI*b+sqrt(3)*c/4)/(a+b+c));</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="I"><a href="#I" class="headerlink" title="I"></a>I</h4><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">pair&lt;int,int&gt; solve(vector&lt;int&gt; a,vector&lt;int&gt; b)&#123;</span><br><span class="line">int num[34];</span><br><span class="line">memset(num,0,sizeof(num));</span><br><span class="line">int r=0;</span><br><span class="line">int bl=0;</span><br><span class="line">for(int i=0;i&lt;6;i++)&#123;</span><br><span class="line">num[a[i]]++;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;6;i++)&#123;</span><br><span class="line">if(num[b[i]]) r++;</span><br><span class="line">&#125;</span><br><span class="line">if(a[6]==b[6]) bl=1;</span><br><span class="line">return &#123;r,bl&#125;;</span><br><span class="line">&#125;</span><br><span class="line">int cal(pair&lt;int,int&gt; pii)&#123;</span><br><span class="line">if(pii.first==6&amp;&amp;pii.second==1) return 1;</span><br><span class="line">if(pii.first==6&amp;&amp;pii.second==0) return 2;</span><br><span class="line">if(pii.first==5&amp;&amp;pii.second==1) return 3;</span><br><span class="line">if((pii.first==5&amp;&amp;pii.second==0)||(pii.first==4&amp;&amp;pii.second==1)) return 4;</span><br><span class="line">if((pii.first==4&amp;&amp;pii.second==0)||(pii.first==3&amp;&amp;pii.second==1)) return 5;</span><br><span class="line">if((pii.first==2&amp;&amp;pii.second==1)||(pii.first==1&amp;&amp;pii.second==1)||(pii.first==0&amp;&amp;pii.second==1)) return 6;</span><br><span class="line">return 99999;</span><br><span class="line">&#125;</span><br><span class="line">const int N = 1e3+100;</span><br><span class="line">vector&lt;int&gt; a[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">int n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">int x;</span><br><span class="line">for(int j=0;j&lt;7;j++)&#123;</span><br><span class="line">cin&gt;&gt;x;</span><br><span class="line">a[i].push_back(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int ans=7;</span><br><span class="line">vector&lt;int&gt; b(7);</span><br><span class="line">for(int i=0;i&lt;7;i++) cin&gt;&gt;b[i];</span><br><span class="line">for(int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">ans=min(ans,cal(solve(a[i],b)));</span><br><span class="line">&#125;</span><br><span class="line">if(ans==7) ans=0;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="J"><a href="#J" class="headerlink" title="J"></a>J</h4><ul><li>当 L 和 R 的差值大于 2019 的时候，其中必定含有 2019 的 倍数，此时答案为 0</li><li>否则暴力枚举</li></ul><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    long long L,R;</span><br><span class="line">    cin&gt;&gt;L&gt;&gt;R;</span><br><span class="line">    if(R-L&gt;2019) cout&lt;&lt;0&lt;&lt;endl;</span><br><span class="line">    else&#123;</span><br><span class="line">        int ans=9999;</span><br><span class="line">        for(int i=L;i&lt;=R;i++)&#123;</span><br><span class="line">            for(int j=i+1;j&lt;=R;j++)&#123;</span><br><span class="line">                ans=min(ans,((i%2019)*(j%2019))%2019);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>今天的题确实不算太难吧，就过了6题，还罚时巨高，主要还是自己的原因。STL和结构体的使用能力还有点欠缺，另外用map统计出现次数这个真的是很有用的东西，set去重，这些都知道的东西用不到平常写题的过程中太亏了。继续加油，Fighting！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;积分赛，被打爆的积分赛（music
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="Algorithm" scheme="https://cndrew.cn/blog/tags/Algorithm/"/>
    
      <category term="c/c++" scheme="https://cndrew.cn/blog/tags/c-c/"/>
    
      <category term="STL" scheme="https://cndrew.cn/blog/tags/STL/"/>
    
      <category term="前缀和" scheme="https://cndrew.cn/blog/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>stringstream(常见函数及其常见用法)</title>
    <link href="https://cndrew.cn/blog/2019/07/19/sstream/"/>
    <id>https://cndrew.cn/blog/2019/07/19/sstream/</id>
    <published>2019-07-19T08:19:10.783Z</published>
    <updated>2019-07-19T09:12:12.768Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Give me three minutes,I will make you learn more about stringstream.<a id="more"></a></p><h3 id="Some-common-usage"><a href="#Some-common-usage" class="headerlink" title="Some common usage"></a>Some common usage</h3><h4 id="Data-type-conversion-数据类型的转换"><a href="#Data-type-conversion-数据类型的转换" class="headerlink" title="Data type conversion(数据类型的转换)"></a>Data type conversion(数据类型的转换)</h4><p>For example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string       a = &quot;521&quot;, b;</span><br><span class="line">    int          c, d = 1314;</span><br><span class="line">    stringstream x, y;</span><br><span class="line">    x &lt;&lt; a;   y &lt;&lt; d;</span><br><span class="line">    x &gt;&gt; c;   y &gt;&gt; b;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl &lt;&lt; c &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;The size of b is &quot; &lt;&lt; sizeof(b) &lt;&lt; &quot;\nThe size of c is &quot; &lt;&lt; sizeof(c) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Output:</p><blockquote><p>5211314<br>5211314<br>The size of b is 24<br>The size of c is 4</p></blockquote><p>In this case,we transform a string to int and an int to string through stringstream.</p><h4 id="Can-be-used-to-split-strings-separated-by-spaces-etc-可以分割被空格分割的字符串"><a href="#Can-be-used-to-split-strings-separated-by-spaces-etc-可以分割被空格分割的字符串" class="headerlink" title="Can be used to split strings separated by spaces etc.(可以分割被空格分割的字符串)"></a>Can be used to split strings separated by spaces etc.(可以分割被空格分割的字符串)</h4><p>For example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string       s = &quot;521 1314&quot;,mid;</span><br><span class="line">    stringstream x(s);</span><br><span class="line">    while (x &gt;&gt; mid)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; mid &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Output:</p><blockquote><p>521<br>1314</p></blockquote><p>This part is always useful in some type.</p><h3 id="Official-explanation"><a href="#Official-explanation" class="headerlink" title="Official explanation"></a>Official explanation</h3><p>CPP: <a href="http://www.cplusplus.com/reference/sstream/stringstream/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/sstream/stringstream/</a></p><p>As far as I know,If you can grasp the common usage,it&#39;s enough in ACM.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Give me three minutes,I will make you learn more about stringstream.
    
    </summary>
    
      <category term="c/c++" scheme="https://cndrew.cn/blog/categories/c-c/"/>
    
    
      <category term="c/c++" scheme="https://cndrew.cn/blog/tags/c-c/"/>
    
      <category term="functions" scheme="https://cndrew.cn/blog/tags/functions/"/>
    
  </entry>
  
  <entry>
    <title>HPU Summer Training Day 3（河南理工暑期集训第三天）</title>
    <link href="https://cndrew.cn/blog/2019/07/19/d3/"/>
    <id>https://cndrew.cn/blog/2019/07/19/d3/</id>
    <published>2019-07-19T06:45:01.725Z</published>
    <updated>2019-07-19T07:48:04.601Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天主要讲了点基本的STL的用法。题写的有点吃力了，以后可能就写不完了，然后攒着写不完的题一天比一天多。<br>Nothing can change my love for you,even you.<a id="more"></a></p><p><center><p color="red">Today&#39;s problem I spent too much wrong on the format,I should be more careful.</p></center></p><h3 id="Windows-Message-Queue"><a href="#Windows-Message-Queue" class="headerlink" title="Windows Message Queue"></a>Windows Message Queue</h3><p>Description:<br>Message queue is the basic fundamental of windows system. For each process, the system maintains a message queue. If something happens to this process, such as mouse click, text change, the system will add a message to the queue. Meanwhile, the process will do a loop for getting message from the queue according to the priority value if it is not empty. Note that the less priority value means the higher priority. In this problem, you are asked to simulate the message queue for putting messages to and getting message from the message queue.<br>Input</p><blockquote><p>There&#39;s only one test case in the input. Each line is a command, &quot;GET&quot; or &quot;PUT&quot;, which means getting message or putting message. If the command is &quot;PUT&quot;, there&#39;re one string means the message name and two integer means the parameter and priority followed by. There will be at most 60000 command. Note that one message can appear twice or more and if two messages have the same priority, the one comes first will be processed first.(i.e., FIFO for the same priority.) Process to the end-of-file.</p></blockquote><p>Output</p><blockquote><p>For each &quot;GET&quot; command, output the command getting from the message queue with the name and parameter in one line. If there&#39;s no message in the queue, output &quot;EMPTY QUEUE!&quot;. There&#39;s no output for &quot;PUT&quot; command.</p></blockquote><p>Sample Input</p><blockquote><p>GET<br>PUT msg1 10 5<br>PUT msg2 10 4<br>GET<br>GET<br>GET</p></blockquote><p>Sample Output</p><blockquote><p>EMPTY QUEUE!<br>msg2 10<br>msg1 10<br>EMPTY QUEUE!</p></blockquote><p>Problem solving:<br>Through a special queue with a struct and Operator overloading.The main question is understand this,oh my poor English.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    string s;</span><br><span class="line">    int    p, q, id;</span><br><span class="line">&#125; n[6005];</span><br><span class="line">bool operator &lt;(const node &amp;x, const node &amp;y)//Operator overloading.</span><br><span class="line">&#123;</span><br><span class="line">    if (x.q == y.q)</span><br><span class="line">        return x.id &gt; y.id;</span><br><span class="line">    return x.q &gt; y.q;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;node&gt; que;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s;</span><br><span class="line">    int    k = 0;</span><br><span class="line">    while (cin &gt;&gt; s)</span><br><span class="line">    &#123;</span><br><span class="line">        if (s[0] == &apos;G&apos;)</span><br><span class="line">        &#123;</span><br><span class="line">            if (que.empty())</span><br><span class="line">                puts(&quot;EMPTY QUEUE!&quot;);</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; que.top().s &lt;&lt; &quot; &quot; &lt;&lt; que.top().p &lt;&lt; endl;</span><br><span class="line">                que.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (s[0] == &apos;P&apos;)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; n[0].s &gt;&gt; n[0].p &gt;&gt; n[0].q;</span><br><span class="line">            n[0].id = k;</span><br><span class="line">            k++;</span><br><span class="line">            que.push(n[0]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Train-Problem-I"><a href="#Train-Problem-I" class="headerlink" title="Train Problem I"></a>Train Problem I</h3><p>Description:<br>As the new term comes, the Ignatius Train Station is very busy nowadays. A lot of student want to get back to school by train(because the trains in the Ignatius Train Station is the fastest all over the world ^v^). But here comes a problem, there is only one railway where all the trains stop. So all the trains come in from one side and get out from the other side. For this problem, if train A gets into the railway first, and then train B gets into the railway before train A leaves, train A can&#39;t leave until train B leaves. The pictures below figure out the problem. Now the problem for you is, there are at most 9 trains in the station, all the trains has an ID(numbered from 1 to n), the trains get into the railway in an order O1, your task is to determine whether the trains can get out in an order O2.<br><img src="https://i.loli.net/2019/07/19/5d31701948a0b85739.png" alt><br><img src="https://i.loli.net/2019/07/19/5d317019666c116696.png" alt><br><img src="https://i.loli.net/2019/07/19/5d3170197930e92310.png" alt><br>Input</p><blockquote><p>The input contains several test cases. Each test case consists of an integer, the number of trains, and two strings, the order of the trains come in:O1, and the order of the trains leave:O2. The input is terminated by the end of file. More details in the Sample Input.</p></blockquote><p>Output</p><blockquote><p>The output contains a string &quot;No.&quot; if you can&#39;t exchange O2 to O1, or you should output a line contains &quot;Yes.&quot;, and then output your way in exchanging the order(you should output &quot;in&quot; for a train getting into the railway, and &quot;out&quot; for a train getting out of the railway). Print a line contains &quot;FINISH&quot; after each test case. More details in the Sample Output.</p></blockquote><p>Sample Input</p><blockquote><p>3 123 321<br>3 123 312</p></blockquote><p>Sample Output</p><blockquote><p>Yes.<br>in<br>in<br>in<br>out<br>out<br>out<br>FINISH<br>No.<br>FINISH</p></blockquote><p>For the first Sample Input, we let train 1 get in, then train 2 and train 3.<br>So now train 3 is at the top of the railway, so train 3 can leave first, then train 2 and train 1.<br>In the second Sample input, we should let train 3 leave first, so we have to let train 1 get in, then train 2 and train 3.<br>Now we can let train 3 leave.<br>But after that we can&#39;t let train 1 leave before train 2, because train 2 is at the top of the railway at the moment.<br>So we output &quot;No.&quot;.<br>Problem solving:<br>An easy problem.Use a stack to simulate this process and a queue to record &#39;in&#39; or &#39;out&#39;.Judge if we can pop or push.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    while (~scanf(&quot;%d&quot;, &amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        int           flag = 0;</span><br><span class="line">        string        a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        stack&lt;char&gt;   s;</span><br><span class="line">        queue&lt;string&gt; q;</span><br><span class="line">        for (int i = 0, j = 0; i &lt; n &amp;&amp; j &lt;= n;)</span><br><span class="line">        &#123;</span><br><span class="line">            if (s.empty() || s.top() != b[i])</span><br><span class="line">            &#123;</span><br><span class="line">                if (j == n)</span><br><span class="line">                &#123;</span><br><span class="line">                    cout &lt;&lt; &quot;No.\nFINISH\n&quot;;</span><br><span class="line">                    flag = 1;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                s.push(a[j]);</span><br><span class="line">                j++;</span><br><span class="line">                q.push(&quot;in&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                s.pop();</span><br><span class="line">                q.push(&quot;out&quot;);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (flag)</span><br><span class="line">            continue;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot;Yes.\n&quot;;</span><br><span class="line">            while (!q.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; q.front() &lt;&lt; endl;</span><br><span class="line">                q.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; &quot;FINISH\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Rails"><a href="#Rails" class="headerlink" title="Rails"></a>Rails</h3><p>Description:<br>There is a famous railway station in PopPush City. Country there is incredibly hilly. The station was built in last century. Unfortunately, funds were extremely limited that time. It was possible to establish only a surface track. Moreover, it turned out that the station could be only a dead-end one (see picture) and due to lack of available space it could have only one track.<br><img src="https://i.loli.net/2019/07/19/5d31704637c7063277.png" alt><br>The local tradition is that every train arriving from the direction A continues in the direction B with coaches reorganized in some way. Assume that the train arriving from the direction A has N &lt;= 1000 coaches numbered in increasing order 1, 2, ..., N. The chief for train reorganizations must know whether it is possible to marshal coaches continuing in the direction B so that their order will be a1, a2, ..., aN. Help him and write a program that decides whether it is possible to get the required order of coaches. You can assume that single coaches can be disconnected from the train before they enter the station and that they can move themselves until they are on the track in the direction B. You can also suppose that at any time there can be located as many coaches as necessary in the station. But once a coach has entered the station it cannot return to the track in the direction A and also once it has left the station in the direction B it cannot return back to the station.</p><p>Input</p><blockquote><p>The input consists of blocks of lines. Each block except the last describes one train and possibly more requirements for its reorganization. In the first line of the block there is the integer N described above. In each of the next lines of the block there is a permutation of 1, 2, ..., N. The last line of the block contains just 0.<br>The last block consists of just one line containing 0.</p></blockquote><p>Output</p><blockquote><p>The output contains the lines corresponding to the lines with permutations in the input. A line of the output contains Yes if it is possible to marshal the coaches in the order required on the corresponding line of the input. Otherwise it contains No. In addition, there is one empty line after the lines corresponding to one block of the input. There is no line in the output corresponding to the last null&#39; block of the input.</p></blockquote><p>Sample Input</p><blockquote><p>5<br>1 2 3 4 5<br>5 4 1 2 3<br>0<br>6<br>6 5 4 3 2 1<br>0<br>0</p></blockquote><p>Sample Output<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line"></span><br><span class="line">Yes</span><br></pre></td></tr></table></figure></p><p>Problem solving:<br>An easy stack question.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[1005];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    while (scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        while (1)</span><br><span class="line">        &#123;</span><br><span class="line">            int flag = 0;</span><br><span class="line">            for (int i = 0; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                cin &gt;&gt; a[i];</span><br><span class="line">                if (a[i] == 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    flag = 1; break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (flag)</span><br><span class="line">                break;</span><br><span class="line">            stack&lt;int&gt; sta;</span><br><span class="line">            int        pos = 0;</span><br><span class="line">            for (int i = 1; i &lt;= n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                sta.push(i);</span><br><span class="line">                while (!sta.empty() &amp;&amp; sta.top() == a[pos])</span><br><span class="line">                &#123;</span><br><span class="line">                    sta.pop();</span><br><span class="line">                    pos++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (sta.empty())</span><br><span class="line">                puts(&quot;Yes&quot;);</span><br><span class="line">            else</span><br><span class="line">                puts(&quot;No&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        puts(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="D-A-B"><a href="#D-A-B" class="headerlink" title="D - {A} + {B}"></a>D - {A} + {B}</h3><p>Description:<br>给你两个集合，要求{A} + {B}.<br>注:同一个集合中不会有两个相同的元素.<br>Input</p><blockquote><p>每组输入数据分为三行,第一行有两个数字n,m(0&lt;n,m&lt;=10000),分别表示集合A和集合B的元素个数.后两行分别表示集合A和集合B.每个元素为不超出int范围的整数,每个元素之间有一个空格隔开.</p></blockquote><p>Output</p><blockquote><p>针对每组数据输出一行数据,表示合并后的集合,要求从小到大输出,每个元素之间有一个空格隔开.</p></blockquote><p>Sample Input</p><blockquote><p>1 2<br>1<br>2 3<br>1 2<br>1<br>1 2</p></blockquote><p>Sample Output</p><blockquote><p>1 2 3<br>1 2</p></blockquote><p>Problem solving:<br>An easy set question.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n, m, a;</span><br><span class="line">    while (~scanf(&quot;%d %d&quot;, &amp;n, &amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        set&lt;int&gt; s;</span><br><span class="line">        for (int i = 0; i &lt; n + m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; a;</span><br><span class="line">            s.insert(a);</span><br><span class="line">        &#125;</span><br><span class="line">        for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (it == s.begin())</span><br><span class="line">                cout &lt;&lt; *it;</span><br><span class="line">            else</span><br><span class="line">                cout &lt;&lt; &quot; &quot; &lt;&lt; *it;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="水果"><a href="#水果" class="headerlink" title="水果"></a>水果</h3><p>Description:<br>夏天来了<del>好开心啊,呵呵,好多好多水果</del><br>Joe经营着一个不大的水果店.他认为生存之道就是经营最受顾客欢迎的水果.现在他想要一份水果销售情况的明细表,这样Joe就可以很容易掌握所有水果的销售情况了.<br>Input</p><blockquote><p>第一行正整数N(0&lt;N&lt;=10)表示有N组测试数据.<br>每组测试数据的第一行是一个整数M(0&lt;M&lt;=100),表示工有M次成功的交易.其后有M行数据,每行表示一次交易,由水果名称(小写字母组成,长度不超过80),水果产地(小写字母组成,长度不超过80)和交易的水果数目(正整数,不超过100)组成.</p></blockquote><p>Output</p><blockquote><p>对于每一组测试数据,请你输出一份排版格式正确(请分析样本输出)的水果销售情况明细表.这份明细表包括所有水果的产地,名称和销售数目的信息.水果先按产地分类,产地按字母顺序排列;同一产地的水果按照名称排序,名称按字母顺序排序.<br>两组测试数据之间有一个空行.最后一组测试数据之后没有空行.</p></blockquote><p>Sample Input</p><blockquote><p>1<br>5<br>apple shandong 3<br>pineapple guangdong 1<br>sugarcane guangdong 1<br>pineapple guangdong 3<br>pineapple guangdong 1</p></blockquote><p>Sample Output</p><blockquote><p>guangdong<br>　　|----pineapple(5)<br>　　|----sugarcane(1)<br>shandong<br>　　|----apple(3)</p></blockquote><p>Problem solving:<br>An unusual problem.We can ues a map in map.And then the iterator is a little different now.Just see the Code.Luckily,map can automatic sorting makes this problem is not so hard.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int    n, m, p;</span><br><span class="line">    string x, y;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    int xxxx=0;</span><br><span class="line">    while (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        if(xxxx!=0) puts(&quot;&quot;);</span><br><span class="line">        xxxx=1;</span><br><span class="line">        int                            i = 0;</span><br><span class="line">        map&lt;string, map&lt;string, int&gt; &gt; ma;</span><br><span class="line">        cin &gt;&gt; m;</span><br><span class="line">        while (m--)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; p;</span><br><span class="line">            ma[y][x] += p;</span><br><span class="line">        &#125;</span><br><span class="line">        map&lt;string, int&gt;::iterator iit;</span><br><span class="line">        for (map&lt;string, map&lt;string, int&gt; &gt;::iterator it = ma.begin(); it != ma.end(); it++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; it-&gt;first &lt;&lt; endl;</span><br><span class="line">            for (iit = it-&gt;second.begin(); iit != it-&gt;second.end(); iit++)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; &quot;   |----&quot; &lt;&lt; iit-&gt;first &lt;&lt; &quot;(&quot; &lt;&lt; iit-&gt;second &lt;&lt; &quot;)&quot; &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Let-the-Balloon-Rise"><a href="#Let-the-Balloon-Rise" class="headerlink" title="Let the Balloon Rise"></a>Let the Balloon Rise</h3><p>Description:<br>Contest time again! How excited it is to see balloons floating around. But to tell you a secret, the judges&#39; favorite time is guessing the most popular problem. When the contest is over, they will count the balloons of each color and find the result.<br>This year, they decide to leave this lovely job to you.<br>Input</p><blockquote><p>Input contains multiple test cases. Each test case starts with a number N (0 &lt; N &lt;= 1000) -- the total number of balloons distributed. The next N lines contain one color each. The color of a balloon is a string of up to 15 lower-case letters.<br>A test case with N = 0 terminates the input and this test case is not to be processed.</p></blockquote><p>Output</p><blockquote><p>For each case, print the color of balloon for the most popular problem on a single line. It is guaranteed that there is a unique solution for each test case.</p></blockquote><p>Sample Input</p><blockquote><p>5<br>green<br>red<br>blue<br>red<br>red<br>3<br>pink<br>orange<br>pink<br>0</p></blockquote><p>Sample Output</p><blockquote><p>red<br>pink</p></blockquote><p>Problem solving:<br>An easy map problem.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int    n;</span><br><span class="line">    string s;</span><br><span class="line">    while (cin &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        map&lt;string, int&gt; ma;</span><br><span class="line">        if (n == 0)</span><br><span class="line">            break;</span><br><span class="line">        while (n--)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; s;</span><br><span class="line">            ma[s]++;</span><br><span class="line">        &#125;</span><br><span class="line">        int    mid = 0;</span><br><span class="line">        string ans;</span><br><span class="line">        for (map&lt;string, int&gt;::iterator it = ma.begin(); it != ma.end(); it++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (it-&gt;second &gt; mid)</span><br><span class="line">            &#123;</span><br><span class="line">                ans = it-&gt;first;</span><br><span class="line">                mid = it-&gt;second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="不重复数字"><a href="#不重复数字" class="headerlink" title="不重复数字"></a>不重复数字</h3><p>Description:<br>给出N个数，要求把其中重复的去掉，只保留第一次出现的数。<br>例如，给出的数为1 2 18 3 3 19 2 3 6 5 4，其中2和3有重复，去除后的结果为1 2 18 3 19 6 5 4。</p><p>Input</p><blockquote><p>输入第一行为正整数T，表示有T组数据。<br>接下来每组数据包括两行，第一行为正整数N，表示有N个数。第二行为要去重的N个正整数。</p></blockquote><p>Output</p><blockquote><p>对于每组数据，输出一行，为去重后剩下的数字，数字之间用一个空格隔开。</p></blockquote><p>Sample Input</p><blockquote><p>2<br>11<br>1 2 18 3 3 19 2 3 6 5 4<br>6<br>1 2 3 4 5 6</p></blockquote><p>Sample Output</p><blockquote><p>1 2 18 3 19 6 5 4<br>1 2 3 4 5 6</p></blockquote><p>Hint</p><blockquote><p>对于30%的数据，1 &lt;= N &lt;= 100，给出的数不大于100，均为非负整数；<br>对于50%的数据，1 &lt;= N &lt;= 10000，给出的数不大于10000，均为非负整数；<br>对于100%的数据，1 &lt;= N &lt;= 50000，给出的数在32位有符号整数范围内。<br>提示:<br>由于数据量很大，使用C++的同学请使用scanf和printf来进行输入输出操作，以免浪费不必要的时间。</p></blockquote><p>Problem solving:<br>We can&#39;t use set here because set will automatic sort.I wanted to ues a flag array to know the number has appread or not.But always RE.So I choose a set to know if the number has already appeared.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">    while (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        int        n, a;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">        set&lt;int&gt;   s;</span><br><span class="line">        int        mid = s.size();</span><br><span class="line">        queue&lt;int&gt; q;</span><br><span class="line">        while (n--)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;a);</span><br><span class="line">            s.insert(a);</span><br><span class="line">            if (s.size() != mid)</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(a);</span><br><span class="line">                mid = s.size();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; q.front() &lt;&lt; &quot; &quot;;</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        puts(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Andy-39-s-First-Dictionary"><a href="#Andy-39-s-First-Dictionary" class="headerlink" title="Andy&#39;s First Dictionary"></a>Andy&#39;s First Dictionary</h3><p>Description:<br>Andy, 8, has a dream - he wants to produce his very own dictionary. This is not an easy task for him, as the number of words that he knows is, well, not quite enough. Instead of thinking up all the words himself, he has a briliant idea. From his bookshelf he would pick one of his favourite story books, from which he would copy out all the distinct words. By arranging the words in<br>alphabetical order, he is done! Of course, it is a really time-consuming job, and this is where a computer program is helpful.You are asked to write a program that lists all the different words in the input text. In this problem, a word is defined as a consecutive sequence of alphabets, in upper and/or lower case. Words with only one letter are also to be considered. Furthermore, your program must be CaSe InSeNsItIvE. For example, words like “Apple”, “apple” or “APPLE” must be considered the same.<br>Input</p><blockquote><p>The input file is a text with no more than 5000 lines. An input line has at most 200 characters. Input<br>is terminated by EOF.</p></blockquote><p>Output</p><blockquote><p>Your output should give a list of different words that appears in the input text, one in a line. The<br>words should all be in lower case, sorted in alphabetical order. You can be sure that he number of<br>distinct words in the text does not exceed 5000.</p></blockquote><p>Sample Input</p><blockquote><p>Adventures in Disneyland<br>Two blondes were going to Disneyland when they came to a fork in the<br>road. The sign read: &quot;Disneyland Left.&quot;<br>So they went home.</p></blockquote><p>Sample Output</p><blockquote><p>a<br>adventures<br>blondes<br>came<br>disneyland<br>fork<br>going<br>home<br>in<br>left<br>read<br>road<br>sign<br>so<br>the<br>they<br>to<br>two<br>went<br>were<br>when</p></blockquote><p>Problem solving:<br>I know a new useful function through this problem--Stringstream.I will write a new artical about this these days.It&#39;s amazing,suitable for us who is lazy.About this problem,you just know what you should do:</p><ol><li>Turn uppercase letter to lower case letters.</li><li>Delete the char which is not a letter.</li></ol><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string      s;</span><br><span class="line">    set&lt;string&gt; se;</span><br><span class="line">    while (cin &gt;&gt; s)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i &lt; s.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (s[i] &gt;= &apos;A&apos; &amp;&amp; s[i] &lt;= &apos;Z&apos;)</span><br><span class="line">                s[i] += 32;</span><br><span class="line">            else if (s[i] &gt;= &apos;a&apos; &amp;&amp; s[i] &lt;= &apos;z&apos;)</span><br><span class="line">                s[i] = s[i];</span><br><span class="line">            else</span><br><span class="line">                s[i] = &apos; &apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        string       mi;</span><br><span class="line">        stringstream mid(s);</span><br><span class="line">        while (mid &gt;&gt; mi)</span><br><span class="line">        &#123;</span><br><span class="line">            se.insert(mi);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (set&lt;string&gt;::iterator it = se.begin(); it != se.end(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="A-and-B-and-Compilation-Errors"><a href="#A-and-B-and-Compilation-Errors" class="headerlink" title="A and B and Compilation Errors"></a>A and B and Compilation Errors</h3><p>Description:<br>A and B are preparing themselves for programming contests.</p><p>B loves to debug his code. But before he runs the solution and starts debugging, he has to first compile the code.</p><p>Initially, the compiler displayed n compilation errors, each of them is represented as a positive integer. After some effort, B managed to fix some mistake and then another one mistake.</p><p>However, despite the fact that B is sure that he corrected the two errors, he can not understand exactly what compilation errors disappeared — the compiler of the language which B uses shows errors in the new order every time! B is sure that unlike many other programming languages, compilation errors for his programming language do not depend on each other, that is, if you correct one error, the set of other error does not change.</p><p>Can you help B find out exactly what two errors he corrected?</p><p>Input</p><blockquote><p>The first line of the input contains integer n (3 ≤ n ≤ 105) — the initial number of compilation errors.<br>The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 109) — the errors the compiler displayed for the first time.<br>The third line contains n - 1 space-separated integers b1, b2, ..., bn - 1 — the errors displayed at the second compilation. It is guaranteed that the sequence in the third line contains all numbers of the second string except for exactly one.<br>The fourth line contains n - 2 space-separated integers с1, с2, ..., сn - 2 — the errors displayed at the third compilation. It is guaranteed that the sequence in the fourth line contains all numbers of the third line except for exactly one.</p></blockquote><p>Output</p><blockquote><p>Print two numbers on a single line: the numbers of the compilation errors that disappeared after B made the first and the second correction, respectively.</p></blockquote><p>Examples<br>Input</p><blockquote><p>5<br>1 5 8 123 7<br>123 7 5 1<br>5 1 7</p></blockquote><p>Output</p><blockquote><p>8<br>123</p></blockquote><p>Input</p><blockquote><p>6<br>1 4 3 3 5 7<br>3 7 5 4 3<br>4 3 7 5</p></blockquote><p>Output</p><blockquote><p>1<br>3</p></blockquote><p>Note</p><blockquote><p>In the first test sample B first corrects the error number 8, then the error number 123.<br>In the second test sample B first corrects the error number 1, then the error number 3. Note that if there are multiple errors with the same number, B can correct only one of them in one step.</p></blockquote><p>Problem solving:<br>Through reding,you will kown the first line we output is the different number between the second line and the third line we input,and the second line we output is the different number between the third line and the fourth line we input.I choose a force way but easy to understand.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int           n, a;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    map&lt;int, int&gt; ma;</span><br><span class="line">    map&lt;int, int&gt; ma1;</span><br><span class="line">    map&lt;int, int&gt; ma2;</span><br><span class="line">    for (int i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        ma[a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; n - 1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        ma1[a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; n - 2; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        ma2[a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    int x = 0, y = 0;</span><br><span class="line">    for (map&lt;int, int&gt;::iterator it = ma.begin(); it != ma.end(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid = it-&gt;first;</span><br><span class="line">        if (ma[mid] != ma1[mid])</span><br><span class="line">            cout &lt;&lt; mid &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    for (map&lt;int, int&gt;::iterator it = ma1.begin(); it != ma1.end(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid = it-&gt;first;</span><br><span class="line">        if (ma2[mid] != ma1[mid])</span><br><span class="line">            cout &lt;&lt; mid &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="排列2"><a href="#排列2" class="headerlink" title="排列2"></a>排列2</h3><p>Description:<br>Ray又对数字的列产生了兴趣：<br>现有四张卡片，用这四张卡片能排列出很多不同的4位数，要求按从小到大的顺序输出这些4位数。<br>Input</p><blockquote><p>每组数据占一行，代表四张卡片上的数字（0&lt;=数字&lt;=9），如果四张卡片都是0，则输入结束。</p></blockquote><p>Output</p><blockquote><p>对每组卡片按从小到大的顺序输出所有能由这四张卡片组成的4位数，千位数字相同的在同一行，同一行中每个四位数间用空格分隔。<br>每组输出数据间空一行，最后一组数据后面没有空行。</p></blockquote><p>Sample Input</p><blockquote><p>1 2 3 4<br>1 1 2 3<br>0 1 2 3<br>0 0 0 0</p></blockquote><p>Sample Output<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1234 1243 1324 1342 1423 1432</span><br><span class="line">2134 2143 2314 2341 2413 2431</span><br><span class="line">3124 3142 3214 3241 3412 3421</span><br><span class="line">4123 4132 4213 4231 4312 4321</span><br><span class="line"></span><br><span class="line">1123 1132 1213 1231 1312 1321</span><br><span class="line">2113 2131 2311</span><br><span class="line">3112 3121 3211</span><br><span class="line"></span><br><span class="line">1023 1032 1203 1230 1302 1320</span><br><span class="line">2013 2031 2103 2130 2301 2310</span><br><span class="line">3012 3021 3102 3120 3201 3210</span><br></pre></td></tr></table></figure></p><p>Problem solving:<br>An easy problem through &#39;next_permutation()&#39;.The most disgusting place is the format.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[5];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int mid, x = 0;</span><br><span class="line">    while (scanf(&quot;%d %d %d %d&quot;, &amp;a[0], &amp;a[1], &amp;a[2], &amp;a[3]) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        sort(a, a + 4);</span><br><span class="line">        if (a[0] == 0 &amp;&amp; a[1] == 0 &amp;&amp; a[2] == 0 &amp;&amp; a[3] == 0)</span><br><span class="line">            break;</span><br><span class="line">        if (x)</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        x = 1;</span><br><span class="line">        int flag = 1;</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            if (a[0] == 0)</span><br><span class="line">                continue;</span><br><span class="line">            if (flag)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; a[0] &lt;&lt; a[1] &lt;&lt; a[2] &lt;&lt; a[3];</span><br><span class="line">                flag = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (mid == a[0])</span><br><span class="line">                cout &lt;&lt; &quot; &quot; &lt;&lt; a[0] &lt;&lt; a[1] &lt;&lt; a[2] &lt;&lt; a[3];</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; endl;</span><br><span class="line">                cout &lt;&lt; a[0] &lt;&lt; a[1] &lt;&lt; a[2] &lt;&lt; a[3];</span><br><span class="line">            &#125;</span><br><span class="line">            mid = a[0];</span><br><span class="line">        &#125; while (next_permutation(a, a + 4));</span><br><span class="line">        puts(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>I have too much PE before I passed this problem.</p><h3 id="Ignatius-and-the-Princess-II"><a href="#Ignatius-and-the-Princess-II" class="headerlink" title="Ignatius and the Princess II"></a>Ignatius and the Princess II</h3><p>Description:<br>Now our hero finds the door to the BEelzebub feng5166. He opens the door and finds feng5166 is about to kill our pretty Princess. But now the BEelzebub has to beat our hero first. feng5166 says, &quot;I have three question for you, if you can work them out, I will release the Princess, or you will be my dinner, too.&quot; Ignatius says confidently, &quot;OK, at last, I will save the Princess.&quot;</p><p>&quot;Now I will show you the first problem.&quot; feng5166 says, &quot;Given a sequence of number 1 to N, we define that 1,2,3...N-1,N is the smallest sequence among all the sequence which can be composed with number 1 to N(each number can be and should be use only once in this problem). So it&#39;s easy to see the second smallest sequence is 1,2,3...N,N-1. Now I will give you two numbers, N and M. You should tell me the Mth smallest sequence which is composed with number 1 to N. It&#39;s easy, isn&#39;t is? Hahahahaha......&quot;<br>Can you help Ignatius to solve this problem?<br>Input</p><blockquote><p>The input contains several test cases. Each test case consists of two numbers, N and M(1&lt;=N&lt;=1000, 1&lt;=M&lt;=10000). You may assume that there is always a sequence satisfied the BEelzebub&#39;s demand. The input is terminated by the end of file.</p></blockquote><p>Output</p><blockquote><p>For each test case, you only have to output the sequence satisfied the BEelzebub&#39;s demand. When output a sequence, you should print a space between two numbers, but do not output any spaces after the last number.</p></blockquote><p>Sample Input</p><blockquote><p>6 4<br>11 8</p></blockquote><p>Sample Output</p><blockquote><p>1 2 3 5 6 4<br>1 2 3 4 5 6 7 9 8 11 10</p></blockquote><p>Problem solving:<br>An easy problem through &#39;next_permutation()&#39;.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[1005];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    while (~scanf(&quot;%d %d&quot;, &amp;n, &amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        int flag = 0;</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            flag++;</span><br><span class="line">            if (flag == m)</span><br><span class="line">                break;</span><br><span class="line">        &#125; while (next_permutation(a + 1, a + n + 1));</span><br><span class="line">        for (int i = 1; i &lt; n; i++)</span><br><span class="line">            cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">        cout &lt;&lt; a[n] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天主要讲了点基本的STL的用法。题写的有点吃力了，以后可能就写不完了，然后攒着写不完的题一天比一天多。&lt;br&gt;Nothing can change my love for you,even you.
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="Algorithm" scheme="https://cndrew.cn/blog/tags/Algorithm/"/>
    
      <category term="c/c++" scheme="https://cndrew.cn/blog/tags/c-c/"/>
    
      <category term="Thinking" scheme="https://cndrew.cn/blog/tags/Thinking/"/>
    
      <category term="HDU" scheme="https://cndrew.cn/blog/tags/HDU/"/>
    
      <category term="CodeForces" scheme="https://cndrew.cn/blog/tags/CodeForces/"/>
    
      <category term="poj" scheme="https://cndrew.cn/blog/tags/poj/"/>
    
      <category term="STL" scheme="https://cndrew.cn/blog/tags/STL/"/>
    
      <category term="UVA" scheme="https://cndrew.cn/blog/tags/UVA/"/>
    
      <category term="math" scheme="https://cndrew.cn/blog/tags/math/"/>
    
      <category term="Stack" scheme="https://cndrew.cn/blog/tags/Stack/"/>
    
      <category term="Queue" scheme="https://cndrew.cn/blog/tags/Queue/"/>
    
      <category term="Stringstream" scheme="https://cndrew.cn/blog/tags/Stringstream/"/>
    
  </entry>
  
  <entry>
    <title>HPU Summer Training Day x（河南理工大学暑期第x天）</title>
    <link href="https://cndrew.cn/blog/2019/07/18/dx/"/>
    <id>https://cndrew.cn/blog/2019/07/18/dx/</id>
    <published>2019-07-18T15:18:12.867Z</published>
    <updated>2019-07-19T12:11:05.984Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主要学的是快速幂，gcd<br>I don&#39;t know what day this is,just record it.<a id="more"></a></p><h3 id="Pseudoprime-numbers"><a href="#Pseudoprime-numbers" class="headerlink" title="Pseudoprime numbers"></a>Pseudoprime numbers</h3><p>Description:<br>Fermat&#39;s theorem states that for any prime number p and for any integer a &gt; 1, ap = a (mod p). That is, if we raise a to the pth power and divide by p, the remainder is a. Some (but not very many) non-prime values of p, known as base-a pseudoprimes, have this property for some a. (And some, known as Carmichael Numbers, are base-a pseudoprimes for all a.)</p><p>Given 2 &lt; p ≤ 1000000000 and 1 &lt; a &lt; p, determine whether or not p is a base-a pseudoprime.</p><p>Input</p><blockquote><p>Input contains several test cases followed by a line containing &quot;0 0&quot;. Each test case consists of a line containing p and a.</p></blockquote><p>Output</p><blockquote><p>For each test case, output &quot;yes&quot; if p is a base-a pseudoprime; otherwise output &quot;no&quot;.</p></blockquote><p>Sample Input</p><blockquote><p>3 2<br>10 3<br>341 2<br>341 3<br>1105 2<br>1105 3<br>0 0</p></blockquote><p>Sample Output</p><blockquote><p>no<br>no<br>yes<br>no<br>yes<br>yes</p></blockquote><p>Problem solving:<br>First judge p is a prime number or not,if p is a prime number output &#39;no&#39;,else then judge a^p%p is equal to a or not,if not equal output &#39;no&#39;.We should use fast power to avoid TLE.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">int s(long long a)</span><br><span class="line">&#123;</span><br><span class="line">if(a==2)</span><br><span class="line">return 1;</span><br><span class="line">for(int i=2;i*i&lt;=a;i++)</span><br><span class="line">if(a%i==0)</span><br><span class="line">return 0;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">long long f(long long a,long long b,long long c)//快速幂模板</span><br><span class="line">&#123;</span><br><span class="line">long long t=1;</span><br><span class="line">a=a%c;</span><br><span class="line">while(b&gt;0)</span><br><span class="line">&#123;</span><br><span class="line">if(b%2==1)</span><br><span class="line">t=t*a%c;</span><br><span class="line">b=b/2;</span><br><span class="line">a=a*a%c;</span><br><span class="line">&#125;</span><br><span class="line">return t;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">long long  a,p;</span><br><span class="line">while(~scanf(&quot;%lld%lld&quot;,&amp;p,&amp;a)&amp;&amp;!(a==0&amp;&amp;p==0))</span><br><span class="line">&#123;</span><br><span class="line">if(s(p))</span><br><span class="line">printf(&quot;no\n&quot;);</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">if(f(a,p,p)==a)</span><br><span class="line">        printf(&quot;yes\n&quot;);</span><br><span class="line">       else</span><br><span class="line">       printf(&quot;no\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Raising-Modulo-Numbers"><a href="#Raising-Modulo-Numbers" class="headerlink" title="Raising Modulo Numbers"></a>Raising Modulo Numbers</h3><p>Description:<br>People are different. Some secretly read magazines full of interesting girls&#39; pictures, others create an A-bomb in their cellar, others like using Windows, and some like difficult mathematical games. Latest marketing research shows, that this market segment was so far underestimated and that there is lack of such games. This kind of game was thus included into the KOKODáKH. The rules follow:</p><p>Each player chooses two numbers Ai and Bi and writes them on a slip of paper. Others cannot see the numbers. In a given moment all players show their numbers to the others. The goal is to determine the sum of all expressions Ai Bi from all players including oneself and determine the remainder after division by a given number M. The winner is the one who first determines the correct result. According to the players&#39; experience it is possible to increase the difficulty by choosing higher numbers.</p><p>You should write a program that calculates the result and is able to find out who won the game.</p><p>Input</p><blockquote><p>The input consists of Z assignments. The number of them is given by the single positive integer Z appearing on the first line of input. Then the assignements follow. Each assignement begins with line containing an integer M (1 &lt;= M &lt;= 45000). The sum will be divided by this number. Next line contains number of players H (1 &lt;= H &lt;= 45000). Next exactly H lines follow. On each line, there are exactly two numbers Ai and Bi separated by space. Both numbers cannot be equal zero at the same time.</p></blockquote><p>Output</p><blockquote><p>For each assingnement there is the only one line of output. On this line, there is a number, the result of expression</p></blockquote><p><img src="https://i.loli.net/2019/07/18/5d30905f4767b53419.png" alt></p><p>Sample Input</p><blockquote><p>3<br>16<br>4<br>2 3<br>3 4<br>4 5<br>5 6<br>36123<br>1<br>2374859 3029382<br>17<br>1<br>3 18132</p></blockquote><p>Sample Output</p><blockquote><p>2<br>13195<br>13</p></blockquote><p>Problem solving:<br>I don&#39;t understand this problem clearly first time,and then I find a little hint in the output,so it&#39;s easy now.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll poww(ll x, ll y, ll maxn)</span><br><span class="line">&#123;</span><br><span class="line">    ll res = 1;</span><br><span class="line">    while (y)</span><br><span class="line">    &#123;</span><br><span class="line">        if (y % 2 != 0)</span><br><span class="line">            res = res * x % maxn;</span><br><span class="line">        x  = x * x % maxn;</span><br><span class="line">        y /= 2;</span><br><span class="line">    &#125;</span><br><span class="line">    return res % maxn;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    ll a, b, c, d, e;</span><br><span class="line">    while (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll sum = 0;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        while (b--)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; d &gt;&gt; e;</span><br><span class="line">            sum += poww(d, e, a);</span><br><span class="line">            sum %= a;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Wolf-and-Rabbit"><a href="#Wolf-and-Rabbit" class="headerlink" title="Wolf and Rabbit"></a>Wolf and Rabbit</h3><p>Description:<br>There is a hill with n holes around. The holes are signed from 0 to n-1.<br><img src="https://i.loli.net/2019/07/18/5d3090c87d97386427.png" alt><br>A rabbit must hide in one of the holes. A wolf searches the rabbit in anticlockwise order. The first hole he get into is the one signed with 0. Then he will get into the hole every m holes. For example, m=2 and n=6, the wolf will get into the holes which are signed 0,2,4,0. If the rabbit hides in the hole which signed 1,3 or 5, she will survive. So we call these holes the safe holes.<br>Input</p><blockquote><p>The input starts with a positive integer P which indicates the number of test cases. Then on the following P lines,each line consists 2 positive integer m and n(0&lt;m,n&lt;2147483648).</p></blockquote><p>Output</p><blockquote><p>For each input m n, if safe holes exist, you should output &quot;YES&quot;, else output &quot;NO&quot; in a single line.</p></blockquote><p>Sample Input</p><blockquote><p>2<br>1 2<br>2 2</p></blockquote><p>Sample Output</p><blockquote><p>NO<br>YES</p></blockquote><p>Problem solving:<br>Nothing to say,just judge the gcd of m and n is equal to 1 or not.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,a,b;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">while(n--)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;a,&amp;b);</span><br><span class="line">if(__gcd(a,b)==1)puts(&quot;NO&quot;);</span><br><span class="line">elseputs(&quot;YES&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Cake"><a href="#Cake" class="headerlink" title="Cake"></a>Cake</h3><p>Description:<br>一次生日Party可能有p人或者q人参加,现准备有一个大蛋糕.问最少要将蛋糕切成多少块(每块大小不一定相等),才能使p人或者q人出席的任何一种情况,都能平均将蛋糕分食.<br>Input</p><blockquote><p>每行有两个数p和q.</p></blockquote><p>Output</p><blockquote><p>输出最少要将蛋糕切成多少块.</p></blockquote><p>Sample Input</p><blockquote><p>2 3</p></blockquote><p>Sample Output</p><blockquote><p>4</p></blockquote><p>Hint</p><blockquote><p>将蛋糕切成大小分别为1/3,1/3,1/6,1/6的四块即满足要求.<br>当2个人来时，每人可以吃1/3+1/6=1/2 , 1/2块。<br>当3个人来时，每人可以吃1/6+1/6=1/3 , 1/3, 1/3块。</p></blockquote><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int p, q;</span><br><span class="line">    while (~scanf(&quot;%d %d&quot;, &amp;p, &amp;q))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; p + q - __gcd(p, q) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="又见GCD"><a href="#又见GCD" class="headerlink" title="又见GCD"></a>又见GCD</h3><p>Description:<br>有三个正整数a,b,c(0&lt;a,b,c&lt;10^6)，其中c不等于b。若a和c的最大公约数为b，现已知a和b，求满足条件的最小的c。<br>Input</p><blockquote><p>第一行输入一个n，表示有n组测试数据，接下来的n行，每行输入两个正整数a,b。</p></blockquote><p>Output</p><blockquote><p>输出对应的c，每组测试数据占一行。</p></blockquote><p>Sample Input</p><blockquote><p>2<br>6 2<br>12 4</p></blockquote><p>Sample Output</p><blockquote><p>4<br>8</p></blockquote><p>Problem solving:<br>What we would like to find is the smallest c,so begin with 2*b.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n, a, b;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    while (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        for (int i = b * 2; ; i += b)</span><br><span class="line">        &#123;</span><br><span class="line">            if (__gcd(a, i) == b)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; i &lt;&lt; endl; break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h3><p>Description:<br>给定两个正整数，计算这两个数的最小公倍数。<br>Input</p><blockquote><p>输入包含多组测试数据，每组只有一行，包括两个不大于1000的正整数.</p></blockquote><p>Output</p><blockquote><p>对于每个测试用例，给出这两个数的最小公倍数，每个实例输出一行。</p></blockquote><p>Sample Input</p><blockquote><p>10 14</p></blockquote><p>Sample Output</p><blockquote><p>70</p></blockquote><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ll n, a, b;</span><br><span class="line">    while (~scanf(&quot;%lld %lld&quot;, &amp;a, &amp;b))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a * b / __gcd(a, b) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="素数判定"><a href="#素数判定" class="headerlink" title="素数判定"></a>素数判定</h3><p>Description:<br>对于表达式n^2+n+41，当n在（x,y）范围内取整数值时（包括x,y）(-39&lt;=x&lt;y&lt;=50)，判定该表达式的值是否都为素数。<br>Input</p><blockquote><p>输入数据有多组，每组占一行，由两个整数x，y组成，当x=0,y=0时，表示输入结束，该行不做处理。</p></blockquote><p>Output</p><blockquote><p>对于每个给定范围内的取值，如果表达式的值都为素数，则输出&quot;OK&quot;,否则请输出“Sorry”,每组输出占一行。</p></blockquote><p>Sample Input</p><blockquote><p>0 1<br>0 0</p></blockquote><p>Sample Output</p><blockquote><p>OK</p></blockquote><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">bool check(ll x)</span><br><span class="line">&#123;</span><br><span class="line">    if (x == 2)</span><br><span class="line">        return 0;</span><br><span class="line">    for (int i = 2; i &lt; sqrt(x + 1); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (x % i == 0)</span><br><span class="line">            return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ll n, a, b;</span><br><span class="line">    while (scanf(&quot;%lld %lld&quot;, &amp;a, &amp;b))</span><br><span class="line">    &#123;</span><br><span class="line">        int flag = 0;</span><br><span class="line">        if (a == 0 &amp;&amp; b == 0)</span><br><span class="line">            break;</span><br><span class="line">        for (ll i = a; i &lt;= b; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ll mid = i*i+ i + 41;</span><br><span class="line">            if (check(mid))</span><br><span class="line">            &#123;</span><br><span class="line">                flag = 1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (flag)</span><br><span class="line">            puts(&quot;Sorry&quot;);</span><br><span class="line">        else</span><br><span class="line">            puts(&quot;OK&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="分拆素数和"><a href="#分拆素数和" class="headerlink" title="分拆素数和"></a>分拆素数和</h3><p>Description:<br>把一个偶数拆成两个不同素数的和，有几种拆法呢？<br>Input</p><blockquote><p>输入包含一些正的偶数，其值不会超过10000，个数不会超过500，若遇0，则结束。</p></blockquote><p>Output</p><blockquote><p>对应每个偶数，输出其拆成不同素数的个数，每个结果占一行。</p></blockquote><p>Sample Input</p><blockquote><p>30<br>26<br>0</p></blockquote><p>Sample Output</p><blockquote><p>3<br>2</p></blockquote><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn = 1e4 + 7;</span><br><span class="line">int       p[maxn];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; maxn; i++)</span><br><span class="line">        p[i] = 1;</span><br><span class="line">    p[0] = p[1] = 0;</span><br><span class="line">    for (int i = 2; i &lt;= sqrt(maxn + 1); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = i + i; j &lt; maxn; j += i)</span><br><span class="line">        &#123;</span><br><span class="line">            p[j] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll n, a, b;</span><br><span class="line">    while (scanf(&quot;%lld&quot;, &amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        if (n == 0)</span><br><span class="line">            break;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int i = 2; i &lt;n / 2; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (p[i] &amp;&amp; p[n - i])</span><br><span class="line">                ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="美素数"><a href="#美素数" class="headerlink" title="美素数"></a>美素数</h3><p>Description:<br>小明对数的研究比较热爱，一谈到数，脑子里就涌现出好多数的问题，今天，小明想考考你对素数的认识。<br>　　问题是这样的：一个十进制数，如果是素数，而且它的各位数字和也是素数，则称之为“美素数”，如29，本身是素数，而且2+9 = 11也是素数，所以它是美素数。<br>　　给定一个区间，你能计算出这个区间内有多少个美素数吗？<br>Input</p><blockquote><p>第一行输入一个正整数T，表示总共有T组数据(T &lt;= 10000)。<br>接下来共T行，每行输入两个整数L，R(1&lt;= L &lt;= R &lt;= 1000000)，表示区间的左值和右值。</p></blockquote><p>Output</p><blockquote><p>对于每组数据，先输出Case数，然后输出区间内美素数的个数（包括端点值L,R）。<br>每组数据占一行，具体输出格式参见样例。</p></blockquote><p>Sample Input</p><blockquote><p>3<br>1 100<br>2 2<br>3 19</p></blockquote><p>Sample Output</p><blockquote><p>Case #1: 14<br>Case #2: 1<br>Case #3: 4</p></blockquote><p>Problem solving:<br>Just By meter(打表).<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e6+7;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll p[maxn];</span><br><span class="line">ll a[maxn];</span><br><span class="line">bool check(ll x)</span><br><span class="line">&#123;</span><br><span class="line">if(p[x])return 0;</span><br><span class="line">ll mid=0;</span><br><span class="line">while(x)</span><br><span class="line">&#123;</span><br><span class="line">mid+=x%10;x/=10;</span><br><span class="line">&#125;</span><br><span class="line">if(p[mid])return 0;</span><br><span class="line">elsereturn 1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">p[0]=p[1]=1;</span><br><span class="line">for(ll i=2;i&lt;sqrt(maxn);i++)</span><br><span class="line">&#123;</span><br><span class="line">for(ll j=i*2;j&lt;maxn;j+=i)</span><br><span class="line">&#123;</span><br><span class="line">p[j]=1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a[0]=0;</span><br><span class="line">for(int i=1;i&lt;maxn;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(check(i))a[i]=a[i-1]+1;</span><br><span class="line">elsea[i]=a[i-1];</span><br><span class="line">&#125;</span><br><span class="line">ll t,l,r;</span><br><span class="line">while(~scanf(&quot;%lld&quot;,&amp;t))</span><br><span class="line">&#123;</span><br><span class="line">for(int i=1;i&lt;=t;i++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%lld %lld&quot;,&amp;l,&amp;r);</span><br><span class="line">printf(&quot;Case #%lld: %lld\n&quot;,i,a[r]-a[l-1]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Key-Set"><a href="#Key-Set" class="headerlink" title="Key Set"></a>Key Set</h3><p>Description:<br>soda has a set S with n integers {1,2,…,n}. A set is called key set if the sum of integers in the set is an even number. He wants to know how many nonempty subsets of S are key set.<br>Input</p><blockquote><p>There are multiple test cases. The first line of input contains an integer T (1≤T≤1e5), indicating the number of test cases. For each test case:<br>The first line contains an integer n (1≤n≤1e9), the number of integers in the set.</p></blockquote><p>Output</p><blockquote><p>For each test case, output the number of key sets modulo 1000000007.</p></blockquote><p>Sample Input</p><blockquote><p>4<br>1<br>2<br>3<br>4</p></blockquote><p>Sample Output</p><blockquote><p>0<br>1<br>3<br>7</p></blockquote><p>Problem solving:<br>The answer is 2^(a-1)-1<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn = 1000000007;</span><br><span class="line">ll poww(ll x, ll y)</span><br><span class="line">&#123;</span><br><span class="line">    ll res = 1;</span><br><span class="line">    while (y)</span><br><span class="line">    &#123;</span><br><span class="line">        if (y % 2 != 0)</span><br><span class="line">            res = res * x % maxn;</span><br><span class="line">        x  = x * x % maxn;</span><br><span class="line">        y /= 2;</span><br><span class="line">    &#125;</span><br><span class="line">    return res % maxn;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n, a, b;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    while (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        cout &lt;&lt; poww(2, a - 1) - 1 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="人见人爱A-B"><a href="#人见人爱A-B" class="headerlink" title="人见人爱A^B"></a>人见人爱A^B</h3><p>Description:<br>求A^B的最后三位数表示的整数。<br>说明：A^B的含义是“A的B次方”<br>Input</p><blockquote><p>输入数据包含多个测试实例，每个实例占一行，由两个正整数A和B组成（1&lt;=A,B&lt;=10000），如果A=0, B=0，则表示输入数据的结束，不做处理。</p></blockquote><p>Output</p><blockquote><p>对于每个测试实例，请输出A^B的最后三位表示的整数，每个输出占一行。</p></blockquote><p>Sample Input</p><blockquote><p>2 3<br>12 6<br>6789 10000<br>0 0</p></blockquote><p>Sample Output</p><blockquote><p>8<br>984<br>1</p></blockquote><p>Problem solving:<br>Fast power.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll poww(ll x, ll y, ll z)</span><br><span class="line">&#123;</span><br><span class="line">    ll ans = 1, base = x; while (y != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        if (y &amp; 1 != 0)</span><br><span class="line">            ans = ans * base % z;</span><br><span class="line">        base = (base % z) * (base % z) % z; y &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ll a, b;</span><br><span class="line">    while (scanf(&quot;%lld %lld&quot;, &amp;a, &amp;b))</span><br><span class="line">    &#123;</span><br><span class="line">        if (a == 0 &amp;&amp; b == 0)</span><br><span class="line">            break;</span><br><span class="line">        cout &lt;&lt; poww(a, b, 1000) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Rightmost-Digit"><a href="#Rightmost-Digit" class="headerlink" title="Rightmost Digit"></a>Rightmost Digit</h3><p>Description:<br>Given a positive integer N, you should output the most right digit of N^N.<br>Input</p><blockquote><p>The input contains several test cases. The first line of the input is a single integer T which is the number of test cases. T test cases follow.<br>Each test case contains a single positive integer N(1&lt;=N&lt;=1,000,000,000).</p></blockquote><p>Output</p><blockquote><p>For each test case, you should output the rightmost digit of N^N.</p></blockquote><p>Sample Input</p><blockquote><p>2<br>3<br>4</p></blockquote><p>Sample Output</p><blockquote><p>7<br>6</p></blockquote><p>Hint</p><blockquote><p>In the first case, 3 <em> 3 </em> 3 = 27, so the rightmost digit is 7.<br>In the second case, 4 <em> 4 </em> 4 * 4 = 256, so the rightmost digit is 6.</p></blockquote><p>Problem solving:<br>Fast power.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll poww(ll x, ll y, ll z)</span><br><span class="line">&#123;</span><br><span class="line">    ll ans = 1, base = x; while (y != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        if (y &amp; 1 != 0)</span><br><span class="line">            ans = ans * base % z;</span><br><span class="line">        base = (base % z) * (base % z) % z; y &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ll n, a;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    while (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        cout &lt;&lt; poww(a, a, 10) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要学的是快速幂，gcd&lt;br&gt;I don&amp;#39;t know what day this is,just record it.
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="Algorithm" scheme="https://cndrew.cn/blog/tags/Algorithm/"/>
    
      <category term="c/c++" scheme="https://cndrew.cn/blog/tags/c-c/"/>
    
      <category term="math" scheme="https://cndrew.cn/blog/tags/math/"/>
    
      <category term="Fast power" scheme="https://cndrew.cn/blog/tags/Fast-power/"/>
    
      <category term="prime" scheme="https://cndrew.cn/blog/tags/prime/"/>
    
      <category term="gcd" scheme="https://cndrew.cn/blog/tags/gcd/"/>
    
      <category term="lcm" scheme="https://cndrew.cn/blog/tags/lcm/"/>
    
  </entry>
  
  <entry>
    <title>Something about __gcd</title>
    <link href="https://cndrew.cn/blog/2019/07/18/sp-gcd/"/>
    <id>https://cndrew.cn/blog/2019/07/18/sp-gcd/</id>
    <published>2019-07-18T15:04:02.870Z</published>
    <updated>2019-07-18T15:43:48.047Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>I have written an article about gcd and lcm,I meet a new way to calculate gcd these days.<a id="more"></a><br>My past gcd aritical: <a href="https://cndrew.cn/blog/2019/03/26/GCD-LCM/">https://cndrew.cn/blog/2019/03/26/GCD-LCM/</a><br>For example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a=199,b=199*2;</span><br><span class="line">printf(&quot;%d\n&quot;,__gcd(a,b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">199</span><br></pre></td></tr></table></figure></p><p>The header file of __gcd is &#39;algorithm&#39;.<br>How about the Time complexity(时间复杂度) of it.<br>I found the source code for its implementation in the source file.Just like Division algorithm(辗转相除法).<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line">  *  This is a helper function for the rotate algorithm specialized on RAIs.</span><br><span class="line">  *  It returns the greatest common divisor of two integer values.</span><br><span class="line"> */</span><br><span class="line"> template&lt;typename _EuclideanRingElement&gt;</span><br><span class="line">   _EuclideanRingElement</span><br><span class="line">   __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)</span><br><span class="line">   &#123;</span><br><span class="line">     while (__n != 0)</span><br><span class="line">&#123;</span><br><span class="line">  _EuclideanRingElement __t = __m % __n;</span><br><span class="line">  __m = __n;</span><br><span class="line">  __n = __t;</span><br><span class="line">&#125;</span><br><span class="line">     return __m;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>Now it&#39;s clear that the Time complexity(时间复杂度) of it is log(n).<br>About this function,many people say it&#39;s probably forbidden in some test,and gcd is not so hard to write,just get too know it.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;I have written an article about gcd and lcm,I meet a new way to calculate gcd these days.
    
    </summary>
    
      <category term="Algorithm" scheme="https://cndrew.cn/blog/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://cndrew.cn/blog/tags/Algorithm/"/>
    
      <category term="c/c++" scheme="https://cndrew.cn/blog/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>HPU Summer Training Day 2（河南理工暑期集训第二天）</title>
    <link href="https://cndrew.cn/blog/2019/07/18/d2/"/>
    <id>https://cndrew.cn/blog/2019/07/18/d2/</id>
    <published>2019-07-18T14:55:32.227Z</published>
    <updated>2019-07-18T15:43:28.837Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天主要学习了sort，结构体的sort。<br>第一天算是结束了，还是有点累的，但是也很有收获，趁着这些题还都勉强能做出来，赶紧多写点吧.<a id="more"></a></p><h3 id="前m大的数"><a href="#前m大的数" class="headerlink" title="前m大的数"></a>前m大的数</h3><p>Description:<br>还记得Gardon给小希布置的那个作业么？（上次比赛的1005）其实小希已经找回了原来的那张数表，现在她想确认一下她的答案是否正确，但是整个的答案是很庞大的表，小希只想让你把答案中最大的M个数告诉她就可以了。<br>给定一个包含N(N&lt;=3000)个正整数的序列，每个数不超过5000，对它们两两相加得到的N*(N-1)/2个和，求出其中前M大的数(M&lt;=1000)并按从大到小的顺序排列。<br>Input</p><blockquote><p>输入可能包含多组数据，其中每组数据包括两行：<br>第一行两个数N和M，<br>第二行N个数，表示该序列。</p></blockquote><p>Output</p><blockquote><p>对于输入的每组数据，输出M个数，表示结果。输出应当按照从大到小的顺序排列。</p></blockquote><p>Sample Input</p><blockquote><p>4 4<br>1 2 3 4<br>4 5<br>5 3 6 4</p></blockquote><p>Sample Output</p><blockquote><p>7 6 5 5<br>11 10 9 9 8</p></blockquote><p>Problem solving:<br>I have nothing to say about this *** problem,just do it without thinking.</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e7;</span><br><span class="line">int a[maxn],b[4000];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,m;</span><br><span class="line">while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;m))</span><br><span class="line">&#123;</span><br><span class="line">int k=0;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">scanf(&quot;%d&quot;,&amp;b[i]);</span><br><span class="line">for(int i=0;i&lt;n-1;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=i+1;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line">a[k]=b[i]+b[j];</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sort(a,a+k);</span><br><span class="line">for(int i=k-1;i&gt;0;i--)</span><br><span class="line">&#123;</span><br><span class="line">if(m==0)break;</span><br><span class="line">if(i==k-1)cout&lt;&lt;a[i];</span><br><span class="line">elsecout&lt;&lt;&quot; &quot;&lt;&lt;a[i];</span><br><span class="line">m--;</span><br><span class="line">&#125;</span><br><span class="line">puts(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="稳定排序"><a href="#稳定排序" class="headerlink" title="稳定排序"></a>稳定排序</h3><p>Description:<br>大家都知道，快速排序是不稳定的排序方法。<br>如果对于数组中出现的任意a[i],a<a href="i&lt;j">j</a>,其中a[i]==a[j]，在进行排序以后a[i]一定出现在a[j]之前，则认为该排序是稳定的。</p><p>某高校招生办得到一份成绩列表，上面记录了考生名字和考生成绩。并且对其使用了某排序算法按成绩进行递减排序。现在请你判断一下该排序算法是否正确，如果正确的话，则判断该排序算法是否为稳定的。<br>Input</p><blockquote><p>本题目包含多组输入，请处理到文件结束。<br>对于每组数据，第一行有一个正整数N(0&lt;N&lt;300)，代表成绩列表中的考生数目。<br>接下来有N行，每一行有一个字符串代表考生名字(长度不超过50，仅包含&#39;a&#39;~&#39;z&#39;),和一个整数代表考生分数(小于500)。其中名字和成绩用一个空格隔开。<br>再接下来又有N行，是上述列表经过某排序算法以后生成的一个序列。格式同上。</p></blockquote><p>Output</p><blockquote><p>对于每组数据，如果算法是正确并且稳定的，就在一行里面输出&quot;Right&quot;。如果算法是正确的但不是稳定的，就在一行里面输出&quot;Not Stable&quot;，并且在下面输出正确稳定排序的列表，格式同输入。如果该算法是错误的，就在一行里面输出&quot;Error&quot;,并且在下面输出正确稳定排序的列表，格式同输入。<br>注意，本题目不考虑该排序算法是错误的，但结果是正确的这样的意外情况。</p></blockquote><p>Sample Input</p><blockquote><p>3<br>aa 10<br>bb 10<br>cc 20<br>cc 20<br>bb 10<br>aa 10<br>3<br>aa 10<br>bb 10<br>cc 20<br>cc 20<br>aa 10<br>bb 10<br>3<br>aa 10<br>bb 10<br>cc 20<br>aa 10<br>bb 10<br>cc 20</p></blockquote><p>Sample Output</p><blockquote><p>Not Stable<br>cc 20<br>aa 10<br>bb 10<br>Right<br>Error<br>cc 20<br>aa 10<br>bb 10</p></blockquote><p>Problem solving:<br>Attention: we&#39;d better make the order in which it arrears.And then just sort for structures.Compare the second input with the right and stable result.If the score&#39;s order is wrong,output &#39;Error&#39;,if the name&#39;s order is wrong,output &#39;Not Stable&#39;,if all order are right,output &#39;Right&#39;.</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">string na;</span><br><span class="line">int s,i;</span><br><span class="line">&#125;p[305],pp[305];</span><br><span class="line">bool cmp(node x,node y)</span><br><span class="line">&#123;</span><br><span class="line">if(x.s==y.s)return x.i&lt;y.i;</span><br><span class="line">return x.s&gt;y.s;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">while(~scanf(&quot;%d&quot;,&amp;n))</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;p[i].na&gt;&gt;p[i].s;</span><br><span class="line">p[i].i=i;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;pp[i].na&gt;&gt;pp[i].s;</span><br><span class="line">&#125;</span><br><span class="line">sort(p,p+n,cmp);</span><br><span class="line">int flag=0;</span><br><span class="line">for(int i=0;i&lt;n-1;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(pp[i].s&lt;pp[i+1].s)</span><br><span class="line">&#123;</span><br><span class="line">flag=1;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(flag)</span><br><span class="line">&#123;</span><br><span class="line">puts(&quot;Error&quot;);</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;p[i].na&lt;&lt;&quot; &quot;&lt;&lt;p[i].s&lt;&lt;&quot;\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(p[i].na!=pp[i].na)</span><br><span class="line">&#123;</span><br><span class="line">flag=1;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(flag)</span><br><span class="line">&#123;</span><br><span class="line">puts(&quot;Not Stable&quot;);</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;p[i].na&lt;&lt;&quot; &quot;&lt;&lt;p[i].s&lt;&lt;&quot;\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">puts(&quot;Right&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="开门人和关门人"><a href="#开门人和关门人" class="headerlink" title="开门人和关门人"></a>开门人和关门人</h3><p>Description:<br>每天第一个到机房的人要把门打开，最后一个离开的人要把门关好。现有一堆杂乱的机房签<br>到、签离记录，请根据记录找出当天开门和关门的人。<br>Input</p><blockquote><p>测试输入的第一行给出记录的总天数N ( &gt; 0 )。下面列出了N天的记录。<br>每天的记录在第一行给出记录的条目数M ( &gt; 0 )，下面是M行，每行的格式为<br>证件号码 签到时间 签离时间<br>其中时间按“小时:分钟:秒钟”（各占2位）给出，证件号码是长度不超过15的字符串。</p></blockquote><p>Output</p><blockquote><p>对每一天的记录输出1行，即当天开门和关门人的证件号码，中间用1空格分隔。<br>注意：在裁判的标准测试输入中，所有记录保证完整，每个人的签到时间在签离时间之前，<br>且没有多人同时签到或者签离的情况。</p></blockquote><p>Sample Input</p><blockquote><p>3<br>1<br>ME3021112225321 00:00:00 23:59:59<br>2<br>EE301218 08:05:35 20:56:35<br>MA301134 12:35:45 21:40:42<br>3<br>CS301111 15:30:28 17:00:10<br>SC3021234 08:00:00 11:25:25<br>CS301133 21:45:00 21:58:40</p></blockquote><p>Sample Output</p><blockquote><p>ME3021112225321 ME3021112225321<br>EE301218 MA301134<br>SC3021234 CS301133</p></blockquote><p>Problem solving:<br>The earliest person and the lastest person is what we should output.The way we get these two person&#39;s name is sort,sort for structures.The best thing is we can find this efficient through sort string.You can look my code carefully to understand this.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">string n,b,e;</span><br><span class="line">&#125;p[1000];</span><br><span class="line">bool cmp(node x,node y)</span><br><span class="line">&#123;</span><br><span class="line">return x.b&lt;y.b;</span><br><span class="line">&#125;</span><br><span class="line">bool ccmp(node x,node y)</span><br><span class="line">&#123;</span><br><span class="line">return x.e&gt;y.e;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">while(n--)</span><br><span class="line">&#123;</span><br><span class="line">int m;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">for(int i=0;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;p[i].n&gt;&gt;p[i].b&gt;&gt;p[i].e;</span><br><span class="line">&#125;</span><br><span class="line">sort(p,p+m,cmp);</span><br><span class="line">cout&lt;&lt;p[0].n&lt;&lt;&quot; &quot;;</span><br><span class="line">sort(p,p+m,ccmp);</span><br><span class="line">cout&lt;&lt;p[0].n;</span><br><span class="line">puts(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="EXCEL排序"><a href="#EXCEL排序" class="headerlink" title="EXCEL排序"></a>EXCEL排序</h3><p>Description:<br>Excel可以对一组纪录按任意指定列排序。现请你编写程序实现类似功能。<br>Input</p><blockquote><p>测试输入包含若干测试用例。每个测试用例的第1行包含两个整数 N (&lt;=100000) 和 C，其中 N 是纪录的条数，C 是指定排序的列号。以下有 N<br>行，每行包含一条学生纪录。每条学生纪录由学号（6位数字，同组测试中没有重复的学号）、姓名（不超过8位且不包含空格的字符串）、成绩（闭区间[0, 100]内的整数）组成，每个项目间用1个空格隔开。当读到 N=0 时，全部输入结束，相应的结果不要输出。</p></blockquote><p>Output</p><blockquote><p>对每个测试用例，首先输出1行“Case i:”，其中 i 是测试用例的编号（从1开始）。随后在 N 行中输出按要求排序后的结果，即：当 C=1 时，按学号递增排序；当 C=2时，按姓名的非递减字典序排序；当 C=3<br>时，按成绩的非递减排序。当若干学生具有相同姓名或者相同成绩时，则按他们的学号递增排序。</p></blockquote><p>Sample Input</p><blockquote><p>3 1<br>000007 James 85<br>000010 Amy 90<br>000001 Zoe 60<br>4 2<br>000007 James 85<br>000010 Amy 90<br>000001 Zoe 60<br>000002 James 98<br>4 3<br>000007 James 85<br>000010 Amy 90<br>000001 Zoe 60<br>000002 James 90<br>0 0</p></blockquote><p>Sample Output</p><blockquote><p>Case 1:<br>000001 Zoe 60<br>000007 James 85<br>000010 Amy 90<br>Case 2:<br>000010 Amy 90<br>000002 James 98<br>000007 James 85<br>000001 Zoe 60<br>Case 3:<br>000001 Zoe 60<br>000007 James 85<br>000002 James 90<br>000010 Amy 90</p></blockquote><p>Problem solving:<br>Look the problem description carefully,and sort for structures.Easy.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">string id,na;</span><br><span class="line">int s;</span><br><span class="line">&#125;p[100008];</span><br><span class="line">bool cmp1(node x,node y)</span><br><span class="line">&#123;</span><br><span class="line">return x.id&lt;y.id;</span><br><span class="line">&#125;</span><br><span class="line">bool cmp2(node x,node y)</span><br><span class="line">&#123;</span><br><span class="line">if(x.na==y.na)</span><br><span class="line">return x.id&lt;y.id;</span><br><span class="line">return x.na&lt;y.na;</span><br><span class="line">&#125;</span><br><span class="line">bool cmp3(node x,node y)</span><br><span class="line">&#123;</span><br><span class="line">if(x.s==y.s)</span><br><span class="line">return x.id&lt;y.id;</span><br><span class="line">return x.s&lt;y.s;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,c,j=0;</span><br><span class="line">while(scanf(&quot;%d %d&quot;,&amp;n,&amp;c)&amp;&amp;n)</span><br><span class="line">&#123;</span><br><span class="line">j++;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">cin&gt;&gt;p[i].id&gt;&gt;p[i].na&gt;&gt;p[i].s;</span><br><span class="line">if(c==1)</span><br><span class="line">&#123;</span><br><span class="line">sort(p,p+n,cmp1);</span><br><span class="line">&#125;</span><br><span class="line">if(c==2)</span><br><span class="line">&#123;</span><br><span class="line">sort(p,p+n,cmp2);</span><br><span class="line">&#125;</span><br><span class="line">if(c==3)</span><br><span class="line">&#123;</span><br><span class="line">sort(p,p+n,cmp3);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;Case %d:\n&quot;,j);</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">cout&lt;&lt;p[i].id&lt;&lt;&quot; &quot;&lt;&lt;p[i].na&lt;&lt;&quot; &quot;&lt;&lt;p[i].s&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="统计同成绩学生人数"><a href="#统计同成绩学生人数" class="headerlink" title="统计同成绩学生人数"></a>统计同成绩学生人数</h3><p>Description:<br>读入N名学生的成绩，将获得某一给定分数的学生人数输出。<br>Input</p><blockquote><p>测试输入包含若干测试用例，每个测试用例的格式为<br>第1行：N<br>第2行：N名学生的成绩，相邻两数字用一个空格间隔。<br>第3行：给定分数<br>当读到N=0时输入结束。其中N不超过1000，成绩分数为（包含）0到100之间的一个整数。</p></blockquote><p>Output</p><blockquote><p>对每个测试用例，将获得给定分数的学生人数输出。</p></blockquote><p>Sample Input</p><blockquote><p>3<br>80 60 90<br>60<br>2<br>85 66<br>0<br>5<br>60 75 90 55 75<br>75<br>0</p></blockquote><p>Sample Output</p><blockquote><p>1<br>0<br>2</p></blockquote><p>Problem solving:<br>We can solve this by loop for,but I think map is exciting.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,a,m;</span><br><span class="line">while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n)</span><br><span class="line">&#123;</span><br><span class="line">map&lt;int,int&gt; ma;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;a);</span><br><span class="line">ma[a]++;</span><br><span class="line">&#125;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">printf(&quot;%d\n&quot;,ma[m]);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="What-Is-Your-Grade"><a href="#What-Is-Your-Grade" class="headerlink" title="What Is Your Grade?"></a>What Is Your Grade?</h3><p>Description:<br>“Point, point, life of student!”<br>This is a ballad（歌谣）well known in colleges, and you must care about your score in this exam too. How many points can you get? Now, I told you the rules which are used in this course.<br>There are 5 problems in this final exam. And I will give you 100 points if you can solve all 5 problems; of course, it is fairly difficulty for many of you. If you can solve 4 problems, you can also get a high score 95 or 90 (you can get the former(前者) only when your rank is in the first half of all students who solve 4 problems). Analogically（以此类推）, you can get 85、80、75、70、65、60. But you will not pass this exam if you solve nothing problem, and I will mark your score with 50.<br>Note, only 1 student will get the score 95 when 3 students have solved 4 problems.<br>I wish you all can pass the exam!<br>Come on!<br>Input</p><blockquote><p>Input contains multiple test cases. Each test case contains an integer N (1&lt;=N&lt;=100, the number of students) in a line first, and then N lines follow. Each line contains P (0&lt;=P&lt;=5 number of problems that have been solved) and T（consumed time）. You can assume that all data are different when 0\&lt;p.<br>A test case starting with a negative integer terminates the input and this test case should not to be processed.</p></blockquote><p>Output</p><blockquote><p>Output the scores of N students in N lines for each case, and there is a blank line after each case.</p></blockquote><p>Sample Input</p><blockquote><p>4<br>5 06:30:17<br>4 07:31:27<br>4 08:12:12<br>4 05:23:13<br>1<br>5 06:30:17<br>-1</p></blockquote><p>Sample Output</p><blockquote><p>100<br>90<br>90<br>95<br>100</p></blockquote><p>Problem solving:<br>&#39;only when your rank is in the first half of all students who solve 4 problems&#39;-&gt;This is important.What we should pay more attention to is the meaning of this problem.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">int na;</span><br><span class="line">string t;</span><br><span class="line">int s;</span><br><span class="line">int i;</span><br><span class="line">&#125;p[105];</span><br><span class="line">bool cmp(node x,node y)</span><br><span class="line">&#123;</span><br><span class="line">if(x.s==y.s)return x.t&lt;y.t;</span><br><span class="line">return x.s&gt;y.s;</span><br><span class="line">&#125;</span><br><span class="line">bool cmp1(node x,node y)</span><br><span class="line">&#123;</span><br><span class="line">return x.i&lt;y.i;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n&gt;0)</span><br><span class="line">&#123;</span><br><span class="line">int mid=0,aa=0,bb=0,cc=0,dd=0;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">p[i].i=i;</span><br><span class="line">cin&gt;&gt;p[i].na&gt;&gt;p[i].t;</span><br><span class="line">if(p[i].na==5)p[i].s=100;</span><br><span class="line">if(p[i].na==0)p[i].s=50;</span><br><span class="line">if(p[i].na==4)&#123;p[i].s=90;aa++;&#125;</span><br><span class="line">if(p[i].na==3)&#123;p[i].s=80;bb++;&#125;</span><br><span class="line">if(p[i].na==2)&#123;p[i].s=70;cc++;&#125;</span><br><span class="line">if(p[i].na==1)&#123;p[i].s=60;dd++;&#125;</span><br><span class="line">&#125;</span><br><span class="line">aa/=2;</span><br><span class="line">bb/=2;</span><br><span class="line">cc/=2;</span><br><span class="line">dd/=2;</span><br><span class="line">sort(p,p+n,cmp);</span><br><span class="line"></span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(p[i].s==90&amp;&amp;aa)</span><br><span class="line">&#123;</span><br><span class="line">p[i].s=95;</span><br><span class="line">aa--;</span><br><span class="line">&#125;</span><br><span class="line">if(p[i].s==80&amp;&amp;bb)</span><br><span class="line">&#123;</span><br><span class="line">p[i].s=85;</span><br><span class="line">bb--;</span><br><span class="line">&#125;</span><br><span class="line">if(p[i].s==70&amp;&amp;cc)</span><br><span class="line">&#123;</span><br><span class="line">p[i].s=75;</span><br><span class="line">cc--;</span><br><span class="line">&#125;</span><br><span class="line">if(p[i].s==60&amp;&amp;dd)</span><br><span class="line">&#123;</span><br><span class="line">p[i].s=65;</span><br><span class="line">dd--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sort(p,p+n,cmp1);</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">cout&lt;&lt;p[i].s&lt;&lt;&quot;\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line">puts(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Magical-Bamboos"><a href="#Magical-Bamboos" class="headerlink" title="Magical Bamboos"></a>Magical Bamboos</h3><p>Description:<br>In a magical forest, there exists N bamboos that don&#39;t quite get cut down the way you would expect.</p><p>Originally, the height of the ith bamboo is equal to hi. In one move, you can push down a bamboo and decrease its height by one, but this move magically causes all the other bamboos to increase in height by one.</p><p>If you can do as many moves as you like, is it possible to make all the bamboos have the same height?</p><p>Input</p><blockquote><p>The first line of input is T – the number of test cases.<br>The first line of each test case contains an integer N (1 ≤ N ≤ 105) - the number of bamboos.<br>The second line contains N space-separated integers hi (1 ≤ hi ≤ 105) - the original heights of the bamboos.</p></blockquote><p>Output</p><blockquote><p>For each test case, output on a single line &quot;yes” (without quotes), if you can make all the bamboos have the same height, and &quot;no&quot; otherwise.</p></blockquote><p>Example</p><blockquote><p>Input<br>2<br>3<br>2 4 2<br>2<br>1 2</p></blockquote><blockquote><p>Output<br>yes<br>no</p></blockquote><p>Problem solving:<br>Sorted this array fist.If the difference of two adjacent numbers have odd,output &#39;no&#39;,otherwise,output &#39;yes&#39;.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e5+7;</span><br><span class="line">int a[maxn];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">while(n--)</span><br><span class="line">&#123;</span><br><span class="line">int m,flag=0;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">for(int i=0;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;m-1;i++)</span><br><span class="line">&#123;</span><br><span class="line">if((a[i+1]-a[i])%2!=0)</span><br><span class="line">&#123;</span><br><span class="line">flag=1;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(flag)puts(&quot;no&quot;);</span><br><span class="line">elseputs(&quot;yes&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Bear-and-Three-Balls"><a href="#Bear-and-Three-Balls" class="headerlink" title="Bear and Three Balls"></a>Bear and Three Balls</h3><p>Description:<br>Limak is a little polar bear. He has n balls, the i-th ball has size ti.</p><p>Limak wants to give one ball to each of his three friends. Giving gifts isn&#39;t easy — there are two rules Limak must obey to make friends happy:</p><p>No two friends can get balls of the same size.<br>No two friends can get balls of sizes that differ by more than 2.<br>For example, Limak can choose balls with sizes 4, 5 and 3, or balls with sizes 90, 91 and 92. But he can&#39;t choose balls with sizes 5, 5 and 6 (two friends would get balls of the same size), and he can&#39;t choose balls with sizes 30, 31 and 33 (because sizes 30 and 33 differ by more than 2).</p><p>Your task is to check whether Limak can choose three balls that satisfy conditions above.</p><p>Input</p><blockquote><p>The first line of the input contains one integer n (3 ≤ n ≤ 50) — the number of balls Limak has.<br>The second line contains n integers t1, t2, ..., tn (1 ≤ ti ≤ 1000) where ti denotes the size of the i-th ball.</p></blockquote><p>Output</p><blockquote><p>Print &quot;YES&quot; (without quotes) if Limak can choose three balls of distinct sizes, such that any two of them differ by no more than 2. Otherwise, print &quot;NO&quot; (without quotes).</p></blockquote><p>Examples</p><blockquote><p>Input<br>4<br>18 55 16 17</p></blockquote><blockquote><p>Output<br>YES</p></blockquote><p>Input</p><blockquote><p>6<br>40 41 43 44 44 44</p></blockquote><p>Output</p><blockquote><p>NO</p></blockquote><p>Input</p><blockquote><p>8<br>5 972 3 4 1 4 970 971</p></blockquote><p>Output</p><blockquote><p>YES</p></blockquote><p>Note</p><blockquote><p>In the first sample, there are 4 balls and Limak is able to choose three of them to satisfy the rules. He must must choose balls with sizes 18, 16 and 17.<br>In the second sample, there is no way to give gifts to three friends without breaking the rules.<br>In the third sample, there is even more than one way to choose balls:</p><ol><li>Choose balls with sizes 3, 4 and 5.</li><li>Choose balls with sizes 972, 970, 971.</li></ol></blockquote><p>Problem solving:<br>If there have three numbers which are adjacent,output &#39;yes&#39;,otherwise ouput&#39;no&#39;.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[100];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,flag=0;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line">sort(a,a+n);</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(binary_search(a,a+n,a[i]+1)&amp;&amp;binary_search(a,a+n,a[i]+2))</span><br><span class="line">&#123;</span><br><span class="line">flag=1;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(flag)puts(&quot;YES&quot;);</span><br><span class="line">elseputs(&quot;NO&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="今年暑假不AC"><a href="#今年暑假不AC" class="headerlink" title="今年暑假不AC"></a>今年暑假不AC</h3><p>Description:<br>“今年暑假不AC？”<br>“是的。”<br>“那你干什么呢？”<br>“看世界杯呀，笨蛋！”<br>“@#\$%^&amp;*%...”</p><p>确实如此，世界杯来了，球迷的节日也来了，估计很多ACMer也会抛开电脑，奔向电视了。<br>作为球迷，一定想看尽量多的完整的比赛，当然，作为新时代的好青年，你一定还会看一些其它的节目，比如新闻联播（永远不要忘记关心国家大事）、非常6+7、超级女生，以及王小丫的《开心辞典》等等，假设你已经知道了所有你喜欢看的电视节目的转播时间表，你会合理安排吗？（目标是能看尽量多的完整节目）<br>Input</p><blockquote><p>输入数据包含多个测试实例，每个测试实例的第一行只有一个整数n(n&lt;=100)，表示你喜欢看的节目的总数，然后是n行数据，每行包括两个数据Ti_s,Ti_e (1&lt;=i&lt;=n)，分别表示第i个节目的开始和结束时间，为了简化问题，每个时间都用一个正整数表示。n=0表示输入结束，不做处理。</p></blockquote><p>Output</p><blockquote><p>对于每个测试实例，输出能完整看到的电视节目的个数，每个测试实例的输出占一行。</p></blockquote><p>Sample Input</p><blockquote><p>12<br>1 3<br>3 4<br>0 7<br>3 8<br>15 19<br>15 20<br>10 15<br>8 18<br>6 12<br>5 10<br>4 14<br>2 9<br>0</p></blockquote><p>Sample Output</p><blockquote><p>5</p></blockquote><p>Problem solving:<br>Greedy,sort by the end time,and then start counting.<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 105;</span><br><span class="line">struct node&#123;</span><br><span class="line">int b,s;</span><br><span class="line">&#125;x[maxn];</span><br><span class="line">bool cmp(node q,node w)</span><br><span class="line">&#123;</span><br><span class="line">return q.s&lt;w.s;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n)</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;x[i].b&gt;&gt;x[i].s;</span><br><span class="line">&#125;</span><br><span class="line">sort(x,x+n,cmp);</span><br><span class="line">int o=x[0].s,ans=1;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(x[i].b&gt;=o)</span><br><span class="line">&#123;</span><br><span class="line">ans++;</span><br><span class="line">o=x[i].s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="The-sum-problem"><a href="#The-sum-problem" class="headerlink" title="The sum problem"></a>The sum problem</h3><p>Description:<br>Given a sequence 1,2,3,......N, your job is to calculate all the possible sub-sequences that the sum of the sub-sequence is M.<br>Input</p><blockquote><p>Input contains multiple test cases. each case contains two integers N, M( 1 &lt;= N, M &lt;= 1000000000).input ends with N = M = 0.</p></blockquote><p>Output</p><blockquote><p>For each test case, print all the possible sub-sequence that its sum is M.The format is show in the sample below.print a blank line after each test case.</p></blockquote><p>Sample Input</p><blockquote><p>20 10<br>50 30<br>0 0</p></blockquote><p>Sample Output</p><blockquote><p>[1,4]<br>[10,10]<br>[4,8]<br>[6,9]<br>[9,11]<br>[30,30]</p></blockquote><p>Problem solving:<br>Sum Formula of Equal Difference Sequences.<br><img src="https://i.loli.net/2019/07/18/5d3012d17685519697.png" alt><br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,m;</span><br><span class="line">while(scanf(&quot;%d %d&quot;,&amp;n,&amp;m))</span><br><span class="line">&#123;</span><br><span class="line">if(m==0&amp;&amp;m==0)break;</span><br><span class="line">for(int i=sqrt(2*m);i&gt;=1;i--)</span><br><span class="line">&#123;</span><br><span class="line">int a=(m-i*(i-1)/2)/i;</span><br><span class="line">if((a*i)+i*(i-1)/2==m)</span><br><span class="line">printf(&quot;[%d,%d]\n&quot;,a,a+i-1);</span><br><span class="line">&#125;</span><br><span class="line">puts(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天主要学习了sort，结构体的sort。&lt;br&gt;第一天算是结束了，还是有点累的，但是也很有收获，趁着这些题还都勉强能做出来，赶紧多写点吧.
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="Algorithm" scheme="https://cndrew.cn/blog/tags/Algorithm/"/>
    
      <category term="c/c++" scheme="https://cndrew.cn/blog/tags/c-c/"/>
    
      <category term="Thinking" scheme="https://cndrew.cn/blog/tags/Thinking/"/>
    
      <category term="HDU" scheme="https://cndrew.cn/blog/tags/HDU/"/>
    
      <category term="CodeForces" scheme="https://cndrew.cn/blog/tags/CodeForces/"/>
    
      <category term="STL" scheme="https://cndrew.cn/blog/tags/STL/"/>
    
      <category term="math" scheme="https://cndrew.cn/blog/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>HPU Summer Training Day 1（河南理工大学暑期第一天）</title>
    <link href="https://cndrew.cn/blog/2019/07/17/d1/"/>
    <id>https://cndrew.cn/blog/2019/07/17/d1/</id>
    <published>2019-07-17T13:15:48.143Z</published>
    <updated>2019-07-18T14:59:25.089Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>盼望着，盼望着，暑假集训来了，希望集训完自己能变的厉害点吧。不然这丢失的40天左右的假期还真是浪费了啊。</p><p><img src="https://i.loli.net/2019/07/17/5d2f23940943935724.jpeg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="Algorithm" scheme="https://cndrew.cn/blog/tags/Algorithm/"/>
    
      <category term="c/c++" scheme="https://cndrew.cn/blog/tags/c-c/"/>
    
      <category term="life" scheme="https://cndrew.cn/blog/tags/life/"/>
    
  </entry>
  
</feed>
