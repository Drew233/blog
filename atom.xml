<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Uncle_drew</title>
  
  <subtitle>Hand down,man down</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://cndrew.cn/blog/"/>
  <updated>2019-08-08T15:21:56.796Z</updated>
  <id>https://cndrew.cn/blog/</id>
  
  <author>
    <name>Uncle_drew</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HPU Summer Day23(河南理工大学暑期第二十三天)</title>
    <link href="https://cndrew.cn/blog/2019/08/08/d23/"/>
    <id>https://cndrew.cn/blog/2019/08/08/d23/</id>
    <published>2019-08-08T15:12:07.932Z</published>
    <updated>2019-08-08T15:21:56.796Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天讲了LCA（最近公共祖先）和强连通分量。LCA有好多种算法，这里我只学会了倍增的写法，关于tarjan以后慢慢来吧。还有今天收获最大的就是基本上会用链式前向星存图啦。<a id="more"></a></p><h3 id="Nearest-Common-Ancestors"><a href="#Nearest-Common-Ancestors" class="headerlink" title="Nearest Common Ancestors"></a>Nearest Common Ancestors</h3><p>Description:<br>A rooted tree is a well-known data structure in computer science and engineering. An example is shown below:<br><img src="http://drew.todest.cn/cxz.png" alt><br>In the figure, each node is labeled with an integer from {1, 2,...,16}. Node 8 is the root of the tree. Node x is an ancestor of node y if node x is in the path between the root and node y. For example, node 4 is an ancestor of node 16. Node 10 is also an ancestor of node 16. As a matter of fact, nodes 8, 4, 10, and 16 are the ancestors of node 16. Remember that a node is an ancestor of itself. Nodes 8, 4, 6, and 7 are the ancestors of node 7. A node x is called a common ancestor of two different nodes y and z if node x is an ancestor of node y and an ancestor of node z. Thus, nodes 8 and 4 are the common ancestors of nodes 16 and 7. A node x is called the nearest common ancestor of nodes y and z if x is a common ancestor of y and z and nearest to y and z among their common ancestors. Hence, the nearest common ancestor of nodes 16 and 7 is node 4. Node 4 is nearer to nodes 16 and 7 than node 8 is.</p><p>For other examples, the nearest common ancestor of nodes 2 and 3 is node 10, the nearest common ancestor of nodes 6 and 13 is node 8, and the nearest common ancestor of nodes 4 and 12 is node 4. In the last example, if y is an ancestor of z, then the nearest common ancestor of y and z is y.</p><p>Write a program that finds the nearest common ancestor of two distinct nodes in a tree.</p><p>Input</p><blockquote><p>The input consists of T test cases. The number of test cases (T) is given in the first line of the input file. Each test case starts with a line containing an integer N , the number of nodes in a tree, 2&lt;=N&lt;=10,000. The nodes are labeled with integers 1, 2,..., N. Each of the next N -1 lines contains a pair of integers that represent an edge --the first integer is the parent node of the second integer. Note that a tree with N nodes has exactly N - 1 edges. The last line of each test case contains two distinct integers whose nearest common ancestor is to be computed.</p></blockquote><p>Output</p><blockquote><p>Print exactly one line for each test case. The line should contain the integer that is the nearest common ancestor.</p></blockquote><p>Sample Input</p><blockquote><p>2<br>16<br>1 14<br>8 5<br>10 16<br>5 9<br>4 6<br>8 4<br>4 10<br>1 13<br>6 15<br>10 11<br>6 7<br>10 2<br>16 3<br>8 1<br>16 12<br>16 7<br>5<br>2 3<br>3 4<br>3 1<br>1 5<br>3 5</p></blockquote><p>Sample Output</p><blockquote><p>4<br>3</p></blockquote><p>Problem solving:<br>这道题的意思就是给你一个图，让你求某两个点的最近公共祖先啦。</p><p>是个板子题，我用的是倍增法，所以有一点需要注意的就是，根节点的确定。这个不能随便选的，我们可以统计输入中第二个点的出现，如果没有在第二次出现过说明没有指向它的边，当成根节点处理即可。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">long long bit[30];</span><br><span class="line">const int xiaozhu = 52121;</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">bit[0]=1;</span><br><span class="line">for(int i=1;i&lt;=29;i++)bit[i]=bit[i-1]*2;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;int&gt; sijia[xiaozhu];</span><br><span class="line">int dep[xiaozhu],p[xiaozhu],f[xiaozhu][30],ai[xiaozhu];</span><br><span class="line">void dfs(int x,int p)</span><br><span class="line">&#123;</span><br><span class="line">dep[x]=dep[p]+1;</span><br><span class="line">f[x][0]=p;</span><br><span class="line">for(int i=1;i&lt;=29;i++)f[x][i]=f[f[x][i-1]][i-1];</span><br><span class="line">for(int i=0;i&lt;sijia[x].size();i++)</span><br><span class="line">&#123;</span><br><span class="line">if(sijia[x][i]!=p)dfs(sijia[x][i],x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int lca(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">if(dep[x]&lt;dep[y])swap(x,y);</span><br><span class="line">int dif=dep[x]-dep[y];</span><br><span class="line">for(int i=29;i&gt;=0;i--)</span><br><span class="line">&#123;</span><br><span class="line">if(dif&gt;=bit[i])</span><br><span class="line">&#123;</span><br><span class="line">x=f[x][i];</span><br><span class="line">dif-=bit[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(x==y)return x;</span><br><span class="line">for(int i=29;i&gt;=0;i--)</span><br><span class="line">&#123;</span><br><span class="line">if(dep[x]&gt;=bit[i]&amp;&amp;f[x][i]!=f[y][i])</span><br><span class="line">&#123;</span><br><span class="line">x=f[x][i];</span><br><span class="line">y=f[y][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return f[x][0];</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,m,u,v;</span><br><span class="line">init();</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">while(n--)</span><br><span class="line">&#123;</span><br><span class="line">memset(f,0,sizeof(f));</span><br><span class="line">memset(dep,0,sizeof(dep));</span><br><span class="line">memset(p,0,sizeof(p));</span><br><span class="line">memset(sijia,0,sizeof(sijia));</span><br><span class="line">memset(ai,0,sizeof(ai));</span><br><span class="line">scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line"></span><br><span class="line">for(int i=1;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;u,&amp;v);</span><br><span class="line">sijia[u].push_back(v);</span><br><span class="line">sijia[v].push_back(u);</span><br><span class="line">ai[v]=1;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(ai[i]==0)</span><br><span class="line">&#123;</span><br><span class="line">dfs(i,0);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;u,&amp;v);</span><br><span class="line">printf(&quot;%d\n&quot;,lca(u,v));</span><br><span class="line">//cout&lt;&lt;&quot;?&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Distance-Queries"><a href="#Distance-Queries" class="headerlink" title="Distance Queries"></a>Distance Queries</h3><p>Description:<br>Farmer John&#39;s cows refused to run in his marathon since he chose a path much too long for their leisurely lifestyle. He therefore wants to find a path of a more reasonable length. The input to this problem consists of the same input as in &quot;Navigation Nightmare&quot;,followed by a line containing a single integer K, followed by K &quot;distance queries&quot;. Each distance query is a line of input containing two integers, giving the numbers of two farms between which FJ is interested in computing distance (measured in the length of the roads along the path between the two farms). Please answer FJ&#39;s distance queries as quickly as possible!<br>Input</p><ul><li>Lines 1..1+M: Same format as &quot;Navigation Nightmare&quot;</li><li>Line 2+M: A single integer, K. 1 &lt;= K &lt;= 10,000</li><li>Lines 3+M..2+M+K: Each line corresponds to a distance query and contains the indices of two farms.</li></ul><p>Output</p><ul><li>Lines 1..K: For each distance query, output on a single line an integer giving the appropriate distance.</li></ul><p>Sample Input</p><blockquote><p>7 6<br>1 6 13 E<br>6 3 9 E<br>3 5 7 S<br>4 1 3 N<br>2 4 20 W<br>4 7 2 S<br>3<br>1 6<br>1 4<br>2 6</p></blockquote><p>Sample Output</p><blockquote><p>13<br>3<br>36</p></blockquote><p>Hint</p><blockquote><p>Farms 2 and 6 are 20+3+13=36 apart.</p></blockquote><p>Problem solving:<br>这个题的意思就是给你一个图，边的权值也都告诉你了。问你两个点到他们最大公共祖先的距离之和。</p><p>这个也是个板子题。但是我们在计算的过程中，要记录一下当前点到达根节点的距离。方便一会计算的时候使用。这是我是用了链式前向星，这样处理距离的话会比较方便。</p><p>另外需要注意的就是最后距离的计算是这样计算的，假设两个点事u,v，那么最后的距离是这样计算的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ans=dis[u]+dis[v]-2*dis[lca(u,v)]</span><br></pre></td></tr></table></figure></p><p>dis数组代表的是当前点到根节点的距离</p><p>这个应该还是很好理解的，u到根节点的距离和v到根节点的距离加上之后，他们的最大公共祖先到根节点的距离相当于加了两次，所以减去这个就是两个点到他们最大公共祖先的距离之和了。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int sijia=1e5;</span><br><span class="line">int f[sijia][30],dis[sijia],dep[sijia],head[sijia];</span><br><span class="line">int n,m,tot=0;</span><br><span class="line">long long bit[30];</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    bit[0]=1;</span><br><span class="line">    for(int i=1;i&lt;=29;i++)</span><br><span class="line">        bit[i]=2*bit[i-1];</span><br><span class="line">&#125;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int to,next,w;</span><br><span class="line">&#125;edge[sijia];</span><br><span class="line">void add(int u,int v,int w)</span><br><span class="line">&#123;</span><br><span class="line">    edge[tot].to=v;</span><br><span class="line">    edge[tot].next=head[u];</span><br><span class="line">    edge[tot].w=w;</span><br><span class="line">    head[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    f[x][0]=y;</span><br><span class="line">    for(int i=1;i&lt;=29;i++)</span><br><span class="line">        f[x][i]=f[f[x][i-1]][i-1];</span><br><span class="line">    for(int i=head[x];i!=-1;i=edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        if(edge[i].to!=y)</span><br><span class="line">        &#123;</span><br><span class="line">            dis[edge[i].to] = dis[x]+edge[i].w;//这个就是处理距离的过程，最后dis数组就是第i个点到根节点的距离</span><br><span class="line">            dep[edge[i].to] = dep[x] + 1;</span><br><span class="line">            dfs(edge[i].to,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int lca(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    int xx=x,yy=y;</span><br><span class="line">    if(dep[x]&lt;dep[y])   swap(x,y);</span><br><span class="line">    int dif=dep[x]-dep[y];</span><br><span class="line">    for(int i=29;i&gt;=0;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        if(dif&gt;=bit[i])</span><br><span class="line">        &#123;</span><br><span class="line">            x=f[x][i];</span><br><span class="line">            dif-=bit[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(x==y)    return dis[xx]+dis[yy]-2*dis[x];</span><br><span class="line">    for(int i=29;i&gt;=0;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        if(dep[x]&gt;=bit[i]&amp;&amp;f[x][i]!=f[y][i])</span><br><span class="line">        &#123;</span><br><span class="line">            x=f[x][i];</span><br><span class="line">            y=f[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dis[xx]+dis[yy]-2*dis[f[x][0]];//这就是那个计算公式</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while(scanf(&quot;%d %d&quot;,&amp;n,&amp;m)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        tot=0;</span><br><span class="line">        memset(f,0,sizeof(f));</span><br><span class="line">        memset(head,-1,sizeof(head));</span><br><span class="line">        memset(dis,0,sizeof(dis));</span><br><span class="line">        memset(dep,0,sizeof(dep));</span><br><span class="line">        init();</span><br><span class="line">        int u,v,w;</span><br><span class="line">        char s;</span><br><span class="line">        for(int i=0;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d %d %d %c&quot;,&amp;u,&amp;v,&amp;w,&amp;s);</span><br><span class="line">            add(u,v,w);</span><br><span class="line">            add(v,u,w);</span><br><span class="line">        &#125;</span><br><span class="line">        dep[0]=0;</span><br><span class="line">        dfs(1,0);</span><br><span class="line">        int k;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;k);</span><br><span class="line">        for(int i=0;i&lt;k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d %d&quot;,&amp;u,&amp;v);</span><br><span class="line">            printf(&quot;%d\n&quot;,lca(u,v));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Closest-Common-Ancestors"><a href="#Closest-Common-Ancestors" class="headerlink" title="Closest Common Ancestors"></a>Closest Common Ancestors</h3><p>Description:<br>Write a program that takes as input a rooted tree and a list of pairs of vertices. For each pair (u,v) the program determines the closest common ancestor of u and v in the tree. The closest common ancestor of two nodes u and v is the node w that is an ancestor of both u and v and has the greatest depth in the tree. A node can be its own ancestor (for example in Figure 1 the ancestors of node 2 are 2 and 5)</p><p>The data set starts with the tree description, in the form:</p><p>nr_of_vertices<br>vertex:(nr_of_successors) successor1 successor2 ... successorn<br>......</p><p>where vertices are represented as integers from 1 to n. The tree description is followed by a list of pairs of vertices, in the form:</p><p>nr_of_pairs<br>(u v) (x y) ...</p><p>The input contents several data sets (at least one).</p><p>Note that white-spaces (tabs, spaces and line breaks) can be used freely in the input.</p><p>For each common ancestor the program prints the ancestor and the number of pair for which it is an ancestor. The results are printed on the standard output on separate lines, in to the ascending order of the vertices, in the format: ancestor:times</p><p>For example, for the following tree:<br><img src="http://drew.todest.cn/cxz1.png" alt><br>the program input and output is:</p><p>Input</p><blockquote><p>5<br>5:(3) 1 4 2<br>1:(0)<br>4:(0)<br>2:(1) 3<br>3:(0)<br>6<br>(1,5) (1,4) (4,2)<br>(2,3)<br>(1,3) (4,3)</p></blockquote><p>Output</p><blockquote><p>2:1<br>5:5</p></blockquote><p>Problem solving:<br>这道题就是给你一个图，问你某两个点的最大公共祖先。</p><p>板子题，但是输入算是个小难点吧。可以直接用scanf的格式控制，美滋滋。</p><p>好久没用scanf的多组输入，TLE三次，我可真是个弟弟。<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">long long bit[30];</span><br><span class="line">const int xiaozhu = 52121;</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">bit[0]=1;</span><br><span class="line">for(int i=1;i&lt;=29;i++)bit[i]=bit[i-1]*2;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;int&gt; sijia[xiaozhu];</span><br><span class="line">int flag[xiaozhu],ans[xiaozhu],dep[xiaozhu],p[xiaozhu],f[xiaozhu][30];</span><br><span class="line">void dfs(int x,int p)</span><br><span class="line">&#123;</span><br><span class="line">dep[x]=dep[p]+1;</span><br><span class="line">f[x][0]=p;</span><br><span class="line">for(int i=1;i&lt;=29;i++)f[x][i]=f[f[x][i-1]][i-1];</span><br><span class="line">for(int i=0;i&lt;sijia[x].size();i++)</span><br><span class="line">&#123;</span><br><span class="line">if(sijia[x][i]!=p)dfs(sijia[x][i],x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int lca(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">if(dep[x]&lt;dep[y])swap(x,y);</span><br><span class="line">int dif=dep[x]-dep[y];</span><br><span class="line">for(int i=29;i&gt;=0;i--)</span><br><span class="line">&#123;</span><br><span class="line">if(dif&gt;=bit[i])</span><br><span class="line">&#123;</span><br><span class="line">x=f[x][i];</span><br><span class="line">dif-=bit[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(x==y)return x;</span><br><span class="line">for(int i=29;i&gt;=0;i--)</span><br><span class="line">&#123;</span><br><span class="line">if(dep[x]&gt;=bit[i]&amp;&amp;f[x][i]!=f[y][i])</span><br><span class="line">&#123;</span><br><span class="line">x=f[x][i];</span><br><span class="line">y=f[y][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return f[x][0];</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,a,b,c;</span><br><span class="line">    init();</span><br><span class="line">    while(scanf(&quot;%d&quot;,&amp;n)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        memset(flag,0,sizeof(flag));</span><br><span class="line">        memset(ans,0,sizeof(ans));</span><br><span class="line">        memset(p,0,sizeof(p));</span><br><span class="line">        memset(f,0,sizeof(f));</span><br><span class="line">        memset(sijia,0,sizeof(sijia));</span><br><span class="line">        for(int i=0;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d:(%d)&quot;,&amp;a,&amp;b);</span><br><span class="line">            while(b--)</span><br><span class="line">            &#123;</span><br><span class="line">                scanf(&quot;%d&quot;,&amp;c);</span><br><span class="line">                sijia[a].push_back(c);</span><br><span class="line">                sijia[c].push_back(a);</span><br><span class="line">                flag[c]=1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!flag[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dep[i]=0;</span><br><span class="line">                dfs(i,0);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int m,u,v;</span><br><span class="line">        char s;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">        for(int i=0;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot; (%d,%d)&quot;,&amp;u,&amp;v);</span><br><span class="line">            ans[lca(u,v)]++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(ans[i])  printf(&quot;%d:%d\n&quot;,i,ans[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="How-far-away-？"><a href="#How-far-away-？" class="headerlink" title="How far away ？"></a>How far away ？</h3><p>Description:<br>There are n houses in the village and some bidirectional roads connecting them. Every day peole always like to ask like this &quot;How far is it if I want to go from house A to house B&quot;? Usually it hard to answer. But luckily int this village the answer is always unique, since the roads are built in the way that there is a unique simple path(&quot;simple&quot; means you can&#39;t visit a place twice) between every two houses. Yout task is to answer all these curious people.<br>Input</p><blockquote><p>First line is a single integer T(T&lt;=10), indicating the number of test cases.<br>  For each test case,in the first line there are two numbers n(2&lt;=n&lt;=40000) and m (1&lt;=m&lt;=200),the number of houses and the number of queries. The following n-1 lines each consisting three numbers i,j,k, separated bu a single space, meaning that there is a road connecting house i and house j,with length k(0&lt;k&lt;=40000).The houses are labeled from 1 to n.<br>  Next m lines each has distinct integers i and j, you areato answer the distance between house i and house j.</p></blockquote><p>Output</p><blockquote><p>For each test case,output m lines. Each line represents the answer of the query. Output a bland line after each test case.</p></blockquote><p>Sample Input</p><blockquote><p>2<br>3 2<br>1 2 10<br>3 1 15<br>1 2<br>2 3<br>2 2<br>1 2 100<br>1 2<br>2 1</p></blockquote><p>Sample Output</p><blockquote><p>10<br>25<br>100<br>100</p></blockquote><p>Problem solving:<br>这道题跟B题很像，题意我也没搞懂，但是一看样例。就知道跟b一样。。。<br>就不多说了吧。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int sijia=1e5;</span><br><span class="line">int f[sijia][30],flag[sijia],dis[sijia],dep[sijia],head[sijia];</span><br><span class="line">int n,m,tot=0;</span><br><span class="line">long long bit[30];</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    bit[0]=1;</span><br><span class="line">    for(int i=1;i&lt;=29;i++)</span><br><span class="line">        bit[i]=2*bit[i-1];</span><br><span class="line">&#125;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int to,next,w;</span><br><span class="line">&#125;edge[sijia];</span><br><span class="line">void add(int u,int v,int w)</span><br><span class="line">&#123;</span><br><span class="line">    edge[tot].to=v;</span><br><span class="line">    edge[tot].next=head[u];</span><br><span class="line">    edge[tot].w=w;</span><br><span class="line">    head[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    f[x][0]=y;</span><br><span class="line">    for(int i=1;i&lt;=29;i++)</span><br><span class="line">        f[x][i]=f[f[x][i-1]][i-1];</span><br><span class="line">    for(int i=head[x];i!=-1;i=edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        if(edge[i].to!=y)</span><br><span class="line">        &#123;</span><br><span class="line">            dis[edge[i].to] = dis[x]+edge[i].w;</span><br><span class="line">            dep[edge[i].to] = dep[x] + 1;</span><br><span class="line">            dfs(edge[i].to,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int lca(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    int xx=x,yy=y;</span><br><span class="line">    if(dep[x]&lt;dep[y])   swap(x,y);</span><br><span class="line">    int dif=dep[x]-dep[y];</span><br><span class="line">    for(int i=29;i&gt;=0;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        if(dif&gt;=bit[i])</span><br><span class="line">        &#123;</span><br><span class="line">            x=f[x][i];</span><br><span class="line">            dif-=bit[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(x==y)    return dis[xx]&gt;dis[yy]?(dis[xx]-dis[yy]):(dis[yy]-dis[xx]);</span><br><span class="line">    for(int i=29;i&gt;=0;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        if(dep[x]&gt;=bit[i]&amp;&amp;f[x][i]!=f[y][i])</span><br><span class="line">        &#123;</span><br><span class="line">            x=f[x][i];</span><br><span class="line">            y=f[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dis[xx]+dis[yy]-2*dis[f[x][0]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    while(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        tot=0;</span><br><span class="line">        memset(f,0,sizeof(f));</span><br><span class="line">        memset(head,-1,sizeof(head));</span><br><span class="line">        memset(dis,0,sizeof(dis));</span><br><span class="line">        memset(dep,0,sizeof(dep));</span><br><span class="line">        init();</span><br><span class="line">        int u,v,w,mm,p;</span><br><span class="line">        scanf(&quot;%d %d&quot;,&amp;mm,&amp;p);</span><br><span class="line">        for(int i=1;i&lt;mm;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d %d %d&quot;,&amp;u,&amp;v,&amp;w);</span><br><span class="line">            add(u,v,w);</span><br><span class="line">            add(v,u,w);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dep[0]=0;</span><br><span class="line">        dfs(1,0);</span><br><span class="line">        for(int i=0;i&lt;p;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d %d&quot;,&amp;u,&amp;v);</span><br><span class="line">            printf(&quot;%d\n&quot;,lca(u,v));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Equivalent-Sets"><a href="#Equivalent-Sets" class="headerlink" title="Equivalent Sets"></a>Equivalent Sets</h3><p>Description:<br>To prove two sets A and B are equivalent, we can first prove A is a subset of B, and then prove B is a subset of A, so finally we got that these two sets are equivalent.<br>You are to prove N sets are equivalent, using the method above: in each step you can prove a set X is a subset of another set Y, and there are also some sets that are already proven to be subsets of some other sets.<br>Now you want to know the minimum steps needed to get the problem proved.<br>Input</p><blockquote><p>The input file contains multiple test cases, in each case, the first line contains two integers N &lt;= 20000 and M &lt;= 50000.<br>Next M lines, each line contains two integers X, Y, means set X in a subset of set Y.</p></blockquote><p>Output</p><blockquote><p>For each case, output a single integer: the minimum steps needed.</p></blockquote><p>Sample Input</p><blockquote><p>4 0<br>3 2<br>1 2<br>1 3</p></blockquote><p>Sample Output</p><blockquote><p>4<br>2</p></blockquote><p>Problem solving:</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天讲了LCA（最近公共祖先）和强连通分量。LCA有好多种算法，这里我只学会了倍增的写法，关于tarjan以后慢慢来吧。还有今天收获最大的就是基本上会用链式前向星存图啦。
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="Algorithm" scheme="https://cndrew.cn/blog/tags/Algorithm/"/>
    
      <category term="c/c++" scheme="https://cndrew.cn/blog/tags/c-c/"/>
    
      <category term="LCA" scheme="https://cndrew.cn/blog/tags/LCA/"/>
    
      <category term="强连通分量" scheme="https://cndrew.cn/blog/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>Win10 or Win7 下下载并配置gcc/g++编译环境</title>
    <link href="https://cndrew.cn/blog/2019/08/07/super/"/>
    <id>https://cndrew.cn/blog/2019/08/07/super/</id>
    <published>2019-08-07T14:05:38.896Z</published>
    <updated>2019-08-07T14:22:02.018Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>近些日子在机房配置过不少次atom(一种文本编辑器)为c++的编译器。也是有很多小伙伴肯定烦于不会配置而放弃了极其漂亮的文本编辑器。今天就给大家详细的介绍一下在win10和win7的环境下如何配置gcc/g++的编译环境。<a id="more"></a></p><p><center>前排提示<br>————————————————————————————————<br>本文更于2019.8.7，如果某些地方与最新的某些东西细节上有出入，请自行圆润的解决。若无法解决，请联系我。</center></p><h3 id="安装gcc-g"><a href="#安装gcc-g" class="headerlink" title="安装gcc/g++"></a>安装gcc/g++</h3><p>无论是win7还是win10，在前面都是一样的<br>首先你需要去官网下载<code>mingw-get-setup.exe</code><br>点此前去下载: <a href="https://osdn.net/projects/mingw/releases/" target="_blank" rel="noopener">MinGW-download</a><br>如图，点击这个下载即可。<br><img src="http://drew.todest.cn/VJWYNHL47%25SQZ%29C_BC0X%25%606.png" alt><br>下载之后直接打开会出现这样的框框<br><img src="http://drew.todest.cn/05%7DL~@%28G$_%296FGD9N4GR3WX.png" alt><br>接下来这一步就很简单，无脑install或者无脑next就行啦。<br>但是这一步必须得说一下<br><img src="http://drew.todest.cn/UJF%60YGEW~4%608PF%7BL%281%5BUN1R.png" alt><br>这个安装路径如果要修改的话，一定要记住你修改到哪里了，路径一定要清楚。如果是真小白，推荐不修改直接无脑next。</p><p>然后就是一波等待，等到进度条跑完的时候，点continue。<br><img src="http://drew.todest.cn/lm.png" alt></p><p>然后就会自己弹出来<code>MinGW Installation Manager</code>的窗口。<br>如果你只是为了配置gcc/g++的编译环境，选上<code>mingw32-gcc-g++-bin</code>,或者右键选择&#39;mark for installation&#39;.<br>这里因为我已经安装过了，所以显示的是已安装的样子。<br><img src="http://drew.todest.cn/xz.png" alt></p><p>选择好之后，点击左上角的Installation，然后选择apply changes.<br><img src="http://drew.todest.cn/ins.png" alt></p><p>这一步直接apply即可。<br><img src="http://drew.todest.cn/AN4X6$%29YPFF4%5DDM9%7DHC74WF.png" alt></p><p>然后就又是等待进度条啦,等他全部安装完，这一步就结束了。</p><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>这一步很重要。确实也有很多人会卡在这里</p><h4 id="Win7版本"><a href="#Win7版本" class="headerlink" title="Win7版本"></a>Win7版本</h4><p>右键我的电脑点击属性，然后找到左上角的高级系统设置，点开之后点击右下角的环境变量。如图：<br><img src="http://drew.todest.cn/hj1.png" alt><br><img src="http://drew.todest.cn/hj2.png" alt><br><img src="http://drew.todest.cn/hj3.png" alt><br>在环境变量的下面的系统变量里面找到&#39;path&#39;,点击编辑<br><img src="http://drew.todest.cn/hj4.png" alt><br>然后会弹出这样的框框<br><img src="http://drew.todest.cn/hj5.png" alt><br>如果你之前没有配置过的话，后面是不会有<code>C:\MinGW\bin</code>的，你要做的就是把这个加上去。<br><code>C:\MinGW\bin</code>把这个加到最后面，如果你是换了安装路径的话这里就填上你的路径，路径就是你的MinGW文件夹下的bin文件夹。这里还有一点需要注意的是，Win7的系统变量里面是以<code>;</code>分隔得，所以如果你在加之前发现最后面没有分号，一定要加上个自己分号，再加上自己的路径。注意：分号很重要<font color="red">!!!</font><br>加好之后无脑确认就好了。<br>然后出来可以去cmd检测一下有没有配置成功。<br>快捷键<code>Win+r</code>打开运行框框输入<code>cmd</code><br>然后在cmd中输入<code>gcc -v</code>，如果成功的出现了版本信息，就说明这一步你已经成功了。<br><img src="http://drew.todest.cn/hj6.png" alt><br><img src="http://drew.todest.cn/hj7.png" alt><br><img src="http://drew.todest.cn/hj8.png" alt></p><h4 id="Win10-版本"><a href="#Win10-版本" class="headerlink" title="Win10 版本"></a>Win10 版本</h4><p>win10的话其实跟win7差不多。唯一不一样的就是添加环境变量的时候比win7方便很多。<br>可以直接添加而不用加分号什么的了。<br>如图直接点击添加即可。<br><img src="http://drew.todest.cn//20190807221820.png" alt><br>其余的就都一样啦。</p><p>如果失败了，请仔细检查以下几点</p><ol><li>MinGW/bin的文件夹路径是否正确</li><li>添加环境变量的地方分号有没有加(Win7的情况下)<br>如果这几步都是正确的却还是配置失败，欢迎联系我。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果上面两步你都已经配置好了，那么恭喜你，你已经可以使用绚丽的文本编辑器作为你写c/c++的IDE了。只需要下载各种编辑器对应的插件然后进行配置就行啦。新世界等着你。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近些日子在机房配置过不少次atom(一种文本编辑器)为c++的编译器。也是有很多小伙伴肯定烦于不会配置而放弃了极其漂亮的文本编辑器。今天就给大家详细的介绍一下在win10和win7的环境下如何配置gcc/g++的编译环境。
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="atom" scheme="https://cndrew.cn/blog/tags/atom/"/>
    
      <category term="MinGW" scheme="https://cndrew.cn/blog/tags/MinGW/"/>
    
      <category term="gcc" scheme="https://cndrew.cn/blog/tags/gcc/"/>
    
      <category term="g++" scheme="https://cndrew.cn/blog/tags/g/"/>
    
  </entry>
  
  <entry>
    <title>HPU Summer Day22(河南理工大学暑期第二十二天)</title>
    <link href="https://cndrew.cn/blog/2019/08/07/d22/"/>
    <id>https://cndrew.cn/blog/2019/08/07/d22/</id>
    <published>2019-08-07T14:02:23.512Z</published>
    <updated>2019-08-07T14:02:38.111Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天讲了拓扑排序，相比较而言还是挺简单的，我觉得这也是BFS的应用。不得不说，BFS和DFS是真的太重要了，在图论里面。<a id="more"></a></p><h3 id="Genealogical-tree"><a href="#Genealogical-tree" class="headerlink" title="Genealogical tree"></a>Genealogical tree</h3><p>Description:<br>The system of Martians&#39; blood relations is confusing enough. Actually, Martians bud when they want and where they want. They gather together in different groups, so that a Martian can have one parent as well as ten. Nobody will be surprised by a hundred of children. Martians have got used to this and their style of life seems to them natural.<br>And in the Planetary Council the confusing genealogical system leads to some embarrassment. There meet the worthiest of Martians, and therefore in order to offend nobody in all of the discussions it is used first to give the floor to the old Martians, than to the younger ones and only than to the most young childless assessors. However, the maintenance of this order really is not a trivial task. Not always Martian knows all of his parents (and there&#39;s nothing to tell about his grandparents!). But if by a mistake first speak a grandson and only than his young appearing great-grandfather, this is a real scandal.<br>Your task is to write a program, which would define once and for all, an order that would guarantee that every member of the Council takes the floor earlier than each of his descendants.<br>Input</p><blockquote><p>The first line of the standard input contains an only number N, 1 &lt;= N &lt;= 100 — a number of members of the Martian Planetary Council. According to the centuries-old tradition members of the Council are enumerated with the natural numbers from 1 up to N. Further, there are exactly N lines, moreover, the I-th line contains a list of I-th member&#39;s children. The list of children is a sequence of serial numbers of children in a arbitrary order separated by spaces. The list of children may be empty. The list (even if it is empty) ends with 0.</p></blockquote><p>Output</p><blockquote><p>The standard output should contain in its only line a sequence of speakers&#39; numbers, separated by spaces. If several sequences satisfy the conditions of the problem, you are to write to the standard output any of them. At least one such sequence always exists.</p></blockquote><p>Sample Input</p><blockquote><p>5<br>0<br>4 5 1 0<br>1 0<br>5 3 0<br>3 0</p></blockquote><p>Sample Output</p><blockquote><p>2 4 5 3 1</p></blockquote><p>Problem solving:<br>题意就是给你n个人，然后分别告诉你n个人后面有几个人，让你输出一种排列方式。</p><p>一开始没看懂题意WA了一次。</p><p>这道题就是拓扑排序的一道板子题。直接写就行了。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int sijia[105];</span><br><span class="line">vector&lt;int&gt; xiaozhu[105];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m,nn,mid;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    nn=n;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        while(cin&gt;&gt;m&amp;&amp;m)</span><br><span class="line">        &#123;</span><br><span class="line">                sijia[m]++;</span><br><span class="line">                xiaozhu[i].push_back(m);</span><br><span class="line">                continue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;int&gt; q;</span><br><span class="line">    for(int i=1;i&lt;=nn;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(sijia[i]==0)</span><br><span class="line">        &#123;</span><br><span class="line">             q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        int qixi=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        cout&lt;&lt;qixi&lt;&lt;&quot; &quot;;</span><br><span class="line">        for(int i=0;i&lt;xiaozhu[qixi].size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sijia[xiaozhu[qixi][i]]--;</span><br><span class="line">            if(sijia[xiaozhu[qixi][i]]==0)</span><br><span class="line">                q.push(xiaozhu[qixi][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Window-Pains"><a href="#Window-Pains" class="headerlink" title="Window Pains"></a>Window Pains</h3><p>Description:<br>Boudreaux likes to multitask, especially when it comes to using his computer. Never satisfied with just running one application at a time, he usually runs nine applications, each in its own window. Due to limited screen real estate, he overlaps these windows and brings whatever window he currently needs to work with to the foreground. If his screen were a 4 x 4 grid of squares, each of Boudreaux&#39;s windows would be represented by the following 2 x 2 windows:<br><img src="http://drew.todest.cn/xiao%20%282%29.png" alt><br>When Boudreaux brings a window to the foreground, all of its squares come to the top, overlapping any squares it shares with other windows. For example, if window 1 and then window 2 were brought to the foreground, the resulting representation would be:<br><img src="http://drew.todest.cn/xiao%20%281%29.png" alt><br>Unfortunately, Boudreaux&#39;s computer is very unreliable and crashes often. He could easily tell if a crash occurred by looking at the windows and seeing a graphical representation that should not occur if windows were being brought to the foreground correctly. And this is where you come in . . .<br>Input</p><blockquote><p>Input to this problem will consist of a (non-empty) series of up to 100 data sets. Each data set will be formatted according to the following description, and there will be no blank lines separating data sets.<br>A single data set has 3 components:<br>Start line - A single line:<br>START<br>Screen Shot - Four lines that represent the current graphical representation of the windows on Boudreaux&#39;s screen. Each position in this 4 x 4 matrix will represent the current piece of window showing in each square. To make input easier, the list of numbers on each line will be delimited by a single space.<br>End line - A single line:<br>END<br>After the last data set, there will be a single line:<br>ENDOFINPUT<br>Note that each piece of visible window will appear only in screen areas where the window could appear when brought to the front. For instance, a 1 can only appear in the top left quadrant.</p></blockquote><p>Output</p><blockquote><p>For each data set, there will be exactly one line of output. If there exists a sequence of bringing windows to the foreground that would result in the graphical representation of the windows on Boudreaux&#39;s screen, the output will be a single line with the statement:<br>THESE WINDOWS ARE CLEAN<br>Otherwise, the output will be a single line with the statement:<br>THESE WINDOWS ARE BROKEN</p></blockquote><p>Sample Input</p><blockquote><p>START<br>1 2 3 3<br>4 5 6 6<br>7 8 9 9<br>7 8 9 9<br>END<br>START<br>1 1 3 3<br>4 1 3 3<br>7 7 9 9<br>7 7 9 9<br>END<br>ENDOFINPUT</p></blockquote><p>Sample Output</p><blockquote><p>THESE WINDOWS ARE CLEAN<br>THESE WINDOWS ARE BROKEN</p></blockquote><p>Problem solving:<br>这道题的题意有点恶心。而且也不太好想+好写。</p><p>这道题也是要用拓扑排序做的。反正我是绝对想不到的，先预处理，把4*4的矩阵初始化成这样的<br><img src="http://drew.todest.cn/B1.png" alt></p><p>这个我还是放大佬链接吧，自认为莫得能力讲清楚。。。<br>点这里进行传送：<a href="https://blog.csdn.net/wang_123_zy/article/details/81391510" target="_blank" rel="noopener">某学姐</a></p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int ma[10][10],sijia[10];</span><br><span class="line">int dr[]=&#123;0,1,0,1&#125;,dc[]=&#123;0,0,1,1&#125;;</span><br><span class="line">vector&lt;int&gt; ve[10][10];</span><br><span class="line">bool solve()</span><br><span class="line">&#123;</span><br><span class="line">    queue&lt;int&gt; q;</span><br><span class="line">    for(int i=0;i&lt;9;i++)</span><br><span class="line">        if(sijia[i]==0) q.push(i);</span><br><span class="line">    int sum=0;</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        int u=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        for(int v=0;v&lt;9;v++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(ma[u][v])</span><br><span class="line">            &#123;</span><br><span class="line">                ma[u][v]=0;</span><br><span class="line">                sijia[v]--;</span><br><span class="line">                if(sijia[v]==0)   q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sum++;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum==9;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i&lt;9;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int r=i/3,c=i%3;</span><br><span class="line">        for(int j=0;j&lt;4;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            int nr=r+dr[j],nc=c+dc[j];</span><br><span class="line">            ve[nr][nc].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    string s;</span><br><span class="line">    while(cin&gt;&gt;s&amp;&amp;s[0]!=&apos;E&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        memset(ma,0,sizeof(ma));</span><br><span class="line">        memset(sijia,0,sizeof(sijia));</span><br><span class="line">        for(int i=0;i&lt;4;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j=0;j&lt;4;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                int v;</span><br><span class="line">                cin&gt;&gt;v;</span><br><span class="line">                v--;</span><br><span class="line">                for(int k=0;k&lt;ve[i][j].size();k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    if(ve[i][j][k]!=v)</span><br><span class="line">                    &#123;</span><br><span class="line">                        int x=ve[i][j][k];</span><br><span class="line">                        if(ma[x][v]==0)</span><br><span class="line">                        &#123;</span><br><span class="line">                            sijia[v]++;</span><br><span class="line">                            ma[x][v]=1;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(solve()) puts(&quot;THESE WINDOWS ARE CLEAN&quot;);</span><br><span class="line">        else    puts(&quot;THESE WINDOWS ARE BROKEN&quot;);</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="确定比赛名次"><a href="#确定比赛名次" class="headerlink" title="确定比赛名次"></a>确定比赛名次</h3><p>Description:</p><blockquote><p>有N个比赛队（1&lt;=N&lt;=500），编号依次为1，2，3，。。。。，N进行比赛，比赛结束后，裁判委员会要将所有参赛队伍从前往后依次排名，但现在裁判委员会不能直接获得每个队的比赛成绩，只知道每场比赛的结果，即P1赢P2，用P1，P2表示，排名时P1在P2之前。现在请你编程序确定排名。</p></blockquote><p>Input</p><blockquote><p>输入有若干组，每组中的第一行为二个数N（1&lt;=N&lt;=500），M；其中N表示队伍的个数，M表示接着有M行的输入数据。接下来的M行数据中，每行也有两个整数P1，P2表示即P1队赢了P2队。</p></blockquote><p>Output</p><blockquote><p>给出一个符合要求的排名。输出时队伍号之间有空格，最后一名后面没有空格。<br>其他说明：符合条件的排名可能不是唯一的，此时要求输出时编号小的队伍在前；输入数据保证是正确的，即输入数据确保一定能有一个符合要求的排名。</p></blockquote><p>Sample Input</p><blockquote><p>4 3<br>1 2<br>2 3<br>4 3</p></blockquote><p>Sample Output</p><blockquote><p>1 2 4 3</p></blockquote><p>Problem solving:<br>给出n个队伍以及队伍的胜负关系，让你输出他们的排名。</p><p>也是一个简单的拓扑排序的板子题，注意以下输出，最后一个数后面没有空格，就行了。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int sijiaxiaozhu=521;</span><br><span class="line">int qixikuaile[sijiaxiaozhu];</span><br><span class="line">vector&lt;int&gt; yongyuan[sijiaxiaozhu];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int n,m,x,y;</span><br><span class="line">  while(cin&gt;&gt;n&gt;&gt;m)</span><br><span class="line">  &#123;</span><br><span class="line">    memset(qixikuaile,0,sizeof(qixikuaile));</span><br><span class="line">    for(int i=0;i&lt;=n;i++) yongyuan[i].clear();</span><br><span class="line">    for(int i=0;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">      cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">      qixikuaile[y]++;</span><br><span class="line">      yongyuan[x].push_back(y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q ;</span><br><span class="line">    int flag=1;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">      if(qixikuaile[i]==0)  q.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">      int mid=q.top();</span><br><span class="line">      q.pop();</span><br><span class="line">      if(flag)</span><br><span class="line">      &#123;</span><br><span class="line">        cout&lt;&lt;mid;</span><br><span class="line">        flag=0;</span><br><span class="line">      &#125;</span><br><span class="line">      else  cout&lt;&lt;&quot; &quot;&lt;&lt;mid;</span><br><span class="line">      for(int i=0;i&lt;yongyuan[mid].size();i++)</span><br><span class="line">      &#123;</span><br><span class="line">        qixikuaile[yongyuan[mid][i]]--;</span><br><span class="line">        if(qixikuaile[yongyuan[mid][i]]==0) q.push(yongyuan[mid][i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="产生冠军"><a href="#产生冠军" class="headerlink" title="产生冠军"></a>产生冠军</h3><p>Description:<br>有一群人，打乒乓球比赛，两两捉对撕杀，每两个人之间最多打一场比赛。<br>球赛的规则如下：<br>如果A打败了B，B又打败了C，而A与C之间没有进行过比赛，那么就认定，A一定能打败C。<br>如果A打败了B，B又打败了C，而且，C又打败了A，那么A、B、C三者都不可能成为冠军。<br>根据这个规则，无需循环较量，或许就能确定冠军。你的任务就是面对一群比赛选手，在经过了若干场撕杀之后，确定是否已经实际上产生了冠军。<br>Input</p><blockquote><p>输入含有一些选手群，每群选手都以一个整数n(n&lt;1000)开头，后跟n对选手的比赛结果，比赛结果以一对选手名字（中间隔一空格）表示，前者战胜后者。如果n为0，则表示输入结束。</p></blockquote><p>Output</p><blockquote><p>对于每个选手群，若你判断出产生了冠军，则在一行中输出“Yes”，否则在一行中输出“No”。</p></blockquote><p>Sample Input</p><blockquote><p>3<br>Alice Bob<br>Smith John<br>Alice Smith<br>5<br>a c<br>c d<br>d e<br>b e<br>a d<br>0</p></blockquote><p>Sample Output</p><blockquote><p>Yes<br>No</p></blockquote><p>Problem solving:<br>这道题跟上一题很像。也是给了你胜负关系，问你能不能确定冠军。但是胜负关系是通过字符串给出的。</p><p>想一下这就是可以用拓扑排序写，但是胜负关系是以字符串给出的，如果直接套我们的板子会发现一个很尴尬的问题，存图的时候字符串不可以做下标。但是这个时候可以用map给每个字符串赋一个值，然后套板子。讲道理，这个应该是可以实现的(虽然我没成功。</p><p>然后想一下，这道题可以这样做。确定冠军的话，就是有一个人一场都没输过。所以我们只需要比较出现的总人数以及输过的总人数的关系即可。如果差一个就说明有一个人一场都没输过。这就能确定冠军了。反之就不能。这样的话一个set就能解决了。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    string x,y;</span><br><span class="line">    while(cin&gt;&gt;n&amp;&amp;n)</span><br><span class="line">    &#123;</span><br><span class="line">        set&lt;string&gt; sijia;</span><br><span class="line">        set&lt;string&gt; xiaozhu;</span><br><span class="line">        for(int i=0;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            sijia.insert(x),sijia.insert(y);</span><br><span class="line">            xiaozhu.insert(y);</span><br><span class="line">        &#125;</span><br><span class="line">            if(sijia.size()-xiaozhu.size()==1)  puts(&quot;Yes&quot;);</span><br><span class="line">            else    puts(&quot;No&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Legal-or-not"><a href="#Legal-or-not" class="headerlink" title="Legal or not"></a>Legal or not</h3><p>Description:<br>ACM-DIY is a large QQ group where many excellent acmers get together. It is so harmonious that just like a big family. Every day,many &quot;holy cows&quot; like HH, hh, AC, ZT, lcc, BF, Qinz and so on chat on-line to exchange their ideas. When someone has questions, many warm-hearted cows like Lost will come to help. Then the one being helped will call Lost &quot;master&quot;, and Lost will have a nice &quot;prentice&quot;. By and by, there are many pairs of &quot;master and prentice&quot;. But then problem occurs: there are too many masters and too many prentices, how can we know whether it is legal or not?</p><p>We all know a master can have many prentices and a prentice may have a lot of masters too, it&#39;s legal. Nevertheless，some cows are not so honest, they hold illegal relationship. Take HH and 3xian for instant, HH is 3xian&#39;s master and, at the same time, 3xian is HH&#39;s master,which is quite illegal! To avoid this,please help us to judge whether their relationship is legal or not.</p><p>Please note that the &quot;master and prentice&quot; relation is transitive. It means that if A is B&#39;s master ans B is C&#39;s master, then A is C&#39;s master.<br>Input</p><blockquote><p>The input consists of several test cases. For each case, the first line contains two integers, N (members to be tested) and M (relationships to be tested)(2 &lt;= N, M &lt;= 100). Then M lines follow, each contains a pair of (x, y) which means x is y&#39;s master and y is x&#39;s prentice. The input is terminated by N = 0.<br>TO MAKE IT SIMPLE, we give every one a number (0, 1, 2,..., N-1). We use their numbers instead of their names.</p></blockquote><p>Output</p><blockquote><p>For each test case, print in one line the judgement of the messy relationship.<br>If it is legal, output &quot;YES&quot;, otherwise &quot;NO&quot;.</p></blockquote><p>Sample Input</p><blockquote><p>3 2<br>0 1<br>1 2<br>2 2<br>0 1<br>1 0<br>0 0</p></blockquote><p>Sample Output</p><blockquote><p>YES<br>NO</p></blockquote><p>Problem solving:<br>题意就是告诉你n个关系，问你会不会产生矛盾。</p><p>一道拓扑排序的板子题，判断是否成环就行。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int sijia[521];</span><br><span class="line">vector&lt;int&gt; xiaozhu[521];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m,a,b;</span><br><span class="line">    while(cin&gt;&gt;n&gt;&gt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        memset(sijia,0,sizeof(sijia));</span><br><span class="line">        for(int i=0;i&lt;=n;i++  )    xiaozhu[i].clear();</span><br><span class="line">        if(n==0&amp;&amp;m==0)  break;</span><br><span class="line">        for(int i=0;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">            sijia[b]++;</span><br><span class="line">            xiaozhu[a].push_back(b);</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;int&gt; q;</span><br><span class="line">        for(int i=0;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(sijia[i]==0)</span><br><span class="line">            q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            int mid=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            n--;</span><br><span class="line">            for(int i=0;i&lt;xiaozhu[mid].size();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                sijia[xiaozhu[mid][i]]--;</span><br><span class="line">                if(sijia[xiaozhu[mid][i]]==0)</span><br><span class="line">                    q.push(xiaozhu[mid][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(n)   puts(&quot;NO&quot;);//如果n不为0，说明成环</span><br><span class="line">        else    puts(&quot;YES&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Reward"><a href="#Reward" class="headerlink" title="Reward"></a>Reward</h3><p>Description:<br>Dandelion&#39;s uncle is a boss of a factory. As the spring festival is coming , he wants to distribute rewards to his workers. Now he has a trouble about how to distribute the rewards.<br>The workers will compare their rewards ,and some one may have demands of the distributing of rewards ,just like a&#39;s reward should more than b&#39;s.Dandelion&#39;s unclue wants to fulfill all the demands, of course ,he wants to use the least money.Every work&#39;s reward will be at least 888 , because it&#39;s a lucky number.<br>Input</p><blockquote><p>One line with two integers n and m ,stands for the number of works and the number of demands .(n&lt;=10000,m&lt;=20000)<br>then m lines ,each line contains two integers a and b ,stands for a&#39;s reward should be more than b&#39;s.</p></blockquote><p>Output</p><blockquote><p>For every case ,print the least money dandelion &#39;s uncle needs to distribute .If it&#39;s impossible to fulfill all the works&#39; demands ,print -1.</p></blockquote><p>Sample Input</p><blockquote><p>2 1<br>1 2<br>2 2<br>1 2<br>2 1</p></blockquote><p>Sample Output</p><blockquote><p>1777<br>-1</p></blockquote><p>Problem solving:<br>这道题还是很有意思的，告诉你每个人的最低工资是888，然后给你大小关系，告诉你大小关系大于后者的工资也得比后者的多，问你老板做少需要支付多少工资。</p><p>虽然也是一道拓扑排序的板子题。但是中间的一些处理还是很难搞得。<br>我们把初始没经过处理的时候的入度为0的顶点的工资都设为888，然后在拓扑排序的过程中，送入队列的点的工资比他前一个加1就行，因为要求的是最少。<br>最后全布累加在一起，输出即可。</p><p>这道题还有一个坑点就是。存图的时候跟输出是反着来的。这个坑到我了。</p><p>注意还有输出-1的情况，就是出现了环的时候。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define maxn 10000</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">vector&lt;int&gt;t[10005];</span><br><span class="line">int in[10005],sum[10005],cnt,u,v,ans;</span><br><span class="line">void Init()   </span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i&lt;maxn;i++)</span><br><span class="line">      t[i].clear();</span><br><span class="line">    while(!q.empty())</span><br><span class="line">      q.pop();</span><br><span class="line">    memset(in,0,sizeof(in));</span><br><span class="line">    ans=0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    while(cin&gt;&gt;n&gt;&gt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        Init();</span><br><span class="line">        for(int i=0;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">            u--;v--;</span><br><span class="line">            in[u]++;</span><br><span class="line">            t[v].push_back(u);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!in[i])</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(i);</span><br><span class="line">                sum[i]=888;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt=0;     </span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;    </span><br><span class="line">            int p=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            for(int i=0;i&lt;t[p].size();i++)   </span><br><span class="line">            &#123;</span><br><span class="line">                in[t[p][i]]--;    </span><br><span class="line">                if(in[t[p][i]]==0)     </span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(t[p][i]);     </span><br><span class="line">                    sum[t[p][i]]=sum[p]+1;    //对工资的处理</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;n;i++)</span><br><span class="line">          ans+=sum[i];</span><br><span class="line">        if(cnt!=n)</span><br><span class="line">          ans=-1;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Ordering-Tasks"><a href="#Ordering-Tasks" class="headerlink" title="Ordering Tasks"></a>Ordering Tasks</h3><p>PDF题面:<a href="https://vj.ti12z.cn/10b4efc19562fa67c26851fd2b184af3?v=1565051545" target="_blank" rel="noopener">七夕快乐</a><br>Description:<br>John has n tasks to do. Unfortunately, the tasks are not independent and the execution of one task is<br>only possible if other tasks have already been executed.<br>Input</p><blockquote><p>The input will consist of several instances of the problem. Each instance begins with a line containing<br>two integers, 1 ≤ n ≤ 100 and m. n is the number of tasks (numbered from 1 to n) and m is the<br>number of direct precedence relations between tasks. After this, there will be m lines with two integers<br>i and j, representing the fact that task i must be executed before task j.<br>An instance with n = m = 0 will finish the input.</p></blockquote><p>Output</p><blockquote><p>For each instance, print a line with n integers representing the tasks in a possible order of execution.</p></blockquote><p>Sample Input</p><blockquote><p>5 4<br>1 2<br>2 3<br>1 3<br>1 5<br>0 0</p></blockquote><p>Sample Output</p><blockquote><p>1 4 2 5 3</p></blockquote><p>Problem solving:<br>题意就是有n个工作，但是有的工作需要在另一个工作完成的基础上才能完成，问你一个合理的顺序。</p><p>拓扑排序板子题啦，输出就行。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int sijia[105];</span><br><span class="line">vector&lt;int&gt; xiaozhu[105];</span><br><span class="line">int n,m,x,y;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while(cin&gt;&gt;n&gt;&gt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        memset(sijia,0,sizeof(sijia));</span><br><span class="line">        for(int i=0;i&lt;=n;i++)   xiaozhu[i].clear();</span><br><span class="line">        if(n==0&amp;&amp;m==0)  break;</span><br><span class="line">        for(int i=0;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            sijia[y]++;</span><br><span class="line">            xiaozhu[x].push_back(y);</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;int&gt; qixi;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(sijia[i]==0) qixi.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        while(!qixi.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            int kuaile=qixi.front();</span><br><span class="line">            qixi.pop();</span><br><span class="line">            cout&lt;&lt;kuaile&lt;&lt;&quot; &quot;;</span><br><span class="line">            for(int i=0;i&lt;xiaozhu[kuaile].size();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                sijia[xiaozhu[kuaile][i]]--;</span><br><span class="line">                if(sijia[xiaozhu[kuaile][i]]==0)</span><br><span class="line">                    qixi.push(xiaozhu[kuaile][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Rank-of-Tetris"><a href="#Rank-of-Tetris" class="headerlink" title="Rank of Tetris"></a>Rank of Tetris</h3><p>Description:<br>自从Lele开发了Rating系统，他的Tetris事业更是如虎添翼，不久他遍把这个游戏推向了全球。</p><p>为了更好的符合那些爱好者的喜好，Lele又想了一个新点子：他将制作一个全球Tetris高手排行榜，定时更新，名堂要比福布斯富豪榜还响。关于如何排名，这个不用说都知道是根据Rating从高到低来排，如果两个人具有相同的Rating，那就按这几个人的RP从高到低来排。</p><p>终于，Lele要开始行动了，对N个人进行排名。为了方便起见，每个人都已经被编号，分别从0到N-1,并且编号越大，RP就越高。<br>同时Lele从狗仔队里取得一些（M个）关于Rating的信息。这些信息可能有三种情况，分别是&quot;A &gt; B&quot;,&quot;A = B&quot;,&quot;A &lt; B&quot;，分别表示A的Rating高于B,等于B,小于B。</p><p>现在Lele并不是让你来帮他制作这个高手榜，他只是想知道，根据这些信息是否能够确定出这个高手榜，是的话就输出&quot;OK&quot;。否则就请你判断出错的原因，到底是因为信息不完全（输出&quot;UNCERTAIN&quot;），还是因为这些信息中包含冲突（输出&quot;CONFLICT&quot;）。<br>注意，如果信息中同时包含冲突且信息不完全，就输出&quot;CONFLICT&quot;。<br>Input</p><blockquote><p>本题目包含多组测试，请处理到文件结束。<br>每组测试第一行包含两个整数N,M(0&lt;=N&lt;=10000,0&lt;=M&lt;=20000),分别表示要排名的人数以及得到的关系数。<br>接下来有M行，分别表示这些关系</p></blockquote><p>Output</p><blockquote><p>对于每组测试，在一行里按题目要求输出</p></blockquote><p>Sample Input</p><blockquote><p>3 3<br>0 &gt; 1<br>1 &lt; 2<br>0 &gt; 2<br>4 4<br>1 = 2<br>1 &gt; 3<br>2 &gt; 0<br>0 &gt; 1<br>3 3<br>1 &gt; 0<br>1 &gt; 2<br>2 &lt; 1</p></blockquote><p>Sample Output</p><blockquote><p>OK<br>CONFLICT<br>UNCERTAIN</p></blockquote><p>Problem solving:<br>题意就是告诉你n个人的rating大小关系。问你给的信息能否确定一个高手榜。如果信息不完全就输出<code>UNCERTAIN</code>，如果有冲突了就输出<code>CONFLICT</code>,如果可以就输出<code>OK</code>。并且如果rating相同的话，比较两个人的RP值，RP值的大小就是编号的大小。</p><p>如果只有大小关系的话，就是一个简单板子题，但是它这里还存在着一种等于的关系。这就很麻烦了。我们需要用到并查集来处理。只要出现等于号，就把那两个人join(合并函数)起来，放在一起处理。然后在存图的过程中如果是等于的关系直接跳过就行，否则就先找一下两个点的父节点，用父节点存图，这样就完美的解决了出现等号的情况——这点可能不是很清楚，自己在脑子里模拟一下想一下就可以了。接下来就是拓扑排序了。</p><p>再说一下三种输出。OK的话当然就是可以构建出来高手榜的时候输出，但是CONFLICT和UNCERTAIN有什么区别呢？</p><p>CONFLICT就是有了冲突，有了冲突是什么情况呢？就是存的图里面出现了有环存在的情况，也就是最后还有入度不为0的结点存在。<br>UNCERTAIN就是不确定，不确定是什么情况呢？就是有两个节点的大小关系不知道，也就是存着入度为0的节点的队列中存在两个以上的节点，这个应该还挺好理解的，如果在同一次循环中出现了两个入度为0的节点，说明这两个点之间没有任何边连接着，所以他俩的大小关系自然是不确定了。</p><p>到这里我们发现并没有处理rating相同然后比较RP的问题，这是为什么呢？<br>因为如果出现了等于关系，那么按照题意来说我们应该比较两者的RP值，但是RP值得大小关系是和和编号的大小一样的，而编号每个人都是不一样的，所以就算出现了相等的情况，在不考虑别的情况下一定能比较出大小。所以不需要考虑这个问题。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m,sijia[52121],p[52121],sum;</span><br><span class="line">vector&lt;int&gt; ma[52121];</span><br><span class="line">struct node&#123;</span><br><span class="line">    int x,y;</span><br><span class="line">    char s;</span><br><span class="line">&#125;xiaozhu[52121];</span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">    return p[x]!=x?p[x]=find(p[x]):x;//并查集的查找函数</span><br><span class="line">&#125;</span><br><span class="line">bool join(int x,int y)//并查集的合并函数，这里设置成bool类型是为了下面方便</span><br><span class="line">&#123;</span><br><span class="line">    x=find(x),y=find(y);</span><br><span class="line">    if(x==y)//如果x和y的父节点已经相等了，就不用在处理了</span><br><span class="line">        return 0;</span><br><span class="line">    p[x]=y;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">void solve()//拓扑排序</span><br><span class="line">&#123;</span><br><span class="line">    queue&lt;int&gt; q;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(p[i]==i&amp;&amp;sijia[i]==0)    q.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    int flag=0;</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        if(q.size()&gt;1)  flag=1;   //入度为0的点同时出现了两个</span><br><span class="line">        int mid=q.front();</span><br><span class="line">        q.pop();sum--;</span><br><span class="line">        for(int i=0;i&lt;ma[mid].size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sijia[ma[mid][i]]--;</span><br><span class="line">            if(sijia[ma[mid][i]]==0)    q.push(ma[mid][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(sum&gt;0)   puts(&quot;CONFLICT&quot;);  //有环存在</span><br><span class="line">    else if(flag)   puts(&quot;UNCERTAIN&quot;);//sum大于0说明同一等级上不是只有唯一的一个</span><br><span class="line">    else    puts(&quot;OK&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while(cin&gt;&gt;n&gt;&gt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        memset(sijia,0,sizeof(sijia));</span><br><span class="line">        memset(ma,0,sizeof(ma));</span><br><span class="line">        sum=n;</span><br><span class="line">        for(int i=0;i&lt;n;i++)    p[i]=i;</span><br><span class="line">        for(int i=0;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;xiaozhu[i].x&gt;&gt;xiaozhu[i].s&gt;&gt;xiaozhu[i].y;</span><br><span class="line">            if(xiaozhu[i].s==&apos;=&apos;)//如果出现了等号，就把两个合并</span><br><span class="line">            &#123;</span><br><span class="line">                if(join(xiaozhu[i].x,xiaozhu[i].y))</span><br><span class="line">                &#123;</span><br><span class="line">                    sum--;//因为合并起来了两个，所以总的拓扑排序用到的节点数减一</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;m;i++)//存图</span><br><span class="line">        &#123;</span><br><span class="line">            if(xiaozhu[i].s==&apos;=&apos;)   continue;</span><br><span class="line">            int xx=find(xiaozhu[i].x),yy=find(xiaozhu[i].y);</span><br><span class="line">            if(xiaozhu[i].s==&apos;&gt;&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                ma[xx].push_back(yy);</span><br><span class="line">                sijia[yy]++;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                ma[yy].push_back(xx);</span><br><span class="line">                sijia[xx]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天讲了拓扑排序，相比较而言还是挺简单的，我觉得这也是BFS的应用。不得不说，BFS和DFS是真的太重要了，在图论里面。
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="Algorithm" scheme="https://cndrew.cn/blog/tags/Algorithm/"/>
    
      <category term="c/c++" scheme="https://cndrew.cn/blog/tags/c-c/"/>
    
      <category term="BFS" scheme="https://cndrew.cn/blog/tags/BFS/"/>
    
      <category term="邻接表" scheme="https://cndrew.cn/blog/tags/%E9%82%BB%E6%8E%A5%E8%A1%A8/"/>
    
      <category term="拓扑排序" scheme="https://cndrew.cn/blog/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Weicome to Uncle_drew&#39;s blog</title>
    <link href="https://cndrew.cn/blog/2019/08/06/guide/"/>
    <id>https://cndrew.cn/blog/2019/08/06/guide/</id>
    <published>2019-08-06T13:11:06.589Z</published>
    <updated>2019-08-08T15:15:45.942Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><center>感谢每一个来到我的博客的小伙伴。这里是欢迎页以及留言板</center><a id="more"></a></p><p><font color="red">前排友情提示 &#39;ctrl+D&#39;收藏本站，并订阅本站的RSS，每日获得<del>最新</del>资讯</font><br>Ps：听说收藏本站之后刷新会触发隐藏彩蛋哦</p><h2 id="关于本站"><a href="#关于本站" class="headerlink" title="关于本站"></a>关于本站</h2><p>本站是基于hexo的next主题经过各种魔改搭建而成的，托管在<a href="cndrew.cn">GitHub</a> &amp;&amp; <a href="blog.cndrew.cn">coding</a>上。</p><p>如果你对本站的某些特效或者各种奇怪的东西有兴趣但不知道如何实现的可以在下面评论或者联系我。</p><h2 id="关于友链"><a href="#关于友链" class="headerlink" title="关于友链"></a>关于友链</h2><p>如果你想跟我互换友链，可以在下方回复。<br>添加要求：</p><ol><li>不要求有几篇几篇文章，只要你是热爱于博客就行，勤于更新，严于律己即可。</li><li>已经添加了本站为友链。友链名字就叫Uncle_drew就行，如果需要描述，就是Hand down,man down.如果需要头像，这个就行。<br><img src="http://drew.todest.cn/dreww.jpg" alt></li><li>真善美不强制要求，但是黄赌毒是肯定不行的。</li><li>不要死链，我无聊的时候会看自己的友链。<br>满足了这上面的要求，在评论区说一下就好啦，我看见了一定会回应的！</li></ol><h2 id="留言板"><a href="#留言板" class="headerlink" title="留言板"></a>留言板</h2><p>这里借评论作为留言板，为所欲为吧！</p><h2 id="关于广告"><a href="#关于广告" class="headerlink" title="关于广告"></a>关于广告</h2><p>本站采用google adsense的广告，之前莫名其妙的因为无效点击？？？被拉进小黑屋，现在也是恢复了。<br>Ps：我知道我的广告放的有点多了。因为我不知道如何把它变少，来自前端渣渣的怒吼。</p><h2 id="建站的投入以及赞赏功能"><a href="#建站的投入以及赞赏功能" class="headerlink" title="建站的投入以及赞赏功能"></a>建站的投入以及赞赏功能</h2><p>我莫得钱买自己服务器，花了200大洋在阿里云买了cndrew.cn这个域名四年。时间就不算了。成本还是很低的。但是本蒻蒻想吃的好呲的，所以开启了赞赏的功能，如果哪里帮到了你并且愿意的话，谢谢你的赞赏。</p><p>在这里我会记录下给我赞赏过的小伙伴。可以在赞赏时候备注你想说的话。如果有网站的话也可以备注上</p><table><thead><tr><th style="text-align:center">Nickname</th><th style="text-align:center">Amount</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://cdreamer.cn/" target="_blank" rel="noopener">豆青</a></td><td style="text-align:center">¥1.00</td><td style="text-align:center">博客写的真的好，帮到了我不少</td></tr><tr><td style="text-align:center">suixin322</td><td style="text-align:center">¥6.60</td><td style="text-align:center">一切执着和努力都源于热爱！加油！</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;感谢每一个来到我的博客的小伙伴。这里是欢迎页以及留言板&lt;/center&gt;
    
    </summary>
    
      <category term="Life" scheme="https://cndrew.cn/blog/categories/Life/"/>
    
    
      <category term="life" scheme="https://cndrew.cn/blog/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>HPU Summer Day21(河南理工大学暑期第二十一天)</title>
    <link href="https://cndrew.cn/blog/2019/08/06/d21/"/>
    <id>https://cndrew.cn/blog/2019/08/06/d21/</id>
    <published>2019-08-06T12:55:34.109Z</published>
    <updated>2019-08-06T13:24:18.140Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天说来话长...<a id="more"></a><br>今天讲了最短路，可能是个人原因我觉得什么都没学到。做题也没做出来几道。就这吧，想补了再补，反正是没怎么写。</p><p>然后老师和会长组织我们在计蒜客上打了2018的ECNA的重现赛，一言难尽，自闭就完事了。。。</p><p>今天我被封了一个月还多的谷歌广告的账号回来了！！！然后我又加了几个广告(确实有点多了，但是我真的不知道怎么减少，等我前端学的不错了再说8)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天说来话长...
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="Algorithm" scheme="https://cndrew.cn/blog/tags/Algorithm/"/>
    
      <category term="c/c++" scheme="https://cndrew.cn/blog/tags/c-c/"/>
    
      <category term="最短路" scheme="https://cndrew.cn/blog/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>HPU Summer Day 20(河南理工大学暑期第二十天)</title>
    <link href="https://cndrew.cn/blog/2019/08/05/d20/"/>
    <id>https://cndrew.cn/blog/2019/08/05/d20/</id>
    <published>2019-08-05T14:23:57.794Z</published>
    <updated>2019-08-05T14:37:22.218Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天讲了并查集和最小生成树。<del>~狠心</del>~望弟成龙的学长直接是给拉了两套题。。。做不完做不完，慢慢补咯<a id="more"></a></p><h3 id="The-Suspects"><a href="#The-Suspects" class="headerlink" title="The Suspects"></a>The Suspects</h3><p>Description:<br>Severe acute respiratory syndrome (SARS), an atypical pneumonia of unknown aetiology, was recognized as a global threat in mid-March 2003. To minimize transmission to others, the best strategy is to separate the suspects from others.<br>In the Not-Spreading-Your-Sickness University (NSYSU), there are many student groups. Students in the same group intercommunicate with each other frequently, and a student may join several groups. To prevent the possible transmissions of SARS, the NSYSU collects the member lists of all student groups, and makes the following rule in their standard operation procedure (SOP).<br>Once a member in a group is a suspect, all members in the group are suspects.<br>However, they find that it is not easy to identify all the suspects when a student is recognized as a suspect. Your job is to write a program which finds all the suspects.<br>Input</p><blockquote><p>The input file contains several cases. Each test case begins with two integers n and m in a line, where n is the number of students, and m is the number of groups. You may assume that 0 &lt; n &lt;= 30000 and 0 &lt;= m &lt;= 500. Every student is numbered by a unique integer between 0 and n−1, and initially student 0 is recognized as a suspect in all the cases. This line is followed by m member lists of the groups, one line per group. Each line begins with an integer k by itself representing the number of members in the group. Following the number of members, there are k integers representing the students in this group. All the integers in a line are separated by at least one space.<br>A case with n = 0 and m = 0 indicates the end of the input, and need not be processed.</p></blockquote><p>Output</p><blockquote><p>For each case, output the number of suspects in one line.</p></blockquote><p>Sample Input</p><blockquote><p>100 4<br>2 1 2<br>5 10 13 11 12 14<br>2 0 1<br>2 99 2<br>200 2<br>1 5<br>5 1 2 3 4 5<br>1 0<br>0 0</p></blockquote><p>Sample Output</p><blockquote><p>4<br>1<br>1</p></blockquote><p>Problem solving:<br>这道题的意思就是编号为0的学生是有病的，然后告诉你几个组，并且知道如果组里面有一个人是确定有病的，那个这一个组的人都是有病的，问你有病的总共有几个人。</p><p>题意理解了题就简单了，就是一个简单的并查集模板问题。但是为了保证你连接的时候用到的最大的那个节点是0，在join(合并函数)里面要加一个判断，保证每次选的最大的父节点是最小的，如果有的话，就可以保证是0了。最后输出父节点是0的个数即可。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int sijiaxiaozhu=3e4+10;</span><br><span class="line">int p[sijiaxiaozhu],n,m,k,mi,mii;</span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">    return p[x]!=x?p[x]=find(p[x]):x;</span><br><span class="line">&#125;</span><br><span class="line">void join(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    x=find(x),y=find(y);</span><br><span class="line">    if(x&lt;y)    p[y]=x;</span><br><span class="line">    else    p[x]=y;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        if(n==0&amp;&amp;m==0)  break;</span><br><span class="line">        for(int i=0;i&lt;n;i++)    p[i]=i;</span><br><span class="line">        for(int i=0;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d %d&quot;,&amp;k,&amp;mi);</span><br><span class="line">            for(int i=0;i&lt;k-1;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                cin&gt;&gt;mii;</span><br><span class="line">                join(mi,mii);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int ans=1;</span><br><span class="line">        for(int i=1;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            find(i);</span><br><span class="line">            // cout&lt;&lt;p[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">            if(p[i]==0) ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="畅通工程"><a href="#畅通工程" class="headerlink" title="畅通工程"></a>畅通工程</h3><p>Description:<br>某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？<br>Input</p><blockquote><p>测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( &lt; 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。<br>注意:两个城市之间可以有多条道路相通,也就是说<br>3 3<br>1 2<br>1 2<br>2 1<br>这种输入也是合法的<br>当N为0时，输入结束，该用例不被处理。</p></blockquote><p>Output</p><blockquote><p>对每个测试用例，在1行里输出最少还需要建设的道路数目。</p></blockquote><p>Sample Input</p><blockquote><p>4 2<br>1 3<br>4 3<br>3 3<br>1 2<br>1 3<br>2 3<br>5 2<br>1 2<br>3 5<br>999 0<br>0</p></blockquote><p>Sample Output</p><blockquote><p>1<br>0<br>2<br>998       </p></blockquote><p>Huge input, scanf is recommended.</p><p>Problem solving:<br>题意就是告诉你村庄的个数以及哪些村庄之间是通路的。问你现在还需要修几条路才可以使每个村庄都可以连通，无论拐几个弯。</p><p>就是一个简单的并查集，有一点难的就是修几条路才可以使村庄全部连通。举个栗子，现在总共四个村庄，1,2是连通的，3,4是连通的。所以现在四个村庄总共被分成了2个部分，此时再多修一条路就可以全部连通了。所以所需修的路的个数就是分成的部分数-1.当一个节点的父节点就是他本身的时候说明这是一个区域。统计父节点与它本身相等的点的个数就是区域的个数。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int sijiaxiaozhu=1e5;</span><br><span class="line">int p[sijiaxiaozhu];</span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">    return p[x]!=x?p[x]=find(p[x]):x;</span><br><span class="line">&#125;</span><br><span class="line">void join(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    x=find(x),y=find(y);</span><br><span class="line">    if(x!=y)    p[x]=y;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m,a,b;</span><br><span class="line">    while(scanf(&quot;%d %d&quot;,&amp;n,&amp;m)&amp;&amp;n)</span><br><span class="line">    &#123;</span><br><span class="line">        int ans=0;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)   p[i]=i;</span><br><span class="line">        for(int i=0;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">            join(a,b);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)   if(p[i]==i) ans++;</span><br><span class="line">        cout&lt;&lt;ans-1&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="还是畅通工程"><a href="#还是畅通工程" class="headerlink" title="还是畅通工程"></a>还是畅通工程</h3><p>Description:<br>某省调查乡村交通状况，得到的统计表中列出了任意两村庄间的距离。省政府“畅通工程”的目标是使全省任何两个村庄间都可以实现公路交通（但不一定有直接的公路相连，只要能间接通过公路可达即可），并要求铺设的公路总长度为最小。请计算最小的公路总长度。<br>Input</p><blockquote><p>测试输入包含若干测试用例。每个测试用例的第1行给出村庄数目N ( &lt; 100 )；随后的N(N-1)/2行对应村庄间的距离，每行给出一对正整数，分别是两个村庄的编号，以及此两村庄间的距离。为简单起见，村庄从1到N编号。<br>当N为0时，输入结束，该用例不被处理。</p></blockquote><p>Output</p><blockquote><p>对每个测试用例，在1行里输出最小的公路总长度。</p></blockquote><p>Sample Input</p><blockquote><p>3<br>1 2 1<br>1 3 2<br>2 3 4<br>4<br>1 2 1<br>1 3 4<br>1 4 1<br>2 3 3<br>2 4 2<br>3 4 5<br>0</p></blockquote><p>Sample Output</p><blockquote><p>3<br>5     </p></blockquote><p>Huge input, scanf is recommended.<br>Problem solving:<br>题意就是给了你n个村庄，并且给了你N(N-1)/2条路。问你如果想让村庄之间互相连通所需要修的路的最短长度是多少。就是一个简单的最小生成树的模板题。用的Kruscal算法。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 10005;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int a,b,c;</span><br><span class="line">&#125;r[maxn];</span><br><span class="line">int p[maxn];</span><br><span class="line">bool cmp(node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">    return a.c&lt;b.c;</span><br><span class="line">&#125;</span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">    return p[x]!=x?p[x]=find(p[x]):x;</span><br><span class="line">&#125;</span><br><span class="line">void join(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    x=find(x),y=find(y);</span><br><span class="line">    if(x!=y)    p[x]=y;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n)</span><br><span class="line">    &#123;</span><br><span class="line">        int sum=0;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)   p[i]=i;</span><br><span class="line">        for(int i=0;i&lt;n*(n-1)/2;i++)</span><br><span class="line">            scanf(&quot;%d %d %d&quot;,&amp;r[i].a,&amp;r[i].b,&amp;r[i].c);</span><br><span class="line">        sort(r,r+n*(n-1)/2,cmp);</span><br><span class="line">        for(int i=0;i&lt;n*(n-1)/2;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(find(r[i].a)!=find(r[i].b))</span><br><span class="line">            &#123;</span><br><span class="line">                sum+=r[i].c;</span><br><span class="line">                join(r[i].a,r[i].b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Ubiquitous-Religions"><a href="#Ubiquitous-Religions" class="headerlink" title="Ubiquitous Religions"></a>Ubiquitous Religions</h3><p>Description:<br>There are so many different religions in the world today that it is difficult to keep track of them all. You are interested in finding out how many different religions students in your university believe in.</p><p>You know that there are n students in your university (0 &lt; n &lt;= 50000). It is infeasible for you to ask every student their religious beliefs. Furthermore, many students are not comfortable expressing their beliefs. One way to avoid these problems is to ask m (0 &lt;= m &lt;= n(n-1)/2) pairs of students and ask them whether they believe in the same religion (e.g. they may know if they both attend the same church). From this data, you may not know what each person believes in, but you can get an idea of the upper bound of how many different religions can be possibly represented on campus. You may assume that each student subscribes to at most one religion.<br>Input</p><blockquote><p>The input consists of a number of cases. Each case starts with a line specifying the integers n and m. The next m lines each consists of two integers i and j, specifying that students i and j believe in the same religion. The students are numbered 1 to n. The end of input is specified by a line in which n = m = 0.</p></blockquote><p>Output</p><blockquote><p>For each test case, print on a single line the case number (starting with 1) followed by the maximum number of different religions that the students in the university believe in.</p></blockquote><p>Sample Input</p><blockquote><p>10 9<br>1 2<br>1 3<br>1 4<br>1 5<br>1 6<br>1 7<br>1 8<br>1 9<br>1 10<br>10 4<br>2 3<br>4 5<br>4 8<br>5 8<br>0 0</p></blockquote><p>Sample Output</p><blockquote><p>Case 1: 1<br>Case 2: 7</p></blockquote><p>Hint<br>Huge input, scanf is recommended.</p><p>Problem solving:<br>题意就是n个学生，m个组，每个组两个人，两个人的宗教信仰是一样的，问你n个学生总共有多少个不同的宗教信仰。简单并查集模板题。</p><p>最后查找父节点就是他本身的个数就是答案。<br>查找的时候别忘了find(i)因为你有可能遇见没有分组的时候对它find的情况，所以你需要在这里find一下避免出现这样的情况导致WA。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m,a,b;</span><br><span class="line">const int sijiaxiaozhu=5e4+10;</span><br><span class="line">int p[sijiaxiaozhu];</span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">    return p[x]!=x?p[x]=find(p[x]):x;</span><br><span class="line">&#125;</span><br><span class="line">void join(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    x=find(x),y=find(y);</span><br><span class="line">    if(x!=y)    p[x]=y;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int flag=1;</span><br><span class="line">    while(scanf(&quot;%d %d&quot;,&amp;n,&amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        if(n==0&amp;&amp;m==0)  break;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)   p[i]=i;</span><br><span class="line">        for(int i=0;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d %d&quot;,&amp;a,&amp;b);</span><br><span class="line">            join(a,b);</span><br><span class="line">        &#125;</span><br><span class="line">        int ans=0;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            find(i);</span><br><span class="line">            if(p[i]==i) ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;Case %d: %d\n&quot;,flag++,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Cube-Stacking"><a href="#Cube-Stacking" class="headerlink" title="Cube Stacking"></a>Cube Stacking</h3><p>Description:<br>Farmer John and Betsy are playing a game with N (1 &lt;= N &lt;= 30,000)identical cubes labeled 1 through N. They start with N stacks, each containing a single cube. Farmer John asks Betsy to perform P (1&lt;= P &lt;= 100,000) operation. There are two types of operations:<br>moves and counts.</p><ul><li>In a move operation, Farmer John asks Bessie to move the stack containing cube X on top of the stack containing cube Y.</li><li>In a count operation, Farmer John asks Bessie to count the number of cubes on the stack with cube X that are under the cube X and report that value.</li></ul><p>Write a program that can verify the results of the game.<br>Input</p><blockquote><ul><li>Line 1: A single integer, P</li><li>Lines 2..P+1: Each of these lines describes a legal operation. Line 2 describes the first operation, etc. Each line begins with a &#39;M&#39; for a move operation or a &#39;C&#39; for a count operation. For move operations, the line also contains two integers: X and Y.For count operations, the line also contains a single integer: X.<br>Note that the value for N does not appear in the input file. No move operation will request a move a stack onto itself.</li></ul></blockquote><p>Output</p><blockquote><p>Print the output from each of the count operations in the same order as the input file.</p></blockquote><p>Sample Input</p><blockquote><p>6<br>M 1 6<br>C 1<br>M 2 4<br>M 2 6<br>C 3<br>C 4</p></blockquote><p>Sample Output</p><blockquote><p>1<br>0<br>2</p></blockquote><p>Problem solving:<br>题意就是会有n次操作，每次操作可能有两种情况，一种是M a b就是把第a列的所有方块放在b的上面。另一种就是C a，就是需要输出a下面有几个方块。</p><p>带权值的并查集。</p><p>这里我用了两个数组进行维护。ans[i]表示i下面方块的个数，now[i]表示i所处的当前列的方块个数。然后如果遇见M这个操作，就把now[a]全部加到now[b]上然后now[a]归零。并且此时ans[find(a)]应该加上now[find(b)].这就实现了把第a列的所有方块放在b上的操作了。</p><p>还有就是find函数的写法，在find的过程中，每次查找到的中间的节点的ans的值都应该加到查找开始的ans的值里面。这个不太好解释，也不太好想通。可以在脑子里过一下并查集的操作，并且结合着这道题的做法，好好想想为什么需要加上去。<br>等我对这个的理解加深的时候再来补上自己成熟的理解。</p><p>下面这个图来解释一下这个样例<br><img src="http://drew.todest.cn/unf.png" alt></p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int sijiaxiaozhu=31314;</span><br><span class="line">int p[sijiaxiaozhu],ans[sijiaxiaozhu],now[sijiaxiaozhu];</span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">    if(p[x]==x) return p[x];</span><br><span class="line">    int mid=p[x];</span><br><span class="line">    p[x]=find(p[x]);</span><br><span class="line">    ans[x]+=ans[mid];</span><br><span class="line">    return p[x];</span><br><span class="line">&#125;</span><br><span class="line">void join(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    int fx=find(x),fy=find(y);</span><br><span class="line">    if(fx==fy)  return ;</span><br><span class="line">    p[fx]=fy;</span><br><span class="line">    ans[fx]+=now[fy];</span><br><span class="line">    now[fy]+=now[fx];</span><br><span class="line">    now[fx]=0;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=1;i&lt;=sijiaxiaozhu;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        now[i]=1;</span><br><span class="line">        p[i]=i;</span><br><span class="line">        ans[i]=0;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        char s;</span><br><span class="line">        int a,b;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        if(s==&apos;M&apos;)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d %d&quot;,&amp;a,&amp;b);</span><br><span class="line">            join(a,b);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;a);</span><br><span class="line">            find(a);</span><br><span class="line">            printf(&quot;%d\n&quot;,ans[a]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Dragon-Balls"><a href="#Dragon-Balls" class="headerlink" title="Dragon Balls"></a>Dragon Balls</h3><p>Description:<br>Five hundred years later, the number of dragon balls will increase unexpectedly, so it&#39;s too difficult for Monkey King(WuKong) to gather all of the dragon balls together.<br>His country has N cities and there are exactly N dragon balls in the world. At first, for the ith dragon ball, the sacred dragon will puts it in the ith city. Through long years, some cities&#39; dragon ball(s) would be transported to other cities. To save physical strength WuKong plans to take Flying Nimbus Cloud, a magical flying cloud to gather dragon balls.<br>Every time WuKong will collect the information of one dragon ball, he will ask you the information of that ball. You must tell him which city the ball is located and how many dragon balls are there in that city, you also need to tell him how many times the ball has been transported so far.<br>Input</p><blockquote><p>The first line of the input is a single positive integer T(0 &lt; T &lt;= 100).<br>For each case, the first line contains two integers: N and Q (2 &lt; N &lt;= 10000 , 2 &lt; Q &lt;= 10000).<br>Each of the following Q lines contains either a fact or a question as the follow format:<br>  T A B : All the dragon balls which are in the same city with A have been transported to the city the Bth ball in. You can assume that the two cities are different.<br>  Q A : WuKong want to know X (the id of the city Ath ball is in), Y (the count of balls in Xth city) and Z (the tranporting times of the Ath ball). (1 &lt;= A, B &lt;= N)</p></blockquote><p>Output</p><blockquote><p>For each test case, output the test case number formated as sample output. Then for each query, output a line with three integers X Y Z saparated by a blank space.</p></blockquote><p>Sample Input</p><blockquote><p>2<br>3 3<br>T 1 2<br>T 3 2<br>Q 2<br>3 4<br>T 1 2<br>Q 1<br>T 1 3<br>Q 1</p></blockquote><p>Sample Output</p><blockquote><p>Case 1:<br>2 3 0<br>Case 2:<br>2 2 1<br>3 3 2</p></blockquote><p>Problem solving:<br>这道题最毒瘤的地方绝对是题意。<br>题目的意思大概就是有n个城市，初始的时候每个城市都有一个龙珠。<br>现在给你输入几个操作，一种是move，一种是count。move后面有两个数，代表着把第一个数代表的城市的所有的龙珠转移到第二个数代表的城市里面。然后count i的时候需要输出3个数。第一个数代表的是编号为i的龙珠当前所在的城市，第二个数是编号为i的龙珠当前所在城市拥有的龙珠个数，第三个数代表的是编号为i的龙珠移动的次数。</p><p>这道题一看就是并查集的问题(如果今天专题不是并查集我可能也想不到)，但这个并不是简单普通的并查集。他要求我们输出的数需要一些巧妙地想法去记录一下。</p><p>我们这里用sum[i]来表示第i个城市当前所具有的龙珠个数，p[i]还是并查集里面的p[i]，刚开始的时候初始化每个点的父节点都是自己，每个城市具有的龙珠个数都是1.</p><p>在join(合并)的过程中注意，题目要求的是把x的龙珠全部放到y，所以sum[y]+=sum[x],sum[x]=0,这一步这样就挺好理解的了。</p><p>然后i所在的城市我们直接输出p[i]就行，i所在的城市的龙珠个数输出sum[i]就行。编号为i的龙珠的移动个数不太好求，那我们怎么求呢？</p><p>我们想一下并查集的，就是有点类似于构建一个图的过程。那么每个龙珠移动的次数就正好是它的初始节点距离最大的那个父节点的距离。这道题里面正好每个龙珠的标号就是它的初始节点的编号，所以类似于find函数的查找再查找一遍就能找出它的移动次数了。</p><p>（还有一点坑了我就是，不要路径压缩。。。我记得板子是压缩了路径的，然后一直WA，一直WA。。。你需要一个查找距离的过程，如果路径压缩了，那每个移动距离都是1了，会破坏原本的构图。这毒瘤样例也没体现这个坑点。太坑了！！！</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int sijiaxiaozhu = 1e5;</span><br><span class="line">int p[sijiaxiaozhu],sum[sijiaxiaozhu];</span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">   return p[x]!=x?find(p[x]):x;</span><br><span class="line">&#125;</span><br><span class="line">int xiaozhu(int x)//这个就是那个查找移动次数的函数</span><br><span class="line">&#123;</span><br><span class="line">    int ans=0;</span><br><span class="line">    while(p[x]!=x)//其实跟并查集的find是差不多的的</span><br><span class="line">    &#123;</span><br><span class="line">        x=p[x];</span><br><span class="line">        ans++;//没查找答案一次加一</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">void join(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    int fx=find(x),fy=find(y);</span><br><span class="line">    if(fx!=fy)</span><br><span class="line">    &#123;</span><br><span class="line">        p[fx]=fy;</span><br><span class="line">        sum[fy]+=sum[fx];//这个就是龙珠转移的过程</span><br><span class="line">        sum[fx]=0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t,nu=0;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        int n,m;</span><br><span class="line">        scanf(&quot;%d %d&quot;,&amp;n,&amp;m);</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            p[i]=i;sum[i]=1;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;Case %d:\n&quot;,++nu);</span><br><span class="line">        while(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            char s[2];</span><br><span class="line">            scanf(&quot;%s&quot;,s);</span><br><span class="line">            if(s[0]==&apos;T&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                int a,b;</span><br><span class="line">                scanf(&quot;%d %d&quot;,&amp;a,&amp;b);</span><br><span class="line">                join(a,b);</span><br><span class="line">            &#125;</span><br><span class="line">            if(s[0]==&apos;Q&apos;)</span><br><span class="line">            &#123;</span><br><span class="line">                int a;</span><br><span class="line">                scanf(&quot;%d&quot;,&amp;a);</span><br><span class="line">                printf(&quot;%d %d %d\n&quot;,find(a),sum[find(a)],xiaozhu(a));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个好像是叫带权并查集吧，挺难理解的。但是只要想做，就没有做不出来的题！</p><h3 id="Zjnu-Stadium"><a href="#Zjnu-Stadium" class="headerlink" title="Zjnu Stadium"></a>Zjnu Stadium</h3><p>Description:<br>In 12th Zhejiang College Students Games 2007, there was a new stadium built in Zhejiang Normal University. It was a modern stadium which could hold thousands of people. The audience Seats made a circle. The total number of columns were 300 numbered 1--300, counted clockwise, we assume the number of rows were infinite.<br>These days, Busoniya want to hold a large-scale theatrical performance in this stadium. There will be N people go there numbered 1--N. Busoniya has Reserved several seats. To make it funny, he makes M requests for these seats: A B X, which means people numbered B must seat clockwise X distance from people numbered A. For example: A is in column 4th and X is 2, then B must in column 6th (6=4+2).<br>Now your task is to judge weather the request is correct or not. The rule of your judgement is easy: when a new request has conflicts against the foregoing ones then we define it as incorrect, otherwise it is correct. Please find out all the incorrect requests and count them as R.<br>Input</p><blockquote><p>There are many test cases:<br>For every case:<br>The first line has two integer N(1&lt;=N&lt;=50,000), M(0&lt;=M&lt;=100,000),separated by a space.<br>Then M lines follow, each line has 3 integer A(1&lt;=A&lt;=N), B(1&lt;=B&lt;=N), X(0&lt;=X\&lt;300) (A!=B), separated by a space.</p></blockquote><p>Output</p><blockquote><p>For every case:<br>Output R, represents the number of incorrect request.</p></blockquote><p>Sample Input</p><blockquote><p>10 10<br>1 2 150<br>3 4 200<br>1 5 270<br>2 6 200<br>6 5 80<br>4 7 150<br>8 9 100<br>4 8 50<br>1 7 100<br>9 2 100</p></blockquote><p>Sample Output</p><blockquote><p>2</p></blockquote><p>Hint<br>Hint:<br>（PS： the 5th and 10th requests are incorrect）</p><p>Problem solving:<br>也是一道带权并查集的题，但是我不会。。。代码先贴上来啦，以后再补题解。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int sijia=52113;</span><br><span class="line">int f[sijia],sijiaxiaozhu[sijia],n,m;</span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">    if(x==f[x])    return f[x];</span><br><span class="line">    int t=f[x];</span><br><span class="line">    f[x]=find(f[x]);</span><br><span class="line">    sijiaxiaozhu[x] += sijiaxiaozhu[t];</span><br><span class="line">    return f[x];</span><br><span class="line">&#125;</span><br><span class="line">bool Union(int x,int y,int m)</span><br><span class="line">&#123;</span><br><span class="line">    int a=find(x),b=find(y);</span><br><span class="line">    if(a==b)</span><br><span class="line">    &#123;</span><br><span class="line">        if(sijiaxiaozhu[x]+m!=sijiaxiaozhu[y])</span><br><span class="line">            return 0;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    f[b]=a;</span><br><span class="line">    sijiaxiaozhu[b]=sijiaxiaozhu[x]+m-sijiaxiaozhu[y];</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a,b,x;</span><br><span class="line">    while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=0;i&lt;=n;i++)</span><br><span class="line">            f[i]=i,sijiaxiaozhu[i]=0;</span><br><span class="line">        int cnt=0;</span><br><span class="line">        for(int i=0;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;x);</span><br><span class="line">            if(!Union(a,b,x))   cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;,cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="How-Many-Tables"><a href="#How-Many-Tables" class="headerlink" title="How Many Tables"></a>How Many Tables</h3><p>Description:<br>Today is Ignatius&#39; birthday. He invites a lot of friends. Now it&#39;s dinner time. Ignatius wants to know how many tables he needs at least. You have to notice that not all the friends know each other, and all the friends do not want to stay with strangers.</p><p>One important rule for this problem is that if I tell you A knows B, and B knows C, that means A, B, C know each other, so they can stay in one table.</p><p>For example: If I tell you A knows B, B knows C, and D knows E, so A, B, C can stay in one table, and D, E have to stay in the other one. So Ignatius needs 2 tables at least.<br>Input</p><blockquote><p>The input starts with an integer T(1&lt;=T&lt;=25) which indicate the number of test cases. Then T test cases follow. Each test case starts with two integers N and M(1&lt;=N,M&lt;=1000). N indicates the number of friends, the friends are marked from 1 to N. Then M lines follow. Each line consists of two integers A and B(A!=B), that means friend A and friend B know each other. There will be a blank line between two cases.</p></blockquote><p>Output</p><blockquote><p>For each test case, just output how many tables Ignatius needs at least. Do NOT print any blanks.</p></blockquote><p>Sample Input</p><blockquote><p>2<br>5 3<br>1 2<br>2 3<br>4 5<br>5 1<br>2 5</p></blockquote><p>Sample Output</p><blockquote><p>2<br>4</p></blockquote><p>Problem solving:<br>题意我也懒得分析了，就是一个简单并查集，套板子就行了。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int sijiaxiaozhu=1e4;</span><br><span class="line">int p[sijiaxiaozhu];</span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">    return p[x]!=x?p[x]=find(p[x]):x;</span><br><span class="line">&#125;</span><br><span class="line">void join(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    x=find(x),y=find(y);</span><br><span class="line">    if(x!=y) p[x]=y;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t,n,m,a,b;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        int ans=0;</span><br><span class="line">        scanf(&quot;%d %d&quot;,&amp;n,&amp;m);</span><br><span class="line">        for(int i=1;i&lt;=n;i++)   p[i]=i;</span><br><span class="line">        for(int i=0;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d %d&quot;,&amp;a,&amp;b);</span><br><span class="line">            join(a,b);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(p[i]==i) ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Highways"><a href="#Highways" class="headerlink" title="Highways"></a>Highways</h3><h3 id="Networking"><a href="#Networking" class="headerlink" title="Networking"></a>Networking</h3><h3 id="Highways-1"><a href="#Highways-1" class="headerlink" title="Highways"></a>Highways</h3><h3 id="Agri-Net"><a href="#Agri-Net" class="headerlink" title="Agri-Net"></a>Agri-Net</h3><h3 id="Jungle-Roads"><a href="#Jungle-Roads" class="headerlink" title="Jungle Roads"></a>Jungle Roads</h3><h3 id="Truck-History"><a href="#Truck-History" class="headerlink" title="Truck History"></a>Truck History</h3><h3 id="畅通工程再续"><a href="#畅通工程再续" class="headerlink" title="畅通工程再续"></a>畅通工程再续</h3><h3 id="Constructing-Roads"><a href="#Constructing-Roads" class="headerlink" title="Constructing Roads"></a>Constructing Roads</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天讲了并查集和最小生成树。&lt;del&gt;~狠心&lt;/del&gt;~望弟成龙的学长直接是给拉了两套题。。。做不完做不完，慢慢补咯
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="Algorithm" scheme="https://cndrew.cn/blog/tags/Algorithm/"/>
    
      <category term="c/c++" scheme="https://cndrew.cn/blog/tags/c-c/"/>
    
      <category term="并查集" scheme="https://cndrew.cn/blog/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="kruscal" scheme="https://cndrew.cn/blog/tags/kruscal/"/>
    
  </entry>
  
  <entry>
    <title>HPU Summer Day 19(河南理工大学暑期第十九天)</title>
    <link href="https://cndrew.cn/blog/2019/08/04/d19/"/>
    <id>https://cndrew.cn/blog/2019/08/04/d19/</id>
    <published>2019-08-04T14:41:06.950Z</published>
    <updated>2019-08-04T14:54:39.018Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天是休息的一天。<a id="more"></a><br>早上五点左右醒来。癔症一会发现睡不着了，六点开始玩手机，玩到七点。<br>到了七点，开始了今天最重要的一件事，给我的图片换一下外链。之前所有的外链都是通过sm.ms弄得，也不能说它不好，就是时间久了的图片加载会很慢很慢，进而拖慢我整个博客的速度。前几天从学长那白嫖了了一个备案过的域名。有时会到了七牛云作图床的时代。不过人家七牛云是真的快。</p><p>换外链换到十一点多，出去吃了个饭直接去机房了。在机房水题水到两点做不下去了就去打了会球，打球回来四点多。</p><p>然后就开始了今天第二重要的事，做一个相册。之前做过，但是因为访问速度直接是弃用了，现在用的这个七牛云可以说是很舒服了。在网上找了个模板，套了一下，就到八点了。<br>想看我得新相册?<br>我帅不帅？<br><a href="https://blog.cndrew.cn/album/" target="_blank" rel="noopener">一般帅</a> <a href="https://blog.cndrew.cn/album/" target="_blank" rel="noopener">帅的惊天动地</a> <a href="https://blog.cndrew.cn/album/" target="_blank" rel="noopener">帅的无法形容</a></p><p>选对了就能进哦</p><p>我的假期就这样没了，没了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是休息的一天。
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="life" scheme="https://cndrew.cn/blog/tags/life/"/>
    
      <category term="html" scheme="https://cndrew.cn/blog/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>HPU Summer Day 18(河南理工大学暑期第十八天)</title>
    <link href="https://cndrew.cn/blog/2019/08/03/d18/"/>
    <id>https://cndrew.cn/blog/2019/08/03/d18/</id>
    <published>2019-08-03T13:24:42.453Z</published>
    <updated>2019-08-03T13:31:17.912Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一转眼已经第18天了啊。<a id="more"></a><br>今天又是一场积分赛，虽然知道了明天要休息一天了，刚刚结束比赛的我现在心里还是高兴不起来。<br>一开始心态就崩了，第一题看不懂，第二题看不懂，第三题太麻烦，第四题，不会，第五题，哦哦，可算是看到个能看懂的题了，这一看就是个规律题啊，盘它。然后WA了，看看榜，一堆人都做出来了第一题。可我还是题都看不懂，emm<br>然后就这个碎了一地的心态做完了整场比赛，有一道感觉可以搞出来的没搞出来，还是很亏的。<br><br>今天了解到一个贼逗比的<del>~学姐</del>~小猪。靠它保佑也过了不少题哈哈哈哈。<br>明天放假。<del>~high起来</del>~其实我准备把博客所有图片放在七牛云上，应该能提速不少。说到这里还是要谢谢学长的，帮我搞了一个备案的域名，谢谢谢谢。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一转眼已经第18天了啊。
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="life" scheme="https://cndrew.cn/blog/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>河南理工大学算法协会暑期集训积分赛（三）</title>
    <link href="https://cndrew.cn/blog/2019/08/03/jifen3/"/>
    <id>https://cndrew.cn/blog/2019/08/03/jifen3/</id>
    <published>2019-08-03T13:23:27.616Z</published>
    <updated>2019-08-03T13:31:01.161Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天如期举行了第三场积分赛，没啥好说的，还是那句话<br>积分赛，被打爆的积分赛(music<a id="more"></a></p><h3 id="蚂蚁觅食（一）"><a href="#蚂蚁觅食（一）" class="headerlink" title="蚂蚁觅食（一）"></a>蚂蚁觅食（一）</h3><p>Description:<br>一只饥饿的小蚂蚁外出觅食，幸运的小蚂蚁发现了好多食物，但是它只有一次搬食物的机会。<br>可因为力气太小了，它不能搬走重量超过自己体重的食物,且只能搬走位置相邻的两个食物，或者只搬走其中一个。<br>食物的位置不会改变。<br>这可难住了这只蚂蚁，它不知道它最多能搬走多重的食物。请帮小蚂蚁计算。</p><p>输入格式</p><blockquote><p>第一行一个正整数n，(n&gt;=0并且n&lt;=1000)<br>第二行n个正整数 A[1].....A[n]，A[i] 表示在第i 个位置上食物的重量。A[i]&lt;=1e9.<br>第三行一个正整数m，表示蚂蚁的体重。(m&lt;=1e9).</p></blockquote><p>输出格式</p><blockquote><p>一个整数表示小蚂蚁能带走的食物的重量。</p></blockquote><p>样例<br>input</p><blockquote><p>3<br>1 3 3<br>4</p></blockquote><p>output</p><blockquote><p>4</p></blockquote><p>Problem solving:<br>神TM签到题，愣是没看懂是啥意思。。。<br>最后看懂了，就是找一个跟m尽量接近的一个数或者相邻两个数的和尽量接近m的。<br>我是把每个数和相邻的数的和存进一个数组然后O(N)查找<br>找到输出就行</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 2005;</span><br><span class="line">long long a[maxn],m;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,ans=0;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i=0;i&lt;n;i++)cin&gt;&gt;a[i];</span><br><span class="line">for(int i=n;i&lt;2*n-1;i++)a[i]=a[i-n]+a[i-n+1];</span><br><span class="line">sort(a,a+2*n-1);</span><br><span class="line">cin&gt;&gt;m;</span><br><span class="line">for(int i=0;i&lt;2*n-1;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(a[i]&gt;m)break;</span><br><span class="line">ans=a[i];</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>###<br>Description:<br>一只饥饿的小蚂蚁外出觅食，幸运的的小蚂蚁发现了好多食物。<br>但是这些食物位于一个N∗M的方格魔法阵的右下角，而小蚂蚁位于方格法阵的左上角。<br>并且小蚂蚁被施展了魔法，它只能向下或者向右走。<br>请你帮助小蚂蚁计算一下，它一共有多少条路可以走到有食物的方格。</p><p>输入格式</p><blockquote><p>多组输入，<br>每一组两个正整数N， M （N,M≤30）。表示一个方格魔法阵。</p></blockquote><p>输出格式</p><blockquote><p>一个整数表示一共有多少条路。</p></blockquote><p>样例<br>input</p><blockquote><p>2 3</p></blockquote><p>output</p><blockquote><p>3</p></blockquote><p>Problem solving:<br>这道题据说可以用排列数做（高中知识。）<br>倒是我哪会高中知识啊，就推呗。<br>然后找到了递推式，我们用dp[x][y]来表示（x，y）位置到终点有几条路。那么可以得到dp[x][y]=dp[i-1][j]+dp[i][j-1]<br>边界条件是，当x或者y等于1的时候只有一条路，因为只能往右或者往下走。<br>推理过程：<br>首先看一下图吧<br><img src="http://drew.todest.cn/jifen1.png" alt><br>假设我们现在要求(4,3)这个位置到终点(1,1)的路径条数，从(4,3)走出来只有两种选择，向右或者向下，所以我们走到了(4,2),(3,3),这时我们只需要求(4,2)(3,3)到终点的路径条数然后求和就行了。以此类推，就可以得到上面的递推式了。</p><p>然后就是注意这个是多组输入。。！！！<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef unsigned long long ll;</span><br><span class="line">ll ans[32][32];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">for(int i=1;i&lt;=31;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=1;j&lt;=31;j++)</span><br><span class="line">&#123;</span><br><span class="line">if(i==1||j==1)ans[i][j]=1;</span><br><span class="line">else ans[i][j]=ans[i-1][j]+ans[i][j-1];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll n,m;</span><br><span class="line">while(cin&gt;&gt;n&gt;&gt;m)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;ans[n][m]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="蚂蚁觅食（三）"><a href="#蚂蚁觅食（三）" class="headerlink" title="蚂蚁觅食（三）"></a>蚂蚁觅食（三）</h3><p>Description:<br>马上就要冬天了，勤劳的小蚂蚁需要储存足够多的食物才能安全过冬。<br>今天，这只小蚂蚁走出巢穴寻找食物，但是这次蚁巢周围只有很少的食物，它需要去别的地方。<br>不幸的是小蚂蚁的体力很有限，而且每走一个单位长度就要消耗一点体力，不能找的时间太久，所以想让你帮忙计算一下它是否能用剩下的体力把足够多的食物搬回蚁巢。<br>由于蚂蚁的嘴太小，每次最多只能衔起一个食物。</p><p>输入格式</p><blockquote><p>输入t组, t≤20<br>第一行三个数n,E,V表示食物的个数，蚂蚁剩余的体力，安全过冬需要的最少食物体积, 0&lt;n≤100,0&lt;E,V≤10000。<br>接下来n行，每行两个数pi,vi,表示第i个食物的位置和体积,0&lt;p[i],v[i]≤1000。<br>初始蚂蚁和蚁巢均在坐标轴原点。</p></blockquote><p>输出格式</p><blockquote><p>每个输出占一行。<br>如果蚂蚁能安全过冬，输出 “YES”,否则输出”NO”。</p></blockquote><p>样例<br>input</p><blockquote><p>2<br>1 2 2<br>1 2<br>1 2 2<br>2 1</p></blockquote><p>output</p><blockquote><p>YES<br>NO</p></blockquote><p>Problem solving:<br>一道简单的01背包题，背包容量是蚂蚁当前剩余的体力值。<br>每个物品的价值就是食物的体积，所占的背包容量的大小就是距离乘2（因为还要回来）。<br>然后比较最多能达到的食物体积，与需要的最少的食物体积进行标比较就行了。01背包的部分套板子写的<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">int n,e,v;</span><br><span class="line">const int maxn=100005;</span><br><span class="line">int si[maxn],jia[maxn],dp[100005];</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">memset(dp,0,sizeof(dp));</span><br><span class="line">cin&gt;&gt;n&gt;&gt;e&gt;&gt;v;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;si[i]&gt;&gt;jia[i];</span><br><span class="line">si[i]*=2;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=e;j&gt;=si[i];j--)</span><br><span class="line">&#123;</span><br><span class="line">dp[j]=max(dp[j],dp[j-si[i]]+jia[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(dp[e]&gt;=v)puts(&quot;YES&quot;);</span><br><span class="line">elseputs(&quot;NO&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="蚂蚁平面"><a href="#蚂蚁平面" class="headerlink" title="蚂蚁平面"></a>蚂蚁平面</h3><p>Description:<br>平面上有 n只蚂蚁，它走过的路径可以看作一条直线</p><p>由这n 条直线定义的某些区域是无界的，而另一些区域则是有界的。</p><p>有界区域的最大个数是多少？</p><p>比如现在有4条直线，只有下面最左边的图中直线定义的有界区域是最多的</p><p><img src="http://drew.todest.cn/jay.png" alt></p><p>输入格式</p><blockquote><p>T 组输入, (1≤T≤100)<br>每组一个数 n ，(1≤n≤109)</p></blockquote><p>输出格式</p><blockquote><p>对于每组数据，输出一个整数表示有界区域的最大个数。</p></blockquote><p>样例</p><p>input</p><blockquote><p>1<br>4</p></blockquote><p>output</p><blockquote><p>3</p></blockquote><p>Problem solving:<br>这道题就是一个公式，n条线能组成的有界区域的最大个数是从1加到n。<br>比赛时候谁知道这是公式啊，画图画到5条线的时候发现的规律写了一遍交了，嘿，还真过了。<br>佩服用矩快的同学，我是真的不知道咋构建矩阵。<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">ll n,t;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">ll ans;</span><br><span class="line">ans=(n-1)*(n-2)/2;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="蚂蚁和斐波那契"><a href="#蚂蚁和斐波那契" class="headerlink" title="蚂蚁和斐波那契"></a>蚂蚁和斐波那契</h3><p>Description:<br>聪明的小蚂蚁最近学习了斐波那契数列,但是它想到了一个问题：<br>从L到R之间斐波那契数列和的奇偶是什么呢？<br>其中Fib[1]=1,Fib[2]=1 .</p><p>输入格式</p><blockquote><p>单组输入:<br>每组输入两个以空格隔开的数字 L 和 R<br>其中 (0&lt;L&lt;=R&lt;1e18)</p></blockquote><p>输出格式</p><blockquote><p>从 L 到 R 斐波那契数列和的奇偶，如果是奇数输出 &quot;1&quot; (不带引号) ，否则输出 &quot;0&quot; (不带引号)</p></blockquote><p>样例<br>input</p><blockquote><p>1 2</p></blockquote><p>output</p><blockquote><p>0</p></blockquote><p>Problem solving:<br>这道题就是个找规律的题没啥好说的，看代码自行体会吧。（我可能写的麻烦了）</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll ans[55];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">ll mid,miid,l,r;</span><br><span class="line">cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">mid=l%3,miid=r%3;</span><br><span class="line">if(mid==0&amp;&amp;miid==0)puts(&quot;0&quot;);</span><br><span class="line">else if(mid==miid)puts(&quot;1&quot;);</span><br><span class="line">else if(mid==0&amp;&amp;miid==1)puts(&quot;1&quot;);</span><br><span class="line">else if(mid==0&amp;&amp;miid==2)puts(&quot;0&quot;);</span><br><span class="line">else if(mid==1&amp;&amp;miid==0)puts(&quot;0&quot;);</span><br><span class="line">else if(mid==2&amp;&amp;miid==0)puts(&quot;1&quot;);</span><br><span class="line">else if(mid==2&amp;&amp;miid==1)puts(&quot;0&quot;);</span><br><span class="line">else if(mid==1&amp;&amp;miid==2)puts(&quot;0&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="蚂蚁装修"><a href="#蚂蚁装修" class="headerlink" title="蚂蚁装修"></a>蚂蚁装修</h3><p>Description:<br>还有一个月就开学了，爱学习的小蚂蚁想庆祝一下！于是它要把它的“家”装修一下。<br>首先要做的就是贴地板。<br>小蚂蚁“家”的地面可以看成一个2∗N 的方格 ，它拥有无数块1∗2 和 2∗1的地板。<br>请你帮下蚂蚁计算一下一共有多少种方法能把地面给放满 。<br>地板不能切割，也不能重叠。</p><p>输入格式</p><blockquote><p>单组输入：<br>只有一个数字 N<br>其中 (0&lt;N&lt;1e18)</p></blockquote><p>输出格式</p><blockquote><p>输出放法数对1e9+7取模的结果</p></blockquote><p>样例<br>input</p><blockquote><p>2</p></blockquote><p>output</p><blockquote><p>2</p></blockquote><p>input</p><blockquote><p>1</p></blockquote><p>output</p><blockquote><p>1</p></blockquote><p>Problem solving:<br>手动画了几个状态，发现这个个数就是斐波那契数列，但是要求的最大的是1e18项，所以正好可以用矩快解决。注意用long long</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int  mod=1e9+7;</span><br><span class="line">typedef long long ll;</span><br><span class="line">struct node&#123;</span><br><span class="line">ll m[2][2];</span><br><span class="line">&#125;;</span><br><span class="line">node mul(node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">node ans;</span><br><span class="line">memset(ans.m,0,sizeof(ans.m));</span><br><span class="line">for(ll i=0;i&lt;2;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(ll j=0;j&lt;2;j++)</span><br><span class="line">&#123;</span><br><span class="line">for(ll k=0;k&lt;2;k++)</span><br><span class="line">&#123;</span><br><span class="line">ans.m[i][j]=(ans.m[i][j]+a.m[i][k]*b.m[k][j])%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line">&#125;</span><br><span class="line">node poww(node a,ll b)</span><br><span class="line">&#123;</span><br><span class="line">node ans;</span><br><span class="line">memset(ans.m,0,sizeof(ans.m));</span><br><span class="line">for(ll i=0;i&lt;2;i++)ans.m[i][i]=1;</span><br><span class="line">while(b)</span><br><span class="line">&#123;</span><br><span class="line">if(b&amp;1)ans=mul(ans,a);</span><br><span class="line">a=mul(a,a);</span><br><span class="line">b/=2;</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line">&#125;</span><br><span class="line">node si,jia;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">si.m[0][0]=2,si.m[1][0]=1,si.m[0][1]=0,si.m[1][1]=0;</span><br><span class="line">jia.m[0][0]=1,jia.m[1][0]=1,jia.m[0][1]=1,jia.m[1][1]=0;</span><br><span class="line">ll n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">if(n==1)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;1%mod&lt;&lt;endl;return 0;</span><br><span class="line">&#125;</span><br><span class="line">if(n==2)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;2%mod&lt;&lt;endl;return 0;</span><br><span class="line">&#125;</span><br><span class="line">node xiaozhu=poww(jia,n-2);</span><br><span class="line">xiaozhu=mul(xiaozhu,si);</span><br><span class="line">cout&lt;&lt;xiaozhu.m[0][0]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="蚂蚁的镜像串"><a href="#蚂蚁的镜像串" class="headerlink" title="蚂蚁的镜像串"></a>蚂蚁的镜像串</h3><p>Description:</p><p>Problem solving:<br>这道题，，是真的坑啊。<br>把可以组成镜像串的字母列出来，判断每一个字符，如果出现了不可以组成镜像串的直接就不是镜像串了。如果你也是这样想的这么单纯，恭喜你你会WA很多次。WA到怀疑人生那种。<br>因为bdpq他们也是可以组成镜像串的。<br>知道了这一点就可以很简单的解决这个问题了</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t;</span><br><span class="line">string s;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">int flag=1;</span><br><span class="line"> string mid=s;</span><br><span class="line"> reverse(mid.begin(),mid.end());</span><br><span class="line">for(int i=0;i&lt;s.size();i++)</span><br><span class="line">&#123;</span><br><span class="line">if((s[i]==&apos;b&apos;&amp;&amp;mid[i]==&apos;d&apos;)||(s[i]==&apos;d&apos;&amp;&amp;mid[i]==&apos;b&apos;)||(s[i]==&apos;p&apos;&amp;&amp;mid[i]==&apos;q&apos;)||(s[i]==&apos;q&apos;&amp;&amp;mid[i]==&apos;p&apos;)||(s[i]==mid[i]&amp;&amp;(s[i]==&apos;A&apos;||s[i]==&apos;H&apos;||s[i]==&apos;I&apos;||s[i]==&apos;i&apos;||s[i]==&apos;l&apos;||s[i]==&apos;M&apos;||s[i]==&apos;m&apos;||s[i]==&apos;n&apos;||s[i]==&apos;O&apos;||s[i]==&apos;o&apos;||s[i]==&apos;T&apos;||s[i]==&apos;U&apos;||s[i]==&apos;u&apos;||s[i]==&apos;V&apos;||s[i]==&apos;v&apos;||s[i]==&apos;W&apos;||s[i]==&apos;w&apos;||s[i]==&apos;X&apos;||s[i]==&apos;x&apos;||s[i]==&apos;Y&apos;)))</span><br><span class="line">&#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">flag=0;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(flag==1)puts(&quot;YES&quot;);</span><br><span class="line">elseputs(&quot;NO&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="蚂蚁赛跑"><a href="#蚂蚁赛跑" class="headerlink" title="蚂蚁赛跑"></a>蚂蚁赛跑</h3><p>Description:<br>小白和小黑非常喜欢养蚂蚁，他们每个人都养了n只蚂蚁。<br>有一天，他们想比一比谁养蚂蚁的本领更强，于是就举办了一场蚂蚁赛跑比赛。假设蚂蚁都是匀速直线奔跑。<br>比赛的规则是这样的：每只蚂蚁必须且最多比一场，赢一场得10分，输一场扣10分。平局都不得分也不扣分。<br>狡猾的小黑同学为了赢得比赛，提前偷到了小白所有蚂蚁得速度，请你帮小黑算一算，他在比赛中最多得多少分。</p><p>输入格式</p><blockquote><p>有多组测试案例，最多有100组，对于每一组案例：<br>第一行以正整数n ,（n≤1000），即每个人的蚂蚁数量。<br>第二行的n个整数是小黑的蚂蚁的速度。<br>第三行的n整数是小白的蚂蚁速度。<br>蚂蚁的速度小于100</p></blockquote><p>输出格式</p><blockquote><p>对于每个输入案例，输出一个整数，这是小黑能够获得的最大分数。</p></blockquote><p>样例<br>input</p><blockquote><p>2<br>10 10<br>10 10<br>2<br>10 1<br>100 8</p></blockquote><p>output</p><blockquote><p>0<br>0</p></blockquote><p>Problem solving:<br>贪心，但是我们贪出来，等到我够贪心了再补上</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *　　　　　　　　┏┓　　 　┏┓</span><br><span class="line"> * 　　　　　　　┏┛┗━━━━━━━┛┗━━━┓</span><br><span class="line"> * 　　　　　　　┃　　　　　　　┃ 　</span><br><span class="line"> * 　　　　　　　┃　　　━　　 　┃</span><br><span class="line"> * 　　　　　　　┃　＞　　　＜　┃</span><br><span class="line"> * 　　　　　　　┃　　　　　　　┃</span><br><span class="line"> * 　　　　　　　┃...　⌒　... 　┃</span><br><span class="line"> * 　　　　　　　┃　　　　　　　┃</span><br><span class="line"> * 　　　　　　　┗━┓　　　┏━┛</span><br><span class="line"> * 　　　　　　　　　┃　　　┃　Code is far away from bug with the animal protecting　　　　　　　　　　</span><br><span class="line"> * 　　　　　　　　　┃　　　┃   神兽保佑,代码无bug</span><br><span class="line"> * 　　　　　　　　　┃　　　┃　　　　　　　　　　　</span><br><span class="line"> * 　　　　　　　　　┃　　　┃  　　　　　　</span><br><span class="line"> * 　　　　　　　　　┃　　　┃</span><br><span class="line"> * 　　　　　　　　　┃　　　┃　　　　　　　　　　　</span><br><span class="line"> * 　　　　　　　　　┃　　　┗━━━┓</span><br><span class="line"> * 　　　　　　　　　┃　　　　　　　┣┓</span><br><span class="line"> * 　　　　　　　　　┃　　　　　　　┏┛</span><br><span class="line"> * 　　　　　　　　　┗┓┓┏━┳┓┏┛</span><br><span class="line"> * 　　　　　　　　　　┃┫┫　┃┫┫</span><br><span class="line"> * 　　　　　　　　　　┗┻┛　┗┻┛</span><br><span class="line"> */</span><br><span class="line">// warm heart, wagging tail,and a smile just for you!</span><br><span class="line">//</span><br><span class="line">//                            _ooOoo_</span><br><span class="line">//                           o8888888o</span><br><span class="line">//                           88&quot; . &quot;88</span><br><span class="line">//                           (| -_- |)</span><br><span class="line">//                           O\  =  /O</span><br><span class="line">//                        ____/`---&apos;\____</span><br><span class="line">//                      .&apos;  \|     |//  `.</span><br><span class="line">//                     /  \|||  :  |||//  \</span><br><span class="line">//                    /  _||||| -:- |||||-  \</span><br><span class="line">//                    |   | \\  -  /// |   |</span><br><span class="line">//                    | \_|  &apos;&apos;\---/&apos;&apos;  |   |</span><br><span class="line">//                    \  .-\__  `-`  ___/-. /</span><br><span class="line">//                  ___`. .&apos;  /--.--\  `. . __</span><br><span class="line">//               .&quot;&quot; &apos;&lt;  `.___\_&lt;|&gt;_/___.&apos;  &gt;&apos;&quot;&quot;.</span><br><span class="line">//              | | :  `- \`.;`\ _ /`;.`/ - ` : | |</span><br><span class="line">//              \  \ `-.   \_ __\ /__ _/   .-` /  /</span><br><span class="line">//         ======`-.____`-.___\_____/___.-`____.-&apos;======</span><br><span class="line">//                            `=---=&apos;</span><br><span class="line">//        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class="line">//</span><br></pre></td></tr></table></figure></p><h3 id="蚂蚁上树"><a href="#蚂蚁上树" class="headerlink" title="蚂蚁上树"></a>蚂蚁上树</h3><p>Description:<br>蚂蚁上树（Sauteed Vermicelli with minced Pork），又名肉末粉条，是四川省及重庆市的特色传统名菜之一。因肉末贴在粉丝上，形似蚂蚁爬在树枝上而得名。这道菜具体的历史，已不可考。但在四川省、重庆市一带，该菜很常见。</p><p>蚂蚁上树通常由粉丝（或者粉条）、肉末为主料，辅以胡萝卜、姜、葱、豆瓣酱等辅料制作而成。成菜后，口味清淡，爽滑美味，色泽红亮，食之别有风味。</p><p>蚂蚁想知道这棵树上距离最远的两个点之间的距离</p><p>给你一个具有 n 个节点的树</p><p>求这棵树上距离最远的两个点之间的距离</p><p>输入格式</p><blockquote><p>第一行一个整数 n ，(1≤n≤1e4)<br>接下来 n−1 行，每行三个整数 x,y,z 表示 x 与 y 之间有一条长度为 z 的边 (1≤x,y≤n,1≤z≤104)</p></blockquote><p>输出格式</p><blockquote><p>一个整数表示树上距离最远的两个点之间的距离</p></blockquote><p>样例<br>input</p><blockquote><p>5<br>1 2 9<br>1 3 3<br>1 5 2<br>2 4 10</p></blockquote><p>output</p><blockquote><p>22</p></blockquote><p>Problem solving:<br>求树的直径，套班子就行啦，别忘了long long</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn=1e4+10;</span><br><span class="line">ll n,x,y,z,dis[maxn],vis[maxn];</span><br><span class="line">vector&lt;pair&lt;int,int&gt; &gt; v[maxn];</span><br><span class="line">void bfs(ll x)</span><br><span class="line">&#123;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">q.push(x);</span><br><span class="line">vis[x]=1;</span><br><span class="line">dis[x]=0;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">x=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">for(int i=0;i&lt;v[x].size();i++)</span><br><span class="line">&#123;</span><br><span class="line">if(!vis[v[x][i].first])</span><br><span class="line">&#123;</span><br><span class="line">q.push(v[x][i].first);</span><br><span class="line">dis[v[x][i].first]=dis[x]+v[x][i].second;</span><br><span class="line">vis[v[x][i].first]=1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i=0;i&lt;n-1;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">v[x].push_back(make_pair(y,z));</span><br><span class="line">v[y].push_back(make_pair(x,z));</span><br><span class="line">&#125;</span><br><span class="line">bfs(1);</span><br><span class="line">ll si=0,jia,ans=0;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(dis[i]&gt;si)</span><br><span class="line">&#123;</span><br><span class="line">si=dis[i];</span><br><span class="line">jia=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">memset(dis,0,sizeof(dis));</span><br><span class="line">bfs(jia);</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">ans=max(ans,dis[i]);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="蚂蚁的游戏"><a href="#蚂蚁的游戏" class="headerlink" title="蚂蚁的游戏"></a>蚂蚁的游戏</h3><p>Description:<br>蚂蚁Bob和蚂蚁Alice是青梅竹蚁，Alice喜欢和Bob一起玩游戏，每当Alice想到新的游戏，都会找Bob一起玩</p><p>今天Alice的游戏是这样的：</p><p>n堆石子，两人轮流取。每次只能在1堆中取，不能不取，最先取完石子者胜</p><p>Alice先取石子，Alice和Bob都非常聪明，拿石子的过程中不会出现失误。</p><p>输入格式</p><blockquote><p>第一行有一个整数T，有T组输入数据(T≤50)<br>每组第一行有一个数n表示有n堆石子，(1≤n≤20000)<br>第二行有n个非零整数x，表示每堆石子的数量(x≤1e3)</p></blockquote><p>输出格式</p><blockquote><p>请你判断Alice能否在游戏中获胜，如果不能获胜，输出NO。<br>否则，输出YES，并输出第一次取石子的所有方法（具体参见样例和提示）</p></blockquote><p>样例<br>input</p><blockquote><p>2<br>2<br>45 45<br>5<br>5 7 8 9 10</p></blockquote><p>output</p><blockquote><p>NO<br>YES<br>3 1<br>4 0<br>5 3</p></blockquote><p>提示<br>对于第一组样例，不论Alice怎么取，Bob总能拿到最后一个石子，所以输出为NO</p><p>对于第二组样例，Alice可以第一次取石子有三种取法：</p><p>第3堆取出7个，剩下1个<br>第4堆全部取出，剩下0个<br>第5堆取出7个，剩下3个<br>对于每组输出，总是按照堆的编号顺序输出的<br>Problem solving:<br>博弈论的问题，好像有板子可以套，但是我并不会。学会了再补吧</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *　　　　　　　　┏┓　　 　┏┓</span><br><span class="line"> * 　　　　　　　┏┛┗━━━━━━━┛┗━━━┓</span><br><span class="line"> * 　　　　　　　┃　　　　　　　┃ 　</span><br><span class="line"> * 　　　　　　　┃　　　━　　 　┃</span><br><span class="line"> * 　　　　　　　┃　＞　　　＜　┃</span><br><span class="line"> * 　　　　　　　┃　　　　　　　┃</span><br><span class="line"> * 　　　　　　　┃...　⌒　... 　┃</span><br><span class="line"> * 　　　　　　　┃　　　　　　　┃</span><br><span class="line"> * 　　　　　　　┗━┓　　　┏━┛</span><br><span class="line"> * 　　　　　　　　　┃　　　┃　Code is far away from bug with the animal protecting　　　　　　　　　　</span><br><span class="line"> * 　　　　　　　　　┃　　　┃   神兽保佑,代码无bug</span><br><span class="line"> * 　　　　　　　　　┃　　　┃　　　　　　　　　　　</span><br><span class="line"> * 　　　　　　　　　┃　　　┃  　　　　　　</span><br><span class="line"> * 　　　　　　　　　┃　　　┃</span><br><span class="line"> * 　　　　　　　　　┃　　　┃　　　　　　　　　　　</span><br><span class="line"> * 　　　　　　　　　┃　　　┗━━━┓</span><br><span class="line"> * 　　　　　　　　　┃　　　　　　　┣┓</span><br><span class="line"> * 　　　　　　　　　┃　　　　　　　┏┛</span><br><span class="line"> * 　　　　　　　　　┗┓┓┏━┳┓┏┛</span><br><span class="line"> * 　　　　　　　　　　┃┫┫　┃┫┫</span><br><span class="line"> * 　　　　　　　　　　┗┻┛　┗┻┛</span><br><span class="line"> */</span><br><span class="line">// warm heart, wagging tail,and a smile just for you!</span><br><span class="line">//</span><br><span class="line">//                            _ooOoo_</span><br><span class="line">//                           o8888888o</span><br><span class="line">//                           88&quot; . &quot;88</span><br><span class="line">//                           (| -_- |)</span><br><span class="line">//                           O\  =  /O</span><br><span class="line">//                        ____/`---&apos;\____</span><br><span class="line">//                      .&apos;  \|     |//  `.</span><br><span class="line">//                     /  \|||  :  |||//  \</span><br><span class="line">//                    /  _||||| -:- |||||-  \</span><br><span class="line">//                    |   | \\  -  /// |   |</span><br><span class="line">//                    | \_|  &apos;&apos;\---/&apos;&apos;  |   |</span><br><span class="line">//                    \  .-\__  `-`  ___/-. /</span><br><span class="line">//                  ___`. .&apos;  /--.--\  `. . __</span><br><span class="line">//               .&quot;&quot; &apos;&lt;  `.___\_&lt;|&gt;_/___.&apos;  &gt;&apos;&quot;&quot;.</span><br><span class="line">//              | | :  `- \`.;`\ _ /`;.`/ - ` : | |</span><br><span class="line">//              \  \ `-.   \_ __\ /__ _/   .-` /  /</span><br><span class="line">//         ======`-.____`-.___\_____/___.-`____.-&apos;======</span><br><span class="line">//                            `=---=&apos;</span><br><span class="line">//        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class="line">//</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天如期举行了第三场积分赛，没啥好说的，还是那句话&lt;br&gt;积分赛，被打爆的积分赛(music
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="Algorithm" scheme="https://cndrew.cn/blog/tags/Algorithm/"/>
    
      <category term="c/c++" scheme="https://cndrew.cn/blog/tags/c-c/"/>
    
      <category term="Greedy" scheme="https://cndrew.cn/blog/tags/Greedy/"/>
    
      <category term="HPUOJ" scheme="https://cndrew.cn/blog/tags/HPUOJ/"/>
    
      <category term="Thinking" scheme="https://cndrew.cn/blog/tags/Thinking/"/>
    
      <category term="BFS" scheme="https://cndrew.cn/blog/tags/BFS/"/>
    
      <category term="矩阵快速幂" scheme="https://cndrew.cn/blog/tags/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
      <category term="树的直径" scheme="https://cndrew.cn/blog/tags/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"/>
    
      <category term="dp" scheme="https://cndrew.cn/blog/tags/dp/"/>
    
      <category term="背包" scheme="https://cndrew.cn/blog/tags/%E8%83%8C%E5%8C%85/"/>
    
      <category term="博弈论" scheme="https://cndrew.cn/blog/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>HPU Summer Day 17(河南理工大学暑期第十七天)</title>
    <link href="https://cndrew.cn/blog/2019/08/02/d17/"/>
    <id>https://cndrew.cn/blog/2019/08/02/d17/</id>
    <published>2019-08-01T16:00:00.000Z</published>
    <updated>2019-08-03T13:27:04.863Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天学长没拉题，给了我充足的时间搞了我一直想搞的东西——给自己做一个专属的头像。当然还是刷了大半天的题的，虽然一道没过。<a id="more"></a><br>我喜欢欧文，喜欢德鲁大叔。也忘了这张图是在哪找到的，但是这也太和我胃口了。<br><img src="http://drew.todest.cn/drew.jpg" alt><br>主体上是德鲁大叔的动漫头像，右手拿着个篮球，右手拿着个地球仪，这个地球仪说法可厉害了。当时欧文在接受采访时说道：我相信地球是平的。这就是欧文的“地平说”。把欧文的最耀眼的三个元素糅合在了一张图我是真的喜欢的没话说。以后怕是不会换头像了。<br>好看是好看，但毕竟是网上下载的，所以可能会有很多人跟我用一样的头像（虽然现在还没遇见。<br>然后我正好有时间，就给他P一下吧<br>P完之后的我的头像<br><img src="http://drew.todest.cn/dreww.jpg" alt><br>第一步我在它衣服的左侧添加了一个ICPC的logo，表明了我<del>~JBer</del>~ACMer的身份。<br>然后你仔细看会发现右下角有一个若隐若现的德鲁大叔妆容二号骑士球衣的欧文扭头在看着你（不仔细看是看不见的）。我最喜欢的就是欧文在骑士的时候。所以这个设计我也是很满意。<br>最后我在左下角加了<code>@cndrew</code>宣告一下主权，哈哈这就结束了。我在ps的时候也是一步一百度，也是学到了不少东西。这次接触ps，让我对ps产生了浓厚的兴趣，以后还会深入学习的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天学长没拉题，给了我充足的时间搞了我一直想搞的东西——给自己做一个专属的头像。当然还是刷了大半天的题的，虽然一道没过。
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="life" scheme="https://cndrew.cn/blog/tags/life/"/>
    
      <category term="Photoshop" scheme="https://cndrew.cn/blog/tags/Photoshop/"/>
    
  </entry>
  
  <entry>
    <title>HPU Summer Day 16(河南理工大学暑期第十六天)</title>
    <link href="https://cndrew.cn/blog/2019/08/01/d16/"/>
    <id>https://cndrew.cn/blog/2019/08/01/d16/</id>
    <published>2019-08-01T12:10:34.187Z</published>
    <updated>2019-08-01T12:31:18.535Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天主要学习了矩阵快速幂的计算以及相关问题的解决方法。题还是挺好写的，矩阵快速幂也挺好理解的，实在不行的话记模板也不错。<a id="more"></a></p><h3 id="求递推序列的第N项"><a href="#求递推序列的第N项" class="headerlink" title="求递推序列的第N项"></a>求递推序列的第N项</h3><p>Description:<br>有一个序列是这样定义的：f(1) = 1, f(2) = 1, f(n) = (A * f(n - 1) + B * f(n - 2)) mod 7.<br>给出A，B和N，求f(n)的值。<br>输入</p><blockquote><p>输入3个数：A,B,N。数字之间用空格分割。(-10000 &lt;= A, B &lt;= 10000, 1 &lt;= N &lt;= 10^9)</p></blockquote><p>输出</p><blockquote><p>输出f(n)的值。</p></blockquote><p>输入样例</p><blockquote><p>3 -1 5</p></blockquote><p>输出样例</p><blockquote><p>6</p></blockquote><p>Problem solving:<br>这道题的意思是给你一个递推公式，求出第n项的值。</p><p>如果直接递推的话，1e9的n一定是会超时的。这时候矩阵快速幂大显身手。<br>只需要构造出来两个矩阵就行，板子题。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">int m[5][5];</span><br><span class="line">&#125;;</span><br><span class="line">node mm,p;</span><br><span class="line">node mul(node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">node now;</span><br><span class="line">memset(now.m,0,sizeof(now.m));</span><br><span class="line">for(int i=1;i&lt;=2;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=1;j&lt;=2;j++)</span><br><span class="line">&#123;</span><br><span class="line">for(int k=1;k&lt;=2;k++)</span><br><span class="line">&#123;</span><br><span class="line">now.m[i][j]=((now.m[i][j]+a.m[i][k]*b.m[k][j])+7)%7;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return now;</span><br><span class="line">&#125;</span><br><span class="line">node poww(node a,int b)</span><br><span class="line">&#123;</span><br><span class="line">node ans;</span><br><span class="line">memset(ans.m,0,sizeof(ans.m));</span><br><span class="line">for(int i=1;i&lt;=2;i++)ans.m[i][i]=1;</span><br><span class="line">while(b)</span><br><span class="line">&#123;</span><br><span class="line">if(b&amp;1)ans=mul(ans,a);</span><br><span class="line">b/=2;</span><br><span class="line">a=mul(a,a);</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a,b,k;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b&gt;&gt;k;</span><br><span class="line">mm.m[1][1]=1,mm.m[2][1]=1;</span><br><span class="line">mm.m[2][2]=0,mm.m[1][2]=0;//构造的一个矩阵</span><br><span class="line">p.m[1][1]=a,p.m[1][2]=b,p.m[2][1]=1,p.m[2][2]=0;//构造的另一个矩阵</span><br><span class="line">if(k==1||k==2)</span><br><span class="line">&#123;</span><br><span class="line">puts(&quot;1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">node mid=poww(p,k-2);</span><br><span class="line">mid=mul(mid,mm);</span><br><span class="line">cout&lt;&lt;mid.m[1][1]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h3><p>Description:<br>给出一个N * N的矩阵，其中的元素均为正整数。求这个矩阵的M次方。由于M次方的计算结果太大，只需要输出每个元素Mod (10^9 + 7）的结果。</p><p>输入</p><blockquote><p>第1行：2个数N和M，中间用空格分隔。N为矩阵的大小，M为M次方。(2 &lt;= N &lt;= 100, 1 &lt;= M &lt;= 10^9)<br>第2 - N + 1行：每行N个数，对应N * N矩阵中的1行。(0 &lt;= N[i] &lt;= 10^9)</p></blockquote><p>输出</p><blockquote><p>共N行，每行N个数，对应M次方Mod (10^9 + 7)的结果。</p></blockquote><p>输入样例</p><blockquote><p>2 3<br>1 1<br>1 1</p></blockquote><p>输出样例</p><blockquote><p>4 4<br>4 4</p></blockquote><p>Problem solving:<br>这个就是个板子题，直接写就行了。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e9+7;</span><br><span class="line">typedef long long ll;</span><br><span class="line">struct node&#123;</span><br><span class="line">ll m[105][105];</span><br><span class="line">&#125;;</span><br><span class="line">ll n,k;</span><br><span class="line">node mul(node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">node ans;</span><br><span class="line">memset(ans.m,0,sizeof(ans.m));</span><br><span class="line">for(ll i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(ll j=0;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line">for(ll k=0;k&lt;n;k++)</span><br><span class="line">&#123;</span><br><span class="line">ans.m[i][j]=(ans.m[i][j]+a.m[i][k]*b.m[k][j])%maxn;//这里已经要先+再取模。坑点</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line">&#125;</span><br><span class="line">node poww(node a,ll b)</span><br><span class="line">&#123;</span><br><span class="line">node now;</span><br><span class="line">memset(now.m,0,sizeof(now.m));</span><br><span class="line">for(ll i=0;i&lt;n;i++)now.m[i][i]=1;</span><br><span class="line">while(b)</span><br><span class="line">&#123;</span><br><span class="line">if(b&amp;1)now=mul(now,a);</span><br><span class="line">b/=2;</span><br><span class="line">a=mul(a,a);</span><br><span class="line">&#125;</span><br><span class="line">return now;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">node ans;</span><br><span class="line">for(ll i=0;i&lt;n;i++)</span><br><span class="line">for(ll j=0;j&lt;n;j++)</span><br><span class="line">cin&gt;&gt;ans.m[i][j];</span><br><span class="line">ans=poww(ans,k);</span><br><span class="line">for(ll i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(ll j=0;j&lt;n;j++)</span><br><span class="line">cout&lt;&lt;ans.m[i][j]&lt;&lt;&quot; &quot;;</span><br><span class="line">puts(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h3><p>Description:<br>给出2个N * N的矩阵M1和M2，输出2个矩阵相乘后的结果。<br>输入</p><blockquote><p>第1行：1个数N，表示矩阵的大小(2 &lt;= N &lt;= 100)<br>第2 - N + 1行，每行N个数，对应M1的1行(0 &lt;= M1[i] &lt;= 1000)<br>第N + 2 - 2N + 1行，每行N个数，对应M2的1行(0 &lt;= M2[i] &lt;= 1000)</p></blockquote><p>输出</p><blockquote><p>输出共N行，每行N个数，对应M1 * M2的结果的一行。</p></blockquote><p>输入样例</p><blockquote><p>2<br>1 0<br>0 1<br>0 1<br>1 0</p></blockquote><p>输出样例</p><blockquote><p>0 1<br>1 0</p></blockquote><p>Problem solving:<br>考察了矩阵相乘的实现<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">int m[105][105];</span><br><span class="line">&#125;;</span><br><span class="line">node a,b;</span><br><span class="line">int n;</span><br><span class="line">node mul(node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">node ans;</span><br><span class="line">memset(ans.m,0,sizeof(ans.m));</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">for(int j=0;j&lt;n;j++)</span><br><span class="line">for(int k=0;k&lt;n;k++)</span><br><span class="line">ans.m[i][j]=ans.m[i][j]+a.m[i][k]*b.m[k][j];//矩阵相乘就是通过这三个for循环实现的</span><br><span class="line">return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">for(int j=0;j&lt;n;j++)</span><br><span class="line">cin&gt;&gt;a.m[i][j];</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">for(int j=0;j&lt;n;j++)</span><br><span class="line">cin&gt;&gt;b.m[i][j];</span><br><span class="line">node ans=mul(a,b);</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;n;j++)</span><br><span class="line">cout&lt;&lt;ans.m[i][j]&lt;&lt;&quot; &quot;;</span><br><span class="line">puts(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Fibonacci"><a href="#Fibonacci" class="headerlink" title="Fibonacci"></a>Fibonacci</h3><p>Description:<br>菲波那契数列是指这样的数列: 数列的第一个是0和第二个数是1，接下来每个数都等于前面2个数之和。 给出一个正整数a，要求菲波那契数列中第a个数的后四位是多少。<br>Input</p><blockquote><p>多组数据 -1结束 范围1~10^9</p></blockquote><p>Output</p><blockquote><p>第x项的后4位</p></blockquote><p>Sample Input</p><blockquote><p>0<br>9<br>999999999<br>1000000000<br>-1</p></blockquote><p>Sample Output</p><blockquote><p>0<br>34<br>626<br>6875</p></blockquote><p>Problem solving:<br>然后毒瘤题意还是忽略了吧，直接看样例妥了<br>求斐波那契的第n项。其实就是给了你递推式，构造出来矩阵就行了。要求输出后四位其实就是对10000取模，每次计算出来都取模，就避免了爆精度的问题。<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod=10000;</span><br><span class="line">struct node&#123;</span><br><span class="line">int m[3][3];</span><br><span class="line">&#125;;</span><br><span class="line">typedef long long ll;</span><br><span class="line">node mm,p;</span><br><span class="line">node mul(node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">node ans;</span><br><span class="line">memset(ans.m,0,sizeof(ans.m));</span><br><span class="line">for(ll i=1;i&lt;=2;i++)</span><br><span class="line">for(ll j=1;j&lt;=2;j++)</span><br><span class="line">for(ll k=1;k&lt;=2;k++)</span><br><span class="line">ans.m[i][j]=((ans.m[i][j]+a.m[i][k]*b.m[k][j])%mod)%mod;</span><br><span class="line">return ans;</span><br><span class="line">&#125;</span><br><span class="line">node poww(node a,ll b)</span><br><span class="line">&#123;</span><br><span class="line">node ans;</span><br><span class="line">memset(ans.m,0,sizeof(ans.m));</span><br><span class="line">for(ll i=1;i&lt;=2;i++)ans.m[i][i]=1;</span><br><span class="line">while(b)</span><br><span class="line">&#123;</span><br><span class="line">if(b&amp;1)ans=mul(ans,a);</span><br><span class="line">a=mul(a,a);</span><br><span class="line">b/=2;</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">ll n;</span><br><span class="line">p.m[1][1]=1,p.m[1][2]=1,p.m[2][1]=1,p.m[2][2]=0;</span><br><span class="line">mm.m[1][1]=1,mm.m[2][1]=1,mm.m[2][2]=0,mm.m[1][2]=0;</span><br><span class="line">while(cin&gt;&gt;n&amp;&amp;n!=-1)</span><br><span class="line">&#123;</span><br><span class="line">if(n==0)</span><br><span class="line">&#123;</span><br><span class="line">puts(&quot;0&quot;);</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">if(n==1||n==2)</span><br><span class="line">&#123;</span><br><span class="line">puts(&quot;1&quot;);</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">node mid=poww(p,n-2);</span><br><span class="line">mid=mul(mid,mm);</span><br><span class="line">cout&lt;&lt;mid.m[1][1]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Tr-A"><a href="#Tr-A" class="headerlink" title="Tr A"></a>Tr A</h3><p>Description:<br>A为一个方阵，则Tr A表示A的迹（就是主对角线上各项的和），现要求Tr(A^k)%9973。<br>Input</p><blockquote><p>数据的第一行是一个T，表示有T组数据。<br>每组数据的第一行有n(2 &lt;= n &lt;= 10)和k(2 &lt;= k &lt; 10^9)两个数据。接下来有n行，每行有n个数据，每个数据的范围是[0,9]，表示方阵A的内容。</p></blockquote><p>Output</p><blockquote><p>对应每组数据，输出Tr(A^k)%9973。</p></blockquote><p>Sample Input</p><blockquote><p>2<br>2 2<br>1 0<br>0 1<br>3 99999999<br>1 2 3<br>4 5 6<br>7 8 9</p></blockquote><p>Sample Output</p><blockquote><p>2<br>2686</p></blockquote><p>Problem solving:<br>直接运用矩阵快速幂求出最后状态的矩阵，对角线相加就行了</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,k;</span><br><span class="line">struct node&#123;</span><br><span class="line">int m[15][15];</span><br><span class="line">&#125;;</span><br><span class="line">node now;</span><br><span class="line">node mul(node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">node ans;</span><br><span class="line">memset(ans.m,0,sizeof(ans.m));</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line">for(int k=0;k&lt;n;k++)</span><br><span class="line">&#123;</span><br><span class="line">ans.m[i][j]=(ans.m[i][j]+a.m[i][k]*b.m[k][j])%9973;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line">&#125;</span><br><span class="line">node poww(node a,int b)</span><br><span class="line">&#123;</span><br><span class="line">node ans;</span><br><span class="line">memset(ans.m,0,sizeof(ans.m));</span><br><span class="line">for(int i=0;i&lt;n;i++)ans.m[i][i]=1;</span><br><span class="line">while(b)</span><br><span class="line">&#123;</span><br><span class="line">if(b&amp;1)ans=mul(ans,a);</span><br><span class="line">a=mul(a,a);</span><br><span class="line">b/=2;</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;n;j++)</span><br><span class="line">cin&gt;&gt;now.m[i][j];</span><br><span class="line">&#125;</span><br><span class="line">node mid=poww(now,k);</span><br><span class="line">int ans=0;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">ans=(ans+mid.m[i][i])%9973;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="A-Simple-Math-Problem"><a href="#A-Simple-Math-Problem" class="headerlink" title="A Simple Math Problem"></a>A Simple Math Problem</h3><p>Description:<br>Lele now is thinking about a simple function f(x).</p><p>If x &lt; 10 f(x) = x.<br>If x &gt;= 10 f(x) = a0 * f(x-1) + a1 * f(x-2) + a2 * f(x-3) + …… + a9 * f(x-10);<br>And ai(0&lt;=i&lt;=9) can only be 0 or 1 .</p><p>Now, I will give a0 ~ a9 and two positive integers k and m ,and could you help Lele to caculate f(k)%m.</p><p>Input</p><blockquote><p>The problem contains mutiple test cases.Please process to the end of file.<br>In each case, there will be two lines.<br>In the first line , there are two positive integers k and m. ( k&lt;2*10^9 , m &lt; 10^5 )<br>In the second line , there are ten integers represent a0 ~ a9.</p></blockquote><p>Output</p><blockquote><p>For each case, output f(k) % m in one line.</p></blockquote><p>Sample Input</p><blockquote><p>10 9999<br>1 1 1 1 1 1 1 1 1 1<br>20 500<br>1 0 1 0 1 0 1 0 1 0</p></blockquote><p>Sample Output</p><blockquote><p>45<br>104</p></blockquote><p>Problem solving:<br>题意就是给你一个递推式求出第n项。</p><p>难点就是递推式有点长，但是这个跟斐波那契那个其实是一样的，构造的常数矩阵是<br><img src="http://drew.todest.cn/ZXIQ1YJDQWHLY3QOP_DJXTE.png" alt></p><p>常数矩阵都构造出来了，那么接下来的就是套版子了。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">struct node&#123;</span><br><span class="line">ll m[15][15];</span><br><span class="line">&#125;;</span><br><span class="line">ll k,m;</span><br><span class="line">node now,p;</span><br><span class="line"></span><br><span class="line">node mul(node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">node now;</span><br><span class="line">memset(now.m,0,sizeof(now.m));</span><br><span class="line">for(int i=0;i&lt;10;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;10;j++)</span><br><span class="line">&#123;</span><br><span class="line">for(int k=0;k&lt;10;k++)</span><br><span class="line">&#123;</span><br><span class="line">now.m[i][j]=(a.m[i][k]*b.m[k][j]+now.m[i][j])%m;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return now;</span><br><span class="line">&#125;</span><br><span class="line">node poww(node a,int b)</span><br><span class="line">&#123;</span><br><span class="line">node ans;</span><br><span class="line">memset(ans.m,0,sizeof(ans.m));</span><br><span class="line">for(int i=0;i&lt;10;i++)ans.m[i][i]=1;</span><br><span class="line">while(b)</span><br><span class="line">&#123;</span><br><span class="line">if(b&amp;1)ans=mul(ans,a);</span><br><span class="line">a=mul(a,a);</span><br><span class="line">b/=2;</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(cin&gt;&gt;k&gt;&gt;m)</span><br><span class="line">&#123;</span><br><span class="line">if(k&lt;=9)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;k&lt;&lt;endl;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;10;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;p.m[0][i];</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;10;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;10;j++)</span><br><span class="line">&#123;</span><br><span class="line">if(i-1==j)</span><br><span class="line">p.m[i][j]=1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;10;i++)now.m[i][0]=9-i;</span><br><span class="line">node ans=poww(p,k-9);</span><br><span class="line">ans=mul(ans,now);</span><br><span class="line">cout&lt;&lt;ans.m[0][0]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Recursive-sequence"><a href="#Recursive-sequence" class="headerlink" title="Recursive sequence"></a>Recursive sequence</h3><p>Description:</p><p>Problem solving:<br>也是给了递推式求第n项的问题，但是这个就比较难了，因为构建常数矩阵的时候会发现一个严肃的问题，n^4与(n+1)^4找关系的时候会很爆炸。</p><p>这时候我们就需要化简了。<br>(n+1)^4=n^4+4*n^3+6*n^2+4*n+1<br>(n+1)^3=n^3+3*n^2+3*n+1<br>(n+1)^2=n^2+2*n+1<br>n+1=n+1</p><p>所以我们构建出来的常数矩阵就是<br><img src="http://drew.todest.cn/1.png" alt></p><p>接下来就是计算了，套板子就行，一开始的矩阵是只有第一列有值得。<br>值分别为b,a,81,27,9,3,1</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll n,a,b;</span><br><span class="line">struct node&#123;</span><br><span class="line">ll m[7][7];</span><br><span class="line">&#125;;</span><br><span class="line">const ll mod=2147493647;</span><br><span class="line">node mm,p;</span><br><span class="line">node mul(node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">node now;</span><br><span class="line">memset(now.m,0,sizeof(now.m));</span><br><span class="line">for(ll i=0;i&lt;7;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(ll j=0;j&lt;7;j++)</span><br><span class="line">&#123;</span><br><span class="line">for(ll k=0;k&lt;7;k++)</span><br><span class="line">&#123;</span><br><span class="line">now.m[i][j]=(a.m[i][k]*b.m[k][j]+now.m[i][j])%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return now;</span><br><span class="line">&#125;</span><br><span class="line">node poww(node a,ll b)</span><br><span class="line">&#123;</span><br><span class="line">node ans;</span><br><span class="line">memset(ans.m,0,sizeof(ans.m));</span><br><span class="line">for(ll i=0;i&lt;10;i++)ans.m[i][i]=1;</span><br><span class="line">while(b)</span><br><span class="line">&#123;</span><br><span class="line">if(b&amp;1)ans=mul(ans,a);</span><br><span class="line">a=mul(a,a);</span><br><span class="line">b/=2;</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">ll t;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;a&gt;&gt;b;</span><br><span class="line">if(n==1)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">if(n==2)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">memset(mm.m,0,sizeof(mm.m));</span><br><span class="line">memset(p.m,0,sizeof(p.m));</span><br><span class="line">mm.m[0][0]=b,mm.m[1][0]=a;</span><br><span class="line">mm.m[2][0]=81,mm.m[3][0]=27,mm.m[4][0]=9,mm.m[5][0]=3,mm.m[6][0]=1;</span><br><span class="line">p.m[0][0]=1,p.m[0][1]=2,p.m[0][2]=1;</span><br><span class="line">p.m[1][0]=1;</span><br><span class="line">p.m[2][2]=1,p.m[2][3]=4,p.m[2][4]=6,p.m[2][5]=4,p.m[2][6]=1;</span><br><span class="line">p.m[3][3]=1,p.m[3][4]=3,p.m[3][5]=3,p.m[3][6]=1;</span><br><span class="line">p.m[4][4]=1,p.m[4][5]=2,p.m[4][6]=1;</span><br><span class="line">p.m[5][5]=1,p.m[5][6]=1;</span><br><span class="line">p.m[6][6]=1;</span><br><span class="line">node mid=poww(p,n-2);</span><br><span class="line">mid=mul(mid,mm);</span><br><span class="line">cout&lt;&lt;mid.m[0][0]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天主要学习了矩阵快速幂的计算以及相关问题的解决方法。题还是挺好写的，矩阵快速幂也挺好理解的，实在不行的话记模板也不错。
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="Algorithm" scheme="https://cndrew.cn/blog/tags/Algorithm/"/>
    
      <category term="c/c++" scheme="https://cndrew.cn/blog/tags/c-c/"/>
    
      <category term="HDU" scheme="https://cndrew.cn/blog/tags/HDU/"/>
    
      <category term="51nod" scheme="https://cndrew.cn/blog/tags/51nod/"/>
    
      <category term="矩阵快速幂" scheme="https://cndrew.cn/blog/tags/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
  </entry>
  
  <entry>
    <title>HPU Summer Day 15(河南理工大学暑期第十五天)</title>
    <link href="https://cndrew.cn/blog/2019/07/31/d15/"/>
    <id>https://cndrew.cn/blog/2019/07/31/d15/</id>
    <published>2019-07-31T14:05:08.076Z</published>
    <updated>2019-07-31T14:22:21.672Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天主要讲了01背包，完全背包，多重背包的相关东西。不太好理解，题也有点难。关于背包东西还有很多，慢慢学吧。<a id="more"></a></p><h3 id="Bone-Collector"><a href="#Bone-Collector" class="headerlink" title="Bone Collector"></a>Bone Collector</h3><p>Description:<br>涂奥最近迷上了吃鸡，房间有n个配件，每个配件有c(c&lt;=1e3)的重量和v(v&lt;=1e3)的价值，哇，涂奥捡了一个2级包，容量为s，所以涂奥最多当多肥的快递员呢？<br>Input</p><blockquote><p>输入的第一行是T, 表示有一共要打T场比赛.<br>每组数据由三行组成.<br>第1行包含两个整数n和s 第2行包含n个整数, 表示每一个配件的价值. 第3行包含n个整数, 表示每个配件的重量.</p></blockquote><p>Output</p><blockquote><p>对每一组数据, 输出涂奥可以多肥.</p></blockquote><p>Sample Input<br>1<br>10 10<br>1 3 5 7 9 11 13 15 17 19<br>19 17 15 13 11 9 7 5 3 1<br>Sample Output<br>51</p><p>Problem solving:<br>跟昨天那道题一样，不过就是换了描述。<br>提议就是给定你容量，然后告诉你每个物品的价值和体积，求你能拿到的最大的价值。<br>01背包问题，直接套板子即可</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int tx=1e6;</span><br><span class="line">int m[tx],M[tx],dp[tx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t,n,s;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;s;</span><br><span class="line">for(int i=0;i&lt;n;i++)cin&gt;&gt;m[i];</span><br><span class="line">for(int i=0;i&lt;n;i++)cin&gt;&gt;M[i];</span><br><span class="line">memset(dp,0,sizeof(dp));</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=s;j&gt;=M[i];j--)</span><br><span class="line">&#123;</span><br><span class="line">dp[j]=max(dp[j],dp[j-M[i]]+m[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;dp[s]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="饭卡"><a href="#饭卡" class="headerlink" title="饭卡"></a>饭卡</h3><p>Description:<br>电子科大本部食堂的饭卡有一种很诡异的设计，即在购买之前判断余额。如果购买一个商品之前，卡上的剩余金额大于或等于5元，就一定可以购买成功（即使购买后卡上余额为负），否则无法购买（即使金额足够）。所以大家都希望尽量使卡上的余额最少。<br>某天，食堂中有n种菜出售，每种菜可购买一次。已知每种菜的价格以及卡上的余额，问最少可使卡上的余额为多少。<br>Input</p><blockquote><p>多组数据。对于每组数据：<br>第一行为正整数n，表示菜的数量。n&lt;=1000。<br>第二行包括n个正整数，表示每种菜的价格。价格不超过50。<br>第三行包括一个正整数m，表示卡上的余额。m&lt;=1000。<br>n=0表示数据结束。</p></blockquote><p>Output</p><blockquote><p>对于每组输入,输出一行,包含一个整数，表示卡上可能的最小余额。</p></blockquote><p>Sample Input</p><blockquote><p>1<br>50<br>5<br>10<br>1 2 3 2 1 1 2 3 2 1<br>50<br>0</p></blockquote><p>Sample Output</p><blockquote><p>-45<br>32</p></blockquote><p>Problem solving:<br>题意就是让你尽可能多的花掉自己的钱，求余额。有一个特殊规定就是如果当前余额大于等于5，能买任何的菜，但是一旦n小于5，就什么都不能买了。<br>也是一道01背包的问题，这里还有一点贪心的感觉就是，为了最后能达到的是最小的余额，我们拿5元出来买最贵的菜。然后就是背包，背包容量是n-5，直接套板子求出n-5的容量下能花费最多钱的情况。<br>最后输出的时候减去最大的花费和最贵的菜即可。<br>但是还有一点就是输入的n就有可能是小于5的。这时直接输出n就行。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int tx=1005;</span><br><span class="line">int m[tx],dp[tx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t,n;</span><br><span class="line">while(cin&gt;&gt;t&amp;&amp;t)</span><br><span class="line">&#123;</span><br><span class="line">memset(dp,0,sizeof(dp));</span><br><span class="line">for(int i=0;i&lt;t;i++)cin&gt;&gt;m[i];</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">if(n&lt;5)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">sort(m,m+t);</span><br><span class="line">for(int i=0;i&lt;t-1;i++)</span><br><span class="line">for(int j=n-5;j&gt;=m[i];j--)</span><br><span class="line">&#123;</span><br><span class="line">dp[j]=max(dp[j],dp[j-m[i]]+m[i]);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;n-dp[n-5]-m[t-1]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="CD"><a href="#CD" class="headerlink" title="CD"></a>CD</h3><p>Description:<br>PDF题面:<a href="https://vj.ti12z.cn/f38ae0d246e80c425804db33c376c68a?v=1564526721" target="_blank" rel="noopener">戳我戳我</a><br>You have a long drive by car ahead. You have a tape recorder, but unfortunately your best music is on<br>CDs. You need to have it on tapes so the problem to solve is: you have a tape N minutes long. How<br>to choose tracks from CD to get most out of tape space and have as short unused space as possible.<br>Assumptions:<br>• number of tracks on the CD does not exceed 20<br>• no track is longer than N minutes<br>• tracks do not repeat<br>• length of each track is expressed as an integer number<br>• N is also integer<br>Program should find the set of tracks which fills the tape best and print it in the same sequence as<br>the tracks are stored on the CD<br>Input</p><blockquote><p>Any number of lines. Each one contains value N, (after space) number of tracks and durations of the<br>tracks. For example from first line in sample data: N = 5, number of tracks=3, first track lasts for 1<br>minute, second one 3 minutes, next one 4 minutes</p></blockquote><p>Output</p><blockquote><p>Set of tracks (and durations) which are the correct solutions and string ‘sum:’ and sum of duration<br>times.</p></blockquote><p>Sample Input</p><blockquote><p>5 3 1 3 4<br>10 4 9 8 4 2<br>20 4 10 5 7 4<br>90 8 10 23 1 2 3 4 5 7<br>45 8 4 10 44 43 12 9 8 2</p></blockquote><p>Sample Output</p><blockquote><p>1 4 sum:5<br>8 2 sum:10<br>10 5 4 sum:19<br>10 23 1 2 3 4 5 7 sum:55<br>4 10 12 9 8 2 sum:45</p></blockquote><p>Problem solving:<br>这道题的意思就是给你一个数，这个就是背包容量然后给你n个数，问你这n个数怎么放能使背包容量最小，并输出这个方法。</p><p>简单的01背包问题。不简单的输出方法。<br>在每次dp查找最优情况的时候进行标记，最后根据标记输出，并且题目要求的输出是出现在前面的就输出在前面，最后还有一点小优化，可以看一下代码注释理解。</p><p>关于这个输出路径，我也不是理解的很清楚，但是很关键的要理解的一点就是dp[j]这个数组的含义。也就是01背包中dp[i][j]的意思:从前i-1个物品中，选出来总重量不超过j的物品时，总价值的最大值</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m,num;</span><br><span class="line">const int maxn=10005;</span><br><span class="line">int a[maxn],dp[maxn],flag[maxn][maxn];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">ios::sync_with_stdio(0);</span><br><span class="line">cin.tie(0);</span><br><span class="line">while(cin&gt;&gt;n&gt;&gt;m)</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;m;i++)cin&gt;&gt;a[i];</span><br><span class="line">memset(flag,0,sizeof(flag));</span><br><span class="line">memset(dp,0,sizeof(dp));</span><br><span class="line">for(int i=m-1;i&gt;=0;i--)//这里倒序主要是在输出的时候方便</span><br><span class="line">&#123;</span><br><span class="line">for(int j=n;j&gt;=a[i];j--)</span><br><span class="line">&#123;</span><br><span class="line">if(dp[j]&lt;dp[j-a[i]]+a[i])//选上了a[i]的情况</span><br><span class="line">&#123;</span><br><span class="line">dp[j]=dp[j-a[i]]+a[i];</span><br><span class="line">flag[i][j]=1;//进行标记</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0,j=n;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(flag[i][j])//标价到的就输出</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">j-=a[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;&quot;sum:&quot;&lt;&lt;dp[n]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Piggy-Bank"><a href="#Piggy-Bank" class="headerlink" title="Piggy-Bank"></a>Piggy-Bank</h3><p>Description:<br>在 ACM 能够开展之前，必须准备预算，并获得必要的财力支持。该活动的主要收入来自于 Irreversibly Bound Money (IBM)。思路很简单。任何时候，某位 ACM 会员有少量的钱时，他将所有的硬币投入到小猪储钱罐中。这个过程不可逆，因为只有把小猪储钱罐打碎才能取出硬币。在足够长的时间之后，小猪储钱罐中有了足够的现金，用于支付 ACM 活动所需的花费。</p><p>但是，小猪储钱罐存在一个大的问题，即无法确定其中有多少钱。因此，我们可能在打碎小猪储钱罐之后，发现里面的钱不够。显然，我们希望避免这种不愉快的情况。唯一的可能是，称一下小猪储钱罐的重量，并尝试猜测里面的有多少硬币。假定我们能够精确判断小猪储钱罐的重量，并且我们也知道给定币种的所有硬币的重量。那么，我们可以保证小猪储钱罐中最少有多少钱。</p><p>你的任务是找出最差的情形，即判断小猪储钱罐中的硬币最少有多少钱。我们需要你的帮助。不能再贸然打碎小猪储钱罐了！</p><p>输入</p><blockquote><p>输入包含 T 组测试数据。输入文件的第一行，给出了 T 的值。<br>对于每组测试数据，第一行包含 E 和 F 两个整数，它们表示空的小猪储钱罐的重量，以及装有硬币的小猪储钱罐的重量。两个重量的计量单位都是 g (克)。小猪储钱罐的重量不会超过 10 kg (千克)，即 1 &lt;= E &lt;= F &lt;= 10000 。每组测试数据的第二行，有一个整数 N (1 &lt;= N &lt;= 500)，提供了给定币种的不同硬币有多少种。接下来的 N 行，每行指定一种硬币类型，每行包含两个整数 P 和 W (1 &lt;= P &lt;= 50000，1 &lt;= W &lt;=10000)。P 是硬币的金额 (货币计量单位)；W 是它的重量，以 g (克) 为计量单位。</p></blockquote><p>输出</p><blockquote><p>对于每组测试数据，打印一行输出。每行必须包含句子 “The minimum amount of money in the piggy-bank is X.” 其中，X 表示对于给定总重量的硬币，所能得到的最少金额。如果无法恰好得到给定的重量，则打印一行 “This is impossible.” 。</p></blockquote><p>示例输入</p><blockquote><p>3<br>10 110<br>2<br>1 1<br>30 50<br>10 110<br>2<br>1 1<br>50 30<br>1 6<br>2<br>10 3<br>20 4</p></blockquote><p>示例输出</p><blockquote><p>The minimum amount of money in the piggy-bank is 60.<br>The minimum amount of money in the piggy-bank is 100.<br>This is impossible.</p></blockquote><p>Problem solving:<br>这道题的意思是给你一个存钱罐的初始和末状态的质量，然后给定你每种硬币的质量和价值。要求这个存钱罐是否存在着能正好放满硬币的情况，如果有求出最小的情况。</p><p>每个硬币可以挑选任意次，所以这是一道完全背包的题。套板子就行，注意我们要求最小值，所以初始化成一个极大值，然后在dp的过程中取min。<br>还有一点就是dp[0]一定要初始化为0，因为这里我们dp[i]表示的就是在i的空间下，能放人的最小的硬币的值。空间为0即不能再放硬币了，所以价值就是0了。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int p[505],w[505],dp[10005];</span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t,s,e,n,cs;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;s&gt;&gt;e&gt;&gt;n;</span><br><span class="line">cs=e-s;</span><br><span class="line">for(int i=0;i&lt;=cs;i++)dp[i]=INF;</span><br><span class="line">for(int i=0;i&lt;n;i++)cin&gt;&gt;p[i]&gt;&gt;w[i];</span><br><span class="line">dp[0]=0;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=w[i];j&lt;=cs;j++)</span><br><span class="line">&#123;</span><br><span class="line">dp[j]=min(dp[j],dp[j-w[i]]+p[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(dp[cs]!=INF)</span><br><span class="line">cout&lt;&lt;&quot;The minimum amount of money in the piggy-bank is &quot;&lt;&lt;dp[cs]&lt;&lt;&quot;.&quot;;</span><br><span class="line">elsecout&lt;&lt;&quot;This is impossible.&quot;;</span><br><span class="line">puts(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Dividing-coins"><a href="#Dividing-coins" class="headerlink" title="Dividing coins"></a>Dividing coins</h3><p>Description:<br>PDF题面：<a href="https://vj.ti12z.cn/59ec771136a22cd223c44370a4f9b67c?v=1564459707" target="_blank" rel="noopener">戳我戳我</a><br>It’s commonly known that the Dutch have invented copper-wire. Two Dutch men were fighting over<br>a nickel, which was made of copper. They were both so eager to get it and the fighting was so fierce,<br>they stretched the coin to great length and thus created copper-wire.<br>Not commonly known is that the fighting started, after the two Dutch tried to divide a bag with<br>coins between the two of them. The contents of the bag appeared not to be equally divisible. The Dutch<br>of the past couldn’t stand the fact that a division should favour one of them and they always wanted<br>a fair share to the very last cent. Nowadays fighting over a single cent will not be seen anymore, but<br>being capable of making an equal division as fair as possible is something that will remain important<br>forever...<br>That’s what this whole problem is about. Not everyone is capable of seeing instantly what’s the<br>most fair division of a bag of coins between two persons. Your help is asked to solve this problem.<br>Given a bag with a maximum of 100 coins, determine the most fair division between two persons.<br>This means that the difference between the amount each person obtains should be minimised. The<br>value of a coin varies from 1 cent to 500 cents. It’s not allowed to split a single coin.<br>Input</p><blockquote><p>A line with the number of problems n, followed by n times:<br>• a line with a non negative integer m (m ≤ 100) indicating the number of coins in the bag<br>• a line with m numbers separated by one space, each number indicates the value of a coin.</p></blockquote><p>Output</p><blockquote><p>The output consists of n lines. Each line contains the minimal positive difference between the amount<br>the two persons obtain when they divide the coins from the corresponding bag.</p></blockquote><p>Sample Input</p><blockquote><p>2<br>3<br>2 3 5<br>4<br>1 2 4 6</p></blockquote><p>Sample Output</p><blockquote><p>0<br>1</p></blockquote><p>Problem solving:<br>这道题的意思就是给你n个硬币，让你分成两堆，求所有分法中两堆价值差值最小的情况。<br>这道题乍一看以为是要贪心，但是WA了。<br>然后想到今天讲的是背包诶，然后脑子里灵光一现(去百度了一下)，想到可以以硬币的总价值的一半为背包容量进行01背包的处理。假设总价值为s，这时我们求出的dp[s/2]就是分成差值最小的两堆中的其中一堆，然后另一堆的价值就是s-sp[s/2],两堆价值的差值就是s-2*dp[s/2]</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int tx=1e5+10;</span><br><span class="line">int m[tx],dp[tx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,t;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">while(n--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">memset(dp,0,sizeof(dp));</span><br><span class="line">int sum=0;</span><br><span class="line">for(int i=0;i&lt;t;i++)cin&gt;&gt;m[i],sum+=m[i];</span><br><span class="line">for(int i=0;i&lt;t;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=sum/2;j&gt;=m[i];j--)</span><br><span class="line">&#123;</span><br><span class="line">dp[j]=max(dp[j],dp[j-m[i]]+m[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;sum-dp[sum/2]-dp[sum/2]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Robberies"><a href="#Robberies" class="headerlink" title="Robberies"></a>Robberies</h3><p>Description:<br>可怜的POIUYTREWQ最近想买下dota2的商品，但是手头缺钱。他想起了之前看过的一部大片，觉得抢银行也许是个不错的选择。他认为，坏人被抓是因为没有预先规划。于是他在之前的几个月对各大银行进行了一次评估； 评估内容包括安全性和可盗窃金额： 他想知道在在某个风险系数下可以偷窃的最大金额<br>Input</p><blockquote><p>第一行给出了一个整数T, 表示有T组测试数据. 对于每一组数据，第一行给出了一个浮点数P, 表示POIUYTREWQ允许被抓的最大概率, 和一个整数N，表示他计划去抢劫的N个银行. 接下来N行, 每行给出一个整数数Mj和浮点数Pj.<br>抢劫银行 j 可获得 Mj 百万美金, 被抓的概率是 Pj .</p></blockquote><p>Output</p><blockquote><p>对于每组数据，每行输出一个整数，表示POIUYTREWQ在被抓概率小于P的情况下，可抢到的最多的金钱。</p></blockquote><p>Notes and Constraints<br>0 &lt; T &lt;= 100<br>0.0 &lt;= P &lt;= 1.0<br>0 &lt; N &lt;= 100<br>0 &lt; Mj &lt;= 100<br>0.0 &lt;= Pj &lt;= 1.0<br>你可以认为每家银行都是独立的。<br>Sample Input</p><blockquote><p>3<br>0.04 3<br>1 0.02<br>2 0.03<br>3 0.05<br>0.06 3<br>2 0.03<br>2 0.03<br>3 0.05<br>0.10 3<br>1 0.03<br>2 0.02<br>3 0.05</p></blockquote><p>Sample Output</p><blockquote><p>2<br>4<br>6</p></blockquote><p>Problem solving:<br>这道题就是先给你一个实数代表这个可怜的孩子能允许的最大的被抓的概率，意思就是你被抓的概率不能超过这个值。然后给你n个银行的获利以及被抓的概率，求最大能偷多少钱。</p><p>这是一道01背包的问题，但是不太一样的是如果我们直接以概率为背包容量的话会出现一个很尴尬的问题就是实数并不可以当做数组的下标，然后我想到了对概率乘上一个较大的数（1e6之类的）然后进行背包的dp，但是这样会WA，由此可见这道题的精度还是很高的，所以这种方法我们行不通。就得换个方向</p><p>这里可以以偷到的美金的数量为背包容量进行01背包，然后求出获得(1~n)内每个美金数量所对应的不被抓住的概率。<br>背包容量就是可以偷到的美金的最大值——所有都偷到。<br>dp[i]表示的就是偷了i美金之后不被抓的概率</p><p>有一点还需要注意的就是dp[0]必须初始化为1，不然后面算出来的dp都是0了。可为什么初始化的是1呢，因为我们现在用的dp数组表示的是偷了i美金之后不被抓的概率，i等于0的意思就是一点美金都没偷，不被抓的概率当然就是1(100%)了。</p><p>为什么我们要求的是不被抓住的概率呢？<br>因为如果是被抓住的概率的话，算总的概率并不好求，可以自己想一下。如果第一次被抓住的概率是0.5，第二次被抓住的概率也是0.5~·~·~第n次被抓住的概率也是0.5，那么总共被抓住的几率并不好求，因为如果第一次被抓住了，后面的就都不用考虑了，以此类推易想到不好求。<br>但是如果是不被抓住的概率，我们直接累乘就行了。<br>最后我们求出对应的每个美金的数量对应的不被抓住的概率，直接O(n)查找到概率大于等于1-p(允许被抓的最大概率)的美金数量输出即可。</p><p>具体可以看一下代码在感受一下，涉及到01背包的直接套板子就行(对和我一样不太理解背包的小伙伴适用<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 105;</span><br><span class="line">int m[maxn];double dp[100005],p[maxn];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">ios::sync_with_stdio(0);</span><br><span class="line">int t;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">memset(dp,0,sizeof(dp));</span><br><span class="line">double pp;int n,sum=0;</span><br><span class="line">cin&gt;&gt;pp&gt;&gt;n;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;m[i]&gt;&gt;p[i];</span><br><span class="line">sum+=m[i];</span><br><span class="line">p[i]=1-p[i];</span><br><span class="line">&#125;</span><br><span class="line">dp[0]=1;//这个初始化很重要</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=sum;j&gt;=m[i];j--)</span><br><span class="line">&#123;</span><br><span class="line">dp[j]=max(dp[j],dp[j-m[i]]*p[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=sum;i&gt;=0;i--)</span><br><span class="line">&#123;</span><br><span class="line">if(dp[i]&gt;=1-pp)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Coin-Change"><a href="#Coin-Change" class="headerlink" title="Coin Change"></a>Coin Change</h3><p>Description:<br>PDF题面:<a href="https://vj.ti12z.cn/0f4c5078f76f023eca12596dd1edb892?v=1564372407" target="_blank" rel="noopener">戳我戳我</a><br>Suppose there are 5 types of coins: 50-cent, 25-cent, 10-cent, 5-cent, and 1-cent. We want to make<br>changes with these coins for a given amount of money.<br>For example, if we have 11 cents, then we can make changes with one 10-cent coin and one 1-cent<br>coin, two 5-cent coins and one 1-cent coin, one 5-cent coin and six 1-cent coins, or eleven 1-cent coins.<br>So there are four ways of making changes for 11 cents with the above coins. Note that we count that<br>there is one way of making change for zero cent.<br>Write a program to find the total number of different ways of making changes for any amount of<br>money in cents. Your program should be able to handle up to 7489 cents.<br>Input</p><blockquote><p>The input file contains any number of lines, each one consisting of a number for the amount of money<br>in cents.</p></blockquote><p>Output</p><blockquote><p>For each input line, output a line containing the number of different ways of making changes with the<br>above 5 types of coins.</p></blockquote><p>Sample Input</p><blockquote><p>11<br>26</p></blockquote><p>Sample Output</p><blockquote><p>4<br>13</p></blockquote><p>Problem solving:<br>这道题的意思就是给你5种硬币，币值都给你了，在给你一个数问有几种方法可以拼出来这个数。</p><p>这是一道完全背包的题，直接套板子就行了。</p><p>这里我第一次不知道为啥TLE了，所以加上了一个记忆化搜索，也可能是cin/cout得锅。<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll ans[7500];</span><br><span class="line">ll solve(ll x)</span><br><span class="line">&#123;</span><br><span class="line">if(ans[x])return ans[x];</span><br><span class="line">    int coins[13]  = &#123; 1, 5, 10, 25, 50&#125;;</span><br><span class="line">    ll  dp[100005] = &#123; 0 &#125;;</span><br><span class="line">    dp[0] = 1;</span><br><span class="line">    for (int i = 0; i &lt; 6; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = coins[i]; j &lt;= x; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j] = dp[j] + dp[j - coins[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans[x]=dp[x];</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ll t, a;</span><br><span class="line">    ios::sync_with_stdio(0);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    while (cin &gt;&gt; a)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; solve(a)/2 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="悼念512汶川大地震遇难同胞——珍惜现在，感恩生活"><a href="#悼念512汶川大地震遇难同胞——珍惜现在，感恩生活" class="headerlink" title="悼念512汶川大地震遇难同胞——珍惜现在，感恩生活"></a>悼念512汶川大地震遇难同胞——珍惜现在，感恩生活</h3><p>Description:<br>急！灾区的食物依然短缺！<br>为了挽救灾区同胞的生命，心系灾区同胞的你准备自己采购一些粮食支援灾区，现在假设你一共有资金n元，而市场有m种大米，每种大米都是袋装产品，其价格不等，并且只能整袋购买。<br>请问：你用有限的资金最多能采购多少公斤粮食呢？</p><p>后记：<br>人生是一个充满了变数的生命过程，天灾、人祸、病痛是我们生命历程中不可预知的威胁。<br>月有阴晴圆缺，人有旦夕祸福，未来对于我们而言是一个未知数。那么，我们要做的就应该是珍惜现在，感恩生活——<br>感谢父母，他们给予我们生命，抚养我们成人；<br>感谢老师，他们授给我们知识，教我们做人<br>感谢朋友，他们让我们感受到世界的温暖；<br>感谢对手，他们令我们不断进取、努力。<br>同样，我们也要感谢痛苦与艰辛带给我们的财富～</p><p>Input</p><blockquote><p>输入数据首先包含一个正整数C，表示有C组测试用例，每组测试用例的第一行是两个整数n和m(1&lt;=n&lt;=100, 1&lt;=m&lt;=100),分别表示经费的金额和大米的种类，然后是m行数据，每行包含3个数p，h和c(1&lt;=p&lt;=20,1&lt;=h&lt;=200,1&lt;=c&lt;=20)，分别表示每袋的价格、每袋的重量以及对应种类大米的袋数。</p></blockquote><p>Output</p><blockquote><p>对于每组测试数据，请输出能够购买大米的最多重量，你可以假设经费买不光所有的大米，并且经费你可以不用完。每个实例的输出占一行。</p></blockquote><p>Sample Input</p><blockquote><p>1<br>8 2<br>2 100 4<br>4 100 2</p></blockquote><p>Sample Output</p><blockquote><p>400</p></blockquote><p>Problem solving:<br>这道题的意思就是给了你最大得经费，还给了你每包米的体积以及价格和这种米的个数，问你在最优的情况下可以买到的米的体积</p><p>这是一道多重背包的题，直接套板子即可。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int tx=1e3;</span><br><span class="line">int m[tx],p[tx],h[tx],c[tx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t,n,x;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;x;</span><br><span class="line">memset(m,0,sizeof(m));</span><br><span class="line">for(int i=0;i&lt;x;i++)cin&gt;&gt;p[i]&gt;&gt;h[i]&gt;&gt;c[i];</span><br><span class="line">for(int i=0;i&lt;x;i++)</span><br><span class="line">&#123;</span><br><span class="line">int mid=c[i];</span><br><span class="line">for(int k=1;mid&gt;0;k*=2)</span><br><span class="line">&#123;</span><br><span class="line">int miid=min(k,mid);</span><br><span class="line">for(int j=n;j&gt;=p[i]*miid;j--)</span><br><span class="line">&#123;</span><br><span class="line">m[j]=max(m[j],m[j-p[i]*miid]+h[i]*miid);</span><br><span class="line">&#125;</span><br><span class="line">mid-=miid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;m[n]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意，这个背包问题中如果涉及到多组输入，dp数组的初始化是很重要的。<br>这些dp啊，背包的好多问题一看都感觉好像用贪心可以写，但是过一会你就会发现贪心并不能解决这些问题，还是老老实实学dp吧、、、</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天主要讲了01背包，完全背包，多重背包的相关东西。不太好理解，题也有点难。关于背包东西还有很多，慢慢学吧。
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="Algorithm" scheme="https://cndrew.cn/blog/tags/Algorithm/"/>
    
      <category term="c/c++" scheme="https://cndrew.cn/blog/tags/c-c/"/>
    
      <category term="dp" scheme="https://cndrew.cn/blog/tags/dp/"/>
    
      <category term="背包" scheme="https://cndrew.cn/blog/tags/%E8%83%8C%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>HPU Summer Day 14(河南理工大学暑期第十四天)</title>
    <link href="https://cndrew.cn/blog/2019/07/30/d14/"/>
    <id>https://cndrew.cn/blog/2019/07/30/d14/</id>
    <published>2019-07-30T14:08:53.537Z</published>
    <updated>2019-07-30T14:11:59.586Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天讲了记忆化搜索，拉的题emm真让人自闭啊。<a id="more"></a></p><h3 id="Function-Run-Fun"><a href="#Function-Run-Fun" class="headerlink" title="Function Run Fun"></a>Function Run Fun</h3><p>Description:<br>We all love recursion! Don&#39;t we?</p><p>Consider a three-parameter recursive function w(a, b, c):</p><p>if a &lt;= 0 or b &lt;= 0 or c &lt;= 0, then w(a, b, c) returns:<br>1</p><p>if a &gt; 20 or b &gt; 20 or c &gt; 20, then w(a, b, c) returns:<br>w(20, 20, 20)</p><p>if a &lt; b and b &lt; c, then w(a, b, c) returns:<br>w(a, b, c-1) + w(a, b-1, c-1) - w(a, b-1, c)</p><p>otherwise it returns:<br>w(a-1, b, c) + w(a-1, b-1, c) + w(a-1, b, c-1) - w(a-1, b-1, c-1)</p><p>This is an easy function to implement. The problem is, if implemented directly, for moderate values of a, b and c (for example, a = 15, b = 15, c = 15), the program takes hours to run because of the massive recursion.<br>Input</p><blockquote><p>The input for your program will be a series of integer triples, one per line, until the end-of-file flag of -1 -1 -1. Using the above technique, you are to calculate w(a, b, c) efficiently and print the result.</p></blockquote><p>Output</p><blockquote><p>Print the value for w(a,b,c) for each triple.</p></blockquote><p>Sample Input</p><blockquote><p>1 1 1<br>2 2 2<br>10 4 6<br>50 50 50<br>-1 7 18<br>-1 -1 -1</p></blockquote><p>Sample Output</p><blockquote><p>w(1, 1, 1) = 2<br>w(2, 2, 2) = 4<br>w(10, 4, 6) = 523<br>w(50, 50, 50) = 1048576<br>w(-1, 7, 18) = 1</p></blockquote><p>Problem solving:<br>这道题没什么好说的，按照题目上的要求来写一个递归就行了，因为是多组输入，所以要用到记忆化搜索。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll a,b,c,dp[21][21][21];</span><br><span class="line">ll dfs(ll m,ll t,ll x)</span><br><span class="line">&#123;</span><br><span class="line">if(m&lt;=0||t&lt;=0||x&lt;=0)</span><br><span class="line">return 1;</span><br><span class="line">if(m&gt;20||t&gt;20||x&gt;20)</span><br><span class="line">returndfs(20,20,20);</span><br><span class="line">if(dp[m][t][x])return dp[m][t][x];</span><br><span class="line">if(m&lt;t&amp;&amp;t&lt;x)</span><br><span class="line">return dp[m][t][x]=dfs(m,t,x-1)+dfs(m,t-1,x-1)-dfs(m,t-1,x);</span><br><span class="line">else</span><br><span class="line">return dp[m][t][x]=dfs(m-1,t,x)+dfs(m-1,t-1,x)+dfs(m-1,t,x-1)-dfs(m-1,t-1,x-1);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c)</span><br><span class="line">&#123;</span><br><span class="line">if(a==-1&amp;&amp;b==-1&amp;&amp;c==-1)</span><br><span class="line">break;</span><br><span class="line">printf(&quot;w(%lld, %lld, %lld) = %lld\n&quot;,a,b,c,dfs(a,b,c));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="滑雪"><a href="#滑雪" class="headerlink" title="滑雪"></a>滑雪</h3><p>Description:<br>Glory非常喜欢玩滑滑梯游戏，下面给出了一个n,m的滑道，其中的数字表示滑道的高度。Glory可以从一个点出发向下滑行，每次只能滑行到相邻的位置(上下左右)中高度严格低于当前高度的地方，不能重复划行已经滑行过的地方，但他希望在这个滑道上滑行尽量远的距离，也即是找一条最长的滑道。</p><p>Input</p><blockquote><p>第一行输入两个数n,m代表滑梯范围行n和列m(1 &lt;= n,m &lt;= 100)。下面是n行，每行有m个整数，代表高度h，(0&lt;=h&lt;=20000)</p></blockquote><p>Output</p><blockquote><p>输出一个值，代表Glory能够在滑滑梯上面滑行的最长长度是多少</p></blockquote><p>Sample Input</p><blockquote><p>3 3<br>9 1 2<br>5 6 7<br>8 4 3</p></blockquote><p>Sample Output</p><blockquote><p>4</p></blockquote><p>Sample Input</p><blockquote><p>4 7<br>7 6 5 4 3 2 1<br>1 5 1 1 1 1 1<br>1 4 3 1 1 1 1<br>1 5 6 7 8 1 1</p></blockquote><p>Sample Output</p><blockquote><p>7</p></blockquote><p>hint</p><blockquote><p>样例1：7-&gt;6-&gt;4-&gt;3 长度为4</p></blockquote><p>Problem solving:<br>四个方向搜索就行了。记忆化搜索要用上，不然会超时。<br>ma[dx][dy]与ma[x][y]的大小关系判断的时候大于小于都是可以的，这个还是很好理解的吧，降序反过来就是升序。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m,ma[105][105],dp[105][105];</span><br><span class="line">int d[4][2]=&#123;1,0,0,1,0,-1,-1,0&#125;;</span><br><span class="line">int dfs(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">int mid=1;</span><br><span class="line">if(dp[x][y])return dp[x][y];</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">int dx=x+d[i][0];</span><br><span class="line">int dy=y+d[i][1];</span><br><span class="line">if(dx&gt;=0&amp;&amp;dx&lt;n&amp;&amp;dy&gt;=0&amp;&amp;dy&lt;m&amp;&amp;ma[dx][dy]&lt;ma[x][y])</span><br><span class="line">&#123;</span><br><span class="line">mid=max(mid,dfs(dx,dy)+1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return dp[x][y]=mid;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">for(int j=0;j&lt;m;j++)</span><br><span class="line">cin&gt;&gt;ma[i][j];</span><br><span class="line">int ans=0;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">for(int j=0;j&lt;m;j++)</span><br><span class="line">ans=max(ans,dfs(i,j));</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="漫步校园"><a href="#漫步校园" class="headerlink" title="漫步校园"></a>漫步校园</h3><p>LL最近沉迷于AC不能自拔，每天寝室、机房两点一线。由于长时间坐在电脑边，缺乏运动。他决定充分利用每次从寝室到机房的时间，在校园里散散步。整个HDU校园呈方形布局，可划分为n*n个小方格，代表各个区域。例如LL居住的18号宿舍位于校园的西北角，即方格(1,1)代表的地方，而机房所在的第三实验楼处于东南端的(n,n)。因有多条路线可以选择，LL希望每次的散步路线都不一样。另外，他考虑从A区域到B区域仅当存在一条从B到机房的路线比任何一条从A到机房的路线更近(否则可能永远都到不了机房了…)。现在他想知道的是，所有满足要求的路线一共有多少条。你能告诉他吗?<br>Input</p><blockquote><p>每组测试数据的第一行为n(2=&lt;n&lt;=50)，接下来的n行每行有n个数，代表经过每个区域所花的时间t(0&lt;t&lt;=50)(由于寝室与机房均在三楼，故起点与终点也得费时)。</p></blockquote><p>Output</p><blockquote><p>针对每组测试数据，输出总的路线数(小于2^63)。</p></blockquote><p>Sample Input</p><blockquote><p>3<br>1 2 3<br>1 2 3<br>1 2 3<br>3<br>1 1 1<br>1 1 1<br>1 1 1</p></blockquote><p>Sample Output</p><blockquote><p>1<br>6</p></blockquote><p>Problem solving:<br>这道题的题意也太难懂了。。。<br>让你求最短路的条数，所以我们需要先求出最短路然后再求条数。<br>先用bfs求出每个点到终点的最短距离然后进行记忆化搜索。<br>（如果阁下真的是在看我的题解，当你看到这的时候，我衷心的给你道个歉，这道题为了你好还是百度吧</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int n;</span><br><span class="line">struct node&#123;</span><br><span class="line">int x,y,c;</span><br><span class="line">bool friend operator &lt;(node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">return a.c&gt;b.c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;r,w;</span><br><span class="line">ll ma[305][305],vis[305][305],dis[305][305],dp[305][305];</span><br><span class="line">int d[4][2]=&#123;0,1,1,0,-1,0,0,-1&#125;;</span><br><span class="line">void bfs()</span><br><span class="line">&#123;</span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line">r.x=n-1,r.y=n-1;r.c=ma[n-1][n-1];</span><br><span class="line">dis[n-1][n-1]=ma[n-1][n-1];</span><br><span class="line">vis[n-1][n-1]=1;</span><br><span class="line">q.push(r);</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">r=q.top();</span><br><span class="line">q.pop();</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">int dx=r.x+d[i][0];</span><br><span class="line">int dy=r.y+d[i][1];</span><br><span class="line">if(dx&lt;0||dy&lt;0||dx&gt;=n||dy&gt;=n||vis[dx][dy])continue;</span><br><span class="line">w.x=dx,w.y=dy,w.c=r.c+ma[dx][dy];</span><br><span class="line">vis[dx][dy]=1;</span><br><span class="line">q.push(w);</span><br><span class="line">dis[dx][dy]=w.c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll dfs(ll x,ll y)</span><br><span class="line">&#123;</span><br><span class="line">if(x==n-1&amp;&amp;y==n-1)return 1;</span><br><span class="line">if(dp[x][y]!=-1)return dp[x][y];</span><br><span class="line">dp[x][y]=0;</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">int dx=x+d[i][0];</span><br><span class="line">int dy=y+d[i][1];</span><br><span class="line">if(dx&lt;0||dy&lt;0||dx&gt;=n||dy&gt;=n||dis[dx][dy]&gt;=dis[x][y])continue;</span><br><span class="line">dp[x][y]+=dfs(dx,dy);</span><br><span class="line">&#125;</span><br><span class="line">return dp[x][y];</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(cin&gt;&gt;n)</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">for(int j=0;j&lt;n;j++)</span><br><span class="line">cin&gt;&gt;ma[i][j];</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">memset(dp,-1,sizeof(dp));</span><br><span class="line">bfs();</span><br><span class="line">cout&lt;&lt;dfs(0,0)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Free-Candies"><a href="#Free-Candies" class="headerlink" title="Free Candies"></a>Free Candies</h3><p>Description:<br>PDF题面:<a href="https://uva.onlinejudge.org/external/101/p10118.pdf" target="_blank" rel="noopener">戳我戳我</a><br><img src="http://drew.todest.cn/Description.png" alt><br>输入<br><img src="http://drew.todest.cn/f8bc32f9c3ed521ffc13c93ad058101e714e8250.png" alt><br>输出<br><img src="http://drew.todest.cn/b2047ac146b5704d62c2c5a4274ff76ea8c1b57b.png" alt><br>Problem solving:<br>题意就是有4个盒子，每个盒子里面都放着糖果，有个最多能放5个糖果的袋子，每次只能取盒子最上面的那个糖果，如果袋子里面有两个颜色相同的糖果可以自己拿走（这道题用数字代表颜色），问你最优情况下能拿走几对糖果，注意是对（2个算一对）。<br>我们这里可以用一个四维数组表示分别从四堆糖果中取出不同个数的糖果的时候的最优解，用一个now数组代表此时在第i堆数组拿到了第now[i]个糖果，用一个flag数组表示这个颜色的糖果是否在袋子里出现过。然后进行dfs查找，注意这里用到了很多回溯，还有记忆化搜索。可以看一下代码注释了解一下具体的dfs过程。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int dp[45][45][45][45],n,ma[4][45];</span><br><span class="line">int now[4],flag[45];</span><br><span class="line">int dfs(int x)//x代表的就是当前袋子里放入的糖果个数</span><br><span class="line">&#123;</span><br><span class="line">int ans=0;//初始化为0</span><br><span class="line">if(dp[now[0]][now[1]][now[2]][now[3]]!=-1)//记忆化搜索</span><br><span class="line">return dp[now[0]][now[1]][now[2]][now[3]];</span><br><span class="line">if(x==5)return 0;//袋子里有5个糖果了，不能放入更多，所以return 0</span><br><span class="line">for(int i=0;i&lt;4;i++)//四堆糖果</span><br><span class="line">&#123;</span><br><span class="line">if(now[i]==n)continue;//在这一堆如果已经取到了第n个，即最后一个，就结束这一堆糖果中的查找</span><br><span class="line">int mid=ma[i][now[i]];//代表的是当前取出的糖果的颜色</span><br><span class="line">now[i]++;//下一次要放入的糖果的颜色</span><br><span class="line">if(flag[mid])//如果现在要放入袋子里的糖果的颜色在袋子里已经存在</span><br><span class="line">&#123;</span><br><span class="line">flag[mid]=0;//把袋子里的颜色相同的那个糖果取出来</span><br><span class="line">ans=max(ans,dfs(x-1)+1);//当前的最优值更新一下，dfs(x-1)即取出颜色相同得糖果之后的最优解，加上的1就是取出的糖果和本来准备放进袋子却没放的糖果这一对</span><br><span class="line">flag[mid]=1;//回溯，把从袋子里取出的糖果再放回去</span><br><span class="line">&#125;</span><br><span class="line">else//现在要放入袋子里的糖果的颜色在袋子里不存在</span><br><span class="line">&#123;</span><br><span class="line">flag[mid]=1;//把这个糖果放进去</span><br><span class="line">ans=max(dfs(x+1),ans);//此时袋子里的糖果数加一</span><br><span class="line">flag[mid]=0;//回溯，把放进去的再取出来</span><br><span class="line">&#125;</span><br><span class="line">now[i]--;//回溯，考虑不放这一个糖果的情况</span><br><span class="line">&#125;</span><br><span class="line">return dp[now[0]][now[1]][now[2]][now[3]]=ans;//记忆化</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(cin&gt;&gt;n&amp;&amp;n)</span><br><span class="line">&#123;</span><br><span class="line">memset(dp,-1,sizeof(dp));</span><br><span class="line">memset(now,0,sizeof(now));</span><br><span class="line">memset(flag,0,sizeof(flag));</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">for(int j=0;j&lt;4;j++)</span><br><span class="line">cin&gt;&gt;ma[j][i];</span><br><span class="line">cout&lt;&lt;dfs(0)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Zipper"><a href="#Zipper" class="headerlink" title="Zipper"></a>Zipper</h3><p>Description:<br>Given three strings, you are to determine whether the third string can be formed by combining the characters in the first two strings. The first two strings can be mixed arbitrarily, but each must stay in its original order.</p><p>For example, consider forming &quot;tcraete&quot; from &quot;cat&quot; and &quot;tree&quot;:</p><p>String A: cat<br>String B: tree<br>String C: tcraete</p><p>As you can see, we can form the third string by alternating characters from the two strings. As a second example, consider forming &quot;catrtee&quot; from &quot;cat&quot; and &quot;tree&quot;:</p><p>String A: cat<br>String B: tree<br>String C: catrtee</p><p>Finally, notice that it is impossible to form &quot;cttaree&quot; from &quot;cat&quot; and &quot;tree&quot;.<br>Input</p><blockquote><p>The first line of input contains a single positive integer from 1 through 1000. It represents the number of data sets to follow. The processing for each data set is identical. The data sets appear on the following lines, one data set per line.<br>For each data set, the line of input consists of three strings, separated by a single space. All strings are composed of upper and lower case letters only. The length of the third string is always the sum of the lengths of the first two strings. The first two strings will have lengths between 1 and 200 characters, inclusive.</p></blockquote><p>Output</p><blockquote><p>For each data set, print:<br>Data set n: yes<br>if the third string can be formed from the first two, or<br>Data set n: no<br>if it cannot. Of course n should be replaced by the data set number. See the sample output below for an example.</p></blockquote><p>Sample Input</p><blockquote><p>3<br>cat tree tcraete<br>cat tree catrtee<br>cat tree cttaree</p></blockquote><p>Sample Output</p><blockquote><p>Data set 1: yes<br>Data set 2: yes<br>Data set 3: no</p></blockquote><p>Problem solving:<br>匹配的时候只会有两种情况</p><ol><li>第一个字符串当前位置的字符与第三个字符串当前位置的字符相等。</li><li>第二个字符串当前位置的字符与第三个字符串当前位置的字符相等。<br>只有这两种情况，所以我们可以直接用dfs进行暴搜。但是这道题需要用到记忆化搜索，用一个二维的标记数组即可。每次查找完当前的一对位置就标记起来，下次遇见的时候就不需要再查找了。</li></ol><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">string a,b,c;</span><br><span class="line">int vis[205][205],flag;</span><br><span class="line">void dfs(int x,int y,int z)</span><br><span class="line">&#123;</span><br><span class="line">if(flag)return ;</span><br><span class="line">if(z==c.size())</span><br><span class="line">&#123;</span><br><span class="line">flag=1;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">if(vis[x][y])return ;</span><br><span class="line">vis[x][y]=1;</span><br><span class="line">if(a[x]==c[z])dfs(x+1,y,z+1);</span><br><span class="line">if(b[y]==c[z])dfs(x,y+1,z+1);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,now=0;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">while(n--)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">flag=0;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">cout&lt;&lt;&quot;Data set &quot;&lt;&lt;++now&lt;&lt;&quot;: &quot;;</span><br><span class="line">dfs(0,0,0);</span><br><span class="line">if(flag)puts(&quot;yes&quot;);</span><br><span class="line">elseputs(&quot;no&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Bone-Collector"><a href="#Bone-Collector" class="headerlink" title="Bone Collector"></a>Bone Collector</h3><p>Description:<br>Many years ago , in Teddy’s hometown there was a man who was called “Bone Collector”. This man like to collect varies of bones , such as dog’s , cow’s , also he went to the grave …<br>The bone collector had a big bag with a volume of V ,and along his trip of collecting there are a lot of bones , obviously , different bone has different value and different volume, now given the each bone’s value along his trip , can you calculate out the maximum of the total value the bone collector can get ?<br><img src="http://drew.todest.cn/bone.png" alt><br>Input</p><blockquote><p>The first line contain a integer T , the number of cases.<br>Followed by T cases , each case three lines , the first line contain two integer N , V, (N &lt;= 1000 , V &lt;= 1000 )representing the number of bones and the volume of his bag. And the second line contain N integers representing the value of each bone. The third line contain N integers representing the volume of each bone.</p></blockquote><p>Output</p><blockquote><p>One integer per line representing the maximum of the total value (this number will be less than 2 31).</p></blockquote><p>Sample Input</p><blockquote><p>1<br>5 10<br>1 2 3 4 5<br>5 4 3 2 1</p></blockquote><p>Sample Output</p><blockquote><p>14</p></blockquote><p>Problem solving:<br>这就是一道背包问题，但是换了描述。<br>背包问题dp得写法我们还没学，今天学到的是用记忆化搜索解决的背包问题。<br>具体的解释请看代码注释</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m,a[1050],b[1050],dp[1050][1050];</span><br><span class="line">int dfs(int x,int y)//x代表的是收集到的骨头的个数</span><br><span class="line">&#123;//y代表的是当前背包剩余容量</span><br><span class="line">if(x==n)return 0;//没有更多骨头可供收集了</span><br><span class="line">if(dp[x][y])return dp[x][y];//已经搜索过一次了，直接调用</span><br><span class="line">int ans;</span><br><span class="line">if(y&lt;b[x])ans=dfs(x+1,y);//当前骨头所占体积大于背包所剩体积，放不进去了，直接跳过</span><br><span class="line">elseans=max(dfs(x+1,y),dfs(x+1,y-b[x])+a[x]);//能放进去，要分两种情况，放或不放，取最大值</span><br><span class="line">return dp[x][y]=ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">memset(dp,0,sizeof(dp));</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">for(int i=0;i&lt;n;i++)cin&gt;&gt;a[i];</span><br><span class="line">for(int i=0;i&lt;n;i++)cin&gt;&gt;b[i];</span><br><span class="line">cout&lt;&lt;dfs(0,m)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="FatMouse-and-Cheese"><a href="#FatMouse-and-Cheese" class="headerlink" title="FatMouse and Cheese"></a>FatMouse and Cheese</h3><p>Description:<br>有一种游戏是的玩法是这样的：<br>有一个n*n的格子,每个格子有一个数字。<br>遵循以下规则:</p><ol><li>玩家每次可以由所在格子向上下左右四个方向进行直线移动，每次移动的距离不得超过m</li><li>玩家一开始在第一行第一列，并且已经获得该格子的分值</li><li>玩家获得每一次移动到的格子的分值</li><li>玩家下一次移动到达的格子的分值要比当前玩家所在的格子的分值要大。</li><li>游戏所有数字加起来也不大，保证所有数字的和不会超过int型整数的范围</li><li>玩家仅能在n*n的格子内移动，超出格子边界属于非法操作</li><li>当玩家不能再次移动时，游戏结束<br>现在问你，玩家所能获得的最大得分是多少？</li></ol><p>Input</p><blockquote><p>有多组测试数据<br>每组测试样例第一行是两个整数n,m (1≤n≤100)(1≤m≤100),当n和m都是-1时为程序结束标志，直接退出即可<br>之后n行，每行n个数字，描述n*n的格子里的数字</p></blockquote><p>Output</p><blockquote><p>对于每组测试数据输出一行，这一行仅有一个整数，代表玩家所能获得的最高得分</p></blockquote><p>Sample Input</p><blockquote><p>3 1<br>1 2 5<br>10 11 6<br>12 12 7<br>-1 -1</p></blockquote><p>Sample Output</p><blockquote><p>37</p></blockquote><p>Problem solving:<br>这道题跟滑雪那道题差不多，有一点不一样的就是这道题里面每次走的步数可以是不一样的并且范围给了我们。这样的话，仍然暴力搜索就行了。把每种步数都考虑进去可以这样实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int d[4][2]=&#123;0,1,1,0,0,-1,-1,0&#125;;</span><br><span class="line">for(int i=0;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=1;j&lt;=m;j++)</span><br><span class="line">    &#123;</span><br><span class="line">    int dx=x+d[i][0]*j;</span><br><span class="line">        int dy=y+d[i][1]*j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后就跟滑雪那道题一样了。<br>主要要用到记忆化搜索，不然会TLE</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m,ma[105][105],dp[105][105];</span><br><span class="line">int d[4][2]=&#123;1,0,0,1,-1,0,0,-1&#125;;</span><br><span class="line">int dfs(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">if(dp[x][y])return dp[x][y];</span><br><span class="line">int ans=0;</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=1;j&lt;=m;j++)</span><br><span class="line">&#123;</span><br><span class="line">int dx=x+d[i][0]*j;</span><br><span class="line">int dy=y+d[i][1]*j;</span><br><span class="line">if(dx&gt;=0&amp;&amp;dy&gt;=0&amp;&amp;dx&lt;n&amp;&amp;dy&lt;n&amp;&amp;ma[dx][dy]&gt;ma[x][y])</span><br><span class="line">&#123;</span><br><span class="line">ans=max(ans,dfs(dx,dy));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return dp[x][y]=ans+ma[x][y];</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(cin&gt;&gt;n&gt;&gt;m&amp;&amp;n!=-1&amp;&amp;m!=-1)</span><br><span class="line">&#123;</span><br><span class="line">memset(dp,0,sizeof(dp));</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">for(int j=0;j&lt;n;j++)</span><br><span class="line">cin&gt;&gt;ma[i][j];</span><br><span class="line">cout&lt;&lt;dfs(0,0)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天讲了记忆化搜索，拉的题emm真让人自闭啊。
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="Algorithm" scheme="https://cndrew.cn/blog/tags/Algorithm/"/>
    
      <category term="c/c++" scheme="https://cndrew.cn/blog/tags/c-c/"/>
    
      <category term="UVA" scheme="https://cndrew.cn/blog/tags/UVA/"/>
    
      <category term="dp" scheme="https://cndrew.cn/blog/tags/dp/"/>
    
      <category term="dfs" scheme="https://cndrew.cn/blog/tags/dfs/"/>
    
      <category term="记忆化搜索" scheme="https://cndrew.cn/blog/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"/>
    
      <category term="hdu" scheme="https://cndrew.cn/blog/tags/hdu/"/>
    
  </entry>
  
  <entry>
    <title>HPU Summer Day 13(河南理工大学暑期第十三天)</title>
    <link href="https://cndrew.cn/blog/2019/07/29/d13/"/>
    <id>https://cndrew.cn/blog/2019/07/29/d13/</id>
    <published>2019-07-29T14:19:00.228Z</published>
    <updated>2019-07-29T14:19:27.029Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天讲了一点关于DP的知识和几道例题，据说这样就算是入门了。今天的题怎么说呢？亏是之前做过，要是之前没做过，还真不知道该怎么写。dp就是玄学？<a id="more"></a><br>今天的题很多都是需要灵光一现（或者百度解题的。具体的我也说不清，自己体会吧。（怎么能告诉你是因为我不会呢？</p><h3 id="The-King’s-Ups-and-Downs"><a href="#The-King’s-Ups-and-Downs" class="headerlink" title="The King’s Ups and Downs"></a>The King’s Ups and Downs</h3><p>Description:<br>The king has guards of all different heights. Rather than line them up in increasing or decreasing height order, he wants to line them up so each guard is either shorter than the guards next to him or taller than the guards next to him (so the heights go up and down along the line). For example, seven guards of heights 160, 162, 164, 166, 168, 170 and 172 cm. could be arranged as:<br><img src="http://drew.todest.cn/YI$DPR%28_8~4%5DN$A2%5BLT%28%7DVU.png" alt><br>or perhaps:<br><img src="http://drew.todest.cn/YI$DPR%28_8~4%5DN$A2%5BLT%28%7DVU.png" alt><br>The king wants to know how many guards he needs so he can have a different up and down order at each changing of the guard for rest of his reign. To be able to do this, he needs to know for a given number of guards, n, how many different up and down orders there are:</p><p>For example, if there are four guards: 1, 2, 3,4 can be arrange as:</p><p>1324, 2143, 3142, 2314, 3412, 4231, 4132, 2413, 3241, 1423</p><p>For this problem, you will write a program that takes as input a positive integer n, the number of guards and returns the number of up and down orders for n guards of differing heights.</p><p>Input</p><blockquote><p>The first line of input contains a single integer P, (1 &lt;= P &lt;= 1000), which is the number of data sets that follow. Each data set consists of single line of input containing two integers. The first integer, D is the data set number. The second integer, n (1 &lt;= n &lt;= 20), is the number of guards of differing heights.</p></blockquote><p>Output</p><blockquote><p>For each data set there is one line of output. It contains the data set number (D) followed by a single space, followed by the number of up and down orders for the n guards.</p></blockquote><p>Sample Input</p><blockquote><p>4<br>1 1<br>2 3<br>3 4<br>4 20</p></blockquote><p>Sample Output</p><blockquote><p>1 1<br>2 4<br>3 10<br>4 740742376475050</p></blockquote><p>Problem solving:<br>这道题我是真的懵逼了。。。<br>看这个大佬的解释吧:<a href="https://blog.csdn.net/niuox/article/details/8866907" target="_blank" rel="noopener">niuox</a><br>题意是求1-n 的全排列中有多少呈现高低高低高低或者地高低高形式排列的个数。</p><p>这种排列叫做：alternating permutations 或者 Extremal Permutations 。</p><p>可以用DP做。</p><p>dp(n,k)表示：长度为n，最后一个数为k，最后两个数是递增的  排列的个数;</p><p>dp2(n,k)表示：长度为n,最后一个数为k,最后两个数是递减的 排列的个数;</p><p>那么：</p><p>dp(n,k) = dp2(n,n+1-k) ;</p><p>很好理解吧，比如说132(低高低)等价于312(高低高)，相对的位置加起来等于4.</p><p>那么我们针对dp[n][k]的最后一位进行如下考虑：</p><p>最后一位是k，因为dp[n][k]最后两个数字是递增的，所以第n-1位的最大值是k-1。那么我们很容易推导出DP方程：<br><img src="http://drew.todest.cn/W6@LCEF1Z61%60%5DGPX%25Y%60_J$Q.hc" alt></p><p>又</p><p><img src="http://drew.todest.cn/68AW~3D2%7BH%25LMQ2Z140E3~R.hc" alt></p><p>所以：dp(n,k) = dp(n-1,n+1-k) + dp(n,k-1)；<br>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=25;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll dp[maxn][maxn],ans[maxn];</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">dp[1][1]=1;ans[1]=1;</span><br><span class="line">for(int i=2;i&lt;=20;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int k=2;k&lt;=i;k++)</span><br><span class="line">&#123;</span><br><span class="line">dp[i][k]=dp[i-1][i+1-k]+dp[i][k-1];</span><br><span class="line">ans[i]+=dp[i][k];</span><br><span class="line">&#125;</span><br><span class="line">ans[i]*=2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">init();</span><br><span class="line">int p,m,n;</span><br><span class="line">cin&gt;&gt;p;</span><br><span class="line">while(p--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">cout&lt;&lt;m&lt;&lt;&quot; &quot;&lt;&lt;ans[n]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="数塔"><a href="#数塔" class="headerlink" title="数塔"></a>数塔</h3><p>Description:<br>在讲述DP算法的时候，一个经典的例子就是数塔问题，它是这样描述的：</p><p>有如下所示的数塔，要求从顶层走到底层，若每一步只能走到相邻的结点，则经过的结点的数字之和最大是多少？<br><img src="http://drew.todest.cn/P40515CDJA5N%5B8NG5%2965K%287.png" alt><br>已经告诉你了，这是个DP的题目，你能AC吗?</p><p>Input</p><blockquote><p>输入数据首先包括一个整数C,表示测试实例的个数，每个测试实例的第一行是一个整数N(1 &lt;= N &lt;= 100)，表示数塔的高度，接下来用N行数字表示数塔，其中第i行有个i个整数，且所有的整数均在区间[0,99]内。</p></blockquote><p>Output</p><blockquote><p>对于每个测试实例，输出可能得到的最大和，每个实例的输出占一行。</p></blockquote><p>Sample Input</p><blockquote><p>1<br>5<br>7<br>3 8<br>8 1 0<br>2 7 4 4<br>4 5 2 6 5</p></blockquote><p>Sample Output</p><blockquote><p>30</p></blockquote><p>Problem solving:<br>挺简单的一道经典的dp的题。这道题我们可以倒着推，状态转移方程就是<br><code>a[i][j]=max(a[i+1][j],a[i+1][j+1])+a[i][j]</code><br>按照这个处理完之后直接输出a[1][1]即可</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 105;</span><br><span class="line">int c,n,a[maxn][maxn],ans[maxn][maxn];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;c;</span><br><span class="line">while(c--)</span><br><span class="line">&#123;</span><br><span class="line">memset(ans,0,sizeof(ans));</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=1;j&lt;=i;j++)</span><br><span class="line">cin&gt;&gt;a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">for(int i=n-1;i&gt;=1;i--)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=1;j&lt;=i;j++)</span><br><span class="line">&#123;</span><br><span class="line">a[i][j]=max(a[i+1][j],a[i+1][j+1])+a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;a[1][1]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="母牛的故事"><a href="#母牛的故事" class="headerlink" title="母牛的故事"></a>母牛的故事</h3><p>Description:<br>有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛。请编程实现在第n年的时候，共有多少头母牛？<br>Input</p><blockquote><p>输入数据由多个测试实例组成，每个测试实例占一行，包括一个整数n(0&lt;n&lt;55)，n的含义如题目中描述。<br>n=0表示输入数据的结束，不做处理。</p></blockquote><p>Output</p><blockquote><p>对于每个测试实例，输出在第n年的时候母牛的数量。<br>每个输出占一行。</p></blockquote><p>Sample Input</p><blockquote><p>2<br>4<br>5<br>0</p></blockquote><p>Sample Output</p><blockquote><p>2<br>4<br>6</p></blockquote><p>Problem solving:<br>经典题。每头小母牛从第四年开始就可以每年生一头小牛，所以第n年牛的个数即为<br><code>a[n]=a[n-1]+a[n-3]</code><br>即状态转移方程。a[n-1]代表的是上一年所有的母牛，a[n-3]代表的是上一年所有的母牛能生出来的小牛的个数。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll ans[60];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">ans[0]=0;ans[1]=1;ans[2]=2;ans[3]=3;ans[4]=4;</span><br><span class="line">for(int i=5;i&lt;60;i++)</span><br><span class="line">ans[i]=ans[i-1]+ans[i-3];</span><br><span class="line">int n;</span><br><span class="line">while(cin&gt;&gt;n&amp;&amp;n)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;ans[n]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="一只小蜜蜂"><a href="#一只小蜜蜂" class="headerlink" title="一只小蜜蜂..."></a>一只小蜜蜂...</h3><p>Description:<br>有一只经过训练的蜜蜂只能爬向右侧相邻的蜂房，不能反向爬行。请编程计算蜜蜂从蜂房a爬到蜂房b的可能路线数。<br>其中，蜂房的结构如下所示。<br><img src="http://drew.todest.cn/Z8H9%5B%60GY5~TQ_$GQL%25U%7B1HX.png" alt><br>Input</p><blockquote><p>输入数据的第一行是一个整数N,表示测试实例的个数，然后是N 行数据，每行包含两个整数a和b(0&lt;a&lt;b&lt;50)。</p></blockquote><p>Output</p><blockquote><p>对于每个测试实例，请输出蜜蜂从蜂房a爬到蜂房b的可能路线数，每个实例的输出占一行。</p></blockquote><p>Sample Input</p><blockquote><p>2<br>1 2<br>3 6</p></blockquote><p>Sample Output</p><blockquote><p>1<br>3</p></blockquote><p>Problem solving:<br>状态转移方程<br>ans[i]=ans[i-1]+ans[i-2]</p><p>要到达一个蜂房，如果这个蜂房在第一排，只能从它左边的蜂房或者左下方的蜂房过来；如果这个蜂房在第二排，只能从它左边的蜂房或者左上方的蜂房过来。（摘自<a href="https://blog.csdn.net/Artprog/article/details/69832070" target="_blank" rel="noopener">csdn</a>）</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll ans[55];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,a,b;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">ans[1]=1,ans[2]=1,ans[3]=2;</span><br><span class="line">for(int i=4;i&lt;50;i++)</span><br><span class="line">ans[i]=ans[i-1]+ans[i-2];</span><br><span class="line">while(n--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">cout&lt;&lt;ans[b-a+1]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="超级楼梯"><a href="#超级楼梯" class="headerlink" title="超级楼梯"></a>超级楼梯</h3><p>Description:<br>有一楼梯共M级，刚开始时你在第一级，若每次只能跨上一级或二级，要走上第M级，共有多少种走法？<br>Input</p><blockquote><p>输入数据首先包含一个整数N，表示测试实例的个数，然后是N行数据，每行包含一个整数M（1&lt;=M&lt;=40）,表示楼梯的级数。</p></blockquote><p>Output</p><blockquote><p>对于每个测试实例，请输出不同走法的数量</p></blockquote><p>Sample Input</p><blockquote><p>2<br>2<br>3</p></blockquote><p>Sample Output</p><blockquote><p>1<br>2</p></blockquote><p>Problem solving:<br>每次能走一级台阶或者两级台阶。所以状态转移方程就是<br>ans[i]=ans[i-1]+ans[i-2]</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll ans[45];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">ans[1]=0;</span><br><span class="line">ans[2]=1;</span><br><span class="line">ans[3]=2;</span><br><span class="line">for(int i=4;i&lt;=40;i++)</span><br><span class="line">ans[i]=ans[i-1]+ans[i-2];</span><br><span class="line">int n,m;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">while(n--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;m;</span><br><span class="line">cout&lt;&lt;ans[m]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Tickets"><a href="#Tickets" class="headerlink" title="Tickets"></a>Tickets</h3><p>Description:<br>现在有n个人要买电影票，如果知道每个人单独买票花费的时间，还有和前一个人一起买花费的时间，问最少花多长时间可以全部买完票。<br>Input</p><blockquote><p>给出 N(1&lt;=N&lt;=10)，表示有N组样例 　　　　给出K (1&lt;=K&lt;=2000)，表示有K个人买票.. 　　　　给出K个数表示这个人单独买票会花的时间..保证每个数 (0s&lt;=Si&lt;=25s) 　　　　给出K-1个数，表示这个人和前面那个人一起买票会花的时间..保证每个数 (0s&lt;=Si&lt;=50s)</p></blockquote><p>Output</p><blockquote><p>对于每一组数据，你需要给出电影院售票结束的时间，售票开始的时间为 08:00:00 am. 时间格式为： HH:MM:SS am|pm. 具体看样例输出</p></blockquote><p>Sample Input</p><blockquote><p>2<br>2<br>20 25<br>40<br>1<br>8</p></blockquote><p>Sample Output</p><blockquote><p>08:00:40 am<br>08:00:08 am<br>Problem solving:<br>这道题也是只要找到状态转移方程就行。状态转移方程<br>ans[i]=min(ans[i-1]+s[i],ans[i-2]+d[i]);<br>s[i]是一个人单独买票用的时间，d[i]是两个人一起买票用的时间</p></blockquote><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=2005;</span><br><span class="line">int s[maxn],d[maxn],ans[maxn];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,k;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">while(n--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;k;</span><br><span class="line">for(int i=1;i&lt;=k;i++)cin&gt;&gt;s[i];</span><br><span class="line">for(int j=2;j&lt;=k;j++)cin&gt;&gt;d[j];</span><br><span class="line">ans[1]=s[1];</span><br><span class="line">for(int i=2;i&lt;=k;i++)</span><br><span class="line">&#123;</span><br><span class="line">ans[i]=min(ans[i-1]+s[i],ans[i-2]+d[i]);</span><br><span class="line">&#125;</span><br><span class="line">int time=ans[k];int h,m,s;</span><br><span class="line">h=time/3600;</span><br><span class="line">m=time%3600/60;</span><br><span class="line">s=time%3600%60;</span><br><span class="line">h+=8;</span><br><span class="line">if(h&lt;=12)</span><br><span class="line">printf(&quot;%02d:%02d:%02d am\n&quot;,h,m,s);</span><br><span class="line">else</span><br><span class="line">printf(&quot;%02d:%02d:%02d pm\n&quot;,h-12,m,s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="钱币兑换问题"><a href="#钱币兑换问题" class="headerlink" title="钱币兑换问题"></a>钱币兑换问题</h3><p>Description:<br>在一个国家仅有1分，2分，3分硬币，将钱N兑换成硬币有很多种兑法。请你编程序计算出共有多少种兑法。<br>Input</p><blockquote><p>每行只有一个正整数N，N小于32768。</p></blockquote><p>Output</p><blockquote><p>对应每个输入，输出兑换方法数。</p></blockquote><p>Sample Input</p><blockquote><p>2934<br>12553</p></blockquote><p>Sample Output</p><blockquote><p>718831<br>13137761</p></blockquote><p>Problem solving:<br>emm，这道题我之前在牛客上面遇见过一道类似的题。只不过那道题里面硬币的个数比这个多。直接套着板子写了、、、</p><p>这是个很基础的背包问题，怎么解释交给时间吧，等我理解了就把这个坑填上。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn=35000;</span><br><span class="line">ll ans[maxn];</span><br><span class="line">ll co[4]=&#123;1,2,3&#125;;</span><br><span class="line">ll solve(ll x)</span><br><span class="line">&#123;</span><br><span class="line">ans[0]=1;</span><br><span class="line">for(int i=0;i&lt;3;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=co[i];j&lt;=x;j++)</span><br><span class="line">&#123;</span><br><span class="line">ans[j]=(ans[j]+ans[j-co[i]]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return ans[x];</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">ll n;</span><br><span class="line">while(cin&gt;&gt;n)</span><br><span class="line">&#123;</span><br><span class="line">memset(ans,0,sizeof(ans));</span><br><span class="line">cout&lt;&lt;solve(n)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Ignatius-and-the-Princess-IV"><a href="#Ignatius-and-the-Princess-IV" class="headerlink" title="Ignatius and the Princess IV"></a>Ignatius and the Princess IV</h3><p>Description:<br>给你n个数字，请你找出出现至少(n+1)/2次的数字。<br>输入</p><blockquote><p>本题包含多组数据，请处理到EOF：<br>每组数据包含两行。<br>第一行一个数字N(1&lt;=N&lt;=999999) ，保证N为奇数。<br>第二行为N个用空格隔开的整数。</p></blockquote><p>输出</p><blockquote><p>对于每组数据，输出一行，表示要求找到的那个数</p></blockquote><p>样例输入</p><blockquote><p>5<br>1 3 2 3 3<br>11<br>1 1 1 1 1 5 5 5 5 5 5<br>7<br>1 1 1 1 1 1 1</p></blockquote><p>样例输出</p><blockquote><p>3<br>5<br>1</p></blockquote><p>Problem solving:<br>这道题没啥说的，找就完了，可以边输入边查找。<br>还有很多办法，比如说直接排序。还有dp的方法。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,flag[1000000];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(cin&gt;&gt;n)</span><br><span class="line">&#123;</span><br><span class="line">int ans,a;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a;</span><br><span class="line">flag[a]++;</span><br><span class="line">if(flag[a]&gt;=(n+1)/2)</span><br><span class="line">ans=a;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="最少拦截系统"><a href="#最少拦截系统" class="headerlink" title="最少拦截系统"></a>最少拦截系统</h3><p>Description:<br>某国为了防御敌国的导弹袭击,发展出一种导弹拦截系统.但是这种导弹拦截系统有一个缺陷:虽然它的第一发炮弹能够到达任意的高度,但是以后每一发炮弹都不能超过前一发的高度.某天,雷达捕捉到敌国的导弹来袭.由于该系统还在试用阶段,所以只有一套系统,因此有可能不能拦截所有的导弹.<br>怎么办呢?多搞几套系统呗!你说说倒蛮容易,成本呢?成本是个大问题啊.所以俺就到这里来求救了,请帮助计算一下最少需要多少套拦截系统.<br>Input</p><blockquote><p>输入若干组数据.每组数据包括:导弹总个数(正整数),导弹依此飞来的高度(雷达给出的高度数据是不大于30000的正整数,用空格分隔)</p></blockquote><p>Output</p><blockquote><p>对应每组数据输出拦截所有导弹最少要配备多少套这种导弹拦截系统.</p></blockquote><p>Sample Input</p><blockquote><p>8 389 207 155 300 299 170 158 65</p></blockquote><p>Sample Output</p><blockquote><p>2</p></blockquote><p>Problem solving:<br>这个题我一开始就没读懂。。。<br>以后每一发炮弹都不能超过前一发的高度，所以这个就是求最大上升子序列的长度。<br>给定排好序的一堆数列中，求其的LIS长度。它的LIS长度就是它非上升子序列的个数。<br>我比较喜欢用这种nlog(n)的写法</p><p>这道题还有一个坑点就是<br>如果此时一个数大于它前面那个数，那么拦截系统就要加一，但是并不代表前面那个系统就没用了。这样说比较抽象，举个栗子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100 60 80 20 50</span><br></pre></td></tr></table></figure></p><p>我们来看一下，一开始我们选择100，大于60，换成了60，然后我们遇到了80，此时就需要一个新的系统了，然后现在是80，我们接着往下看遇到了20，再换成20，然后遇到了50，现在的50是大于20没错，但是上一个变成60的系统还可以使用，所以答案是2.</p><p>也就是因为这个所以不可以直接查找遇见大于前面那个数的情况就加一，这也是这个LIS以及dp的巧妙之处！</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e5+10;</span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line">int a[maxn],dp[maxn],n;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int pos;</span><br><span class="line">while(cin&gt;&gt;pos)</span><br><span class="line">&#123;</span><br><span class="line">fill(dp,dp+pos,INF);</span><br><span class="line">for(int i=0;i&lt;pos;i++)cin&gt;&gt;a[i];</span><br><span class="line">for(int i=0;i&lt;pos;i++)</span><br><span class="line">&#123;</span><br><span class="line">*lower_bound(dp,dp+pos,a[i])=a[i];</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;lower_bound(dp,dp+pos,INF)-dp&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天讲了一点关于DP的知识和几道例题，据说这样就算是入门了。今天的题怎么说呢？亏是之前做过，要是之前没做过，还真不知道该怎么写。dp就是玄学？
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="Algorithm" scheme="https://cndrew.cn/blog/tags/Algorithm/"/>
    
      <category term="c/c++" scheme="https://cndrew.cn/blog/tags/c-c/"/>
    
      <category term="DP" scheme="https://cndrew.cn/blog/tags/DP/"/>
    
      <category term="HDU" scheme="https://cndrew.cn/blog/tags/HDU/"/>
    
      <category term="poj" scheme="https://cndrew.cn/blog/tags/poj/"/>
    
  </entry>
  
  <entry>
    <title>HPU Summer Day 12(河南理工大学暑期第十二天)</title>
    <link href="https://cndrew.cn/blog/2019/07/28/d12/"/>
    <id>https://cndrew.cn/blog/2019/07/28/d12/</id>
    <published>2019-07-28T11:30:22.600Z</published>
    <updated>2019-08-04T01:29:39.311Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天休息一天，但是经过了昨天的自闭，我还是选择了在机房坐了大半天，写了不少水题，记录一下几道给我很大感触的题。<a id="more"></a></p><h3 id="烤面包片"><a href="#烤面包片" class="headerlink" title="烤面包片"></a>烤面包片</h3><p>Description:<br>鸡尾酒最喜欢吃东北的烤面包片了。每次到东北地区的区域赛或者是秦皇岛的wannafly camp，鸡尾酒都会吃很多的烤面包片，即使比赛打铁也觉得不枉此行。</p><p>“我想吃烤面包片！！！”这不，半年没吃烤面包片的鸡尾酒看到大家都聚集在秦皇岛参加暑假camp，羡慕地发出了想要的声音。</p><p>当鸡尾酒“想要”的时候，他说的话会带三个感叹号来表示非常“想要”。至于有多“想要”，他给了你一个算式让你来体会。</p><p>给你两个整数 nn 和 modmod，输出 n!!!n!!! 对 modmod 求余的结果（每个!! 都代表一个阶乘符号）</p><p>输入描述</p><blockquote><p>输入共一行包含两个整数依序为 n 和 mod，意义如题面所示。（0≤n≤1e9，1≤mod≤1e9）</p></blockquote><p>输出描述</p><blockquote><p>输出一个小于 mod的非负整数表示答案。</p></blockquote><p>样例输入 1</p><blockquote><p>2 6324</p></blockquote><p>样例输出 1</p><blockquote><p>2</p></blockquote><p>样例输入 2</p><blockquote><p>3 999999999</p></blockquote><p>样例输出 2</p><blockquote><p>731393874</p></blockquote><p>提示</p><blockquote><p>在第一个样例中，由于 2! = 22!=2，所以 2!!! = (((2!)!)!) = ((2!)!) = (2!) = 22!!!=(((2!)!)!)=((2!)!)=(2!)=2。2模了6324还是2！所以答案为2。</p></blockquote><p>Problem solving:<br>这道题一看就吓着我了，阶乘的阶乘的阶乘，这个数可以很大的。我已开始甚至想到了大数打表，但是那样的话时间复杂度也很不乐观，可是这道题过的人还那么多。</p><p>在我的师父——著名acmer——cc的讲解下我知道了这道题的解法。</p><p>如果n是1，或者是2，那么他们阶乘的阶乘就是本身。可以直接输出它本身对mod取模。n是0的情况跟n为1是一样的，因为0的阶乘是1嘛。<br>如果n是3，按照题目中的方式计算即可。<br>如果n&gt;=4,就会出现一个很nb的现象，4!!!是大于1e9很多的，也就是说此时的答案为0.为什么为0呢，因为n大于1e9，mod最大才是1e9，n的阶乘算的过程中一定会乘到一个跟mod相等的数，相等的数取模为0,0乘任何数都为0，所以答案是0.</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll n,mod,nn=720;</span><br><span class="line">ll solve()</span><br><span class="line">&#123;</span><br><span class="line">  if(n==0||n==1)return 1%mod;</span><br><span class="line">  if(n==2)return 2%mod;</span><br><span class="line">  if(n&gt;3)return 0;</span><br><span class="line">ll mid=1;</span><br><span class="line">for(ll i=1;i&lt;=nn;i++)</span><br><span class="line">&#123;</span><br><span class="line">mid*=i;</span><br><span class="line">mid%=mod;</span><br><span class="line">&#125;</span><br><span class="line">return mid;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;mod;</span><br><span class="line">n=solve();</span><br><span class="line">cout&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="幂次方"><a href="#幂次方" class="headerlink" title="幂次方"></a>幂次方</h3><p>Description:<br>任何一个正整数都可以用2的幂次方表示。例如：<br>137=2^7+2^3+2^0<br>同时约定方次用括号来表示，即ab可表示为a（b）。<br>由此可知，137可表示为：<br>2（7）+2（3）+2（0）<br>进一步：7=2^2+2+2^0（2^1用2表示）<br>3=2+2^0<br>所以最后137可表示为：<br>2（2（2）+2+2（0））+2（2+2（0））+2（0）<br>又如：<br>1315=2^10+2^8+2^5+2+1<br>所以1315最后可表示为：<br>2（2（2+2（0））+2）+2（2（2+2（0）））+2（2（2）+2（0））+2+2（0）</p><p>输入描述:</p><blockquote><p>正整数（n ≤ 20000）</p></blockquote><p>输出描述:</p><blockquote><p>符合约定的n的0，2表示（在表示中不能有空格）</p></blockquote><p>示例1<br>输入</p><blockquote><p>1315</p></blockquote><p>输出</p><blockquote><p>2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)</p></blockquote><p>Problem solving:<br>一开始想着用二进制形式表示，然后通过一些特殊的手段一直找1的位置，可以用bitset来实现，可是没写出来，希望如果有大佬会写的话教一下我，感激不尽。</p><p>然后我去百度了一下这道题，就被这道题巧妙地思路给震撼到了。通过递归实现。<br>思路大概就是先找到小于当前数的最大的2的次方数，然后查找下一个2的次方数，这道题用到了递归，就会很抽象一项（像某fs一样令人脱发。不太好理解，多看看代码吧。<br>说实话我也没很懂，啧啧啧</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void solve(int n)</span><br><span class="line">&#123;</span><br><span class="line">if(n&gt;4)</span><br><span class="line">&#123;</span><br><span class="line">int t=1;</span><br><span class="line">while(pow(2,t)&lt;=n)t++;</span><br><span class="line">cout&lt;&lt;&quot;2(&quot;;</span><br><span class="line">solve(t-1);</span><br><span class="line">cout&lt;&lt;&quot;)&quot;;</span><br><span class="line">if(n!=pow(2,t-1))cout&lt;&lt;&quot;+&quot;;</span><br><span class="line">solve(n-pow(2,t-1));</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">switch(n)</span><br><span class="line">&#123;</span><br><span class="line">case 0:return ;</span><br><span class="line">case 1:cout&lt;&lt;&quot;2(0)&quot;; break;</span><br><span class="line">case 2:cout&lt;&lt;&quot;2&quot;; break;</span><br><span class="line">case 3:cout&lt;&lt;&quot;2+2(0)&quot;;break;</span><br><span class="line">case 4:cout&lt;&lt;&quot;2(2)&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">solve(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天休息一天，但是经过了昨天的自闭，我还是选择了在机房坐了大半天，写了不少水题，记录一下几道给我很大感触的题。
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="c/c++" scheme="https://cndrew.cn/blog/tags/c-c/"/>
    
      <category term="nowcoder" scheme="https://cndrew.cn/blog/tags/nowcoder/"/>
    
      <category term="Thinking " scheme="https://cndrew.cn/blog/tags/Thinking/"/>
    
      <category term="comet oj" scheme="https://cndrew.cn/blog/tags/comet-oj/"/>
    
  </entry>
  
  <entry>
    <title>河南理工大学算法协会暑期集训积分赛（二）</title>
    <link href="https://cndrew.cn/blog/2019/07/27/jifen2/"/>
    <id>https://cndrew.cn/blog/2019/07/27/jifen2/</id>
    <published>2019-07-27T14:39:20.785Z</published>
    <updated>2019-08-04T02:09:43.082Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>积分赛，被打爆的积分赛（music<a id="more"></a></p><p>欢迎访问我校oj：<a href="https://hpuoj.com/" target="_blank" rel="noopener">hpuoj</a><br>本场积分赛传送门: <a href="https://hpuoj.com/contest/23/" target="_blank" rel="noopener">Uncle_drew is so handsome</a></p><h3 id="再战斐波那契"><a href="#再战斐波那契" class="headerlink" title="再战斐波那契"></a>再战斐波那契</h3><p>Description:<br>小z 学会了斐波那契和 gcd 后，老师又给他出了个难题，求第N个和第M个斐波那契数的最大公约数，这可难倒了小z ，不过在小z 的再三请求下，老师又告诉他了个条件，gcd(N,M)∈[1,90]。<br>可是，笨拙的小z 还是不会，于是请求你帮他解答这个问题。</p><p>已知:<br><img src="http://drew.todest.cn//20190804100226.png" alt></p><p>输入格式<br>输入包括 T 组，T∈[1,10].<br>接下来 T 行,每行两个整数 N,M, 表示斐波那契的第 N 项和第 M 项，(N,M∈[1,1e18]).</p><p>输出格式<br>输出包含 T 行,每行输出一个整数.</p><p>样例<br>input</p><blockquote><p>3<br>1 2<br>2 3<br>3 4</p></blockquote><p>output</p><blockquote><p>1<br>1<br>1</p></blockquote><p>Problem solving:<br>神tm签到题。。。<br>这道题主要是有个规律斐波那契数列第M项和第N项的gcd就是斐波那契数列第gcd（m,n）项的值。即：<br>gcd(f(m),f(n)) = f(gcd(m,n))<br>顺便记一下<br>long long可以存到大概第92项斐波那契数，unsigned一下会再多一项。Ps：我之前一直以为50项就爆long long了。。。如果知道这个92，那猜这个规律应该就挺简单了吧。<br>而我是跑了N个循环找到的当时并不确定的规律。。。</p><p>Code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">unsigned long long a[100],x,y;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">a[0]=0,a[1]=1;</span><br><span class="line">for(int i=2;i&lt;=100;i++)</span><br><span class="line">&#123;a[i]=a[i-1]+a[i-2];</span><br><span class="line">&#125;</span><br><span class="line">int t;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">cout&lt;&lt;a[__gcd(x,y)]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="恐怖的怪物"><a href="#恐怖的怪物" class="headerlink" title="恐怖的怪物"></a>恐怖的怪物</h3><p>Description:<br>一天早上，Dicer一觉醒来，发现自己来到了MineCraft的世界里面，身为MineCraft游戏爱好者的他欣喜不已，于是他在地下挖了一片长方体的空间作为秘密基地，可是他发现光照亮度小于等于7时，会有恐怖的怪物出现，并且他通过查阅资料发现光源方块产生光照每一米（方格）衰减1光照等级。</p><p>此规律在坐标轴的3个方向上（东西、南北、上下）均成立。换句话来说，对角线方向的光照衰减依照“曼哈顿距离”（两个点在坐标系上的绝对轴距总和）计算。这意味着，假如地上插着一支火把（光照等级14），则在水平面上与火把相邻的4个方向的方格上光照等级均为13，而在水平面上与火把对角的4个方格上光照等级均为12（譬如，西北方格的光照等级为14-向西1级-向北1级）。</p><p>上述这种衰减特性会在光源周围产生菱形的照明。该效果会在光源周围的光源扩散呈钻石状。如果被不透明方块阻挡，光照也可以沿着复杂而弯曲的路径扩散。</p><p>如下图所示，红色为光源（亮度等级为14）,黑色为秘密物品，其余各个位置光照强度如图所示。<br><img src="http://drew.todest.cn//20190804100243.png" alt></p><p>秘密基地为N∗M的空间，不考虑高度，初始地面光照强度为0。为了不生成恐怖的怪物，Dicer布置了一些光源，但他不知道是否仍会生成怪物，现在请你帮助Dicer判断。</p><p>注：光源及秘密物品均为不透明方块，且其上方均不会生成怪物。</p><p>输入格式<br>第一行是一个T。（1≤T≤100）<br>接下来有T组数据，每一组第一行是N,M,（1≤N,M≤1000）,接下来有N行，每行M个字符，代表秘密基地地面放置的方块，0代表空气，#代表秘密物品，Y代表萤石(光照等级为15)，H代表火把(光照等级为14)，F代表附魔台(光照等级为12)，R代表激活的红石火把(光照等级为7)。</p><p>输出格式<br>输出包含T行，每行如果仍会生成怪物，输出”Yes”,否则输出”No”。</p><p>样例<br>input</p><blockquote><p>2<br>2 3<br>0Y0<br>00#<br>3 4<br>R00#<br>00R0<br>0R00</p></blockquote><p>output</p><blockquote><p>No<br>Yes</p></blockquote><p>input</p><blockquote><p>2<br>1 5<br>0Y0R0<br>2 4<br>Y#0R<br>0000</p></blockquote><p>output</p><blockquote><p>Yes<br>No</p></blockquote><p>input</p><blockquote><p>1<br>5 4<br>Y0F0<br>0000<br>0000<br>0000<br>0000</p></blockquote><p>output</p><blockquote><p>No</p></blockquote><p>Problem solving:<br>简单？的bfs问题。就是条件有点多。。。比赛的时候写炸了</p><p>这道题给了5s，按理说只要查找写的对，就不会超时。我想了一下我的方法，应该是里面出现了死循环，咳咳。</p><p>这道题的难点就是每个点的亮度有可能源于两个点，而你肯定要取最大值。但是怎么取？我一开始直接用了max，然后就是一直tle，因为这样会出现死循环的情况，就是满足不了return的情况。后来看了学长的代码，吃了一惊，原来还可以这样写。</p><p>开三个队列，分别存储出现Y，H，F的位置。然后从存着Y的队列开始进行bfs，如果当前亮度是到了14，就把装有H的队列中的元素放入第一个队列继续bfs，12也是同理。这一点还挺好理解的。这样操作的话，每个点自然就是可以达到尽可能大的亮度。最后在判断有没有小于等于7的空地存在即可。</p><p>在今天之前我还一直以为我的bfs挺不错的。现在我觉得我连mc的资深玩家都不配当了。<br>Code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn=1010;</span><br><span class="line">int t,n,m,l[maxn][maxn];</span><br><span class="line">char s[maxn][maxn];</span><br><span class="line">int d[4][2]=&#123;1,0,0,1,-1,0,0,-1&#125;;</span><br><span class="line">struct node&#123;</span><br><span class="line">int x,y;</span><br><span class="line">&#125;;</span><br><span class="line">queue&lt;node&gt; wo,yao,meizi;</span><br><span class="line">bool bfs()</span><br><span class="line">&#123;</span><br><span class="line">while(!wo.empty())</span><br><span class="line">&#123;</span><br><span class="line">int x=wo.front().x;</span><br><span class="line">int y=wo.front().y;</span><br><span class="line">wo.pop();</span><br><span class="line">if(l[x][y]==8)break;</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">int dx=x+d[i][0];</span><br><span class="line">int dy=y+d[i][1];</span><br><span class="line">if(dx&lt;0||dx&gt;=n||dy&lt;0||dy&gt;=m||s[dx][dy]!=&apos;0&apos;||l[dx][dy])</span><br><span class="line">continue;</span><br><span class="line">l[dx][dy]=l[x][y]-1;</span><br><span class="line">wo.push(&#123;dx,dy&#125;);</span><br><span class="line">while(l[dx][dy]==14&amp;&amp;(!yao.empty()))</span><br><span class="line">&#123;</span><br><span class="line">wo.push(yao.front());</span><br><span class="line">yao.pop();</span><br><span class="line">&#125;</span><br><span class="line">while(l[dx][dy]==12&amp;&amp;(!meizi.empty()))</span><br><span class="line">&#123;</span><br><span class="line">wo.push(meizi.front());</span><br><span class="line">meizi.pop();</span><br><span class="line">&#125;</span><br><span class="line">//cout&lt;&lt;l[dx][dy]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">for(int j=0;j&lt;m;j++)</span><br><span class="line">if(l[i][j]&lt;=7&amp;&amp;s[i][j]==&apos;0&apos;)return 0;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">while(!wo.empty())wo.pop();</span><br><span class="line">while(!yao.empty())yao.pop();</span><br><span class="line">while(!meizi.empty())meizi.pop();</span><br><span class="line">memset(l,0,sizeof(l));</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;m;j++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;s[i][j];</span><br><span class="line">if(s[i][j]==&apos;Y&apos;)wo.push(&#123;i,j&#125;),l[i][j]=15;</span><br><span class="line">if(s[i][j]==&apos;H&apos;)yao.push(&#123;i,j&#125;),l[i][j]=14;</span><br><span class="line">if(s[i][j]==&apos;F&apos;)meizi.push(&#123;i,j&#125;),l[i][j]=12;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(bfs())puts(&quot;No&quot;);</span><br><span class="line">elseputs(&quot;Yes&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="连连看"><a href="#连连看" class="headerlink" title="连连看"></a>连连看</h3><p>Description:<br>众所周知，《连连看》是一个老少皆宜的游戏。<br>《连连看》是由黄兴武创作的一款PC端益智类游戏，只要将相同的两张牌用三根以内的线段连在一起就可以消除，规则简单容易上手。</p><p>现在呢，Boctorio学长突然想玩连连看了，但不是单纯的玩游戏，他想自己出一局连连看。<br>由于Boctorio学长是一个蒟蒻，他不知道自己出的连连看是否符合能够通过多次操作将其全部消除，所以想要你帮他检查一下他出的连连看是否符合规则。</p><p>输入格式<br>第一行输入个T,表示T组数据（1≤t≤100）<br>每组数据第一行两个数 n,m ,表示连连看棋盘的长和宽（1≤n,m≤100）<br>接下来 n 行，每行输入 m 个正整数aij，表示 m 个棋子 (1≤aij≤n∗m)。</p><p>每种棋子只会出现一对，因此数据保证只有一种有效结果。</p><p>输出格式<br>每组数据输出一行。<br>如果棋盘符合规定，输出”Yes”，否则，输出”No”（不包括引号）。</p><p>样例<br>input</p><blockquote><p>3<br>2 2<br>1 2<br>2 1<br>3 4<br>1 6 2 3<br>4 5 3 1<br>4 2 6 5<br>4 4<br>1 2 3 6<br>8 4 7 8<br>5 6 5 7<br>1 2 3 4</p></blockquote><p>output</p><blockquote><p>No<br>No<br>Yes</p></blockquote><p>Problem solving:<br>暂无(毫无思路题)</p><p>Code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *　　　　　　　　┏┓　　 　┏┓</span><br><span class="line"> * 　　　　　　　┏┛┗━━━━━━━┛┗━━━┓</span><br><span class="line"> * 　　　　　　　┃　　　　　　　┃ 　</span><br><span class="line"> * 　　　　　　　┃　　　━　　 　┃</span><br><span class="line"> * 　　　　　　　┃　＞　　　＜　┃</span><br><span class="line"> * 　　　　　　　┃　　　　　　　┃</span><br><span class="line"> * 　　　　　　　┃...　⌒　... 　┃</span><br><span class="line"> * 　　　　　　　┃　　　　　　　┃</span><br><span class="line"> * 　　　　　　　┗━┓　　　┏━┛</span><br><span class="line"> * 　　　　　　　　　┃　　　┃　Code is far away from bug with the animal protecting　　　　　　　　　　</span><br><span class="line"> * 　　　　　　　　　┃　　　┃   神兽保佑,代码无bug</span><br><span class="line"> * 　　　　　　　　　┃　　　┃　　　　　　　　　　　</span><br><span class="line"> * 　　　　　　　　　┃　　　┃  　　　　　　</span><br><span class="line"> * 　　　　　　　　　┃　　　┃</span><br><span class="line"> * 　　　　　　　　　┃　　　┃　　　　　　　　　　　</span><br><span class="line"> * 　　　　　　　　　┃　　　┗━━━┓</span><br><span class="line"> * 　　　　　　　　　┃　　　　　　　┣┓</span><br><span class="line"> * 　　　　　　　　　┃　　　　　　　┏┛</span><br><span class="line"> * 　　　　　　　　　┗┓┓┏━┳┓┏┛</span><br><span class="line"> * 　　　　　　　　　　┃┫┫　┃┫┫</span><br><span class="line"> * 　　　　　　　　　　┗┻┛　┗┻┛</span><br><span class="line"> */</span><br><span class="line">// warm heart, wagging tail,and a smile just for you!</span><br><span class="line">//</span><br><span class="line">//                            _ooOoo_</span><br><span class="line">//                           o8888888o</span><br><span class="line">//                           88&quot; . &quot;88</span><br><span class="line">//                           (| -_- |)</span><br><span class="line">//                           O\  =  /O</span><br><span class="line">//                        ____/`---&apos;\____</span><br><span class="line">//                      .&apos;  \|     |//  `.</span><br><span class="line">//                     /  \|||  :  |||//  \</span><br><span class="line">//                    /  _||||| -:- |||||-  \</span><br><span class="line">//                    |   | \\  -  /// |   |</span><br><span class="line">//                    | \_|  &apos;&apos;\---/&apos;&apos;  |   |</span><br><span class="line">//                    \  .-\__  `-`  ___/-. /</span><br><span class="line">//                  ___`. .&apos;  /--.--\  `. . __</span><br><span class="line">//               .&quot;&quot; &apos;&lt;  `.___\_&lt;|&gt;_/___.&apos;  &gt;&apos;&quot;&quot;.</span><br><span class="line">//              | | :  `- \`.;`\ _ /`;.`/ - ` : | |</span><br><span class="line">//              \  \ `-.   \_ __\ /__ _/   .-` /  /</span><br><span class="line">//         ======`-.____`-.___\_____/___.-`____.-&apos;======</span><br><span class="line">//                            `=---=&apos;</span><br><span class="line">//        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class="line">//</span><br></pre></td></tr></table></figure></p><h3 id="Points-in-rectangle"><a href="#Points-in-rectangle" class="headerlink" title="Points in rectangle"></a>Points in rectangle</h3><p>Description:<br>在二维平面中有一个矩形，它的四个坐标点分别为(0,a),(a,0),(n,n−a),(n−a,n)。你现在有m个点，现在你想知道有多少个点是在这个矩形内的(边上的也算)。</p><p>输入格式<br>第一行输入n,a(1≤a\&lt;n≤1e3)。<br>第二行一个正整数m(1≤m≤1e3),代表你拥有的点的个数，接下来m行，每行一个点的坐标xi,yi(1≤xi,yi≤1e3)。</p><p>输出格式<br>第一行输出在矩形内的点的个数，然后输出在矩形内点的坐标，横坐标大的优先，如果横坐标相同，则纵坐标大的优先。如果没有，输出−1。</p><p>样例<br>input</p><blockquote><p>6 1<br>5<br>1 2<br>1 3<br>2 3<br>3 4<br>4 5</p></blockquote><p>output</p><blockquote><p>4<br>4 5<br>3 4<br>2 3<br>1 2</p></blockquote><p>Problem solving:<br>也算是一道签到了吧，就是不太好想，不画一下的话。<br>我的思路是把四条边的表达式写出来，对每个输入的x找出y的边界值然后进行比较。</p><p>如图所示，将图分为三部分，然后我们可以这样判断<br>1.如果x，y中有一个大于n的，就说明这个点不会在矩形中<br>2.x\&lt;a的时候，根据x的值求出直线表达式y1,y2所对应的值，此时y1的值就是下界，y2的值就是上界，如果y在y1和y2中间就说明这个点在矩阵中。<br>3.x&gt;n-a的时候，跟上面一样不过此时上下界对应的值是y2和y4<br>4.x&gt;a &amp;&amp; x\&lt;n-a的时候，上下界对应的值是y3和y4</p><p>关于y1，y2,y3,y4的表达式<br>本题中这个还是很好求得的<br>y1=-x+a                y2=x+a<br>y3=-x+2*n-a            y4=x-a</p><p><img src="http://drew.todest.cn//20190804100330.png" alt></p><p>判断完用结构体排一下序输出即可。</p><p>Code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">int x,y;</span><br><span class="line">&#125;p[1005];</span><br><span class="line">bool cmp(node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">if(a.x==b.x)return a.y&gt;b.y;</span><br><span class="line">return a.x&gt;b.x;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,a,m,x,y,pos=0;</span><br><span class="line">double s,k,sx,sy;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;a&gt;&gt;m;</span><br><span class="line">for(int i=0;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">if(x&gt;n||y&gt;n)continue;</span><br><span class="line">if(x&gt;=a&amp;&amp;x&lt;=n-a)</span><br><span class="line">&#123;</span><br><span class="line">if(y&gt;x+a||y&lt;x-a)continue;</span><br><span class="line">&#125;</span><br><span class="line">if(x&lt;a)</span><br><span class="line">&#123;</span><br><span class="line">if(y&gt;x+a||y&lt;-x+a)continue;</span><br><span class="line">&#125;</span><br><span class="line">if(x&gt;n-a)</span><br><span class="line">&#123;</span><br><span class="line">if(y&lt;x-a||y&gt;-x+2*n-a)continue;</span><br><span class="line">&#125;</span><br><span class="line">p[pos].x=x,p[pos].y=y;</span><br><span class="line">pos++;</span><br><span class="line">&#125;</span><br><span class="line">if(pos==0)</span><br><span class="line">puts(&quot;-1&quot;);</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;pos&lt;&lt;endl;</span><br><span class="line">sort(p,p+pos,cmp);</span><br><span class="line">for(int i=0;i&lt;pos;i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;p[i].x&lt;&lt;&apos; &apos;&lt;&lt;p[i].y&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Numbers-of-interval"><a href="#Numbers-of-interval" class="headerlink" title="Numbers of interval"></a>Numbers of interval</h3><p>Description:<br><img src="https:///2019/07/27/5d3c2d6a4a45986514.png" alt></p><p>输入格式<br>第一行输入n,k(1≤n,k≤1e6).<br>接下来输入n个数，第i个数为ai(1≤ai≤1e3).</p><p>输出格式<br>输出满足条件的区间个数</p><p>样例<br>input<br>3 5<br>2 3 5<br>output<br>4</p><p>Problem solving:<br>这道题做出来的人很多，我忘了lower_bound，用一个前缀和数组就行了。注意这道题的ans会爆int。<br>这道题看了学长的题解和标程之后觉得自己明白的很透彻。然后跟一个同学交流这道题的时候发现自己也是没那么明白。不过现在还是很透彻的，记录一下。</p><p>主要需要理解的就是在你构造的前缀和数组中第n项到第m项的和为<br>sum[m]-sum[n-1](注意是n-1，如果是n的话，那表示的就是第n+1项到第m项的和，因为你会把a[n]也减掉。</p><p>现在我们要查找区间和大于等于k的区间个数，因为是前缀和数组，所以构造出来的前缀和数组一定是有序的（升序。如果直接O(n*n)，1e6的数据范围肯定会超时。又正好看到数组是有序的，这时候就<del>~很自然</del>~的想到二分(虽然我并没有想到)。区间和大于等于k即a[m]-a[n-1]&gt;=k,所以我们先确定区间的左端点，然后二分查找到第一个使区间和大于等于k的右端点的值，此时我们找到的这个右端点的右面的每一个端点都可以跟那个确定的左端点组成一个区间和大于等于k的区间，查找所有点为左端点的情况，答案累加即可。<br>唯一有点绕的就是sum[n]-sum[m-1]&gt;=k换成了sum[m-1]+k&lt;=sum[n]<br>查找第一个符合要求的右端点可以这样写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lower_bound(sum+1,sum+n+1,k+a[i-1])-sum</span><br></pre></td></tr></table></figure></p><p>Code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[1000050],p[1000050];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,k;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">cin&gt;&gt;a[i],p[i]=p[i-1]+a[i];</span><br><span class="line">long long ans=0;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">int mid=lower_bound(p+1,p+1+n,p[i-1]+k)-p;</span><br><span class="line">ans+=(n-mid+1);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="剪纸"><a href="#剪纸" class="headerlink" title="剪纸"></a>剪纸</h3><p>Description:<br>中国剪纸是一种用剪刀或刻刀在纸上剪刻花纹，用于装点生活或配合其他民俗活动的民间艺术。在中国，剪纸具有广泛的群众基础，交融于各族人民的社会生活，是各种民俗活动的重要组成部分。其传承赓续的视觉形象和造型格式，蕴涵了丰富的文化历史信息，表达了广大民众的社会认以、道德观念、实践经验、生活理想和审美情趣，具有认知、教化、表意、抒情、娱乐、交往等多重社会价值。<br>2006年5月20日，剪纸艺术遗产经国务院批准列入第一批国家级非物质文化遗产名录 。2009年9月28日至10月2日举行的联合国教科文组织保护非物质文化遗产政府间委员会第四次会议上，中国申报的中国剪纸项目入选“人类非物质文化遗产代表作名录”。</p><p>剪窗花最基本的操作为将剪纸进行多次对折，然后对对折之后的纸进行裁剪，展开后就是一个精美的艺术品。现在我们对问题进行化简，我们利用如下方法将一张形状矩形的纸按照对阵轴进行对折：<br><img src="http://drew.todest.cn//20190804100348.png" alt><br>假设剪后的形状为一个三角形，则展开效果为：<br><img src="http://drew.todest.cn//20190804100532.png" alt><br>现在给你一个对折两次且剪切后的图形，请你给出展开的图形形状。</p><p>输入格式<br>多组输入，处理到文件结束。<br>每组输入第一行两个数字n,m（1≤n,m≤100)。<br>接下来n行，每行m个字符，表示对折且剪切后的图形。<br>保证输入字符只包含 ‘.’ 和 ‘*’ 。</p><p>输出格式<br>输出展开后的图形。</p><p>样例<br>input<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">**.</span><br><span class="line">*..</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>output<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">..**..</span><br><span class="line">.****.</span><br><span class="line">.****.</span><br><span class="line">..**..</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p><p>Problem solving:<br>签到题，搞清楚每个点的关系就行。（这个我写的可能是有点麻烦了，可以去看一下下面学长的标程</p><p>Code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m;</span><br><span class="line">char a[405][405];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;m))</span><br><span class="line">&#123;</span><br><span class="line">for(int i=n;i&lt;2*n;i++)</span><br><span class="line">for(int j=m;j&lt;2*m;j++)</span><br><span class="line">cin&gt;&gt;a[i][j];</span><br><span class="line">for(int i=n;i&lt;2*n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;m;j++)</span><br><span class="line">&#123;</span><br><span class="line">a[i][j]=a[i][2*m-j-1];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;m;j++)</span><br><span class="line">&#123;</span><br><span class="line">a[i][j]=a[2*n-i-1][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=m;j&lt;2*m;j++)</span><br><span class="line">&#123;</span><br><span class="line">a[i][j]=a[2*n-i-1][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;2*n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;2*m;j++)</span><br><span class="line">cout&lt;&lt;a[i][j];</span><br><span class="line">puts(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Fake-hpuoj-predictor"><a href="#Fake-hpuoj-predictor" class="headerlink" title="Fake hpuoj predictor"></a>Fake hpuoj predictor</h3><p>Description:<br>总所周知，HPU(Harmonious and Peaceful University) Online Judge具有一个强大的的rating(积分)系统，它采用的是国际上权威的ELO等级分制度(ELO Rating System)，LOL，守望先锋,codeforces,topcoder等知名游戏的排行均是采用此制度。<br>具体算法为：<br><img src="http://drew.todest.cn//20190804100820.png" alt><br>其中R(A)和R(B)为选手A和B初始的rating，那么E(A)和E(B)即为这两者进行对战后A和B各自获胜的期望。<br>本场比赛的积分公式即为<br><img src="http://drew.todest.cn//20190804100845.png" alt><br>RA代表上轮比赛结束后的积分。<br>K为积分系数,对于不同等级的选手的K是不同的。<br>SA代表比赛实际总得分，对于每局比赛来说，每赢一个人就会加1分,输了不扣分。<br>EAi代表A与第i个选手比赛获胜的期望。<br>对于HPU Online Judge，用户等级表为:<br><img src="http://drew.todest.cn//20190804100927.png" alt><br>codancer有一个成为Grand Master的梦想，已知他的初始rating为0，他总共参加了m场比赛，对于每场比赛有一个榜单，对于codancer来说，排在他前面的人都打败了他，排在他后面的人都输给了他，因此你可以通过和每个参加比赛的选手比较计算出总得分SA和总期望∑EAi。<br>那么最终codancer打完本场比赛后的rating为<br><img src="http://drew.todest.cn//20190804100941.png" alt><br>现在他打完了这m场比赛后他迫切的想知道自己的rating变为了多少(因为管理员太懒了，已经鸽了m场的rating计算了)，现在他想让你帮他写一个预测器来预测一下。</p><p>输入格式<br>单组输入，第一行输入一个m(1≤m≤100)，代表codancer参加的比赛的数量。<br>接下来对于每场比赛：<br>第一行输入一个整数n代表有n(1≤n≤100)个人参加的比赛。<br>接下来n行每行输入一个字符串和数字，代表参赛选手的用户名和他的rating，codancer即为他自己的用户名(用户名长度不超过20)，假如输入的名字为codancer,则不用输入数字(其他参赛选手的rating是不会更新的，因为管理员太懒了)。</p><p>输出格式<br>输出codancer最终的rating，向上取整。</p><p>样例<br>input</p><blockquote><p>3<br>5<br>tourist 2000<br>capryang 1900<br>boctorio 1800<br>dicer 1800<br>codancer<br>2<br>codancer<br>rookie 200<br>2<br>wzy 1500<br>codancer</p></blockquote><p>output</p><blockquote><p>12</p></blockquote><p>提示<br>每计算完一场都需要向上取整，建议参与运算的变量都使用double。</p><p>Problem solving:<br>这道题的难点就是读题。读懂了之后直接模拟就行了。<br>学长说：写了就能过。。。<br>然后我无限wa。最后借了学长的代码看了一下。也没发现有啥不一样的，可能就是精度问题吧。</p><p>Code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">double find(double x)</span><br><span class="line">&#123;</span><br><span class="line">if(x&lt;=1349)return 15;</span><br><span class="line">if(x&lt;=1499)return 20;</span><br><span class="line">if(x&lt;=1599)return 25;</span><br><span class="line">if(x&lt;=1699)return 30;</span><br><span class="line">if(x&lt;=1799)return 35;</span><br><span class="line">return 50;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">string s;</span><br><span class="line">double ra=0,rb;</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">double ea=0,sum=0;</span><br><span class="line">double k=find(ra),sa=0;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">if(s==&quot;codancer&quot;)</span><br><span class="line">&#123;</span><br><span class="line">sa=n-i;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">cin&gt;&gt;rb;</span><br><span class="line">ea=1.0/(1+pow(10,(rb-ra)/400));</span><br><span class="line">sum+=ea;</span><br><span class="line">&#125;</span><br><span class="line">ra=ceil(ra+k*(sa-sum));</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%.0lf\n&quot;,ra);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="花花与三猫Catlive"><a href="#花花与三猫Catlive" class="headerlink" title="花花与三猫Catlive"></a>花花与三猫Catlive</h3><p>Description:<br>“大佬”中分和“呆B”李白正在玩一个游戏，游戏规则是这样的：</p><ol><li>游戏刚开始的时候，中分和李白相距L步，相对而望。</li><li>老父亲和老母亲手中各有一个M个面的均匀骰子。（也就是说可以随机生成[1,m]内的任意一个数字，且概率均等）</li><li>在每个回合开始的时候，老父亲和老母亲都会掷一下手中的骰子。</li><li>当老父亲的骰子掷到1的时候，中分可以向李白走一步。</li><li>当老母亲的骰子掷到m的时候，李白可以向中分走一步。</li><li>当中分和李白相遇的时候，游戏结束。</li></ol><p>可是老父亲和老母亲刚刚拍完新节目，他们太累了，不想做这个游戏，但是他们还很想知道，这个游戏平均需要多少次才能结束。聪明的你，能告诉他们吗？</p><p>结果是一个实数s，可以证明s能被表示成一个分数 qp，请输出q⋅p−1，其中q−1表示q在模109+7意义下的逆元。</p><p>输入格式<br>第一行是一个正整数 T(1≤T≤1000)，表示测试样例的组数。<br>接下来T行，每行两个正整数L,M(1≤L,M≤1000)，含义如题面描述。</p><p>输出格式<br>输出包括T行，每行一个答案。</p><p>样例<br>input</p><blockquote><p>2<br>1 2<br>2 1</p></blockquote><p>output</p><blockquote><p>1<br>1</p></blockquote><p>提示<br>2在模109+7意义下的逆元是500000004<br>Problem solving:<br>这道题比赛的时候嫌题面太长我就没看。后来发现这就是一道水题。。。题意就是两个人的距离给出了是L，用一个m面的骰子掷一下，如果是1或者m，就会有人走一步，不用管是谁走，效果都是一样的。所以每次有人走一步的概率就是2/m，总共要走l步，让输出的就是l/（2/m），即l*m/2<br>表面上这道题还让你求逆元，实际上这里我们用到的只有2的逆元，而且还给出了2在模1e9+7意义下的逆元。所以，是个水题。以后这种看见题面太长就不想看的坏毛病必须得改一下了。</p><p>Code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">long long n,m;</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">cout&lt;&lt;n*m*500000004%1000000007&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Same-String"><a href="#Same-String" class="headerlink" title="Same String"></a>Same String</h3><p>Description:<br>有两个只由小写字母组成的长度为n的字符串s1,s2和m组字母对应关系，每一组关系由两个字母c1和c2组成，代表c1可以直接变成c2,你需要判断s1是否可以通过这m组关系转换为s2。</p><p>输入格式<br>第一行输入一个n(1≤n≤100)，代表字符串的长度。<br>第二行和第三行输入两个字符串s1,s2。<br>第四行输入一个m(1≤m≤325)，代表有m组关系。<br>接下来m行，第i行两个字符ui,vi,代表ui可以直接变为vi。</p><p>输出格式<br>如果s1可以通过这些m组关系转化变为s2，输出”YES”，否则输出”NO”。</p><p>样例<br>input</p><blockquote><p>6<br>aabbcc<br>cdbcad<br>4<br>a c<br>c a<br>a d<br>b c</p></blockquote><p>output</p><blockquote><p>YES</p></blockquote><p>提示<br>可以转换多次，比如a可以转换为b，而b可以转换为c，则a可以转换为c。<br>样例一：aabbcc-&gt;cabbcc-&gt;cdbbcc-&gt;cdbccc-&gt;cdbcac-&gt;cdbcaa-&gt;cdbcad<br>Problem solving:<br>这道题我是用存图做的，跟昨天专练里面的一道题很像，就不详细讲了。<br>这道题还有另一种算法，可以看下面学长的标程<br>Code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int mmp[50][50],vis[50];</span><br><span class="line">bool bfs(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">q.push(x);vis[x]=1;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">x=q.front();q.pop();</span><br><span class="line">if(x==y)return 1;</span><br><span class="line">for(int i=0;i&lt;=26;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(mmp[x][i]&amp;&amp;vis[i]==0)</span><br><span class="line">&#123;</span><br><span class="line">q.push(i);</span><br><span class="line">vis[i]=1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,m;string a,b;</span><br><span class="line">char c,d;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;a&gt;&gt;b&gt;&gt;m;</span><br><span class="line">for(int i=0;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;c&gt;&gt;d;</span><br><span class="line">int x=c-&apos;a&apos;,y=d-&apos;a&apos;;</span><br><span class="line">mmp[x][y]=1;</span><br><span class="line">&#125;</span><br><span class="line">int flag=0;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">if(bfs(a[i]-&apos;a&apos;,b[i]-&apos;a&apos;)==0)</span><br><span class="line">&#123;</span><br><span class="line">flag=1;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(flag)puts(&quot;NO&quot;);</span><br><span class="line">elseputs(&quot;YES&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="学长标程和题解"><a href="#学长标程和题解" class="headerlink" title="学长标程和题解"></a>学长标程和题解</h3><h4 id="再战斐波那契-1"><a href="#再战斐波那契-1" class="headerlink" title="再战斐波那契"></a>再战斐波那契</h4><p>Problem solving:<br>打表找规律会发现GCD(F(N),F(M))=F(GCD(N,M))</p><p>Code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long</span><br><span class="line">ll f[10000];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">ll n,m;</span><br><span class="line">f[1]=f[2]=1;</span><br><span class="line">for(int i=3;i&lt;=100;i++) f[i]=f[i-1]+f[i-2];</span><br><span class="line">int t;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">while(t--)&#123;</span><br><span class="line">scanf(&quot;%lld %lld&quot;,&amp;n,&amp;m);</span><br><span class="line">printf(&quot;%lld\n&quot;,f[__gcd(n,m)]);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="恐怖的怪物-1"><a href="#恐怖的怪物-1" class="headerlink" title="恐怖的怪物"></a>恐怖的怪物</h4><p>Problem solving:<br>对于每个有光源的点暴力的BFS<br>每次BFS 更新各点光源的最大值<br>不透明方块不需要更新</p><p>Code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long</span><br><span class="line">#define pii pair&lt;int,int&gt;</span><br><span class="line">const int inf=0x3f3f3f3f;</span><br><span class="line">const ll INF=0x3f3f3f3f3f3f3f3f;</span><br><span class="line">const int maxn=1000+10;</span><br><span class="line"></span><br><span class="line">int t,n,m;</span><br><span class="line">char mp[maxn][maxn];</span><br><span class="line">int vis[maxn][maxn];</span><br><span class="line">int d[4][2]=&#123;1,0,-1,0,0,1,0,-1&#125;;</span><br><span class="line">queue&lt;pii&gt;H,F;</span><br><span class="line">queue&lt;pii&gt;que;</span><br><span class="line">void init()&#123;</span><br><span class="line">while(!que.empty()) que.pop();</span><br><span class="line">while(!H.empty()) H.pop();</span><br><span class="line">while(!F.empty()) F.pop();</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">for(int j=1;j&lt;=m;j++)</span><br><span class="line">vis[i][j]=0;</span><br><span class="line">&#125;</span><br><span class="line">bool BFS()&#123;</span><br><span class="line">while(!que.empty())&#123;</span><br><span class="line">int x=que.front().first;</span><br><span class="line">int y=que.front().second;</span><br><span class="line">que.pop();</span><br><span class="line">if(vis[x][y]==8) break;</span><br><span class="line">for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">int xx=x+d[i][0];</span><br><span class="line">int yy=y+d[i][1];</span><br><span class="line">if(xx&lt;=0 || xx&gt;n || yy&lt;=0 || yy&gt;m || vis[xx][yy] || mp[xx][yy]!=&apos;0&apos;) continue;</span><br><span class="line">vis[xx][yy]=vis[x][y]-1;</span><br><span class="line">que.push(pii(xx,yy));</span><br><span class="line">while(vis[xx][yy]==14 &amp;&amp; (!H.empty()))&#123;</span><br><span class="line">que.push(H.front());</span><br><span class="line">H.pop();</span><br><span class="line">&#125;</span><br><span class="line">while(vis[xx][yy]==12 &amp;&amp; (!F.empty()))&#123;</span><br><span class="line">que.push(F.front());</span><br><span class="line">F.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">for(int j=1;j&lt;=m;j++)</span><br><span class="line">if(vis[i][j]&lt;=7 &amp;&amp; mp[i][j]==&apos;0&apos;) return false;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">while(t--)&#123;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;n,&amp;m);</span><br><span class="line">init();</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">scanf(&quot;%s&quot;,mp[i]+1);</span><br><span class="line">for(int j=1;j&lt;=m;j++)&#123;</span><br><span class="line">if(mp[i][j]==&apos;Y&apos;) que.push(pii(i,j)),vis[i][j]=15 ;//15</span><br><span class="line">if(mp[i][j]==&apos;H&apos;) H.push(pii(i,j)),vis[i][j]=14;//14</span><br><span class="line">if(mp[i][j]==&apos;F&apos;) F.push(pii(i,j)),vis[i][j]=12;//12</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(BFS()) printf(&quot;No\n&quot;);</span><br><span class="line">else printf(&quot;Yes\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="连连看-1"><a href="#连连看-1" class="headerlink" title="连连看"></a>连连看</h4><p>Problem solving:<br>dfs 瞎胡找即可，保存上一步的位置，上一步的方向，上一<br>步为止的拐角数，然后处理一些复杂的情况可。<br>由于只有三个条直线，只能拐两个弯，dfs 能够剪枝至很低<br>的复杂度，标程大约为0.3s。<br>（由于年代久远，其实出题人也不太记得这个题是不是有什<br>么坑了。</p><p>Code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long</span><br><span class="line">int mp[200][200];</span><br><span class="line">int n,m;</span><br><span class="line">int sx,sy;</span><br><span class="line">int dir[4][2]=&#123;&#123;1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;;//分别对应下，右，左，上</span><br><span class="line">int check(int x,int y)&#123;</span><br><span class="line">if(x&lt;0 || x&gt;n+1 || y&lt;0 || y&gt;m+1)</span><br><span class="line">return 1;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool judge(int x,int y,int step,int pos)&#123;//pos表示上一步方向</span><br><span class="line">if(step&gt;3) return 0;//如果超过了三步，不符合规则</span><br><span class="line">if(mp[x][y]==mp[sx][sy] &amp;&amp; pos!=-1)&#123;//如果两个字符相等并且不是同一个（由于下面有方向限制，所以两个值不可能相等）</span><br><span class="line">mp[x][y]=0;//删去配对字符</span><br><span class="line">mp[sx][sy]=0;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">if(mp[x][y]!=0 &amp;&amp; pos!=-1) return 0;//如果不相等并且不是通路，不符合规则</span><br><span class="line">int i,x1,y1;</span><br><span class="line">for(i=0;i&lt;4;i++)&#123;</span><br><span class="line">if(i+pos==3) continue;//不能有正相反的方向 (0.下 3.上)   (1.右 2.左)</span><br><span class="line">x1=x+dir[i][0];</span><br><span class="line">y1=y+dir[i][1];</span><br><span class="line">if(check(x1,y1)) continue;//检查是否越界</span><br><span class="line">if(judge(x1,y1,step+(pos==i?0:1),i))&#123;//找到一个就返回</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t,times,sum;</span><br><span class="line">int i,j;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">while(t--)&#123;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;n,&amp;m);</span><br><span class="line">memset(mp,0,sizeof(mp));</span><br><span class="line">for(i=1;i&lt;=n;i++)&#123;</span><br><span class="line">for(j=1;j&lt;=m;j++)&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;mp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sum=0;</span><br><span class="line">times=0;//times表示查找的次数，大于等于n*m相当于查找一遍还没有找到</span><br><span class="line">i=j=1;</span><br><span class="line">while(sum&lt;n*m &amp;&amp; times&lt;n*m)&#123;</span><br><span class="line">for(i=1;i&lt;=n;i++)&#123;</span><br><span class="line">for(j=1;j&lt;=m;j++)&#123;</span><br><span class="line">times++;</span><br><span class="line">sx=i,sy=j;</span><br><span class="line">if(mp[i][j]!=0 &amp;&amp; judge(i,j,0,-1))&#123;</span><br><span class="line">sum+=2;</span><br><span class="line">times=0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(sum==n*m)&#123;</span><br><span class="line">printf(&quot;Yes\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">printf(&quot;No\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Points-in-rectangle-1"><a href="#Points-in-rectangle-1" class="headerlink" title="Points in rectangle"></a>Points in rectangle</h4><p>Problem solving:<br>对于给定的矩形，求出四个边的直线方程<br>对于给定的点判断和四条直线的关系即可O(1) 的判断是否<br>在矩形内<br>统计完直接排序即可</p><p>Code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 2e3+100;</span><br><span class="line">struct point&#123;</span><br><span class="line">long long x,y;</span><br><span class="line">bool friend operator&lt;(point a,point b)&#123;</span><br><span class="line">if(a.x==b.x) return a.y&gt;b.y;</span><br><span class="line">return a.x&gt;b.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;p[N];</span><br><span class="line">long long n,a;</span><br><span class="line">bool check(point P)&#123;</span><br><span class="line">return -P.x+a&lt;=P.y&amp;&amp;-P.x+2*n-a&gt;=P.y&amp;&amp;P.x-a&lt;=P.y&amp;&amp;P.x+a&gt;=P.y;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">//freopen(&quot;17.in&quot;,&quot;r&quot;,stdin);</span><br><span class="line">//freopen(&quot;17.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">vector&lt;point&gt; re;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;a;</span><br><span class="line">int m;</span><br><span class="line">cin&gt;&gt;m;</span><br><span class="line">for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">if(check(p[i])) re.push_back(p[i]);</span><br><span class="line">&#125;</span><br><span class="line">sort(re.begin(),re.end());</span><br><span class="line">if(re.empty())&#123;</span><br><span class="line">cout&lt;&lt;-1&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">cout&lt;&lt;re.size()&lt;&lt;endl;</span><br><span class="line">for(auto v:re) cout&lt;&lt;v.x&lt;&lt;&apos; &apos;&lt;&lt;v.y&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Numbers-of-interval-1"><a href="#Numbers-of-interval-1" class="headerlink" title="Numbers of interval"></a>Numbers of interval</h4><p>Problem solving:<br>构造前缀和数组sum<br>枚举l 然后二分最小的r，那么r 及其右边的都满足条件<br>线性枚举即可, 复杂度O(nlog(n))</p><p>Code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e6+100;</span><br><span class="line">typedef long long ll;</span><br><span class="line">long long a[N],sum[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">int n,k;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i],sum[i]=sum[i-1]+a[i];</span><br><span class="line">long long ans=0;</span><br><span class="line">for(int l=1;l&lt;=n;l++)&#123;</span><br><span class="line">int id=lower_bound(sum+1,sum+n+1,k+sum[l-1])-sum;</span><br><span class="line">ans+=(n-id+1);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="剪纸-1"><a href="#剪纸-1" class="headerlink" title="剪纸"></a>剪纸</h4><p>Problem solving:<br>开一个二维数组构造即可</p><p>Code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1000+10;</span><br><span class="line">int n,m,a;</span><br><span class="line">char str[1000+10][1000+10];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;m))&#123;</span><br><span class="line">for(int i=n;i&lt;n*2;i++)&#123;</span><br><span class="line">scanf(&quot;%s&quot;,str[i]+m);</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">for(int j=0;j&lt;m;j++)&#123;</span><br><span class="line">str[i][j]=str[n*2-1-i][j]=str[i][m*2-1-j]=str[n*2-1-i][m*2-1-j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;n*2;i++)&#123;</span><br><span class="line">for(int j=0;j&lt;m*2;j++)&#123;</span><br><span class="line">printf(&quot;%c&quot;,str[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Fake-hpuoj-predictor-1"><a href="#Fake-hpuoj-predictor-1" class="headerlink" title="Fake hpuoj predictor"></a>Fake hpuoj predictor</h4><p>Problem solving:<br>暴力算出codancer 实际的得分和期望得分<br>根据他当前的rating 使用不同的K 更新rating<br>每次更新完rating 向上取整</p><p>Code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1000+10;</span><br><span class="line">int n,m,a;</span><br><span class="line">struct node&#123;</span><br><span class="line">char name[30];</span><br><span class="line">double rating;</span><br><span class="line">&#125;p[maxn];</span><br><span class="line">double cal(double rating)&#123;</span><br><span class="line">if(rating&lt;1350) return 15.0;</span><br><span class="line">else if(rating&lt;1500) return 20.0;</span><br><span class="line">else if(rating&lt;1600) return 25.0;</span><br><span class="line">else if(rating&lt;1700) return 30.0;</span><br><span class="line">else if(rating&lt;1800) return 35.0;</span><br><span class="line">else return 50.0;</span><br><span class="line">&#125;</span><br><span class="line">double Rating(double rating)&#123;</span><br><span class="line">double k=cal(rating);</span><br><span class="line">double ea=0,sa=0;</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">if(strcmp(p[i].name,&quot;codancer&quot;)==0) continue;</span><br><span class="line">ea+=1.0/(1.0+pow(10,(p[i].rating-rating)/400.0));</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">if(strcmp(p[i].name,&quot;codancer&quot;)==0)&#123;</span><br><span class="line">sa=n-1-i;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">double now_rating=rating+k*(sa-ea);</span><br><span class="line">//return now_rating;</span><br><span class="line">return ceil(now_rating);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int m;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">double codancerNB_rating=0.0;</span><br><span class="line">while(m--)&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">scanf(&quot;%s&quot;,p[i].name);</span><br><span class="line">if(strcmp(p[i].name,&quot;codancer&quot;)==0)&#123;</span><br><span class="line">p[i].rating=codancerNB_rating;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">scanf(&quot;%lf&quot;,&amp;p[i].rating);</span><br><span class="line">&#125;</span><br><span class="line">codancerNB_rating=Rating(codancerNB_rating);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%.0lf\n&quot;,ceil(codancerNB_rating));</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="花花与三猫Catlive-1"><a href="#花花与三猫Catlive-1" class="headerlink" title="花花与三猫Catlive"></a>花花与三猫Catlive</h4><p>Problem solving:<br>每次每只猫能够向前走一步的概率为2/M<br>答案即为L/（2/m）= LM/2</p><p>Code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">const int MOD = 1e9 + 7;</span><br><span class="line">int qpow(int a, int b, int mod)&#123;</span><br><span class="line">    int res = 1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1) res = 1LL * res * a % mod;</span><br><span class="line">        a = 1LL * a * a % mod;</span><br><span class="line">        b &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int inv(int p, int mod)&#123;</span><br><span class="line">    return qpow(p, mod - 2, mod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    int L, M;</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        scanf(&quot;%d %d&quot;, &amp;L, &amp;M);</span><br><span class="line">        printf(&quot;%lld\n&quot;, 1LL * L * M * 500000004 % MOD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Same-String-1"><a href="#Same-String-1" class="headerlink" title="Same String"></a>Same String</h4><p>Problem solving:<br>解法一: 对于m 组关系建好图，每次判断某个字母可否到达<br>另一个字母<br>解法二: 利用Warshall 可以O(263) 求出传递闭包然后O(1<br>的判断可达性</p><p>Code：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e6+100;</span><br><span class="line">typedef long long ll;</span><br><span class="line">bool f[26][26];</span><br><span class="line">int main()&#123;</span><br><span class="line">// for(int it=1;it&lt;=40;it++)&#123;</span><br><span class="line">// memset(f,0,sizeof(f));</span><br><span class="line">// Create_InFiles(it);</span><br><span class="line">// Create_OutFiles(it);</span><br><span class="line">int n,m;</span><br><span class="line">string s1,s2;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line">cin&gt;&gt;m;</span><br><span class="line">char u,v;</span><br><span class="line">for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">f[u-&apos;a&apos;][v-&apos;a&apos;]=1;</span><br><span class="line">&#125;</span><br><span class="line">for(int j=0;j&lt;26;j++)&#123;</span><br><span class="line">for(int i=0;i&lt;26;i++)&#123;</span><br><span class="line">for(int k=0;k&lt;26;k++)&#123;</span><br><span class="line">f[i][k]|=(f[i][j]&amp;f[j][k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bool check=0;</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">if(s1[i]!=s2[i])&#123;</span><br><span class="line">if(f[s1[i]-&apos;a&apos;][s2[i]-&apos;a&apos;]==0)&#123;</span><br><span class="line">check=1;break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(check)&#123;</span><br><span class="line">puts(&quot;NO&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else puts(&quot;YES&quot;);</span><br><span class="line">// &#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;积分赛，被打爆的积分赛（music
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="Algorithm" scheme="https://cndrew.cn/blog/tags/Algorithm/"/>
    
      <category term="greedy" scheme="https://cndrew.cn/blog/tags/greedy/"/>
    
      <category term="inverse-modulo" scheme="https://cndrew.cn/blog/tags/inverse-modulo/"/>
    
      <category term="BFS" scheme="https://cndrew.cn/blog/tags/BFS/"/>
    
      <category term="gcd" scheme="https://cndrew.cn/blog/tags/gcd/"/>
    
      <category term="前缀和" scheme="https://cndrew.cn/blog/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>HPU Summer Day 11(河南理工大学暑期第十一天)</title>
    <link href="https://cndrew.cn/blog/2019/07/27/d11/"/>
    <id>https://cndrew.cn/blog/2019/07/27/d11/</id>
    <published>2019-07-27T14:26:52.051Z</published>
    <updated>2019-08-04T01:29:58.724Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一不留神，暑期集训的三分之一就过去了。<a id="more"></a><br>开始集训的第十一天，举办了第二次积分赛，这次学长还开了网上的同步赛，打完也是挺自闭的。唉，好好学习，明天休息，收拾一下，没啥事还是敲代码吧。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一不留神，暑期集训的三分之一就过去了。
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="life" scheme="https://cndrew.cn/blog/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>HPU Summer Training Day 10(河南理工大学暑期第十天)</title>
    <link href="https://cndrew.cn/blog/2019/07/26/d10/"/>
    <id>https://cndrew.cn/blog/2019/07/26/d10/</id>
    <published>2019-07-26T14:20:54.177Z</published>
    <updated>2019-08-04T01:52:09.380Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天没讲题，加练，没啥好说的，除了脑仁疼就是脑仁疼。还有两道似乎是用到DFS的是真的写不出来了。慢慢补吧。<a id="more"></a></p><h3 id="Knight-Moves"><a href="#Knight-Moves" class="headerlink" title="Knight Moves"></a>Knight Moves</h3><p>Description:<br>Background<br>Mr Somurolov, fabulous chess-gamer indeed, asserts that no one else but him can move knights from one position to another so fast. Can you beat him?<br>The Problem<br>Your task is to write a program to calculate the minimum number of moves needed for a knight to reach one point from another, so that you have the chance to be faster than Somurolov.<br>For people not familiar with chess, the possible knight moves are shown in Figure 1.</p><p><img src="http://drew.todest.cn//20190804094930.png" alt></p><p>Input</p><blockquote><p>The input begins with the number n of scenarios on a single line by itself.<br>Next follow n scenarios. Each scenario consists of three lines containing integer numbers. The first line specifies the length l of a side of the chess board (4 &lt;= l &lt;= 300). The entire board has size l <em> l. The second and third line contain pair of integers {0, ..., l-1}\</em>{0, ..., l-1} specifying the starting and ending position of the knight on the board. The integers are separated by a single blank. You can assume that the positions are valid positions on the chess board of that scenario.</p></blockquote><p>Output</p><blockquote><p>For each scenario of the input you have to calculate the minimal amount of knight moves which are necessary to move from the starting point to the ending point. If starting point and ending point are equal,distance is zero. The distance must be written on a single line.</p></blockquote><p>Sample Input</p><blockquote><p>3<br>8<br>0 0<br>7 0<br>100<br>0 0<br>30 50<br>10<br>1 1<br>1 1</p></blockquote><p>Sample Output</p><blockquote><p>5<br>28<br>0</p></blockquote><p>Problem solving:<br>简单的BFS模板题，8个方向查找即可。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">int x,y;</span><br><span class="line">&#125;;</span><br><span class="line">const int maxn=305;</span><br><span class="line">int vis[maxn][maxn];</span><br><span class="line">int step[maxn][maxn];</span><br><span class="line">int n,m,sx,sy,ex,ey;</span><br><span class="line">int d[8][2]=&#123;2,1,1,2,-1,2,-2,1,-2,-1,-1,-2,1,-2,2,-1&#125;;</span><br><span class="line">void bfs()</span><br><span class="line">&#123;</span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line">node now,mid;</span><br><span class="line">vis[sx][sy]=1;</span><br><span class="line">now.x=sx,now.y=sy;</span><br><span class="line">q.push(now);</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">mid=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">for(int i = 0 ;i&lt;8;i++)</span><br><span class="line">&#123;</span><br><span class="line">now.x=mid.x+d[i][0];</span><br><span class="line">now.y=mid.y+d[i][1];</span><br><span class="line">if(now.x&lt;0||now.x&gt;=m||now.y&lt;0||now.y&gt;=m||vis[now.x][now.y])continue;</span><br><span class="line">vis[now.x][now.y]=1;</span><br><span class="line">step[now.x][now.y]=step[mid.x][mid.y]+1;</span><br><span class="line">q.push(now);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">while(n--)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">memset(step,0,sizeof(step));</span><br><span class="line">cin&gt;&gt;m&gt;&gt;sx&gt;&gt;sy&gt;&gt;ex&gt;&gt;ey;</span><br><span class="line">bfs();</span><br><span class="line">cout&lt;&lt;step[ex][ey]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="变形课"><a href="#变形课" class="headerlink" title="变形课"></a>变形课</h3><p>Description:<br>呃......变形课上Harry碰到了一点小麻烦,因为他并不像Hermione那样能够记住所有的咒语而随意的将一个棒球变成刺猬什么的,但是他发现了变形咒语的一个统一规律:如果咒语是以a开头b结尾的一个单词,那么它的作用就恰好是使A物体变成B物体.<br>Harry已经将他所会的所有咒语都列成了一个表,他想让你帮忙计算一下他是否能完成老师的作业,将一个B(ball)变成一个M(Mouse),你知道,如果他自己不能完成的话,他就只好向Hermione请教,并且被迫听一大堆好好学习的道理.<br>Input</p><blockquote><p>测试数据有多组。每组有多行，每行一个单词,仅包括小写字母,是Harry所会的所有咒语.数字0表示一组输入结束.</p></blockquote><p>Output</p><blockquote><p>如果Harry可以完成他的作业,就输出&quot;Yes.&quot;,否则就输出&quot;No.&quot;(不要忽略了句号)</p></blockquote><p>Sample Input</p><blockquote><p>so<br>soon<br>river<br>goes<br>them<br>got<br>moon<br>begin<br>big<br>0</p></blockquote><p>Sample Output</p><blockquote><p>Yes.</p></blockquote><p>Harry 可以念这个咒语:&quot;big-got-them&quot;.</p><p>Problem solving:<br>这道题我的想法是用邻接表存图，把输入的每一个单词的首字母与最后一个字母当成两个节点，并且是有向边，然后bfs以&#39;b&#39;为起点查找如果能找到&#39;m&#39;与它相连，就输出Yes，反之输出&#39;No&#39;.<br>这道题还有一个很难受的地方就是输入、、、多组套多组，里面的多组还有结束条件。不过写完这道题也算是学会了，这样写就行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while(cin&gt;&gt;s)</span><br><span class="line">&#123;</span><br><span class="line">while(s!=&apos;0&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int ma[100][100],vis[100];</span><br><span class="line">bool bfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">q.push(x);</span><br><span class="line">vis[x]=1;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">x=q.front();</span><br><span class="line">if(x==&apos;m&apos;-&apos;0&apos;)return 1;</span><br><span class="line">q.pop();</span><br><span class="line">for(int i=&apos;a&apos;-&apos;0&apos;;i&lt;=&apos;z&apos;-&apos;0&apos;;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(ma[x][i]==1&amp;&amp;!vis[i])</span><br><span class="line">&#123;</span><br><span class="line">vis[i]=1;</span><br><span class="line">//cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">//cout&lt;&lt;ma[x][i]&lt;&lt;&quot;?&quot;&lt;&lt;ma[i][x]&lt;&lt;endl;</span><br><span class="line">q.push(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">string s;</span><br><span class="line">while(cin&gt;&gt;s)</span><br><span class="line">&#123;</span><br><span class="line">memset(ma,0,sizeof(ma));</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">while(s!=&quot;0&quot;)</span><br><span class="line">&#123;</span><br><span class="line">char sx=s[0],ex=s[s.size()-1];</span><br><span class="line">//cout&lt;&lt;sx-&apos;0&apos;&lt;&lt;&quot; &quot;&lt;&lt;ex-&apos;0&apos;&lt;&lt;endl;</span><br><span class="line">ma[sx-&apos;0&apos;][ex-&apos;0&apos;]=1;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(bfs(&apos;b&apos;-&apos;0&apos;))puts(&quot;Yes.&quot;);</span><br><span class="line">else puts(&quot;No.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Pet"><a href="#Pet" class="headerlink" title="Pet"></a>Pet</h3><p>Description:<br>一天早上小明醒来时发现他的宠物仓鼠不见了。 他在房间寻找但是没找到仓鼠。 他想用奶酪诱饵去找回仓鼠。 他把奶酪诱饵放在房间并且等待了好几天。 但是可怜的小明除了老鼠和蟑螂没见到任何东西。 他找到学校的地图发现地图上没有环路，并且学校里的每个站点都可以从他的房间到达。 奶酪诱饵的手册提到在距离D之内宠物必定会被吸引回来. 你的任务是帮助小明从给定的地图中有多少可能的站点是仓鼠的藏身处. 假定仓鼠一直藏在学校的某个站点并且两个相邻站点间的距离都是1个单位。<br>Input</p><blockquote><p>输入包含多组数据。 第一行一个整数T (0&lt;T&lt;=10), 表示测试数据的组数。 每组数据, 第一行包含两个整数 N (0&lt;N&lt;=100000) 和 D(0&lt;D&lt;N). N 是学校里的站点数， D 是诱饵的影响距离。 下面 N-1行为地图描述, 每行一对 x 和 y(0&lt;=x,y&lt;N), 用一个空格隔开, 表示x和y两个站点是相邻的。小明的房间用0表示。</p></blockquote><p>Output</p><blockquote><p>对于每组数据，输出可能找到仓鼠的站点数。<br>Sample Input<br>1<br>10 2<br>0 1<br>0 2<br>0 3<br>1 4<br>1 5<br>2 6<br>3 7<br>4 8<br>6 9</p></blockquote><p>Sample Output</p><blockquote><p>2</p></blockquote><p>Problem solving:<br>题意还挺好理解的，就是问你一个图距离顶点距离大于某一值得点有多少个。构建一个图，因为现在已经知道了0是顶点，直接从0开始bfs查找，找出每个点距离0的最远距离，与给的定值进行比较即可。<br>注意多组输入每次需要初始化（我因为这个WA了一发。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e5+10;</span><br><span class="line">vector&lt;int&gt; v[maxn];</span><br><span class="line">int dis[maxn],vis[maxn],ans;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,d,t,x,y;</span><br><span class="line">void bfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">q.push(x);</span><br><span class="line">vis[x]=1;dis[x]=0;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">x=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">for(int i=0;i&lt;v[x].size();i++)</span><br><span class="line">&#123;</span><br><span class="line">if(v[x][i]&amp;&amp;!vis[v[x][i]])</span><br><span class="line">&#123;</span><br><span class="line">q.push(v[x][i]);</span><br><span class="line">vis[v[x][i]]=1;</span><br><span class="line">dis[v[x][i]]=dis[x]+1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">memset(dis,0,sizeof(dis));</span><br><span class="line">ans=0;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;n,&amp;d);</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">v[i].clear();</span><br><span class="line">for(int i=1;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;x,&amp;y);</span><br><span class="line">v[x].push_back(y);</span><br><span class="line">v[y].push_back(x);</span><br><span class="line">&#125;</span><br><span class="line">bfs(0);</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(dis[i]&gt;d)ans++;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d\n&quot;,ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="蜘蛛牌"><a href="#蜘蛛牌" class="headerlink" title="蜘蛛牌"></a>蜘蛛牌</h3><p>Description:<br>蜘蛛牌是windows xp操作系统自带的一款纸牌游戏，游戏规则是这样的：只能将牌拖到比她大一的牌上面（A最小，K最大），如果拖动的牌上有按顺序排好的牌时，那么这些牌也跟着一起移动，游戏的目的是将所有的牌按同一花色从小到大排好，为了简单起见，我们的游戏只有同一花色的10张牌，从A到10，且随机的在一行上展开，编号从1到10，把第i号上的牌移到第j号牌上，移动距离为abs(i-j)，现在你要做的是求出完成游戏的最小移动距离。<br>Input</p><blockquote><p>第一个输入数据是T，表示数据的组数。<br>每组数据有一行，10个输入数据，数据的范围是[1,10]，分别表示A到10，我们保证每组数据都是合法的。</p></blockquote><p>Output</p><blockquote><p>对应每组数据输出最小移动距离。</p></blockquote><p>Sample Input</p><blockquote><p>1<br>1 2 3 4 5 6 7 8 9 10</p></blockquote><p>Sample Output</p><blockquote><p>9</p></blockquote><p>Problem solving:<br>暂无（毫无思路题，据说是dfs）</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *　　　　　　　　┏┓　　 　┏┓</span><br><span class="line"> * 　　　　　　　┏┛┗━━━━━━━┛┗━━━┓</span><br><span class="line"> * 　　　　　　　┃　　　　　　　┃ 　</span><br><span class="line"> * 　　　　　　　┃　　　━　　 　┃</span><br><span class="line"> * 　　　　　　　┃　＞　　　＜　┃</span><br><span class="line"> * 　　　　　　　┃　　　　　　　┃</span><br><span class="line"> * 　　　　　　　┃...　⌒　... 　┃</span><br><span class="line"> * 　　　　　　　┃　　　　　　　┃</span><br><span class="line"> * 　　　　　　　┗━┓　　　┏━┛</span><br><span class="line"> * 　　　　　　　　　┃　　　┃　Code is far away from bug with the animal protecting　　　　　　　　　　</span><br><span class="line"> * 　　　　　　　　　┃　　　┃   神兽保佑,代码无bug</span><br><span class="line"> * 　　　　　　　　　┃　　　┃　　　　　　　　　　　</span><br><span class="line"> * 　　　　　　　　　┃　　　┃  　　　　　　</span><br><span class="line"> * 　　　　　　　　　┃　　　┃</span><br><span class="line"> * 　　　　　　　　　┃　　　┃　　　　　　　　　　　</span><br><span class="line"> * 　　　　　　　　　┃　　　┗━━━┓</span><br><span class="line"> * 　　　　　　　　　┃　　　　　　　┣┓</span><br><span class="line"> * 　　　　　　　　　┃　　　　　　　┏┛</span><br><span class="line"> * 　　　　　　　　　┗┓┓┏━┳┓┏┛</span><br><span class="line"> * 　　　　　　　　　　┃┫┫　┃┫┫</span><br><span class="line"> * 　　　　　　　　　　┗┻┛　┗┻┛</span><br><span class="line"> */</span><br><span class="line">// warm heart, wagging tail,and a smile just for you!</span><br><span class="line">//</span><br><span class="line">//                            _ooOoo_</span><br><span class="line">//                           o8888888o</span><br><span class="line">//                           88&quot; . &quot;88</span><br><span class="line">//                           (| -_- |)</span><br><span class="line">//                           O\  =  /O</span><br><span class="line">//                        ____/`---&apos;\____</span><br><span class="line">//                      .&apos;  \|     |//  `.</span><br><span class="line">//                     /  \|||  :  |||//  \</span><br><span class="line">//                    /  _||||| -:- |||||-  \</span><br><span class="line">//                    |   | \\  -  /// |   |</span><br><span class="line">//                    | \_|  &apos;&apos;\---/&apos;&apos;  |   |</span><br><span class="line">//                    \  .-\__  `-`  ___/-. /</span><br><span class="line">//                  ___`. .&apos;  /--.--\  `. . __</span><br><span class="line">//               .&quot;&quot; &apos;&lt;  `.___\_&lt;|&gt;_/___.&apos;  &gt;&apos;&quot;&quot;.</span><br><span class="line">//              | | :  `- \`.;`\ _ /`;.`/ - ` : | |</span><br><span class="line">//              \  \ `-.   \_ __\ /__ _/   .-` /  /</span><br><span class="line">//         ======`-.____`-.___\_____/___.-`____.-&apos;======</span><br><span class="line">//                            `=---=&apos;</span><br><span class="line">//        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class="line">//</span><br></pre></td></tr></table></figure></p><h3 id="逃离迷宫"><a href="#逃离迷宫" class="headerlink" title="逃离迷宫"></a>逃离迷宫</h3><p>Description:<br>给定一个m × n (m行, n列)的迷宫，迷宫中有两个位置，gloria想从迷宫的一个位置走到另外一个位置，当然迷宫中有些地方是空地，gloria可以穿越，有些地方是障碍，她必须绕行，从迷宫的一个位置，只能走到与它相邻的4个位置中,当然在行走过程中，gloria不能走到迷宫外面去。令人头痛的是，gloria是个没什么方向感的人，因此，她在行走过程中，不能转太多弯了，否则她会晕倒的。我们假定给定的两个位置都是空地，初始时，gloria所面向的方向未定，她可以选择4个方向的任何一个出发，而不算成一次转弯。gloria能从一个位置走到另外一个位置吗？<br>Input</p><blockquote><p>第1行为一个整数t (1 ≤ t ≤ 100),表示测试数据的个数，接下来为t组测试数据，每组测试数据中，<br>　　第1行为两个整数m, n (1 ≤ m, n ≤ 100),分别表示迷宫的行数和列数，接下来m行，每行包括n个字符，其中字符&#39;.&#39;表示该位置为空地，字符&#39;*&#39;表示该位置为障碍，输入数据中只有这两种字符，每组测试数据的最后一行为5个整数k, x 1, y 1, x 2, y 2 (1 ≤ k ≤ 10, 1 ≤ x 1, x 2 ≤ n, 1 ≤ y 1, y 2 ≤ m),其中k表示gloria最多能转的弯数，(x 1, y 1), (x 2, y 2)表示两个位置，其中x 1，x 2对应列，y 1, y 2对应行。</p></blockquote><p>Output</p><blockquote><p>　　每组测试数据对应为一行，若gloria能从一个位置走到另外一个位置，输出“yes”，否则输出“no”。</p></blockquote><p>Sample Input</p><blockquote><p>2<br>5 5<br>...<strong><br>*.</strong>.<br>.....<br>.....<br><em>....<br>1 1 1 1 3<br>5 5<br>...**</em>.*<em>.<br>.....<br>.....</em>....<br>2 1 1 1 3</p></blockquote><p>Sample Output</p><blockquote><p>no<br>yes</p></blockquote><p>Problem solving:<br>这也是一道查找的题，给了你起点和终点和最大拐弯次数，问你能不能从起点走到终点。我选择了bfs，其实是一道挺简单的题，难点就是如何得到当前转弯的次数。我一开始想着用x，y坐标的差值来表示，但是又麻烦又不好理解。然后我在网上看到了一种写法。就是在bfs的过程中，每选择了一个方向就按照这个方向一直走下去直到越界或者到了走不了的点。这一步描述的如果你不是很懂，可以参考一下下面代码我加上的注释。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m,t,sx,sy,ex,ey,k;</span><br><span class="line">char s[105][105];</span><br><span class="line">int vis[105][105];</span><br><span class="line">struct node&#123;</span><br><span class="line">int x,y,flag;//flag就是用来存当前的拐弯次数</span><br><span class="line">&#125;;</span><br><span class="line">int d[4][2]=&#123;1,0,0,1,0,-1,-1,0&#125;;</span><br><span class="line">bool bfs()</span><br><span class="line">&#123;</span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line">node now,mid;</span><br><span class="line">now.x=sx,now.y=sy,now.flag=-1;//初始的转弯次数设为-1是因为第一次走是不算入转弯次数的</span><br><span class="line">vis[sx][sy]=1;</span><br><span class="line">q.push(now);</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">//cout&lt;&lt;&quot;?&quot;;</span><br><span class="line">now=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">if(now.flag&gt;=k)continue;//如果此时转弯次数已经大于k了，就没有走下去的必要了。这一点在这种写法中很重要</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">mid.x=now.x+d[i][0];</span><br><span class="line">mid.y=now.y+d[i][1];</span><br><span class="line">mid.flag=now.flag+1;//此时你选择了一个方向</span><br><span class="line">while(1)//沿着这个方向一直走下去</span><br><span class="line">&#123;</span><br><span class="line">if(mid.x&lt;0||mid.x&gt;=n||mid.y&lt;0||mid.y&gt;=m||s[mid.x][mid.y]==&apos;*&apos;)break;//如果越界了或者不能走了，就说明沿着这个方向一直走走不下去了，break就行</span><br><span class="line">if(mid.x==ex&amp;&amp;mid.y==ey)return 1;//如果当前走到的点与终点相等，就说明可以走到，返回true</span><br><span class="line">if(vis[mid.x][mid.y]==0)</span><br><span class="line">&#123;</span><br><span class="line">vis[mid.x][mid.y]=1;</span><br><span class="line">q.push(mid);</span><br><span class="line">&#125;</span><br><span class="line">mid.x+=d[i][0];//沿着这个方向更新到下一个走到的点的x，y坐标</span><br><span class="line">mid.y+=d[i][1];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">cin&gt;&gt;s[i];</span><br><span class="line">cin&gt;&gt;k&gt;&gt;sy&gt;&gt;sx&gt;&gt;ey&gt;&gt;ex;//这有个坑，它先输入的是y的值</span><br><span class="line">sx--,sy--,ex--,ey--;</span><br><span class="line">if(bfs()) puts(&quot;yes&quot;);</span><br><span class="line">elseputs(&quot;no&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Kaitou-Kid-The-Phantom-Thief-2"><a href="#Kaitou-Kid-The-Phantom-Thief-2" class="headerlink" title="Kaitou Kid - The Phantom Thief (2)"></a>Kaitou Kid - The Phantom Thief (2)</h3><p>Description:<br>破解字迷之后，你得知Kid将会在展览开始后T分钟内盗取至少一颗宝石，并离开展馆。整个展馆呈矩形分布，划分为N*M个区域，有唯一的入口和出口（不能从出口进入，同样不能从入口出去）。由某个区域可直接移动至相邻四个区域中的一个，且最快需要一分钟。假设Kid进入放有宝石的区域即可盗取宝石，无需耗时。问至少要封锁几个区域（可以封锁放有宝石的区域，但不能封锁入口和出口）才能保证Kid无法完成任务。<br>Input</p><blockquote><p>输入的第一行有一个整数C，代表有C组测试数据。每组测试数据的第一行有三个整数N，M，T(2&lt;=N,M&lt;=8,T&gt;0)。接下来N行M列为展馆布置图，其中包括：<br>&#39;S&#39;：入口<br>&#39;E&#39;：出口<br>&#39;J&#39;：放有宝石的区域，至少出现一次<br>&#39;.&#39;：空白区域<br>&#39;#&#39;：墙</p></blockquote><p>Output</p><blockquote><p>对每组测试数据，输出至少要封锁的区域数。</p></blockquote><p>Sample Input</p><blockquote><p>2<br>5 5 5<br>SJJJJ<br>..##J<br>.JJJJ<br>.J...<br>EJ...<br>5 5 6<br>SJJJJ<br>..##J<br>.JJJJ<br>.J...<br>EJ...</p></blockquote><p>Sample Output</p><blockquote><p>0<br>2</p></blockquote><p>Problem solving:<br>暂无（据说是bfs+dfs）</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *　　　　　　　　┏┓　　 　┏┓</span><br><span class="line"> * 　　　　　　　┏┛┗━━━━━━━┛┗━━━┓</span><br><span class="line"> * 　　　　　　　┃　　　　　　　┃ 　</span><br><span class="line"> * 　　　　　　　┃　　　━　　 　┃</span><br><span class="line"> * 　　　　　　　┃　＞　　　＜　┃</span><br><span class="line"> * 　　　　　　　┃　　　　　　　┃</span><br><span class="line"> * 　　　　　　　┃...　⌒　... 　┃</span><br><span class="line"> * 　　　　　　　┃　　　　　　　┃</span><br><span class="line"> * 　　　　　　　┗━┓　　　┏━┛</span><br><span class="line"> * 　　　　　　　　　┃　　　┃　Code is far away from bug with the animal protecting　　　　　　　　　　</span><br><span class="line"> * 　　　　　　　　　┃　　　┃   神兽保佑,代码无bug</span><br><span class="line"> * 　　　　　　　　　┃　　　┃　　　　　　　　　　　</span><br><span class="line"> * 　　　　　　　　　┃　　　┃  　　　　　　</span><br><span class="line"> * 　　　　　　　　　┃　　　┃</span><br><span class="line"> * 　　　　　　　　　┃　　　┃　　　　　　　　　　　</span><br><span class="line"> * 　　　　　　　　　┃　　　┗━━━┓</span><br><span class="line"> * 　　　　　　　　　┃　　　　　　　┣┓</span><br><span class="line"> * 　　　　　　　　　┃　　　　　　　┏┛</span><br><span class="line"> * 　　　　　　　　　┗┓┓┏━┳┓┏┛</span><br><span class="line"> * 　　　　　　　　　　┃┫┫　┃┫┫</span><br><span class="line"> * 　　　　　　　　　　┗┻┛　┗┻┛</span><br><span class="line"> */</span><br><span class="line">// warm heart, wagging tail,and a smile just for you!</span><br><span class="line">//</span><br><span class="line">//                            _ooOoo_</span><br><span class="line">//                           o8888888o</span><br><span class="line">//                           88&quot; . &quot;88</span><br><span class="line">//                           (| -_- |)</span><br><span class="line">//                           O\  =  /O</span><br><span class="line">//                        ____/`---&apos;\____</span><br><span class="line">//                      .&apos;  \|     |//  `.</span><br><span class="line">//                     /  \|||  :  |||//  \</span><br><span class="line">//                    /  _||||| -:- |||||-  \</span><br><span class="line">//                    |   | \\  -  /// |   |</span><br><span class="line">//                    | \_|  &apos;&apos;\---/&apos;&apos;  |   |</span><br><span class="line">//                    \  .-\__  `-`  ___/-. /</span><br><span class="line">//                  ___`. .&apos;  /--.--\  `. . __</span><br><span class="line">//               .&quot;&quot; &apos;&lt;  `.___\_&lt;|&gt;_/___.&apos;  &gt;&apos;&quot;&quot;.</span><br><span class="line">//              | | :  `- \`.;`\ _ /`;.`/ - ` : | |</span><br><span class="line">//              \  \ `-.   \_ __\ /__ _/   .-` /  /</span><br><span class="line">//         ======`-.____`-.___\_____/___.-`____.-&apos;======</span><br><span class="line">//                            `=---=&apos;</span><br><span class="line">//        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class="line">//</span><br></pre></td></tr></table></figure></p><h3 id="A计划"><a href="#A计划" class="headerlink" title="A计划"></a>A计划</h3><p>Description:<br>可怜的公主在一次次被魔王掳走一次次被骑士们救回来之后，而今，不幸的她再一次面临生命的考验。魔王已经发出消息说将在T时刻吃掉公主，因为他听信谣言说吃公主的肉也能长生不老。年迈的国王正是心急如焚，告招天下勇士来拯救公主。不过公主早已习以为常，她深信智勇的骑士LJ肯定能将她救出。<br>现据密探所报，公主被关在一个两层的迷宫里，迷宫的入口是S（0，0，0），公主的位置用P表示，时空传输机用#表示，墙用*表示，平地用.表示。骑士们一进入时空传输机就会被转到另一层的相对位置，但如果被转到的位置是墙的话，那骑士们就会被撞死。骑士们在一层中只能前后左右移动，每移动一格花1时刻。层间的移动只能通过时空传输机，且不需要任何时间。<br>Input</p><blockquote><p>输入的第一行C表示共有C个测试数据，每个测试数据的前一行有三个整数N，M，T。 N，M迷宫的大小N<em>M（1 &lt;= N,M &lt;=10)。T如上所意。接下去的前N</em>M表示迷宫的第一层的布置情况，后N*M表示迷宫第二层的布置情况。</p></blockquote><p>Output</p><blockquote><p>如果骑士们能够在T时刻能找到公主就输出“YES”，否则输出“NO”。</p></blockquote><p>Sample Input</p><blockquote><p>1<br>5 5 14<br>S<em>#</em>.<br>.#...<br>.....<br><em>**</em>.<br>...#.<br>..*.P</p></blockquote><p>#.<em>..<br>**</em>..<br>...<em>.</em>.#..</p><p>Sample Output</p><blockquote><p>YES</p></blockquote><p>Problem solving:<br>哇，这道题坑的一批。最后玄学过题<br>就是个三维的bfs，而且给定了只有两层。<br>因为遇到传送门进行传送的时候是不需要耗费时间的，所以传送门那需要特殊处理一下（可以想一下，如果传送门传送过去的位置还是传送门，就成死循环了。如果传送门传送过去是墙，也可以直接看做这个传送门是一堵墙）</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int c,n,m,t;</span><br><span class="line">struct node&#123;</span><br><span class="line">int x,y,z,step;</span><br><span class="line">&#125;;</span><br><span class="line">int d[4][2]=&#123;1,0,0,1,0,-1,-1,0&#125;,vis[2][15][15],flag;</span><br><span class="line">char s[2][15][15];</span><br><span class="line">node now,mid,meizi;</span><br><span class="line">void bfs()</span><br><span class="line">&#123;</span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line">q.push(now);</span><br><span class="line">vis[now.x][now.y][now.z]=1;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">mid=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">if(s[mid.x][mid.y][mid.z]==&apos;P&apos;&amp;&amp;mid.step&lt;=t)</span><br><span class="line">&#123;</span><br><span class="line">flag=1;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">meizi=mid;</span><br><span class="line">meizi.y+=d[i][0];</span><br><span class="line">meizi.z+=d[i][1];</span><br><span class="line">meizi.step+=1;</span><br><span class="line">if(meizi.step&gt;t||meizi.y&lt;0||meizi.y&gt;=n||meizi.z&lt;0||meizi.z&gt;=m||vis[meizi.x][meizi.y][meizi.z]||s[meizi.x][meizi.y][meizi.z]==&apos;*&apos;)</span><br><span class="line">continue;</span><br><span class="line">vis[meizi.x][meizi.y][meizi.z]=1;</span><br><span class="line">if(s[meizi.x][meizi.y][meizi.z]==&apos;#&apos;&amp;&amp;s[(meizi.x+1)%2][meizi.y][meizi.z]!=&apos;*&apos;&amp;&amp;!vis[(meizi.x+1)%2][meizi.y][meizi.z])</span><br><span class="line">meizi.x=(meizi.x+1)%2;</span><br><span class="line">q.push(meizi);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;c;</span><br><span class="line">while(c--)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;t;</span><br><span class="line">for(int i=0;i&lt;2;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line">for(int k=0;k&lt;m;k++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;s[i][j][k];</span><br><span class="line">if(s[i][j][k]==&apos;S&apos;)</span><br><span class="line">&#123;</span><br><span class="line">now.x=i,now.y=j,now.z=k,now.step=0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(int j=0;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line">for(int k=0;k&lt;m;k++)</span><br><span class="line">&#123;</span><br><span class="line">if(s[0][j][k]==&apos;#&apos;&amp;&amp;s[1][j][k]==&apos;*&apos;)</span><br><span class="line">&#123;</span><br><span class="line">s[0][j][k]=s[1][j][k]=&apos;*&apos;;</span><br><span class="line">&#125;</span><br><span class="line">if(s[0][j][k]==&apos;*&apos;&amp;&amp;s[1][j][k]==&apos;#&apos;)</span><br><span class="line">&#123;</span><br><span class="line">s[0][j][k]=s[1][j][k]=&apos;*&apos;;</span><br><span class="line">&#125;</span><br><span class="line">if(s[0][j][k]==&apos;#&apos;&amp;&amp;s[1][j][k]==&apos;#&apos;)</span><br><span class="line">&#123;</span><br><span class="line">s[0][j][k]=s[1][j][k]=&apos;*&apos;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flag=0;</span><br><span class="line">bfs();</span><br><span class="line">if(flag)puts(&quot;YES&quot;);</span><br><span class="line">elseputs(&quot;NO&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Nightmare"><a href="#Nightmare" class="headerlink" title="Nightmare"></a>Nightmare</h3><p>Description:<br>Ignatius had a nightmare last night. He found himself in a labyrinth with a time bomb on him. The labyrinth has an exit, Ignatius should get out of the labyrinth before the bomb explodes. The initial exploding time of the bomb is set to 6 minutes. To prevent the bomb from exploding by shake, Ignatius had to move slowly, that is to move from one area to the nearest area(that is, if Ignatius stands on (x,y) now, he could only on (x+1,y), (x-1,y), (x,y+1), or (x,y-1) in the next minute) takes him 1 minute. Some area in the labyrinth contains a Bomb-Reset-Equipment. They could reset the exploding time to 6 minutes.</p><p>Given the layout of the labyrinth and Ignatius&#39; start position, please tell Ignatius whether he could get out of the labyrinth, if he could, output the minimum time that he has to use to find the exit of the labyrinth, else output -1.</p><p>Here are some rules:</p><ol><li>We can assume the labyrinth is a 2 array.</li><li>Each minute, Ignatius could only get to one of the nearest area, and he should not walk out of the border, of course he could not walk on a wall, too.</li><li>If Ignatius get to the exit when the exploding time turns to 0, he can&#39;t get out of the labyrinth.</li><li>If Ignatius get to the area which contains Bomb-Rest-Equipment when the exploding time turns to 0, he can&#39;t use the equipment to reset the bomb.</li><li>A Bomb-Reset-Equipment can be used as many times as you wish, if it is needed, Ignatius can get to any areas in the labyrinth as many times as you wish.</li><li>The time to reset the exploding time can be ignore, in other words, if Ignatius get to an area which contain Bomb-Rest-Equipment, and the exploding time is larger than 0, the exploding time would be reset to 6.<br>Input<blockquote><p>The input contains several test cases. The first line of the input is a single integer T which is the number of test cases. T test cases follow.<br>Each test case starts with two integers N and M(1&lt;=N,Mm=8) which indicate the size of the labyrinth. Then N lines follow, each line contains M integers. The array indicates the layout of the labyrinth.<br>There are five integers which indicate the different type of area in the labyrinth:<br>0: The area is a wall, Ignatius should not walk on it.<br>1: The area contains nothing, Ignatius can walk on it.<br>2: Ignatius&#39; start position, Ignatius starts his escape from this position.<br>3: The exit of the labyrinth, Ignatius&#39; target position.<br>4: The area contains a Bomb-Reset-Equipment, Ignatius can delay the exploding time by walking to these areas.</p></blockquote></li></ol><p>Output</p><blockquote><p>For each test case, if Ignatius can get out of the labyrinth, you should output the minimum time he needs, else you should just output -1.</p></blockquote><p>Sample Input</p><blockquote><p>3<br>3 3<br>2 1 1<br>1 1 0<br>1 1 3<br>4 8<br>2 1 1 0 1 1 1 0<br>1 0 4 1 1 0 4 1<br>1 0 0 0 0 0 0 1<br>1 1 1 4 1 1 1 3<br>5 8<br>1 2 1 1 1 1 1 4<br>1 0 0 0 1 0 0 1<br>1 4 1 0 1 1 0 1<br>1 0 0 0 0 3 0 1<br>1 1 4 1 1 1 1 1</p></blockquote><p>Sample Output</p><blockquote><p>4<br>-1<br>13</p></blockquote><p>Problem solving:<br>这道题我是用bfs来做的，跟一种题很像，就是给你规定一个时间看能否走出迷宫之类的问题。<br>但是这道题有一种新的规则，就是如果走到某些特殊的点。时间会更新一次。<br>0是墙，不可以走<br>1是路<br>2是起点<br>3是终点<br>4是可以重置时间的点<br>刚开始看到这里的时候我想着肯定要经过很负责的处理。但是后来发现其实我们只需要知道这两点就可以了。并且题目中规定如果时间为0就不能继续走下去了。</p><ol><li>每个点都是可以重复访问的</li><li>可以刷新时间的点我们只走一次<br>第一点到不需要怎么理解，就是第二点我们该如何理解呢？<br>如果同一个位置的炸弹你第二次走到了它上面就说明此时已经不是最优解了。所以每个刷新时间的点我们每次走完之后就把它存为0——即墙。</li></ol><p>关于第二点的理解还有另一种解释方式:<br>上同一位置是bomb离explode的时间长短来标记。简言之，如果第二次踏上一个位置，那么找出路已用的时间肯定是增加了，那为啥还要走上这条路呢？唯一的追求就是bomb离爆炸的时间增大了。所以可以利用这个条件来标记了。每次在入队前检查下爆炸时间是否比上次在同一位置的大，若是，则入队；反之，入队无意义了。从以上的分析中可以引出另一思路，也就是只要进入位置4，那么bomb就会延时到6分钟，最大的延时时间。换句话说，下次再进入该4位置，也不会获得更大的延时时间了。所以，只要访问过位置4了，就可以直接标记为0位置，表明下次不可在访问。详见代码二。<br>转载于：<a href="http://blog.sina.com.cn/s/blog_7f09a7160101sym7.html" target="_blank" rel="noopener">clouddyx</a></p><p>其实想一下也确实是，假设我们现在走到了一个可以重置时间的点，如果下次在走到这，是不是就一直循环下去了，所以按照这个理解也可以。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m,a[10][10];</span><br><span class="line">struct node&#123;</span><br><span class="line">int x,y,step,time;</span><br><span class="line">&#125;;</span><br><span class="line">int d[4][2]=&#123;1,0,0,1,0,-1,-1,0&#125;;</span><br><span class="line">int ans;</span><br><span class="line">node now,mid;</span><br><span class="line">void bfs()</span><br><span class="line">&#123;</span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line">q.push(now);</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">//cout&lt;&lt;&quot;?&quot;&lt;&lt;endl;</span><br><span class="line">now=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">if(now.time&lt;=0)continue;</span><br><span class="line">if(a[now.x][now.y]==3)</span><br><span class="line">&#123;</span><br><span class="line">ans=now.step;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">mid.x=now.x+d[i][0];</span><br><span class="line">mid.y=now.y+d[i][1];</span><br><span class="line">mid.step=now.step+1;</span><br><span class="line">mid.time=now.time-1;</span><br><span class="line">if(mid.x&lt;0||mid.x&gt;=n||mid.y&lt;0||mid.y&gt;=m||mid.time&lt;=0||a[mid.x][mid.y]==0)continue;</span><br><span class="line">if(a[mid.x][mid.y]==4)</span><br><span class="line">&#123;</span><br><span class="line">a[mid.x][mid.y]=0;</span><br><span class="line">mid.time=6;</span><br><span class="line">&#125;</span><br><span class="line">q.push(mid);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">ans=-1;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;m;j++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a[i][j];</span><br><span class="line">if(a[i][j]==2)</span><br><span class="line">&#123;</span><br><span class="line">now.x=i,now.y=j,now.step=0,now.time=6;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bfs();</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="胜利大逃亡"><a href="#胜利大逃亡" class="headerlink" title="胜利大逃亡"></a>胜利大逃亡</h3><p>Description:<br>Ignatius被魔王抓走了,有一天魔王出差去了,这可是Ignatius逃亡的好机会.</p><p>魔王住在一个城堡里,城堡是一个A<em>B</em>C的立方体,可以被表示成A个B*C的矩阵,刚开始Ignatius被关在(0,0,0)的位置,离开城堡的门在(A-1,B-1,C-1)的位置,现在知道魔王将在T分钟后回到城堡,Ignatius每分钟能从一个坐标走到相邻的六个坐标中的其中一个.现在给你城堡的地图,请你计算出Ignatius能否在魔王回来前离开城堡(只要走到出口就算离开城堡,如果走到出口的时候魔王刚好回来也算逃亡成功),如果可以请输出需要多少分钟才能离开,如果不能则输出-1.<br><img src="https://i..net/2019/07/26/5d3af3fd5f8c290859.png" alt><br>Input</p><blockquote><p>输入数据的第一行是一个正整数K,表明测试数据的数量.每组测试数据的第一行是四个正整数A,B,C和T(1&lt;=A,B,C&lt;=50,1&lt;=T&lt;=1000),它们分别代表城堡的大小和魔王回来的时间.然后是A块输入数据(先是第0块,然后是第1块,第2块......),每块输入数据有B行,每行有C个正整数,代表迷宫的布局,其中0代表路,1代表墙.(如果对输入描述不清楚,可以参考Sample Input中的迷宫描述,它表示的就是上图中的迷宫)<br>特别注意:本题的测试数据非常大,请使用scanf输入,我不能保证使用cin能不超时.在本OJ上请使用Visual C++提交.</p></blockquote><p>Output</p><blockquote><p>对于每组测试数据,如果Ignatius能够在魔王回来前离开城堡,那么请输出他最少需要多少分钟,否则输出-1.</p></blockquote><p>Sample Input</p><blockquote><p>1<br>3 3 4 20<br>0 1 1 1<br>0 0 1 1<br>0 1 1 1<br>1 1 1 1<br>1 0 0 1<br>0 1 1 1<br>0 0 0 0<br>0 1 1 0<br>0 1 1 0</p></blockquote><p>Sample Output</p><blockquote><p>11</p></blockquote><p>Problem solving:<br>简单的三维bfs，直接写就行了，六个方向。注意多组输入需要初始化，我又是这WA了一次。。。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a,b,c,k;</span><br><span class="line">int s[51][51][51];</span><br><span class="line">int vis[51][51][51];</span><br><span class="line">struct node&#123;</span><br><span class="line">int x,y,z,step;</span><br><span class="line">&#125;;</span><br><span class="line">node mz,mid,ne;</span><br><span class="line">int d[6][3]=&#123;1,0,0, -1,0,0, 0,1,0, 0,-1,0, 0,0,1,0,0,-1&#125;,ans;</span><br><span class="line">void bfs()</span><br><span class="line">&#123;</span><br><span class="line">mz.x=mz.y=mz.z=mz.step=0;</span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line">q.push(mz);</span><br><span class="line">vis[0][0][0]=1;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">mid=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">if(mid.step&gt;k)</span><br><span class="line">&#123;</span><br><span class="line">return  ;</span><br><span class="line">&#125;</span><br><span class="line">if(mid.x==a-1&amp;&amp;mid.y==b-1&amp;&amp;mid.z==c-1&amp;&amp;mid.step&lt;=k)</span><br><span class="line">&#123;</span><br><span class="line">ans=mid.step;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;6;i++)</span><br><span class="line">&#123;</span><br><span class="line">ne.x=mid.x+d[i][0];</span><br><span class="line">ne.y=mid.y+d[i][1];</span><br><span class="line">ne.z=mid.z+d[i][2];</span><br><span class="line">if(ne.x&lt;0||ne.x&gt;=a||ne.y&lt;0||ne.y&gt;=b||ne.z&lt;0||ne.z&gt;=c||vis[ne.x][ne.y][ne.z]||s[ne.x][ne.y][ne.z]==1)</span><br><span class="line">continue;</span><br><span class="line">ne.step=mid.step+1;</span><br><span class="line">vis[ne.x][ne.y][ne.z]=1;</span><br><span class="line">q.push(ne);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t;scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">ans=-1;</span><br><span class="line">scanf(&quot;%d %d %d %d&quot;,&amp;a,&amp;b,&amp;c,&amp;k);</span><br><span class="line">for(int i=0;i&lt;a;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;b;j++)</span><br><span class="line">&#123;</span><br><span class="line">for(int k=0;k&lt;c;k++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%1d&quot;,&amp;s[i][j][k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bfs();</span><br><span class="line">printf(&quot;%d\n&quot;,ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="A-strange-lift"><a href="#A-strange-lift" class="headerlink" title="A strange lift"></a>A strange lift</h3><p>Description:<br>计院有一个bug电梯，可能是hyk造的，很多bug，电梯只有两个按钮，“上”和“下”，电梯每层都可以停，每层都有一个数字Ki（0&lt;=Ki&lt;=n），当你在一层楼，你按“上”键会到1+K1层，你按“下”键会到1-K1层。当然，电梯不能升到N以上，也不能降到1以下。例如，有一个五层楼的建筑，k1=3，k2=3，k3=1，k4=2，k5=5。从第一层开始，你可以按“上”按钮，然后你就上到第四层，如果在第一层按“下”按钮，电梯就不能做到，因为你知道它不能下到负二层。负二楼不存在。<br>那么，你想从A层到B层，你至少要按多少次“上”或“下”按钮呢？</p><p>Input</p><blockquote><p>输入由几个测试用例组成，每个测试用例包含两行。<br>第一行包含三个整数n，a，b（1&lt;=n，a，b&lt;=200），如上文所述，第二行包含n个整数k1，k2，….kn。<br>单个0表示输入的结束。</p></blockquote><p>Output</p><blockquote><p>对于每种情况下的输入输出一个整数，当你在A层，你必须按下按钮的最少次数，你想去B层。如果你不能到达B层，打印“-1”。</p></blockquote><p>Sample Input</p><blockquote><p>5 1 5<br>3 3 1 2 5<br>0</p></blockquote><p>Sample Output</p><blockquote><p>3</p></blockquote><p>Problem solving:<br>也是一道存图的题。每次存的时候注意判断第二个点与0跟n的大小关系。也是有向图。<br>注意初始化！！！又是这样WA了一次。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,a,b,meizi;</span><br><span class="line">int s[250][250],ans;</span><br><span class="line">int vis[250],step[250];</span><br><span class="line">void bfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">q.push(x);</span><br><span class="line">vis[x]=1,step[x]=0;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">int mid=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">//cout&lt;&lt;mid&lt;&lt;endl;</span><br><span class="line">if(mid==b)</span><br><span class="line">&#123;</span><br><span class="line">//cout&lt;&lt;&quot;?&quot;&lt;&lt;endl;</span><br><span class="line">ans=step[mid];</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">//cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;s[x][i]&lt;&lt;endl;</span><br><span class="line">if(s[mid][i]&amp;&amp;vis[i]==0)</span><br><span class="line">&#123;</span><br><span class="line">q.push(i);</span><br><span class="line">vis[i]=1;</span><br><span class="line">step[i]=step[mid]+1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(cin&gt;&gt;n&amp;&amp;n)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">memset(step,0,sizeof(step));</span><br><span class="line">memset(s,0,sizeof(s));</span><br><span class="line">ans=-1;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;meizi;</span><br><span class="line">if(i+meizi&gt;=1&amp;&amp;i+meizi&lt;=n)s[i][meizi+i]=1;</span><br><span class="line">if(i-meizi&gt;=1&amp;&amp;i-meizi&lt;=n)  s[i][i-meizi]=1;</span><br><span class="line">&#125;</span><br><span class="line">bfs(a);</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天没讲题，加练，没啥好说的，除了脑仁疼就是脑仁疼。还有两道似乎是用到DFS的是真的写不出来了。慢慢补吧。
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="Algorithm" scheme="https://cndrew.cn/blog/tags/Algorithm/"/>
    
      <category term="c/c++" scheme="https://cndrew.cn/blog/tags/c-c/"/>
    
      <category term="DFS" scheme="https://cndrew.cn/blog/tags/DFS/"/>
    
      <category term="HDU" scheme="https://cndrew.cn/blog/tags/HDU/"/>
    
      <category term="poj" scheme="https://cndrew.cn/blog/tags/poj/"/>
    
      <category term="STL" scheme="https://cndrew.cn/blog/tags/STL/"/>
    
      <category term="BFS" scheme="https://cndrew.cn/blog/tags/BFS/"/>
    
      <category term="邻接表" scheme="https://cndrew.cn/blog/tags/%E9%82%BB%E6%8E%A5%E8%A1%A8/"/>
    
      <category term="Queue" scheme="https://cndrew.cn/blog/tags/Queue/"/>
    
  </entry>
  
  <entry>
    <title>树的直径以及邻接表，链式前向星的存图</title>
    <link href="https://cndrew.cn/blog/2019/07/25/mapsave/"/>
    <id>https://cndrew.cn/blog/2019/07/25/mapsave/</id>
    <published>2019-07-25T14:23:57.943Z</published>
    <updated>2019-08-04T02:12:09.279Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天的学习及刷题的过程中遇到了一些新的知识——树的直径，和前几天学到但没使用过的邻接表存图以及链式前向星存图。内容也不少，所以特意新开一篇文章进行介绍。<a id="more"></a></p><p>先来了解一下什么是树：<br>树（tree）是包含n（n&gt;0）个结点的有穷集，其中：</p><ul><li>每个元素称为结点（node）；</li><li>有一个特定的结点被称为根结点或树根（root）；</li><li>除根结点之外的其余数据元素被分为m（m≥0）个互不相交<br>的集合T1，T2，…Tm-1，其中每一个集合Tm-1（1≤i≤m）<br>本身也是一棵树，被称作原树的子树（subtree）。</li></ul><p>树中距离最大的两个结点之间的距离称为树的直径。<br><img src="http://drew.todest.cn//20190804101208.png" alt></p><p>树的直径的求法：</p><p>两次dfs或bfs。第一次任意选一个点进行dfs(bfs)找到离它最远的<br>点，此点就是最长路的一个端点，再以此点进行dfs（bfs），找到<br>离它最远的点，此点就是最长路的另一个端点，于是就找到了树<br>的直径。</p><p>证明：<br>假设此树的最长路径是从s到t,我们选择的点为u。<br>反证法：假设搜到的点是v。<br>1、v在这条最长路径上，那么dis[u,v]&gt;dis[u,v]+dis[v,s],显然矛<br>盾。<br>2、v不在这条最长路径上，我们在最长路径上选择一个点为po，<br>则dis[u,v]&gt;dis[u,po]+dis[po,t]，那么有dis[s,v]=dis[s,po]+dis[po,u]<br>+dis[u,v]&gt;dis[s,po]+dis[po,t]=dis[s,t],即dis[s,v]&gt;dis[s,t],矛盾。<br>也许你想说u本身就在最长路径，或则其它的一些情况，但其实<br>都能用类似于上面的反证法来证明的。<br>综上所述，你两次dfs(bfs)就可以求出最长路径的两个端点和路<br>径长度。        以上内容参考与学长的PDF</p><p>其实证明看不太懂得话问题不大，就是随便找一个位置先进行dfs或者bfs到达一个端点，再以这个端点为起点dfs或者bfs到达另一个端点即可。</p><p>有的题它让你处理的就是字符串组成的图，但是有的题就不会这么好心了，他会给出你节点，边，甚至有的还会给你出权值。此时我们就需要自己存图。</p><p>说到存图，一般都有三种方法。</p><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>用二维数组进行存图，这个是最普通的办法，但是有一个致命的缺点就是当题目数据中的点比较多的时候有极高的空间复杂度，会爆内存。不过数据范围小的时候用二维数组来存图。还是很简单的。<br>举个栗子：<br>5个点 4条边<br>对每条边输入三个数，两个端点以及这条边的权值<br>1 2 2<br>2 3 4<br>4 5 1<br>1 4 2<br>1 5 3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">char s[maxn][maxn];</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y&gt;&gt;p;</span><br><span class="line">    s[x][y]=p;</span><br><span class="line">s[y][x]=p;//如果是有向图的话，就不需要这一句了    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>访问的时候直接s[i][j]就行了</p><h2 id="邻接表法"><a href="#邻接表法" class="headerlink" title="邻接表法"></a>邻接表法</h2><p>邻接表法就是用vector来进行存储，这个也挺好理解，跟二维数组可以一样的理解。<br>举个栗子：<br>5个点 4条边<br>对每条边输入三个数，两个端点以及这条边的权值<br>1 2 2<br>2 3 4<br>4 5 1<br>1 4 2<br>1 5 3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//无权值</span><br><span class="line">vector&lt;int&gt; v[maxn];</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    v[x].push_back(y);</span><br><span class="line">    v[y].push_back(x);//有向边的话不需要者一句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//有权值</span><br><span class="line">vector&lt;pair&lt;int,int&gt; &gt; v[maxn]；</span><br><span class="line">fot(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">    v[x].push_back(make_pair(y,z));</span><br><span class="line">    v[y].push_back(make_pair(x,z));//有向边的话不需要者一句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问每条边的时候需要这样写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;v[i].size();j++)</span><br><span class="line">    &#123;</span><br><span class="line">    cout&lt;&lt;v[i][j].first&lt;&lt;&quot;-&gt;&quot;&lt;&lt;v[i][j].second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h2><p>链式前向星是一种很巧妙地方法。<br>首先建立一个结构体<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Edge</span><br><span class="line">&#123;</span><br><span class="line">    int e;//表示第i条边的终点</span><br><span class="line">    int w;//权值</span><br><span class="line">    int next;//表示同起点的下一条边</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>加边<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cnt=0,head=-1;</span><br><span class="line">void add ( int u, int v, int w)</span><br><span class="line">&#123;</span><br><span class="line">edge [cnt ].w = w;</span><br><span class="line">edge [cnt ]. to = v;</span><br><span class="line">edge [cnt ]. next = head [u];</span><br><span class="line">head [u] = cnt ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>边的遍历<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (int i= head [u];~i;i= edge [i]. next )</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt;u&lt;&lt;&quot; -&gt;&quot; &lt;&lt;edge [i].e&lt;&lt; endl ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>链式前向星不会遍历到不存在的边。<br>内存利用率高，相比vector实现的邻接表而言，可以准确开辟最多边数的内存，不像vector实现的邻接表有爆内存的风险。</p><p>如果有兴趣深入理解存图的话可以参考一下这几篇博客：<a href="https://blog.csdn.net/acdreamers/article/details/16902023" target="_blank" rel="noopener">https://blog.csdn.net/acdreamers/article/details/16902023</a></p><p><a href="https://jzqt.github.io/2015/07/21/ACM%E5%9B%BE%E8%AE%BA%E4%B9%8B%E5%AD%98%E5%9B%BE%E6%96%B9%E5%BC%8F/" target="_blank" rel="noopener">https://jzqt.github.io/2015/07/21/ACM%E5%9B%BE%E8%AE%BA%E4%B9%8B%E5%AD%98%E5%9B%BE%E6%96%B9%E5%BC%8F/</a></p><p>三种存图方式的介绍就到这里了，我最喜欢用的是第二种，好理解又方便写，但是不得不承认链式前向星的优秀，还是应该会用的。</p><p>说完了存图，我还想说一下用邻接表存了图之后该如何进行搜索（这里以bfs为例）。</p><p>我们只需要对每个顶点进行搜索即可，即bfs传递的参数为邻接表中的第一个元素。<br>直接上代码吧<br>无权值得<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e5+10;</span><br><span class="line">int dis[maxn],ans,vis[maxn],n,a,b;</span><br><span class="line">vector&lt;int&gt; v[maxn];</span><br><span class="line">int bfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">memset(dis,0,sizeof(dis));</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">q.push(x);</span><br><span class="line">vis[x]=1,dis[x]=0;</span><br><span class="line">int point;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">x=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">if(dis[x]&gt;ans)</span><br><span class="line">&#123;</span><br><span class="line">ans=dis[x];</span><br><span class="line">point=x;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;v[x].size();i++)</span><br><span class="line">&#123;</span><br><span class="line">if(!vis[v[x][i]])</span><br><span class="line">&#123;</span><br><span class="line">vis[v[x][i]]=1;</span><br><span class="line">dis[v[x][i]]=dis[x]+1;</span><br><span class="line">q.push(v[x][i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return point;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i=1;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">v[a].push_back(b);</span><br><span class="line">v[b].push_back(a);</span><br><span class="line">&#125;</span><br><span class="line">ans=0;</span><br><span class="line">int point=bfs(1);</span><br><span class="line">ans=0;</span><br><span class="line">bfs(point);</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有权值的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a,b,c,ans;</span><br><span class="line">const int maxn = 1e5+10;</span><br><span class="line">int vis[maxn],dis[maxn];//dis数组储存的就是当前点能向一个确定的方向走的最大的距离。vis就是一个标记数组防止重复访问。</span><br><span class="line">vector&lt;pair&lt;int,int&gt; &gt; v[maxn]; //用来存图，可以看成是一个二维数组,因为是有权值的，所以在vector中套用了一个pair</span><br><span class="line">int bfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">    memset(vis,0,sizeof(vis));//因为要进行多次bfs，所以每次都要清空一下数组</span><br><span class="line">    memset(dis,0,sizeof(dis));</span><br><span class="line">    vis[x]=1;//已经访问过的节点标记为1</span><br><span class="line">    int point=0;//用来储存当前所能走到的最远的点</span><br><span class="line">    queue&lt;int&gt; q;//用来实现bfs的队列</span><br><span class="line">    q.push(x);</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        x=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        if(dis[x]&gt;ans)//如果当前点能走的最大的步数大于ans，ans初始为0，如果大于就更新ans和point的值</span><br><span class="line">        &#123;</span><br><span class="line">            ans=dis[x];</span><br><span class="line">            point=x;</span><br><span class="line">        &#125;</span><br><span class="line">        pair&lt;int,int&gt; mid;</span><br><span class="line">        for(int i=0;i&lt;v[x].size();i++)//对v[x]中的每一个元素进行bfs</span><br><span class="line">        &#123;</span><br><span class="line">            mid=v[x][i];</span><br><span class="line">            if(!vis[mid.first])//没访问过就继续</span><br><span class="line">            &#123;</span><br><span class="line">                vis[mid.first]=1;//标记成已经访问过的</span><br><span class="line">                dis[mid.first]=dis[x]+mid.second;//这个点的能走的最大的距离多了一个dis[x]</span><br><span class="line">                q.push(mid.first);//放进队列以进行bfs</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return point;//把当前走到的最远的点返回</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c)</span><br><span class="line">    &#123;</span><br><span class="line">        v[a].push_back(make_pair(b,c));//存图</span><br><span class="line">        v[b].push_back(make_pair(a,c));</span><br><span class="line">    &#125;</span><br><span class="line">    ans=0;//初始化</span><br><span class="line">    int point=bfs(1);</span><br><span class="line">    ans=0;</span><br><span class="line">    bfs(point);//第二次以某一端点位起点的bfs</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里只需要看一下对邻接表中vector下标的使用即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的学习及刷题的过程中遇到了一些新的知识——树的直径，和前几天学到但没使用过的邻接表存图以及链式前向星存图。内容也不少，所以特意新开一篇文章进行介绍。
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="Algorithm" scheme="https://cndrew.cn/blog/tags/Algorithm/"/>
    
      <category term="BFS" scheme="https://cndrew.cn/blog/tags/BFS/"/>
    
      <category term="树的直径" scheme="https://cndrew.cn/blog/tags/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"/>
    
      <category term="邻接表" scheme="https://cndrew.cn/blog/tags/%E9%82%BB%E6%8E%A5%E8%A1%A8/"/>
    
      <category term="“链式前向星”" scheme="https://cndrew.cn/blog/tags/%E2%80%9C%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F%E2%80%9D/"/>
    
  </entry>
  
  <entry>
    <title>HPU Summer Training Day 9（河南理工大学暑期第九天）</title>
    <link href="https://cndrew.cn/blog/2019/07/25/d9/"/>
    <id>https://cndrew.cn/blog/2019/07/25/d9/</id>
    <published>2019-07-25T14:21:15.879Z</published>
    <updated>2019-08-04T01:49:09.111Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天主要讲了树的直径，是用bfs和dfs实现的，但是我的dfs，emm，一言难尽，所以我只用了bfs。<a id="more"></a><br>关于今天刷题遇到的主要的知识，请去这里查看。</p><center><font color="red">-------------------------------------&gt;<a href="https://cndrew.cn/blog/2019/07/25/mapsave">戳这里</a>&lt;-------------------------------------</font></center><h3 id="Labyrinth"><a href="#Labyrinth" class="headerlink" title="Labyrinth"></a>Labyrinth</h3><p>Description:<br>The northern part of the Pyramid contains a very large and complicated labyrinth. The labyrinth is divided into square blocks, each of them either filled by rock, or free. There is also a little hook on the floor in the center of every free block. The ACM have found that two of the hooks must be connected by a rope that runs through the hooks in every block on the path between the connected ones. When the rope is fastened, a secret door opens. The problem is that we do not know which hooks to connect. That means also that the neccessary length of the rope is unknown. Your task is to determine the maximum length of the rope we could need for a given labyrinth.<br>Input</p><blockquote><p>The input consists of T test cases. The number of them (T) is given on the first line of the input file. Each test case begins with a line containing two integers C and R (3 &lt;= C,R &lt;= 1000) indicating the number of columns and rows. Then exactly R lines follow, each containing C characters. These characters specify the labyrinth. Each of them is either a hash mark (#) or a period (.). Hash marks represent rocks, periods are free blocks. It is possible to walk between neighbouring blocks only, where neighbouring blocks are blocks sharing a common side. We cannot walk diagonally and we cannot step out of the labyrinth.</p></blockquote><blockquote><p>The labyrinth is designed in such a way that there is exactly one path between any two free blocks. Consequently, if we find the proper hooks to connect, it is easy to find the right path connecting them.<br>Output<br>Your program must print exactly one line of output for each test case. The line must contain the sentence &quot;Maximum rope length is X.&quot; where Xis the length of the longest path between any two free blocks, measured in blocks.</p></blockquote><p>Sample Input</p><blockquote><p>2<br>3 3</p></blockquote><p>###</p><p>#.#</p><p>###<br>7 6</p><p>#######</p><p>#.#.###</p><p>#.#.###</p><p>#.#.#.#</p><p>#.....#</p><p>#######</p><p>Sample Output</p><blockquote><p>Maximum rope length is 0.<br>Maximum rope length is 8.</p></blockquote><p>Hint</p><blockquote><p>Huge input, scanf is recommended.<br>If you use recursion, maybe stack overflow. and now C++/c &#39;s stack size is larger than G++/gcc</p></blockquote><p>Problem solving:<br>这一题是最简单的求树的直径的题，bfs两次即可，注意虽然第一次开始查找的位置可以是任意的，但是第二次开始的位置应该是第一次查找到最后的那个位置，还有就是两个bfs之间不要忘了memset。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int dis[1005][1005];</span><br><span class="line">int vis[1005][1005];</span><br><span class="line">char s[1005][1005];</span><br><span class="line">int d[4][2]=&#123;1,0,0,1,-1,0,0,-1&#125;;</span><br><span class="line">struct node&#123;</span><br><span class="line">int x,y;</span><br><span class="line">&#125;;</span><br><span class="line">int n,c,r,sx,sy;</span><br><span class="line">int bfs(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">node now,mid;</span><br><span class="line">queue&lt;node&gt; que;</span><br><span class="line">now.x=x;now.y=y;</span><br><span class="line">que.push(now);</span><br><span class="line">vis[x][y]=1;dis[x][y]=0;</span><br><span class="line">while(!que.empty())</span><br><span class="line">&#123;</span><br><span class="line">now=que.front();</span><br><span class="line">que.pop();</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">mid.x=now.x+d[i][0];</span><br><span class="line">mid.y=now.y+d[i][1];</span><br><span class="line">if(mid.x&lt;0||mid.x&gt;=r||mid.y&lt;0||mid.y&gt;=c||s[mid.x][mid.y]==&apos;#&apos;||vis[mid.x][mid.y])continue;</span><br><span class="line">vis[mid.x][mid.y]=1;</span><br><span class="line">dis[mid.x][mid.y]=dis[now.x][now.y]+1;</span><br><span class="line">que.push(mid);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">while(n--)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">memset(dis,0,sizeof(dis));</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;c,&amp;r);</span><br><span class="line">int flag=0;</span><br><span class="line">for(int i=0;i&lt;r;i++)scanf(&quot;%s&quot;,s[i]);</span><br><span class="line">for(int i=0;i&lt;r;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;c;j++)</span><br><span class="line">&#123;</span><br><span class="line">if(s[i][j]==&apos;.&apos;)</span><br><span class="line">&#123;</span><br><span class="line">sx=i,sy=j;</span><br><span class="line">flag=1;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">if(flag)break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bfs(sx,sy);int px=0;</span><br><span class="line">for(int i=0;i&lt;r;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;c;j++)</span><br><span class="line">&#123;</span><br><span class="line">if(dis[i][j]&gt;px)</span><br><span class="line">&#123;</span><br><span class="line">sx=i;</span><br><span class="line">sy=j;</span><br><span class="line">px=dis[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">memset(dis,0,sizeof(dis));</span><br><span class="line">bfs(sx,sy);</span><br><span class="line">int ans=0;</span><br><span class="line">for(int i=0;i&lt;r;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;c;j++)</span><br><span class="line">&#123;</span><br><span class="line">ans=max(ans,dis[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;Maximum rope length is %d.\n&quot;,ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Cow-Marathon"><a href="#Cow-Marathon" class="headerlink" title="Cow Marathon"></a>Cow Marathon</h3><p>Description:<br>After hearing about the epidemic of obesity in the USA, Farmer John wants his cows to get more exercise, so he has committed to create a bovine marathon for his cows to run. The marathon route will include a pair of farms and a path comprised of a sequence of roads between them. Since FJ wants the cows to get as much exercise as possible he wants to find the two farms on his map that are the farthest apart from each other (distance being measured in terms of total length of road on the path between the two farms). Help him determine the distances between this farthest pair of farms.<br>有n个农田和m条路，以及每条路的方向（方向在这道题中没有用），求最长的一条路，也就是两点间的最大距离，即树的直径.<br>Input</p><blockquote><ul><li>Lines 1.....: Same input format as &quot;Navigation Nightmare&quot;.</li></ul></blockquote><p>Output</p><blockquote><ul><li>Line 1: An integer giving the distance between the farthest pair of farms.</li></ul></blockquote><p>Sample Input</p><blockquote><p>7 6<br>1 6 13 E<br>6 3 9 E<br>3 5 7 S<br>4 1 3 N<br>2 4 20 W<br>4 7 2 S</p></blockquote><p>Sample Output</p><blockquote><p>52</p></blockquote><p>Hint</p><blockquote><p>The longest marathon runs from farm 2 via roads 4, 1, 6 and 3 to farm 5 and is of length 20+3+13+9+7=52.</p></blockquote><p>Problem solving:<br>这道题就是一道带权的无向图求树的最大直径。<br>直接套模板即可。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a,b,c,ans,n,m;</span><br><span class="line">const int maxn = 1e5+10;</span><br><span class="line">int vis[maxn],dis[maxn];</span><br><span class="line">char s;</span><br><span class="line">vector&lt;pair&lt;int,int&gt; &gt; v[maxn];</span><br><span class="line">int bfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">memset(dis,0,sizeof(dis));</span><br><span class="line">vis[x]=1;</span><br><span class="line">int point=0;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">q.push(x);</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">x=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">if(dis[x]&gt;ans)</span><br><span class="line">&#123;</span><br><span class="line">ans=dis[x];</span><br><span class="line">point=x;</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;int,int&gt; mid;</span><br><span class="line">for(int i=0;i&lt;v[x].size();i++)</span><br><span class="line">&#123;</span><br><span class="line">mid=v[x][i];</span><br><span class="line">if(!vis[mid.first])</span><br><span class="line">&#123;</span><br><span class="line">vis[mid.first]=1;</span><br><span class="line">dis[mid.first]=dis[x]+mid.second;</span><br><span class="line">q.push(mid.first);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return point;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">while(m--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;s;</span><br><span class="line">v[a].push_back(make_pair(b,c));</span><br><span class="line">v[b].push_back(make_pair(a,c));</span><br><span class="line">&#125;</span><br><span class="line">ans=0;</span><br><span class="line">int point=bfs(1);</span><br><span class="line">ans=0;</span><br><span class="line">bfs(point);</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Roads-in-the-North"><a href="#Roads-in-the-North" class="headerlink" title="Roads in the North"></a>Roads in the North</h3><p>Description:<br>Building and maintaining roads among communities in the far North is an expensive business. With this in mind, the roads are build such that there is only one route from a village to a village that does not pass through some other village twice.<br>Given is an area in the far North comprising a number of villages and roads among them such that any village can be reached by road from any other village. Your job is to find the road distance between the two most remote villages in the area.</p><p>The area has up to 10,000 villages connected by road segments. The villages are numbered from 1.<br>Input</p><blockquote><p>Input to the problem is a sequence of lines, each containing three positive integers: the number of a village, the number of a different village, and the length of the road segment connecting the villages in kilometers. All road segments are two-way.</p></blockquote><p>Output</p><blockquote><p>You are to output a single integer: the road distance between the two most remote villages in the area.</p></blockquote><p>Sample Input</p><blockquote><p>5 1 6<br>1 4 5<br>6 3 9<br>2 6 8<br>6 1 7</p></blockquote><p>Sample Output</p><blockquote><p>22</p></blockquote><p>Problem solving:<br>同B，直接套模板即可。这里是输入组数不确定，所以直接while(cin)即可。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a,b,c,ans;</span><br><span class="line">const int maxn = 1e5+10;</span><br><span class="line">int vis[maxn],dis[maxn];</span><br><span class="line">vector&lt;pair&lt;int,int&gt; &gt; v[maxn];</span><br><span class="line">int bfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">memset(dis,0,sizeof(dis));</span><br><span class="line">vis[x]=1;</span><br><span class="line">int point=0;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">q.push(x);</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">x=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">if(dis[x]&gt;ans)</span><br><span class="line">&#123;</span><br><span class="line">ans=dis[x];</span><br><span class="line">point=x;</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;int,int&gt; mid;</span><br><span class="line">for(int i=0;i&lt;v[x].size();i++)</span><br><span class="line">&#123;</span><br><span class="line">mid=v[x][i];</span><br><span class="line">if(!vis[mid.first])</span><br><span class="line">&#123;</span><br><span class="line">vis[mid.first]=1;</span><br><span class="line">dis[mid.first]=dis[x]+mid.second;</span><br><span class="line">q.push(mid.first);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return point;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c)</span><br><span class="line">&#123;</span><br><span class="line">v[a].push_back(make_pair(b,c));</span><br><span class="line">v[b].push_back(make_pair(a,c));</span><br><span class="line">&#125;</span><br><span class="line">ans=0;</span><br><span class="line">int point=bfs(1);</span><br><span class="line">ans=0;</span><br><span class="line">bfs(point);</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Computer"><a href="#Computer" class="headerlink" title="Computer"></a>Computer</h3><p>Description:<br>一所学校不久前买了第一台电脑（所以这台电脑的ID是1）。近年来，学校购买了N-1新电脑。每台新电脑都连接到一台先前安装的电脑上。学校的管理人员担心网络运行缓慢，希望知道第i台计算机需要发送信号的最大距离si（即到最远计算机的电缆长度）。您需要提供此信息。<br><img src="http://drew.todest.cn//20190804094845.png" alt></p><p>提示：示例输入与此图对应。从图中，你可以看到计算机4离1最远，所以s1=3。计算机4和5是距离2最远的，所以s2=2。计算机5是离3最远的，所以s3=3。我们也得到了s4=4，s5=4。<br>输入</p><blockquote><p>输入文件包含多组测试样例。在每组样例中，第一行中都有自然数n（n&lt;=10000），然后是（n-1）行，其中包含对计算机的描述。第i行包含两个自然数-第i计算机所连接的计算机和用于连接的电缆长度。电缆总长度不超过1e9。输入行中的数字用空格分隔。</p></blockquote><p>输出</p><blockquote><p>对于每组样例，输出n行。第i行第i台计算机的到其他计算机的最大长度Si（1&lt;=i&lt;=n）。</p></blockquote><p>样例输入</p><blockquote><p>5<br>1 1<br>2 1<br>3 1<br>1 1</p></blockquote><p>样例输出</p><blockquote><p>3<br>2<br>3<br>4<br>4</p></blockquote><p>提示</p><blockquote><p>示例输入与此图对应。从图中，你可以看到计算机4离1最远，所以s1=3。计算机4和5是距离2最远的，所以s2=2。计算机5是离3最远的，所以s3=3。我们也得到了s4=4，s5=4。</p></blockquote><p>Problem solving:<br>这道题应该是今天最难的题了。一开始毫无思路，但是后来听了学长一句话。离某个点最远的一定是树的直径的端点。我们第一次bfs结束时的点是这个树的两个端点之一，再以这个端点就行bfs结束的时候就到了另外一个端点，而且我们在查找的过程中使用的dis数组就是当前位置距离将要到达的！！端点！！的距离，所以就在bfs一次，与上一次得到的距离去max最大值即可。总结一下就是三次bfs。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const long long maxn=1e5;</span><br><span class="line">long long n,a,b,ans;</span><br><span class="line">long long vis[maxn],dis[maxn],dis2[maxn];</span><br><span class="line">vector&lt;pair&lt;long long,long long&gt; &gt; v[maxn];</span><br><span class="line">long long bfs(long long x)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">memset(dis,0,sizeof(dis));</span><br><span class="line">ans=0;</span><br><span class="line">queue&lt;long long&gt; q;</span><br><span class="line">q.push(x);</span><br><span class="line">vis[x]=1;</span><br><span class="line">long long point;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">x=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">if(dis[x]&gt;ans)</span><br><span class="line">&#123;</span><br><span class="line">ans=dis[x];</span><br><span class="line">point=x;</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;long long,long long&gt; mid;</span><br><span class="line">for(long long i=0;i&lt;v[x].size();i++)</span><br><span class="line">&#123;</span><br><span class="line">mid=v[x][i];</span><br><span class="line">if(!vis[mid.first])</span><br><span class="line">&#123;</span><br><span class="line">vis[mid.first]=1;</span><br><span class="line">dis[mid.first]=dis[x]+mid.second;</span><br><span class="line">q.push(mid.first);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return point;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(cin&gt;&gt;n)</span><br><span class="line">&#123;</span><br><span class="line">memset(v,0,sizeof(v));</span><br><span class="line">for(long long i=2;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">v[a].push_back(make_pair(i,b));</span><br><span class="line">v[i].push_back(make_pair(a,b));</span><br><span class="line">&#125;</span><br><span class="line">long long point=bfs(1);</span><br><span class="line">long long next=bfs(point);</span><br><span class="line">for(long long i=1;i&lt;=n;i++)dis2[i]=dis[i];</span><br><span class="line">bfs(next);</span><br><span class="line">for(long long i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;max(dis2[i],dis[i])&lt;&lt;endl;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Farthest-Nodes-in-a-Tree"><a href="#Farthest-Nodes-in-a-Tree" class="headerlink" title="Farthest Nodes in a Tree"></a>Farthest Nodes in a Tree</h3><p>Description:<br>Given a tree (a connected graph with no cycles), you have to find the farthest nodes in the tree. The edges of the tree are weighted and undirected. That means you have to find two nodes in the tree whose distance is maximum amongst all nodes.</p><p>Input</p><blockquote><p>Input starts with an integer T (≤ 10), denoting the number of test cases.<br>Each case starts with an integer n (2 ≤ n ≤ 30000) denoting the total number of nodes in the tree. The nodes are numbered from 0 to n-1. Each of the next n-1 lines will contain three integers u v w (0 ≤ u, v &lt; n, u ≠ v, 1 ≤ w ≤ 10000) denoting that node u and v are connected by an edge whose weight is w. You can assume that the input will form a valid tree.</p></blockquote><p>Output</p><blockquote><p>For each case, print the case number and the maximum distance.</p></blockquote><p>Sample Input</p><blockquote><p>2<br>4<br>0 1 20<br>1 2 30<br>2 3 50<br>5<br>0 2 20<br>2 1 10<br>0 3 29<br>0 4 50</p></blockquote><p>Sample Output</p><blockquote><p>Case 1: 100<br>Case 2: 80</p></blockquote><p>Problem solving:<br>同BC，直接套模板就行。然后就是输出格式的控制</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">const int maxn= 1e5+10;</span><br><span class="line">using namespace std;</span><br><span class="line">int dis[maxn],ans;</span><br><span class="line">bool vis[maxn];</span><br><span class="line">vector&lt;pair&lt;int,int&gt; &gt; v[maxn];</span><br><span class="line">int bfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">memset(dis,0,sizeof(dis));</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">queue&lt;int&gt; que;</span><br><span class="line">que.push(x);vis[x]=1;</span><br><span class="line">int point=0;</span><br><span class="line">while(!que.empty())</span><br><span class="line">&#123;</span><br><span class="line">int f=que.front();</span><br><span class="line">que.pop();</span><br><span class="line">if(dis[f]&gt;ans)</span><br><span class="line">&#123;</span><br><span class="line">ans=dis[f];</span><br><span class="line">point=f;</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;int,int&gt; t;</span><br><span class="line">for(int i=0;i&lt;v[f].size();i++)</span><br><span class="line">&#123;</span><br><span class="line">t=v[f][i];</span><br><span class="line">if(vis[t.first]==0)</span><br><span class="line">&#123;</span><br><span class="line">vis[t.first]=1;</span><br><span class="line">dis[t.first]=dis[f]+t.second;</span><br><span class="line">que.push(t.first);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return point;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,m,x,y,z,flag=0;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">while(n--)</span><br><span class="line">&#123;</span><br><span class="line">memset(v,0,sizeof(v));</span><br><span class="line">cin&gt;&gt;m;</span><br><span class="line">for(int i=1;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">v[x].push_back(make_pair(y,z));</span><br><span class="line">v[y].push_back(make_pair(x,z));</span><br><span class="line">&#125;</span><br><span class="line">ans=0;</span><br><span class="line">int point=bfs(1);</span><br><span class="line">ans=0;</span><br><span class="line">bfs(point);</span><br><span class="line">printf(&quot;Case %d: %d\n&quot;,++flag,ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="51nod-2602-树的直径"><a href="#51nod-2602-树的直径" class="headerlink" title="51nod 2602 树的直径"></a>51nod 2602 树的直径</h3><p>Description:<br>一棵树的直径就是这棵树上存在的最长路径。现在有一棵n个节点的树，现在想知道这棵树的直径包含的边的个数是多少？<br><img src="http://drew.todest.cn//20190804094907.png" alt></p><p>如图所示的数据，这棵树的直径为(1-2-3-6-9)这条路径，包含的边的个数为4，所以答案是4。</p><p>输入</p><blockquote><p>第1行：一个整数n，表示树上的节点个数。(1&lt;=n&lt;=100000)<br>第2-n行：每行有两个整数u,v,表示u与v之间有一条路径。(1&lt;=u,v&lt;=n)</p></blockquote><p>输出</p><blockquote><p>输出一个整数，表示这棵树直径所包含的边的个数。</p></blockquote><p>输入样例</p><blockquote><p>10<br>1 2<br>2 3<br>3 4<br>3 5<br>3 6<br>3 7<br>3 10<br>6 8<br>6 9</p></blockquote><p>输出样例</p><blockquote><p>4</p></blockquote><p>Problem solving:<br>求树的直径的模板题。不过无权值。</p><p>Code:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e5+10;</span><br><span class="line">int dis[maxn],ans,vis[maxn],n,a,b;</span><br><span class="line">vector&lt;int&gt; v[maxn];</span><br><span class="line">int bfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">memset(dis,0,sizeof(dis));</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">q.push(x);</span><br><span class="line">vis[x]=1,dis[x]=0;</span><br><span class="line">int point;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">x=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">if(dis[x]&gt;ans)</span><br><span class="line">&#123;</span><br><span class="line">ans=dis[x];</span><br><span class="line">point=x;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;v[x].size();i++)</span><br><span class="line">&#123;</span><br><span class="line">if(!vis[v[x][i]])</span><br><span class="line">&#123;</span><br><span class="line">vis[v[x][i]]=1;</span><br><span class="line">dis[v[x][i]]=dis[x]+1;</span><br><span class="line">q.push(v[x][i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return point;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i=1;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">v[a].push_back(b);</span><br><span class="line">v[b].push_back(a);</span><br><span class="line">&#125;</span><br><span class="line">ans=0;</span><br><span class="line">int point=bfs(1);</span><br><span class="line">ans=0;</span><br><span class="line">bfs(point);</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>上面有三道题我都直接说得套模板。那么求树的直径的模板是什么呢？这里只写上带权的吧，不带权的可以类比得出。或者去这里看：<center><font color="red">------------------------------&gt;<a href="https://cndrew.cn/blog/2019/07/25/mapsave">戳这里</a>&lt;------------------------------</font></center></p><p>在这里我结合代码想详细的分析一下这个模板。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a,b,c,ans;</span><br><span class="line">const int maxn = 1e5+10;</span><br><span class="line">int vis[maxn],dis[maxn];//dis数组储存的就是当前点能向一个确定的方向走的最大的距离。vis就是一个标记数组防止重复访问。</span><br><span class="line">vector&lt;pair&lt;int,int&gt; &gt; v[maxn]; //用来存图，可以看成是一个二维数组,因为是有权值的，所以在vector中套用了一个pair</span><br><span class="line">int bfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">    memset(vis,0,sizeof(vis));//因为要进行多次bfs，所以每次都要清空一下数组</span><br><span class="line">    memset(dis,0,sizeof(dis));</span><br><span class="line">    vis[x]=1;//已经访问过的节点标记为1</span><br><span class="line">    int point=0;//用来储存当前所能走到的最远的点</span><br><span class="line">    queue&lt;int&gt; q;//用来实现bfs的队列</span><br><span class="line">    q.push(x);</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        x=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        if(dis[x]&gt;ans)//如果当前点能走的最大的步数大于ans，ans初始为0，如果大于就更新ans和point的值</span><br><span class="line">        &#123;</span><br><span class="line">            ans=dis[x];</span><br><span class="line">            point=x;</span><br><span class="line">        &#125;</span><br><span class="line">        pair&lt;int,int&gt; mid;</span><br><span class="line">        for(int i=0;i&lt;v[x].size();i++)//对v[x]中的每一个元素进行bfs</span><br><span class="line">        &#123;</span><br><span class="line">            mid=v[x][i];</span><br><span class="line">            if(!vis[mid.first])//没访问过就继续</span><br><span class="line">            &#123;</span><br><span class="line">                vis[mid.first]=1;//标记成已经访问过的</span><br><span class="line">                dis[mid.first]=dis[x]+mid.second;//这个点的能走的最大的距离多了一个dis[x]</span><br><span class="line">                q.push(mid.first);//放进队列以进行bfs</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return point;//把当前走到的最远的点返回</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c)</span><br><span class="line">    &#123;</span><br><span class="line">        v[a].push_back(make_pair(b,c));//存图</span><br><span class="line">        v[b].push_back(make_pair(a,c));</span><br><span class="line">    &#125;</span><br><span class="line">    ans=0;//初始化</span><br><span class="line">    int point=bfs(1);</span><br><span class="line">    ans=0;</span><br><span class="line">    bfs(point);//第二次以某一端点位起点的bfs</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="学长标程"><a href="#学长标程" class="headerlink" title="学长标程"></a>学长标程</h3><p>学长写的代码比我的好看多了。。。贴一下</p><h4 id="Labyrinth-1"><a href="#Labyrinth-1" class="headerlink" title="Labyrinth"></a>Labyrinth</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int N,M,u,v,ans;</span><br><span class="line">int dir[4][2]=&#123;1,0,0,1,-1,0,0,-1&#125;;</span><br><span class="line">char MAP[1200][1200];</span><br><span class="line">bool vis[1200][1200];</span><br><span class="line">void dfs(int x,int y,int res)&#123;</span><br><span class="line">for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">int nx=dir[i][0]+x;</span><br><span class="line">int ny=dir[i][1]+y;</span><br><span class="line">if(nx&gt;=0&amp;&amp;nx&lt;N&amp;&amp;ny&gt;=0&amp;&amp;ny&lt;M&amp;&amp;vis[nx][ny]==0&amp;&amp;MAP[nx][ny]==&apos;.&apos;)&#123;</span><br><span class="line">vis[nx][ny]=1;</span><br><span class="line">dfs(nx,ny,res+1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(res&gt;=ans)&#123;</span><br><span class="line">u=x;v=y;ans=res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">int T;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;T);</span><br><span class="line">while(T--)&#123;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;M,&amp;N);</span><br><span class="line">for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">scanf(&quot;%s&quot;,&amp;MAP[i]);</span><br><span class="line">&#125;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">ans=0;</span><br><span class="line">for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">for(int j=0;j&lt;M;j++)&#123;</span><br><span class="line">if(MAP[i][j]==&apos;.&apos;)&#123;</span><br><span class="line">dfs(i,j,0);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">dfs(u,v,0);</span><br><span class="line">cout&lt;&lt;&quot;Maximum rope length is &quot;&lt;&lt;ans&lt;&lt;&apos;.&apos;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Cow-Marathon-1"><a href="#Cow-Marathon-1" class="headerlink" title="Cow Marathon"></a>Cow Marathon</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int N,M,X,Y,Z,ans;</span><br><span class="line">int dis[40020];</span><br><span class="line">bool vis[40020];</span><br><span class="line">vector&lt;pair&lt;int,int&gt; &gt;V[40020];</span><br><span class="line">int bfs(int n)&#123;</span><br><span class="line">memset(dis,0,sizeof(dis));</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">queue&lt;int&gt;Q;</span><br><span class="line">Q.push(n);</span><br><span class="line">vis[n]=1;</span><br><span class="line">ans=0;</span><br><span class="line">int point=0,t;</span><br><span class="line">while(!Q.empty())&#123;</span><br><span class="line">t=Q.front();</span><br><span class="line">Q.pop();</span><br><span class="line">if(dis[t]&gt;ans)&#123;</span><br><span class="line">ans=dis[t];</span><br><span class="line">point=t;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;V[t].size();i++)&#123;</span><br><span class="line">if(vis[V[t][i].first]==0)&#123;</span><br><span class="line">vis[V[t][i].first]=1;</span><br><span class="line">dis[V[t][i].first]=dis[t]+V[t][i].second;</span><br><span class="line">Q.push(V[t][i].first);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return point;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;N,&amp;M);</span><br><span class="line">for(int i=0;i&lt;M;i++)&#123;</span><br><span class="line">scanf(&quot;%d%d%d %*c&quot;,&amp;X,&amp;Y,&amp;Z);</span><br><span class="line">V[X].push_back(make_pair(Y,Z));</span><br><span class="line">V[Y].push_back(make_pair(X,Z));</span><br><span class="line">&#125;</span><br><span class="line">bfs(bfs(1));</span><br><span class="line">printf(&quot;%d\n&quot;,ans);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Roads-in-the-North-1"><a href="#Roads-in-the-North-1" class="headerlink" title="Roads in the North"></a>Roads in the North</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int N,M,X,Y,Z,ans;</span><br><span class="line">int dis[40020];</span><br><span class="line">bool vis[40020];</span><br><span class="line">vector&lt;pair&lt;int,int&gt; &gt;V[40020];</span><br><span class="line">int bfs(int n)&#123;</span><br><span class="line">memset(dis,0,sizeof(dis));</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">queue&lt;int&gt;Q;</span><br><span class="line">Q.push(n);</span><br><span class="line">vis[n]=1;</span><br><span class="line">ans=0;</span><br><span class="line">int point=0,t;</span><br><span class="line">while(!Q.empty())&#123;</span><br><span class="line">t=Q.front();</span><br><span class="line">Q.pop();</span><br><span class="line">if(dis[t]&gt;ans)&#123;</span><br><span class="line">ans=dis[t];</span><br><span class="line">point=t;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;V[t].size();i++)&#123;</span><br><span class="line">if(vis[V[t][i].first]==0)&#123;</span><br><span class="line">vis[V[t][i].first]=1;</span><br><span class="line">dis[V[t][i].first]=dis[t]+V[t][i].second;</span><br><span class="line">Q.push(V[t][i].first);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return point;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">while(scanf(&quot;%d%d%d&quot;,&amp;X,&amp;Y,&amp;Z)!=EOF)&#123;</span><br><span class="line">V[X].push_back(make_pair(Y,Z));</span><br><span class="line">V[Y].push_back(make_pair(X,Z));</span><br><span class="line">&#125;</span><br><span class="line">bfs(bfs(1));</span><br><span class="line">printf(&quot;%d\n&quot;,ans);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Computer-1"><a href="#Computer-1" class="headerlink" title="Computer"></a>Computer</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int N,M,X,Y,Z,ans;</span><br><span class="line">int dis[40020];</span><br><span class="line">int diss[40020];</span><br><span class="line">bool vis[40020];</span><br><span class="line">vector&lt;pair&lt;int,int&gt; &gt;V[40020];</span><br><span class="line">int bfs(int n)&#123;</span><br><span class="line">memset(dis,0,sizeof(dis));</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">queue&lt;int&gt;Q;</span><br><span class="line">Q.push(n);</span><br><span class="line">vis[n]=1;</span><br><span class="line">ans=0;</span><br><span class="line">int point,t;</span><br><span class="line">while(!Q.empty())&#123;</span><br><span class="line">t=Q.front();</span><br><span class="line">Q.pop();</span><br><span class="line">if(dis[t]&gt;ans)&#123;</span><br><span class="line">ans=dis[t];</span><br><span class="line">point=t;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;V[t].size();i++)&#123;</span><br><span class="line">if(vis[V[t][i].first]==0)&#123;</span><br><span class="line">vis[V[t][i].first]=1;</span><br><span class="line">dis[V[t][i].first]=dis[t]+V[t][i].second;</span><br><span class="line">Q.push(V[t][i].first);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return point;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">while(scanf(&quot;%d&quot;,&amp;N)!=EOF)&#123;</span><br><span class="line">for(int i=0;i&lt;=N;i++)V[i].clear();</span><br><span class="line">for(int i=1;i&lt;N;i++)&#123;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;X,&amp;Z);</span><br><span class="line">V[i+1].push_back(make_pair(X,Z));</span><br><span class="line">V[X].push_back(make_pair(i+1,Z));</span><br><span class="line">&#125;</span><br><span class="line">int point=bfs(bfs(1));</span><br><span class="line">for(int i=1;i&lt;=N;i++)&#123;</span><br><span class="line">diss[i]=dis[i];</span><br><span class="line">&#125;</span><br><span class="line">bfs(point);</span><br><span class="line">for(int i=1;i&lt;=N;i++)&#123;</span><br><span class="line">printf(&quot;%d\n&quot;,max(dis[i],diss[i]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Farthest-Nodes-in-a-Tree-1"><a href="#Farthest-Nodes-in-a-Tree-1" class="headerlink" title="Farthest Nodes in a Tree"></a>Farthest Nodes in a Tree</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int N,M,X,Y,Z,ans;</span><br><span class="line">int dis[40020];</span><br><span class="line">bool vis[40020];</span><br><span class="line">vector&lt;pair&lt;int,int&gt; &gt;V[40020];</span><br><span class="line">int bfs(int n)&#123;</span><br><span class="line">memset(dis,0,sizeof(dis));</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">queue&lt;int&gt;Q;</span><br><span class="line">Q.push(n);</span><br><span class="line">vis[n]=1;</span><br><span class="line">ans=0;</span><br><span class="line">int point,t;</span><br><span class="line">while(!Q.empty())&#123;</span><br><span class="line">t=Q.front();</span><br><span class="line">Q.pop();</span><br><span class="line">if(dis[t]&gt;ans)&#123;</span><br><span class="line">ans=dis[t];</span><br><span class="line">point=t;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;V[t].size();i++)&#123;</span><br><span class="line">if(vis[V[t][i].first]==0)&#123;</span><br><span class="line">vis[V[t][i].first]=1;</span><br><span class="line">dis[V[t][i].first]=dis[t]+V[t][i].second;</span><br><span class="line">Q.push(V[t][i].first);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return point;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">int T,Case=1;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;T);</span><br><span class="line">while(T--)&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;N);</span><br><span class="line">for(int i=0;i&lt;N;i++)V[i].clear();</span><br><span class="line">for(int i=1;i&lt;N;i++)&#123;</span><br><span class="line">scanf(&quot;%d%d%d&quot;,&amp;X,&amp;Y,&amp;Z);</span><br><span class="line">V[X].push_back(make_pair(Y,Z));</span><br><span class="line">V[Y].push_back(make_pair(X,Z));</span><br><span class="line">&#125;</span><br><span class="line">bfs(bfs(0));</span><br><span class="line">printf(&quot;Case %d: %d\n&quot;,Case++,ans);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int N,M,X,Y,Z,ans;</span><br><span class="line">int dis[100020];</span><br><span class="line">bool vis[100020];</span><br><span class="line">vector&lt;pair&lt;int,int&gt; &gt;V[100020];</span><br><span class="line">int bfs(int n)&#123;</span><br><span class="line">memset(dis,0,sizeof(dis));</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">queue&lt;int&gt;Q;</span><br><span class="line">Q.push(n);</span><br><span class="line">vis[n]=1;</span><br><span class="line">ans=0;</span><br><span class="line">int point,t;</span><br><span class="line">while(!Q.empty())&#123;</span><br><span class="line">t=Q.front();</span><br><span class="line">Q.pop();</span><br><span class="line">if(dis[t]&gt;ans)&#123;</span><br><span class="line">ans=dis[t];</span><br><span class="line">point=t;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;V[t].size();i++)&#123;</span><br><span class="line">if(vis[V[t][i].first]==0)&#123;</span><br><span class="line">vis[V[t][i].first]=1;</span><br><span class="line">dis[V[t][i].first]=dis[t]+V[t][i].second;</span><br><span class="line">Q.push(V[t][i].first);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return point;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;N);</span><br><span class="line">for(int i=1;i&lt;N;i++)&#123;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;X,&amp;Y);</span><br><span class="line">V[X].push_back(make_pair(Y,1));</span><br><span class="line">V[Y].push_back(make_pair(X,1));</span><br><span class="line">&#125;</span><br><span class="line">bfs(bfs(1));</span><br><span class="line">printf(&quot;%d\n&quot;,ans);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天主要讲了树的直径，是用bfs和dfs实现的，但是我的dfs，emm，一言难尽，所以我只用了bfs。
    
    </summary>
    
      <category term="Training" scheme="https://cndrew.cn/blog/categories/Training/"/>
    
    
      <category term="Algorithm" scheme="https://cndrew.cn/blog/tags/Algorithm/"/>
    
      <category term="HDU" scheme="https://cndrew.cn/blog/tags/HDU/"/>
    
      <category term="51nod" scheme="https://cndrew.cn/blog/tags/51nod/"/>
    
      <category term="poj" scheme="https://cndrew.cn/blog/tags/poj/"/>
    
      <category term="BFS" scheme="https://cndrew.cn/blog/tags/BFS/"/>
    
      <category term="树的直径" scheme="https://cndrew.cn/blog/tags/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"/>
    
  </entry>
  
</feed>
