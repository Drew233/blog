<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HPU Summer Day 20(河南理工大学暑期第二十天)]]></title>
    <url>%2Fblog%2F2019%2F08%2F05%2Fd20%2F</url>
    <content type="text"><![CDATA[今天讲了并查集和最小生成树。~狠心~望弟成龙的学长直接是给拉了两套题。。。做不完做不完，慢慢补咯 The SuspectsDescription:Severe acute respiratory syndrome (SARS), an atypical pneumonia of unknown aetiology, was recognized as a global threat in mid-March 2003. To minimize transmission to others, the best strategy is to separate the suspects from others.In the Not-Spreading-Your-Sickness University (NSYSU), there are many student groups. Students in the same group intercommunicate with each other frequently, and a student may join several groups. To prevent the possible transmissions of SARS, the NSYSU collects the member lists of all student groups, and makes the following rule in their standard operation procedure (SOP).Once a member in a group is a suspect, all members in the group are suspects.However, they find that it is not easy to identify all the suspects when a student is recognized as a suspect. Your job is to write a program which finds all the suspects.Input The input file contains several cases. Each test case begins with two integers n and m in a line, where n is the number of students, and m is the number of groups. You may assume that 0 &lt; n &lt;= 30000 and 0 &lt;= m &lt;= 500. Every student is numbered by a unique integer between 0 and n−1, and initially student 0 is recognized as a suspect in all the cases. This line is followed by m member lists of the groups, one line per group. Each line begins with an integer k by itself representing the number of members in the group. Following the number of members, there are k integers representing the students in this group. All the integers in a line are separated by at least one space.A case with n = 0 and m = 0 indicates the end of the input, and need not be processed. Output For each case, output the number of suspects in one line. Sample Input 100 42 1 25 10 13 11 12 142 0 12 99 2200 21 55 1 2 3 4 51 00 0 Sample Output 411 Problem solving:这道题的意思就是编号为0的学生是有病的，然后告诉你几个组，并且知道如果组里面有一个人是确定有病的，那个这一个组的人都是有病的，问你有病的总共有几个人。 题意理解了题就简单了，就是一个简单的并查集模板问题。但是为了保证你连接的时候用到的最大的那个节点是0，在join(合并函数)里面要加一个判断，保证每次选的最大的父节点是最小的，如果有的话，就可以保证是0了。最后输出父节点是0的个数即可。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int sijiaxiaozhu=3e4+10;int p[sijiaxiaozhu],n,m,k,mi,mii;int find(int x)&#123; return p[x]!=x?p[x]=find(p[x]):x;&#125;void join(int x,int y)&#123; x=find(x),y=find(y); if(x&lt;y) p[y]=x; else p[x]=y;&#125;int main()&#123; while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;m)) &#123; if(n==0&amp;&amp;m==0) break; for(int i=0;i&lt;n;i++) p[i]=i; for(int i=0;i&lt;m;i++) &#123; scanf(&quot;%d %d&quot;,&amp;k,&amp;mi); for(int i=0;i&lt;k-1;i++) &#123; cin&gt;&gt;mii; join(mi,mii); &#125; &#125; int ans=1; for(int i=1;i&lt;n;i++) &#123; find(i); // cout&lt;&lt;p[i]&lt;&lt;&quot; &quot;; if(p[i]==0) ans++; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125; 畅通工程Description:某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？Input 测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( &lt; 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。注意:两个城市之间可以有多条道路相通,也就是说3 31 21 22 1这种输入也是合法的当N为0时，输入结束，该用例不被处理。 Output 对每个测试用例，在1行里输出最少还需要建设的道路数目。 Sample Input 4 21 34 33 31 21 32 35 21 23 5999 00 Sample Output 102998 Huge input, scanf is recommended. Problem solving:题意就是告诉你村庄的个数以及哪些村庄之间是通路的。问你现在还需要修几条路才可以使每个村庄都可以连通，无论拐几个弯。 就是一个简单的并查集，有一点难的就是修几条路才可以使村庄全部连通。举个栗子，现在总共四个村庄，1,2是连通的，3,4是连通的。所以现在四个村庄总共被分成了2个部分，此时再多修一条路就可以全部连通了。所以所需修的路的个数就是分成的部分数-1.当一个节点的父节点就是他本身的时候说明这是一个区域。统计父节点与它本身相等的点的个数就是区域的个数。 Code:1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;const int sijiaxiaozhu=1e5;int p[sijiaxiaozhu];int find(int x)&#123; return p[x]!=x?p[x]=find(p[x]):x;&#125;void join(int x,int y)&#123; x=find(x),y=find(y); if(x!=y) p[x]=y;&#125;int main()&#123; int n,m,a,b; while(scanf(&quot;%d %d&quot;,&amp;n,&amp;m)&amp;&amp;n) &#123; int ans=0; for(int i=1;i&lt;=n;i++) p[i]=i; for(int i=0;i&lt;m;i++) &#123; cin&gt;&gt;a&gt;&gt;b; join(a,b); &#125; for(int i=1;i&lt;=n;i++) if(p[i]==i) ans++; cout&lt;&lt;ans-1&lt;&lt;endl; &#125;&#125; 还是畅通工程Description:某省调查乡村交通状况，得到的统计表中列出了任意两村庄间的距离。省政府“畅通工程”的目标是使全省任何两个村庄间都可以实现公路交通（但不一定有直接的公路相连，只要能间接通过公路可达即可），并要求铺设的公路总长度为最小。请计算最小的公路总长度。Input 测试输入包含若干测试用例。每个测试用例的第1行给出村庄数目N ( &lt; 100 )；随后的N(N-1)/2行对应村庄间的距离，每行给出一对正整数，分别是两个村庄的编号，以及此两村庄间的距离。为简单起见，村庄从1到N编号。当N为0时，输入结束，该用例不被处理。 Output 对每个测试用例，在1行里输出最小的公路总长度。 Sample Input 31 2 11 3 22 3 441 2 11 3 41 4 12 3 32 4 23 4 50 Sample Output 35 Huge input, scanf is recommended.Problem solving:题意就是给了你n个村庄，并且给了你N(N-1)/2条路。问你如果想让村庄之间互相连通所需要修的路的最短长度是多少。就是一个简单的最小生成树的模板题。用的Kruscal算法。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 10005;struct node&#123; int a,b,c;&#125;r[maxn];int p[maxn];bool cmp(node a,node b)&#123; return a.c&lt;b.c;&#125;int find(int x)&#123; return p[x]!=x?p[x]=find(p[x]):x;&#125;void join(int x,int y)&#123; x=find(x),y=find(y); if(x!=y) p[x]=y;&#125;int main()&#123; int n; while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n) &#123; int sum=0; for(int i=1;i&lt;=n;i++) p[i]=i; for(int i=0;i&lt;n*(n-1)/2;i++) scanf(&quot;%d %d %d&quot;,&amp;r[i].a,&amp;r[i].b,&amp;r[i].c); sort(r,r+n*(n-1)/2,cmp); for(int i=0;i&lt;n*(n-1)/2;i++) &#123; if(find(r[i].a)!=find(r[i].b)) &#123; sum+=r[i].c; join(r[i].a,r[i].b); &#125; &#125; cout&lt;&lt;sum&lt;&lt;endl; &#125;&#125; Ubiquitous ReligionsDescription:There are so many different religions in the world today that it is difficult to keep track of them all. You are interested in finding out how many different religions students in your university believe in. You know that there are n students in your university (0 &lt; n &lt;= 50000). It is infeasible for you to ask every student their religious beliefs. Furthermore, many students are not comfortable expressing their beliefs. One way to avoid these problems is to ask m (0 &lt;= m &lt;= n(n-1)/2) pairs of students and ask them whether they believe in the same religion (e.g. they may know if they both attend the same church). From this data, you may not know what each person believes in, but you can get an idea of the upper bound of how many different religions can be possibly represented on campus. You may assume that each student subscribes to at most one religion.Input The input consists of a number of cases. Each case starts with a line specifying the integers n and m. The next m lines each consists of two integers i and j, specifying that students i and j believe in the same religion. The students are numbered 1 to n. The end of input is specified by a line in which n = m = 0. Output For each test case, print on a single line the case number (starting with 1) followed by the maximum number of different religions that the students in the university believe in. Sample Input 10 91 21 31 41 51 61 71 81 91 1010 42 34 54 85 80 0 Sample Output Case 1: 1Case 2: 7 HintHuge input, scanf is recommended. Problem solving:题意就是n个学生，m个组，每个组两个人，两个人的宗教信仰是一样的，问你n个学生总共有多少个不同的宗教信仰。简单并查集模板题。 最后查找父节点就是他本身的个数就是答案。查找的时候别忘了find(i)因为你有可能遇见没有分组的时候对它find的情况，所以你需要在这里find一下避免出现这样的情况导致WA。 Code:1234567891011121314151617181920212223242526272829303132333435#include&lt;cstdio&gt;using namespace std;int n,m,a,b;const int sijiaxiaozhu=5e4+10;int p[sijiaxiaozhu];int find(int x)&#123; return p[x]!=x?p[x]=find(p[x]):x;&#125;void join(int x,int y)&#123; x=find(x),y=find(y); if(x!=y) p[x]=y;&#125;int main()&#123; int flag=1; while(scanf(&quot;%d %d&quot;,&amp;n,&amp;m)) &#123; if(n==0&amp;&amp;m==0) break; for(int i=1;i&lt;=n;i++) p[i]=i; for(int i=0;i&lt;m;i++) &#123; scanf(&quot;%d %d&quot;,&amp;a,&amp;b); join(a,b); &#125; int ans=0; for(int i=1;i&lt;=n;i++) &#123; find(i); if(p[i]==i) ans++; &#125; printf(&quot;Case %d: %d\n&quot;,flag++,ans); &#125;&#125; Cube StackingDescription:Farmer John and Betsy are playing a game with N (1 &lt;= N &lt;= 30,000)identical cubes labeled 1 through N. They start with N stacks, each containing a single cube. Farmer John asks Betsy to perform P (1&lt;= P &lt;= 100,000) operation. There are two types of operations:moves and counts. In a move operation, Farmer John asks Bessie to move the stack containing cube X on top of the stack containing cube Y. In a count operation, Farmer John asks Bessie to count the number of cubes on the stack with cube X that are under the cube X and report that value. Write a program that can verify the results of the game.Input Line 1: A single integer, P Lines 2..P+1: Each of these lines describes a legal operation. Line 2 describes the first operation, etc. Each line begins with a &#39;M&#39; for a move operation or a &#39;C&#39; for a count operation. For move operations, the line also contains two integers: X and Y.For count operations, the line also contains a single integer: X.Note that the value for N does not appear in the input file. No move operation will request a move a stack onto itself. Output Print the output from each of the count operations in the same order as the input file. Sample Input 6M 1 6C 1M 2 4M 2 6C 3C 4 Sample Output 102 Problem solving:题意就是会有n次操作，每次操作可能有两种情况，一种是M a b就是把第a列的所有方块放在b的上面。另一种就是C a，就是需要输出a下面有几个方块。 带权值的并查集。 这里我用了两个数组进行维护。ans[i]表示i下面方块的个数，now[i]表示i所处的当前列的方块个数。然后如果遇见M这个操作，就把now[a]全部加到now[b]上然后now[a]归零。并且此时ans[find(a)]应该加上now[find(b)].这就实现了把第a列的所有方块放在b上的操作了。 还有就是find函数的写法，在find的过程中，每次查找到的中间的节点的ans的值都应该加到查找开始的ans的值里面。这个不太好解释，也不太好想通。可以在脑子里过一下并查集的操作，并且结合着这道题的做法，好好想想为什么需要加上去。等我对这个的理解加深的时候再来补上自己成熟的理解。 下面这个图来解释一下这个样例 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int sijiaxiaozhu=31314;int p[sijiaxiaozhu],ans[sijiaxiaozhu],now[sijiaxiaozhu];int find(int x)&#123; if(p[x]==x) return p[x]; int mid=p[x]; p[x]=find(p[x]); ans[x]+=ans[mid]; return p[x];&#125;void join(int x,int y)&#123; int fx=find(x),fy=find(y); if(fx==fy) return ; p[fx]=fy; ans[fx]+=now[fy]; now[fy]+=now[fx]; now[fx]=0;&#125;int main()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=sijiaxiaozhu;i++) &#123; now[i]=1; p[i]=i; ans[i]=0; &#125; for(int i=0;i&lt;n;i++) &#123; char s; int a,b; cin&gt;&gt;s; if(s==&apos;M&apos;) &#123; scanf(&quot;%d %d&quot;,&amp;a,&amp;b); join(a,b); &#125; else &#123; scanf(&quot;%d&quot;,&amp;a); find(a); printf(&quot;%d\n&quot;,ans[a]); &#125; &#125;&#125; Dragon BallsDescription:Five hundred years later, the number of dragon balls will increase unexpectedly, so it&#39;s too difficult for Monkey King(WuKong) to gather all of the dragon balls together.His country has N cities and there are exactly N dragon balls in the world. At first, for the ith dragon ball, the sacred dragon will puts it in the ith city. Through long years, some cities&#39; dragon ball(s) would be transported to other cities. To save physical strength WuKong plans to take Flying Nimbus Cloud, a magical flying cloud to gather dragon balls.Every time WuKong will collect the information of one dragon ball, he will ask you the information of that ball. You must tell him which city the ball is located and how many dragon balls are there in that city, you also need to tell him how many times the ball has been transported so far.Input The first line of the input is a single positive integer T(0 &lt; T &lt;= 100).For each case, the first line contains two integers: N and Q (2 &lt; N &lt;= 10000 , 2 &lt; Q &lt;= 10000).Each of the following Q lines contains either a fact or a question as the follow format: T A B : All the dragon balls which are in the same city with A have been transported to the city the Bth ball in. You can assume that the two cities are different. Q A : WuKong want to know X (the id of the city Ath ball is in), Y (the count of balls in Xth city) and Z (the tranporting times of the Ath ball). (1 &lt;= A, B &lt;= N) Output For each test case, output the test case number formated as sample output. Then for each query, output a line with three integers X Y Z saparated by a blank space. Sample Input 23 3T 1 2T 3 2Q 23 4T 1 2Q 1T 1 3Q 1 Sample Output Case 1:2 3 0Case 2:2 2 13 3 2 Problem solving:这道题最毒瘤的地方绝对是题意。题目的意思大概就是有n个城市，初始的时候每个城市都有一个龙珠。现在给你输入几个操作，一种是move，一种是count。move后面有两个数，代表着把第一个数代表的城市的所有的龙珠转移到第二个数代表的城市里面。然后count i的时候需要输出3个数。第一个数代表的是编号为i的龙珠当前所在的城市，第二个数是编号为i的龙珠当前所在城市拥有的龙珠个数，第三个数代表的是编号为i的龙珠移动的次数。 这道题一看就是并查集的问题(如果今天专题不是并查集我可能也想不到)，但这个并不是简单普通的并查集。他要求我们输出的数需要一些巧妙地想法去记录一下。 我们这里用sum[i]来表示第i个城市当前所具有的龙珠个数，p[i]还是并查集里面的p[i]，刚开始的时候初始化每个点的父节点都是自己，每个城市具有的龙珠个数都是1. 在join(合并)的过程中注意，题目要求的是把x的龙珠全部放到y，所以sum[y]+=sum[x],sum[x]=0,这一步这样就挺好理解的了。 然后i所在的城市我们直接输出p[i]就行，i所在的城市的龙珠个数输出sum[i]就行。编号为i的龙珠的移动个数不太好求，那我们怎么求呢？ 我们想一下并查集的，就是有点类似于构建一个图的过程。那么每个龙珠移动的次数就正好是它的初始节点距离最大的那个父节点的距离。这道题里面正好每个龙珠的标号就是它的初始节点的编号，所以类似于find函数的查找再查找一遍就能找出它的移动次数了。 （还有一点坑了我就是，不要路径压缩。。。我记得板子是压缩了路径的，然后一直WA，一直WA。。。你需要一个查找距离的过程，如果路径压缩了，那每个移动距离都是1了，会破坏原本的构图。这毒瘤样例也没体现这个坑点。太坑了！！！ Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;const int sijiaxiaozhu = 1e5;int p[sijiaxiaozhu],sum[sijiaxiaozhu];int find(int x)&#123; return p[x]!=x?find(p[x]):x;&#125;int xiaozhu(int x)//这个就是那个查找移动次数的函数&#123; int ans=0; while(p[x]!=x)//其实跟并查集的find是差不多的的 &#123; x=p[x]; ans++;//没查找答案一次加一 &#125; return ans;&#125;void join(int x,int y)&#123; int fx=find(x),fy=find(y); if(fx!=fy) &#123; p[fx]=fy; sum[fy]+=sum[fx];//这个就是龙珠转移的过程 sum[fx]=0; &#125;&#125;int main()&#123; int t,nu=0; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; int n,m; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; p[i]=i;sum[i]=1; &#125; printf(&quot;Case %d:\n&quot;,++nu); while(m--) &#123; char s[2]; scanf(&quot;%s&quot;,s); if(s[0]==&apos;T&apos;) &#123; int a,b; scanf(&quot;%d %d&quot;,&amp;a,&amp;b); join(a,b); &#125; if(s[0]==&apos;Q&apos;) &#123; int a; scanf(&quot;%d&quot;,&amp;a); printf(&quot;%d %d %d\n&quot;,find(a),sum[find(a)],xiaozhu(a)); &#125; &#125; &#125;&#125; 这个好像是叫带权并查集吧，挺难理解的。但是只要想做，就没有做不出来的题！ Zjnu StadiumDescription:In 12th Zhejiang College Students Games 2007, there was a new stadium built in Zhejiang Normal University. It was a modern stadium which could hold thousands of people. The audience Seats made a circle. The total number of columns were 300 numbered 1--300, counted clockwise, we assume the number of rows were infinite.These days, Busoniya want to hold a large-scale theatrical performance in this stadium. There will be N people go there numbered 1--N. Busoniya has Reserved several seats. To make it funny, he makes M requests for these seats: A B X, which means people numbered B must seat clockwise X distance from people numbered A. For example: A is in column 4th and X is 2, then B must in column 6th (6=4+2).Now your task is to judge weather the request is correct or not. The rule of your judgement is easy: when a new request has conflicts against the foregoing ones then we define it as incorrect, otherwise it is correct. Please find out all the incorrect requests and count them as R.Input There are many test cases:For every case:The first line has two integer N(1&lt;=N&lt;=50,000), M(0&lt;=M&lt;=100,000),separated by a space.Then M lines follow, each line has 3 integer A(1&lt;=A&lt;=N), B(1&lt;=B&lt;=N), X(0&lt;=X\&lt;300) (A!=B), separated by a space. Output For every case:Output R, represents the number of incorrect request. Sample Input 10 101 2 1503 4 2001 5 2702 6 2006 5 804 7 1508 9 1004 8 501 7 1009 2 100 Sample Output 2 HintHint:（PS： the 5th and 10th requests are incorrect） Problem solving:也是一道带权并查集的题，但是我不会。。。代码先贴上来啦，以后再补题解。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;const int sijia=52113;int f[sijia],sijiaxiaozhu[sijia],n,m;int find(int x)&#123; if(x==f[x]) return f[x]; int t=f[x]; f[x]=find(f[x]); sijiaxiaozhu[x] += sijiaxiaozhu[t]; return f[x];&#125;bool Union(int x,int y,int m)&#123; int a=find(x),b=find(y); if(a==b) &#123; if(sijiaxiaozhu[x]+m!=sijiaxiaozhu[y]) return 0; return 1; &#125; f[b]=a; sijiaxiaozhu[b]=sijiaxiaozhu[x]+m-sijiaxiaozhu[y]; return 1;&#125;int main()&#123; int a,b,x; while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;m)) &#123; for(int i=0;i&lt;=n;i++) f[i]=i,sijiaxiaozhu[i]=0; int cnt=0; for(int i=0;i&lt;m;i++) &#123; scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;x); if(!Union(a,b,x)) cnt++; &#125; printf(&quot;%d\n&quot;,cnt); &#125;&#125; How Many TablesDescription:Today is Ignatius&#39; birthday. He invites a lot of friends. Now it&#39;s dinner time. Ignatius wants to know how many tables he needs at least. You have to notice that not all the friends know each other, and all the friends do not want to stay with strangers. One important rule for this problem is that if I tell you A knows B, and B knows C, that means A, B, C know each other, so they can stay in one table. For example: If I tell you A knows B, B knows C, and D knows E, so A, B, C can stay in one table, and D, E have to stay in the other one. So Ignatius needs 2 tables at least.Input The input starts with an integer T(1&lt;=T&lt;=25) which indicate the number of test cases. Then T test cases follow. Each test case starts with two integers N and M(1&lt;=N,M&lt;=1000). N indicates the number of friends, the friends are marked from 1 to N. Then M lines follow. Each line consists of two integers A and B(A!=B), that means friend A and friend B know each other. There will be a blank line between two cases. Output For each test case, just output how many tables Ignatius needs at least. Do NOT print any blanks. Sample Input 25 31 22 34 55 12 5 Sample Output 24 Problem solving:题意我也懒得分析了，就是一个简单并查集，套板子就行了。 Code:12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;const int sijiaxiaozhu=1e4;int p[sijiaxiaozhu];int find(int x)&#123; return p[x]!=x?p[x]=find(p[x]):x;&#125;void join(int x,int y)&#123; x=find(x),y=find(y); if(x!=y) p[x]=y;&#125;int main()&#123; int t,n,m,a,b; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; int ans=0; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) p[i]=i; for(int i=0;i&lt;m;i++) &#123; scanf(&quot;%d %d&quot;,&amp;a,&amp;b); join(a,b); &#125; for(int i=1;i&lt;=n;i++) &#123; if(p[i]==i) ans++; &#125; printf(&quot;%d\n&quot;,ans); &#125;&#125; HighwaysNetworkingHighwaysAgri-NetJungle RoadsTruck History畅通工程再续Constructing Roads]]></content>
      <categories>
        <category>Training</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>c/c++</tag>
        <tag>并查集</tag>
        <tag>kruscal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HPU Summer Day 19(河南理工大学暑期第十九天)]]></title>
    <url>%2Fblog%2F2019%2F08%2F04%2Fd19%2F</url>
    <content type="text"><![CDATA[今天是休息的一天。早上五点左右醒来。癔症一会发现睡不着了，六点开始玩手机，玩到七点。到了七点，开始了今天最重要的一件事，给我的图片换一下外链。之前所有的外链都是通过sm.ms弄得，也不能说它不好，就是时间久了的图片加载会很慢很慢，进而拖慢我整个博客的速度。前几天从学长那白嫖了了一个备案过的域名。有时会到了七牛云作图床的时代。不过人家七牛云是真的快。 换外链换到十一点多，出去吃了个饭直接去机房了。在机房水题水到两点做不下去了就去打了会球，打球回来四点多。 然后就开始了今天第二重要的事，做一个相册。之前做过，但是因为访问速度直接是弃用了，现在用的这个七牛云可以说是很舒服了。在网上找了个模板，套了一下，就到八点了。想看我得新相册?我帅不帅？一般帅 帅的惊天动地 帅的无法形容 选对了就能进哦 我的假期就这样没了，没了。]]></content>
      <categories>
        <category>Training</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HPU Summer Day 18(河南理工大学暑期第十八天)]]></title>
    <url>%2Fblog%2F2019%2F08%2F03%2Fd18%2F</url>
    <content type="text"><![CDATA[一转眼已经第18天了啊。今天又是一场积分赛，虽然知道了明天要休息一天了，刚刚结束比赛的我现在心里还是高兴不起来。一开始心态就崩了，第一题看不懂，第二题看不懂，第三题太麻烦，第四题，不会，第五题，哦哦，可算是看到个能看懂的题了，这一看就是个规律题啊，盘它。然后WA了，看看榜，一堆人都做出来了第一题。可我还是题都看不懂，emm然后就这个碎了一地的心态做完了整场比赛，有一道感觉可以搞出来的没搞出来，还是很亏的。今天了解到一个贼逗比的~学姐~小猪。靠它保佑也过了不少题哈哈哈哈。明天放假。~high起来~其实我准备把博客所有图片放在七牛云上，应该能提速不少。说到这里还是要谢谢学长的，帮我搞了一个备案的域名，谢谢谢谢。]]></content>
      <categories>
        <category>Training</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[河南理工大学算法协会暑期集训积分赛（三）]]></title>
    <url>%2Fblog%2F2019%2F08%2F03%2Fjifen3%2F</url>
    <content type="text"><![CDATA[今天如期举行了第三场积分赛，没啥好说的，还是那句话积分赛，被打爆的积分赛(music 蚂蚁觅食（一）Description:一只饥饿的小蚂蚁外出觅食，幸运的小蚂蚁发现了好多食物，但是它只有一次搬食物的机会。可因为力气太小了，它不能搬走重量超过自己体重的食物,且只能搬走位置相邻的两个食物，或者只搬走其中一个。食物的位置不会改变。这可难住了这只蚂蚁，它不知道它最多能搬走多重的食物。请帮小蚂蚁计算。 输入格式 第一行一个正整数n，(n&gt;=0并且n&lt;=1000)第二行n个正整数 A[1].....A[n]，A[i] 表示在第i 个位置上食物的重量。A[i]&lt;=1e9.第三行一个正整数m，表示蚂蚁的体重。(m&lt;=1e9). 输出格式 一个整数表示小蚂蚁能带走的食物的重量。 样例input 31 3 34 output 4 Problem solving:神TM签到题，愣是没看懂是啥意思。。。最后看懂了，就是找一个跟m尽量接近的一个数或者相邻两个数的和尽量接近m的。我是把每个数和相邻的数的和存进一个数组然后O(N)查找找到输出就行 Code:12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2005;long long a[maxn],m;int main()&#123; int n,ans=0; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; for(int i=n;i&lt;2*n-1;i++) a[i]=a[i-n]+a[i-n+1]; sort(a,a+2*n-1); cin&gt;&gt;m; for(int i=0;i&lt;2*n-1;i++) &#123; if(a[i]&gt;m) break; ans=a[i]; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125; ###Description:一只饥饿的小蚂蚁外出觅食，幸运的的小蚂蚁发现了好多食物。但是这些食物位于一个N∗M的方格魔法阵的右下角，而小蚂蚁位于方格法阵的左上角。并且小蚂蚁被施展了魔法，它只能向下或者向右走。请你帮助小蚂蚁计算一下，它一共有多少条路可以走到有食物的方格。 输入格式 多组输入，每一组两个正整数N， M （N,M≤30）。表示一个方格魔法阵。 输出格式 一个整数表示一共有多少条路。 样例input 2 3 output 3 Problem solving:这道题据说可以用排列数做（高中知识。）倒是我哪会高中知识啊，就推呗。然后找到了递推式，我们用dp[x][y]来表示（x，y）位置到终点有几条路。那么可以得到dp[x][y]=dp[i-1][j]+dp[i][j-1]边界条件是，当x或者y等于1的时候只有一条路，因为只能往右或者往下走。推理过程：首先看一下图吧假设我们现在要求(4,3)这个位置到终点(1,1)的路径条数，从(4,3)走出来只有两种选择，向右或者向下，所以我们走到了(4,2),(3,3),这时我们只需要求(4,2)(3,3)到终点的路径条数然后求和就行了。以此类推，就可以得到上面的递推式了。 然后就是注意这个是多组输入。。！！！Code:1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ll;ll ans[32][32];int main()&#123; for(int i=1;i&lt;=31;i++) &#123; for(int j=1;j&lt;=31;j++) &#123; if(i==1||j==1) ans[i][j]=1; else ans[i][j]=ans[i-1][j]+ans[i][j-1]; &#125; &#125; ll n,m; while(cin&gt;&gt;n&gt;&gt;m) &#123; cout&lt;&lt;ans[n][m]&lt;&lt;endl; &#125;&#125; 蚂蚁觅食（三）Description:马上就要冬天了，勤劳的小蚂蚁需要储存足够多的食物才能安全过冬。今天，这只小蚂蚁走出巢穴寻找食物，但是这次蚁巢周围只有很少的食物，它需要去别的地方。不幸的是小蚂蚁的体力很有限，而且每走一个单位长度就要消耗一点体力，不能找的时间太久，所以想让你帮忙计算一下它是否能用剩下的体力把足够多的食物搬回蚁巢。由于蚂蚁的嘴太小，每次最多只能衔起一个食物。 输入格式 输入t组, t≤20第一行三个数n,E,V表示食物的个数，蚂蚁剩余的体力，安全过冬需要的最少食物体积, 0&lt;n≤100,0&lt;E,V≤10000。接下来n行，每行两个数pi,vi,表示第i个食物的位置和体积,0&lt;p[i],v[i]≤1000。初始蚂蚁和蚁巢均在坐标轴原点。 输出格式 每个输出占一行。如果蚂蚁能安全过冬，输出 “YES”,否则输出”NO”。 样例input 21 2 21 21 2 22 1 output YESNO Problem solving:一道简单的01背包题，背包容量是蚂蚁当前剩余的体力值。每个物品的价值就是食物的体积，所占的背包容量的大小就是距离乘2（因为还要回来）。然后比较最多能达到的食物体积，与需要的最少的食物体积进行标比较就行了。01背包的部分套板子写的Code:1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;int n,e,v;const int maxn=100005;int si[maxn],jia[maxn],dp[100005];using namespace std;int main()&#123; int t; cin&gt;&gt;t; while(t--) &#123; memset(dp,0,sizeof(dp)); cin&gt;&gt;n&gt;&gt;e&gt;&gt;v; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;si[i]&gt;&gt;jia[i]; si[i]*=2; &#125; for(int i=0;i&lt;n;i++) &#123; for(int j=e;j&gt;=si[i];j--) &#123; dp[j]=max(dp[j],dp[j-si[i]]+jia[i]); &#125; &#125; if(dp[e]&gt;=v) puts(&quot;YES&quot;); else puts(&quot;NO&quot;); &#125;&#125; 蚂蚁平面Description:平面上有 n只蚂蚁，它走过的路径可以看作一条直线 由这n 条直线定义的某些区域是无界的，而另一些区域则是有界的。 有界区域的最大个数是多少？ 比如现在有4条直线，只有下面最左边的图中直线定义的有界区域是最多的 输入格式 T 组输入, (1≤T≤100)每组一个数 n ，(1≤n≤109) 输出格式 对于每组数据，输出一个整数表示有界区域的最大个数。 样例 input 14 output 3 Problem solving:这道题就是一个公式，n条线能组成的有界区域的最大个数是从1加到n。比赛时候谁知道这是公式啊，画图画到5条线的时候发现的规律写了一遍交了，嘿，还真过了。佩服用矩快的同学，我是真的不知道咋构建矩阵。Code:123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; ll n,t; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n; ll ans; ans=(n-1)*(n-2)/2; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125; 蚂蚁和斐波那契Description:聪明的小蚂蚁最近学习了斐波那契数列,但是它想到了一个问题：从L到R之间斐波那契数列和的奇偶是什么呢？其中Fib[1]=1,Fib[2]=1 . 输入格式 单组输入:每组输入两个以空格隔开的数字 L 和 R其中 (0&lt;L&lt;=R&lt;1e18) 输出格式 从 L 到 R 斐波那契数列和的奇偶，如果是奇数输出 &quot;1&quot; (不带引号) ，否则输出 &quot;0&quot; (不带引号) 样例input 1 2 output 0 Problem solving:这道题就是个找规律的题没啥好说的，看代码自行体会吧。（我可能写的麻烦了） Code:12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll ans[55];int main()&#123; ll mid,miid,l,r; cin&gt;&gt;l&gt;&gt;r; mid=l%3,miid=r%3; if(mid==0&amp;&amp;miid==0) puts(&quot;0&quot;); else if(mid==miid) puts(&quot;1&quot;); else if(mid==0&amp;&amp;miid==1) puts(&quot;1&quot;); else if(mid==0&amp;&amp;miid==2) puts(&quot;0&quot;); else if(mid==1&amp;&amp;miid==0) puts(&quot;0&quot;); else if(mid==2&amp;&amp;miid==0) puts(&quot;1&quot;); else if(mid==2&amp;&amp;miid==1) puts(&quot;0&quot;); else if(mid==1&amp;&amp;miid==2) puts(&quot;0&quot;); return 0;&#125; 蚂蚁装修Description:还有一个月就开学了，爱学习的小蚂蚁想庆祝一下！于是它要把它的“家”装修一下。首先要做的就是贴地板。小蚂蚁“家”的地面可以看成一个2∗N 的方格 ，它拥有无数块1∗2 和 2∗1的地板。请你帮下蚂蚁计算一下一共有多少种方法能把地面给放满 。地板不能切割，也不能重叠。 输入格式 单组输入：只有一个数字 N其中 (0&lt;N&lt;1e18) 输出格式 输出放法数对1e9+7取模的结果 样例input 2 output 2 input 1 output 1 Problem solving:手动画了几个状态，发现这个个数就是斐波那契数列，但是要求的最大的是1e18项，所以正好可以用矩快解决。注意用long long Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;const int mod=1e9+7;typedef long long ll;struct node&#123; ll m[2][2];&#125;;node mul(node a,node b)&#123; node ans; memset(ans.m,0,sizeof(ans.m)); for(ll i=0;i&lt;2;i++) &#123; for(ll j=0;j&lt;2;j++) &#123; for(ll k=0;k&lt;2;k++) &#123; ans.m[i][j]=(ans.m[i][j]+a.m[i][k]*b.m[k][j])%mod; &#125; &#125; &#125; return ans;&#125;node poww(node a,ll b)&#123; node ans; memset(ans.m,0,sizeof(ans.m)); for(ll i=0;i&lt;2;i++) ans.m[i][i]=1; while(b) &#123; if(b&amp;1) ans=mul(ans,a); a=mul(a,a); b/=2; &#125; return ans;&#125;node si,jia;int main()&#123; si.m[0][0]=2,si.m[1][0]=1,si.m[0][1]=0,si.m[1][1]=0; jia.m[0][0]=1,jia.m[1][0]=1,jia.m[0][1]=1,jia.m[1][1]=0; ll n; cin&gt;&gt;n; if(n==1) &#123; cout&lt;&lt;1%mod&lt;&lt;endl;return 0; &#125; if(n==2) &#123; cout&lt;&lt;2%mod&lt;&lt;endl;return 0; &#125; node xiaozhu=poww(jia,n-2); xiaozhu=mul(xiaozhu,si); cout&lt;&lt;xiaozhu.m[0][0]&lt;&lt;endl;&#125; 蚂蚁的镜像串Description: Problem solving:这道题，，是真的坑啊。把可以组成镜像串的字母列出来，判断每一个字符，如果出现了不可以组成镜像串的直接就不是镜像串了。如果你也是这样想的这么单纯，恭喜你你会WA很多次。WA到怀疑人生那种。因为bdpq他们也是可以组成镜像串的。知道了这一点就可以很简单的解决这个问题了 Code:1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int t; string s; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;s; int flag=1; string mid=s; reverse(mid.begin(),mid.end()); for(int i=0;i&lt;s.size();i++) &#123; if((s[i]==&apos;b&apos;&amp;&amp;mid[i]==&apos;d&apos;)||(s[i]==&apos;d&apos;&amp;&amp;mid[i]==&apos;b&apos;)||(s[i]==&apos;p&apos;&amp;&amp;mid[i]==&apos;q&apos;)||(s[i]==&apos;q&apos;&amp;&amp;mid[i]==&apos;p&apos;)||(s[i]==mid[i]&amp;&amp;(s[i]==&apos;A&apos;||s[i]==&apos;H&apos;||s[i]==&apos;I&apos;||s[i]==&apos;i&apos;||s[i]==&apos;l&apos;||s[i]==&apos;M&apos;||s[i]==&apos;m&apos;||s[i]==&apos;n&apos;||s[i]==&apos;O&apos;||s[i]==&apos;o&apos;||s[i]==&apos;T&apos;||s[i]==&apos;U&apos;||s[i]==&apos;u&apos;||s[i]==&apos;V&apos;||s[i]==&apos;v&apos;||s[i]==&apos;W&apos;||s[i]==&apos;w&apos;||s[i]==&apos;X&apos;||s[i]==&apos;x&apos;||s[i]==&apos;Y&apos;))) &#123; continue; &#125; else &#123; flag=0; break; &#125; &#125; if(flag==1) puts(&quot;YES&quot;); else puts(&quot;NO&quot;); &#125;&#125; 蚂蚁赛跑Description:小白和小黑非常喜欢养蚂蚁，他们每个人都养了n只蚂蚁。有一天，他们想比一比谁养蚂蚁的本领更强，于是就举办了一场蚂蚁赛跑比赛。假设蚂蚁都是匀速直线奔跑。比赛的规则是这样的：每只蚂蚁必须且最多比一场，赢一场得10分，输一场扣10分。平局都不得分也不扣分。狡猾的小黑同学为了赢得比赛，提前偷到了小白所有蚂蚁得速度，请你帮小黑算一算，他在比赛中最多得多少分。 输入格式 有多组测试案例，最多有100组，对于每一组案例：第一行以正整数n ,（n≤1000），即每个人的蚂蚁数量。第二行的n个整数是小黑的蚂蚁的速度。第三行的n整数是小白的蚂蚁速度。蚂蚁的速度小于100 输出格式 对于每个输入案例，输出一个整数，这是小黑能够获得的最大分数。 样例input 210 1010 10210 1100 8 output 00 Problem solving:贪心，但是我们贪出来，等到我够贪心了再补上 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * ┏┓ ┏┓ * ┏┛┗━━━━━━━┛┗━━━┓ * ┃ ┃ * ┃ ━ ┃ * ┃ ＞ ＜ ┃ * ┃ ┃ * ┃... ⌒ ... ┃ * ┃ ┃ * ┗━┓ ┏━┛ * ┃ ┃ Code is far away from bug with the animal protecting * ┃ ┃ 神兽保佑,代码无bug * ┃ ┃ * ┃ ┃ * ┃ ┃ * ┃ ┃ * ┃ ┗━━━┓ * ┃ ┣┓ * ┃ ┏┛ * ┗┓┓┏━┳┓┏┛ * ┃┫┫ ┃┫┫ * ┗┻┛ ┗┻┛ */// warm heart, wagging tail,and a smile just for you!//// _ooOoo_// o8888888o// 88&quot; . &quot;88// (| -_- |)// O\ = /O// ____/`---&apos;\____// .&apos; \| |// `.// / \||| : |||// \// / _||||| -:- |||||- \// | | \\ - /// | |// | \_| &apos;&apos;\---/&apos;&apos; | |// \ .-\__ `-` ___/-. /// ___`. .&apos; /--.--\ `. . __// .&quot;&quot; &apos;&lt; `.___\_&lt;|&gt;_/___.&apos; &gt;&apos;&quot;&quot;.// | | : `- \`.;`\ _ /`;.`/ - ` : | |// \ \ `-. \_ __\ /__ _/ .-` / /// ======`-.____`-.___\_____/___.-`____.-&apos;======// `=---=&apos;// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^// 蚂蚁上树Description:蚂蚁上树（Sauteed Vermicelli with minced Pork），又名肉末粉条，是四川省及重庆市的特色传统名菜之一。因肉末贴在粉丝上，形似蚂蚁爬在树枝上而得名。这道菜具体的历史，已不可考。但在四川省、重庆市一带，该菜很常见。 蚂蚁上树通常由粉丝（或者粉条）、肉末为主料，辅以胡萝卜、姜、葱、豆瓣酱等辅料制作而成。成菜后，口味清淡，爽滑美味，色泽红亮，食之别有风味。 蚂蚁想知道这棵树上距离最远的两个点之间的距离 给你一个具有 n 个节点的树 求这棵树上距离最远的两个点之间的距离 输入格式 第一行一个整数 n ，(1≤n≤1e4)接下来 n−1 行，每行三个整数 x,y,z 表示 x 与 y 之间有一条长度为 z 的边 (1≤x,y≤n,1≤z≤104) 输出格式 一个整数表示树上距离最远的两个点之间的距离 样例input 51 2 91 3 31 5 22 4 10 output 22 Problem solving:求树的直径，套班子就行啦，别忘了long long Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=1e4+10;ll n,x,y,z,dis[maxn],vis[maxn];vector&lt;pair&lt;int,int&gt; &gt; v[maxn];void bfs(ll x)&#123; queue&lt;int&gt; q; q.push(x); vis[x]=1; dis[x]=0; while(!q.empty()) &#123; x=q.front(); q.pop(); for(int i=0;i&lt;v[x].size();i++) &#123; if(!vis[v[x][i].first]) &#123; q.push(v[x][i].first); dis[v[x][i].first]=dis[x]+v[x][i].second; vis[v[x][i].first]=1; &#125; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n; for(int i=0;i&lt;n-1;i++) &#123; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; v[x].push_back(make_pair(y,z)); v[y].push_back(make_pair(x,z)); &#125; bfs(1); ll si=0,jia,ans=0; for(int i=1;i&lt;=n;i++) &#123; if(dis[i]&gt;si) &#123; si=dis[i]; jia=i; &#125; &#125; memset(vis,0,sizeof(vis)); memset(dis,0,sizeof(dis)); bfs(jia); for(int i=1;i&lt;=n;i++) &#123; ans=max(ans,dis[i]); &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125; 蚂蚁的游戏Description:蚂蚁Bob和蚂蚁Alice是青梅竹蚁，Alice喜欢和Bob一起玩游戏，每当Alice想到新的游戏，都会找Bob一起玩 今天Alice的游戏是这样的： n堆石子，两人轮流取。每次只能在1堆中取，不能不取，最先取完石子者胜 Alice先取石子，Alice和Bob都非常聪明，拿石子的过程中不会出现失误。 输入格式 第一行有一个整数T，有T组输入数据(T≤50)每组第一行有一个数n表示有n堆石子，(1≤n≤20000)第二行有n个非零整数x，表示每堆石子的数量(x≤1e3) 输出格式 请你判断Alice能否在游戏中获胜，如果不能获胜，输出NO。否则，输出YES，并输出第一次取石子的所有方法（具体参见样例和提示） 样例input 2245 4555 7 8 9 10 output NOYES3 14 05 3 提示对于第一组样例，不论Alice怎么取，Bob总能拿到最后一个石子，所以输出为NO 对于第二组样例，Alice可以第一次取石子有三种取法： 第3堆取出7个，剩下1个第4堆全部取出，剩下0个第5堆取出7个，剩下3个对于每组输出，总是按照堆的编号顺序输出的Problem solving:博弈论的问题，好像有板子可以套，但是我并不会。学会了再补吧 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * ┏┓ ┏┓ * ┏┛┗━━━━━━━┛┗━━━┓ * ┃ ┃ * ┃ ━ ┃ * ┃ ＞ ＜ ┃ * ┃ ┃ * ┃... ⌒ ... ┃ * ┃ ┃ * ┗━┓ ┏━┛ * ┃ ┃ Code is far away from bug with the animal protecting * ┃ ┃ 神兽保佑,代码无bug * ┃ ┃ * ┃ ┃ * ┃ ┃ * ┃ ┃ * ┃ ┗━━━┓ * ┃ ┣┓ * ┃ ┏┛ * ┗┓┓┏━┳┓┏┛ * ┃┫┫ ┃┫┫ * ┗┻┛ ┗┻┛ */// warm heart, wagging tail,and a smile just for you!//// _ooOoo_// o8888888o// 88&quot; . &quot;88// (| -_- |)// O\ = /O// ____/`---&apos;\____// .&apos; \| |// `.// / \||| : |||// \// / _||||| -:- |||||- \// | | \\ - /// | |// | \_| &apos;&apos;\---/&apos;&apos; | |// \ .-\__ `-` ___/-. /// ___`. .&apos; /--.--\ `. . __// .&quot;&quot; &apos;&lt; `.___\_&lt;|&gt;_/___.&apos; &gt;&apos;&quot;&quot;.// | | : `- \`.;`\ _ /`;.`/ - ` : | |// \ \ `-. \_ __\ /__ _/ .-` / /// ======`-.____`-.___\_____/___.-`____.-&apos;======// `=---=&apos;// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^//]]></content>
      <categories>
        <category>Training</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>c/c++</tag>
        <tag>Greedy</tag>
        <tag>HPUOJ</tag>
        <tag>Thinking</tag>
        <tag>BFS</tag>
        <tag>矩阵快速幂</tag>
        <tag>树的直径</tag>
        <tag>dp</tag>
        <tag>背包</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HPU Summer Day 17(河南理工大学暑期第十七天)]]></title>
    <url>%2Fblog%2F2019%2F08%2F02%2Fd17%2F</url>
    <content type="text"><![CDATA[今天学长没拉题，给了我充足的时间搞了我一直想搞的东西——给自己做一个专属的头像。当然还是刷了大半天的题的，虽然一道没过。我喜欢欧文，喜欢德鲁大叔。也忘了这张图是在哪找到的，但是这也太和我胃口了。主体上是德鲁大叔的动漫头像，右手拿着个篮球，右手拿着个地球仪，这个地球仪说法可厉害了。当时欧文在接受采访时说道：我相信地球是平的。这就是欧文的“地平说”。把欧文的最耀眼的三个元素糅合在了一张图我是真的喜欢的没话说。以后怕是不会换头像了。好看是好看，但毕竟是网上下载的，所以可能会有很多人跟我用一样的头像（虽然现在还没遇见。然后我正好有时间，就给他P一下吧P完之后的我的头像第一步我在它衣服的左侧添加了一个ICPC的logo，表明了我~JBer~ACMer的身份。然后你仔细看会发现右下角有一个若隐若现的德鲁大叔妆容二号骑士球衣的欧文扭头在看着你（不仔细看是看不见的）。我最喜欢的就是欧文在骑士的时候。所以这个设计我也是很满意。最后我在左下角加了@cndrew宣告一下主权，哈哈这就结束了。我在ps的时候也是一步一百度，也是学到了不少东西。这次接触ps，让我对ps产生了浓厚的兴趣，以后还会深入学习的。]]></content>
      <categories>
        <category>Training</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>Photoshop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HPU Summer Day 16(河南理工大学暑期第十六天)]]></title>
    <url>%2Fblog%2F2019%2F08%2F01%2Fd16%2F</url>
    <content type="text"><![CDATA[今天主要学习了矩阵快速幂的计算以及相关问题的解决方法。题还是挺好写的，矩阵快速幂也挺好理解的，实在不行的话记模板也不错。 求递推序列的第N项Description:有一个序列是这样定义的：f(1) = 1, f(2) = 1, f(n) = (A * f(n - 1) + B * f(n - 2)) mod 7.给出A，B和N，求f(n)的值。输入 输入3个数：A,B,N。数字之间用空格分割。(-10000 &lt;= A, B &lt;= 10000, 1 &lt;= N &lt;= 10^9) 输出 输出f(n)的值。 输入样例 3 -1 5 输出样例 6 Problem solving:这道题的意思是给你一个递推公式，求出第n项的值。 如果直接递推的话，1e9的n一定是会超时的。这时候矩阵快速幂大显身手。只需要构造出来两个矩阵就行，板子题。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;struct node&#123; int m[5][5];&#125;;node mm,p;node mul(node a,node b)&#123; node now; memset(now.m,0,sizeof(now.m)); for(int i=1;i&lt;=2;i++) &#123; for(int j=1;j&lt;=2;j++) &#123; for(int k=1;k&lt;=2;k++) &#123; now.m[i][j]=((now.m[i][j]+a.m[i][k]*b.m[k][j])+7)%7; &#125; &#125; &#125; return now;&#125;node poww(node a,int b)&#123; node ans; memset(ans.m,0,sizeof(ans.m)); for(int i=1;i&lt;=2;i++) ans.m[i][i]=1; while(b) &#123; if(b&amp;1) ans=mul(ans,a); b/=2; a=mul(a,a); &#125; return ans;&#125;int main()&#123; int a,b,k; cin&gt;&gt;a&gt;&gt;b&gt;&gt;k; mm.m[1][1]=1,mm.m[2][1]=1; mm.m[2][2]=0,mm.m[1][2]=0;//构造的一个矩阵 p.m[1][1]=a,p.m[1][2]=b,p.m[2][1]=1,p.m[2][2]=0;//构造的另一个矩阵 if(k==1||k==2) &#123; puts(&quot;1&quot;); &#125; else &#123; node mid=poww(p,k-2); mid=mul(mid,mm); cout&lt;&lt;mid.m[1][1]&lt;&lt;endl; &#125;&#125; 矩阵快速幂Description:给出一个N * N的矩阵，其中的元素均为正整数。求这个矩阵的M次方。由于M次方的计算结果太大，只需要输出每个元素Mod (10^9 + 7）的结果。 输入 第1行：2个数N和M，中间用空格分隔。N为矩阵的大小，M为M次方。(2 &lt;= N &lt;= 100, 1 &lt;= M &lt;= 10^9)第2 - N + 1行：每行N个数，对应N * N矩阵中的1行。(0 &lt;= N[i] &lt;= 10^9) 输出 共N行，每行N个数，对应M次方Mod (10^9 + 7)的结果。 输入样例 2 31 11 1 输出样例 4 44 4 Problem solving:这个就是个板子题，直接写就行了。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e9+7;typedef long long ll;struct node&#123; ll m[105][105];&#125;;ll n,k;node mul(node a,node b)&#123; node ans; memset(ans.m,0,sizeof(ans.m)); for(ll i=0;i&lt;n;i++) &#123; for(ll j=0;j&lt;n;j++) &#123; for(ll k=0;k&lt;n;k++) &#123; ans.m[i][j]=(ans.m[i][j]+a.m[i][k]*b.m[k][j])%maxn;//这里已经要先+再取模。坑点 &#125; &#125; &#125; return ans;&#125;node poww(node a,ll b)&#123; node now; memset(now.m,0,sizeof(now.m)); for(ll i=0;i&lt;n;i++) now.m[i][i]=1; while(b) &#123; if(b&amp;1) now=mul(now,a); b/=2; a=mul(a,a); &#125; return now;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;k; node ans; for(ll i=0;i&lt;n;i++) for(ll j=0;j&lt;n;j++) cin&gt;&gt;ans.m[i][j]; ans=poww(ans,k); for(ll i=0;i&lt;n;i++) &#123; for(ll j=0;j&lt;n;j++) cout&lt;&lt;ans.m[i][j]&lt;&lt;&quot; &quot;; puts(&quot;&quot;); &#125;&#125; 矩阵乘法Description:给出2个N * N的矩阵M1和M2，输出2个矩阵相乘后的结果。输入 第1行：1个数N，表示矩阵的大小(2 &lt;= N &lt;= 100)第2 - N + 1行，每行N个数，对应M1的1行(0 &lt;= M1[i] &lt;= 1000)第N + 2 - 2N + 1行，每行N个数，对应M2的1行(0 &lt;= M2[i] &lt;= 1000) 输出 输出共N行，每行N个数，对应M1 * M2的结果的一行。 输入样例 21 00 10 11 0 输出样例 0 11 0 Problem solving:考察了矩阵相乘的实现Code:12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;struct node&#123; int m[105][105];&#125;;node a,b;int n;node mul(node a,node b)&#123; node ans; memset(ans.m,0,sizeof(ans.m)); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) for(int k=0;k&lt;n;k++) ans.m[i][j]=ans.m[i][j]+a.m[i][k]*b.m[k][j];//矩阵相乘就是通过这三个for循环实现的 return ans;&#125;int main()&#123; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) cin&gt;&gt;a.m[i][j]; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) cin&gt;&gt;b.m[i][j]; node ans=mul(a,b); for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;n;j++) cout&lt;&lt;ans.m[i][j]&lt;&lt;&quot; &quot;; puts(&quot;&quot;); &#125;&#125; FibonacciDescription:菲波那契数列是指这样的数列: 数列的第一个是0和第二个数是1，接下来每个数都等于前面2个数之和。 给出一个正整数a，要求菲波那契数列中第a个数的后四位是多少。Input 多组数据 -1结束 范围1~10^9 Output 第x项的后4位 Sample Input 099999999991000000000-1 Sample Output 0346266875 Problem solving:然后毒瘤题意还是忽略了吧，直接看样例妥了求斐波那契的第n项。其实就是给了你递推式，构造出来矩阵就行了。要求输出后四位其实就是对10000取模，每次计算出来都取模，就避免了爆精度的问题。Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int mod=10000;struct node&#123; int m[3][3];&#125;;typedef long long ll;node mm,p;node mul(node a,node b)&#123; node ans; memset(ans.m,0,sizeof(ans.m)); for(ll i=1;i&lt;=2;i++) for(ll j=1;j&lt;=2;j++) for(ll k=1;k&lt;=2;k++) ans.m[i][j]=((ans.m[i][j]+a.m[i][k]*b.m[k][j])%mod)%mod; return ans;&#125;node poww(node a,ll b)&#123; node ans; memset(ans.m,0,sizeof(ans.m)); for(ll i=1;i&lt;=2;i++) ans.m[i][i]=1; while(b) &#123; if(b&amp;1) ans=mul(ans,a); a=mul(a,a); b/=2; &#125; return ans;&#125;int main()&#123; ll n; p.m[1][1]=1,p.m[1][2]=1,p.m[2][1]=1,p.m[2][2]=0; mm.m[1][1]=1,mm.m[2][1]=1,mm.m[2][2]=0,mm.m[1][2]=0; while(cin&gt;&gt;n&amp;&amp;n!=-1) &#123; if(n==0) &#123; puts(&quot;0&quot;); continue; &#125; if(n==1||n==2) &#123; puts(&quot;1&quot;); continue; &#125; node mid=poww(p,n-2); mid=mul(mid,mm); cout&lt;&lt;mid.m[1][1]&lt;&lt;endl; &#125;&#125; Tr ADescription:A为一个方阵，则Tr A表示A的迹（就是主对角线上各项的和），现要求Tr(A^k)%9973。Input 数据的第一行是一个T，表示有T组数据。每组数据的第一行有n(2 &lt;= n &lt;= 10)和k(2 &lt;= k &lt; 10^9)两个数据。接下来有n行，每行有n个数据，每个数据的范围是[0,9]，表示方阵A的内容。 Output 对应每组数据，输出Tr(A^k)%9973。 Sample Input 22 21 00 13 999999991 2 34 5 67 8 9 Sample Output 22686 Problem solving:直接运用矩阵快速幂求出最后状态的矩阵，对角线相加就行了 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;int n,k;struct node&#123; int m[15][15];&#125;;node now;node mul(node a,node b)&#123; node ans; memset(ans.m,0,sizeof(ans.m)); for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;n;j++) &#123; for(int k=0;k&lt;n;k++) &#123; ans.m[i][j]=(ans.m[i][j]+a.m[i][k]*b.m[k][j])%9973; &#125; &#125; &#125; return ans;&#125;node poww(node a,int b)&#123; node ans; memset(ans.m,0,sizeof(ans.m)); for(int i=0;i&lt;n;i++) ans.m[i][i]=1; while(b) &#123; if(b&amp;1) ans=mul(ans,a); a=mul(a,a); b/=2; &#125; return ans;&#125;int main()&#123; int t; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n&gt;&gt;k; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;n;j++) cin&gt;&gt;now.m[i][j]; &#125; node mid=poww(now,k); int ans=0; for(int i=0;i&lt;n;i++) &#123; ans=(ans+mid.m[i][i])%9973; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125; A Simple Math ProblemDescription:Lele now is thinking about a simple function f(x). If x &lt; 10 f(x) = x.If x &gt;= 10 f(x) = a0 * f(x-1) + a1 * f(x-2) + a2 * f(x-3) + …… + a9 * f(x-10);And ai(0&lt;=i&lt;=9) can only be 0 or 1 . Now, I will give a0 ~ a9 and two positive integers k and m ,and could you help Lele to caculate f(k)%m. Input The problem contains mutiple test cases.Please process to the end of file.In each case, there will be two lines.In the first line , there are two positive integers k and m. ( k&lt;2*10^9 , m &lt; 10^5 )In the second line , there are ten integers represent a0 ~ a9. Output For each case, output f(k) % m in one line. Sample Input 10 99991 1 1 1 1 1 1 1 1 120 5001 0 1 0 1 0 1 0 1 0 Sample Output 45104 Problem solving:题意就是给你一个递推式求出第n项。 难点就是递推式有点长，但是这个跟斐波那契那个其实是一样的，构造的常数矩阵是 常数矩阵都构造出来了，那么接下来的就是套版子了。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;struct node&#123; ll m[15][15];&#125;;ll k,m;node now,p;node mul(node a,node b)&#123; node now; memset(now.m,0,sizeof(now.m)); for(int i=0;i&lt;10;i++) &#123; for(int j=0;j&lt;10;j++) &#123; for(int k=0;k&lt;10;k++) &#123; now.m[i][j]=(a.m[i][k]*b.m[k][j]+now.m[i][j])%m; &#125; &#125; &#125; return now;&#125;node poww(node a,int b)&#123; node ans; memset(ans.m,0,sizeof(ans.m)); for(int i=0;i&lt;10;i++) ans.m[i][i]=1; while(b) &#123; if(b&amp;1) ans=mul(ans,a); a=mul(a,a); b/=2; &#125; return ans;&#125;int main()&#123; while(cin&gt;&gt;k&gt;&gt;m) &#123; if(k&lt;=9) &#123; cout&lt;&lt;k&lt;&lt;endl; continue; &#125; for(int i=0;i&lt;10;i++) &#123; cin&gt;&gt;p.m[0][i]; &#125; for(int i=1;i&lt;10;i++) &#123; for(int j=0;j&lt;10;j++) &#123; if(i-1==j) p.m[i][j]=1; &#125; &#125; for(int i=0;i&lt;10;i++) now.m[i][0]=9-i; node ans=poww(p,k-9); ans=mul(ans,now); cout&lt;&lt;ans.m[0][0]&lt;&lt;endl; &#125;&#125; Recursive sequenceDescription: Problem solving:也是给了递推式求第n项的问题，但是这个就比较难了，因为构建常数矩阵的时候会发现一个严肃的问题，n^4与(n+1)^4找关系的时候会很爆炸。 这时候我们就需要化简了。(n+1)^4=n^4+4*n^3+6*n^2+4*n+1(n+1)^3=n^3+3*n^2+3*n+1(n+1)^2=n^2+2*n+1n+1=n+1 所以我们构建出来的常数矩阵就是 接下来就是计算了，套板子就行，一开始的矩阵是只有第一列有值得。值分别为b,a,81,27,9,3,1 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll n,a,b;struct node&#123; ll m[7][7];&#125;;const ll mod=2147493647;node mm,p;node mul(node a,node b)&#123; node now; memset(now.m,0,sizeof(now.m)); for(ll i=0;i&lt;7;i++) &#123; for(ll j=0;j&lt;7;j++) &#123; for(ll k=0;k&lt;7;k++) &#123; now.m[i][j]=(a.m[i][k]*b.m[k][j]+now.m[i][j])%mod; &#125; &#125; &#125; return now;&#125;node poww(node a,ll b)&#123; node ans; memset(ans.m,0,sizeof(ans.m)); for(ll i=0;i&lt;10;i++) ans.m[i][i]=1; while(b) &#123; if(b&amp;1) ans=mul(ans,a); a=mul(a,a); b/=2; &#125; return ans;&#125;int main()&#123; ll t; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n&gt;&gt;a&gt;&gt;b; if(n==1) &#123; cout&lt;&lt;a&lt;&lt;endl; continue; &#125; if(n==2) &#123; cout&lt;&lt;b&lt;&lt;endl; continue; &#125; memset(mm.m,0,sizeof(mm.m)); memset(p.m,0,sizeof(p.m)); mm.m[0][0]=b,mm.m[1][0]=a; mm.m[2][0]=81,mm.m[3][0]=27,mm.m[4][0]=9,mm.m[5][0]=3,mm.m[6][0]=1; p.m[0][0]=1,p.m[0][1]=2,p.m[0][2]=1; p.m[1][0]=1; p.m[2][2]=1,p.m[2][3]=4,p.m[2][4]=6,p.m[2][5]=4,p.m[2][6]=1; p.m[3][3]=1,p.m[3][4]=3,p.m[3][5]=3,p.m[3][6]=1; p.m[4][4]=1,p.m[4][5]=2,p.m[4][6]=1; p.m[5][5]=1,p.m[5][6]=1; p.m[6][6]=1; node mid=poww(p,n-2); mid=mul(mid,mm); cout&lt;&lt;mid.m[0][0]&lt;&lt;endl; &#125;&#125;]]></content>
      <categories>
        <category>Training</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>c/c++</tag>
        <tag>HDU</tag>
        <tag>51nod</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HPU Summer Day 15(河南理工大学暑期第十五天)]]></title>
    <url>%2Fblog%2F2019%2F07%2F31%2Fd15%2F</url>
    <content type="text"><![CDATA[今天主要讲了01背包，完全背包，多重背包的相关东西。不太好理解，题也有点难。关于背包东西还有很多，慢慢学吧。 Bone CollectorDescription:涂奥最近迷上了吃鸡，房间有n个配件，每个配件有c(c&lt;=1e3)的重量和v(v&lt;=1e3)的价值，哇，涂奥捡了一个2级包，容量为s，所以涂奥最多当多肥的快递员呢？Input 输入的第一行是T, 表示有一共要打T场比赛.每组数据由三行组成.第1行包含两个整数n和s 第2行包含n个整数, 表示每一个配件的价值. 第3行包含n个整数, 表示每个配件的重量. Output 对每一组数据, 输出涂奥可以多肥. Sample Input110 101 3 5 7 9 11 13 15 17 1919 17 15 13 11 9 7 5 3 1Sample Output51 Problem solving:跟昨天那道题一样，不过就是换了描述。提议就是给定你容量，然后告诉你每个物品的价值和体积，求你能拿到的最大的价值。01背包问题，直接套板子即可 Code:123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;const int tx=1e6;int m[tx],M[tx],dp[tx];int main()&#123; int t,n,s; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n&gt;&gt;s; for(int i=0;i&lt;n;i++) cin&gt;&gt;m[i]; for(int i=0;i&lt;n;i++) cin&gt;&gt;M[i]; memset(dp,0,sizeof(dp)); for(int i=0;i&lt;n;i++) &#123; for(int j=s;j&gt;=M[i];j--) &#123; dp[j]=max(dp[j],dp[j-M[i]]+m[i]); &#125; &#125; cout&lt;&lt;dp[s]&lt;&lt;endl; &#125;&#125; 饭卡Description:电子科大本部食堂的饭卡有一种很诡异的设计，即在购买之前判断余额。如果购买一个商品之前，卡上的剩余金额大于或等于5元，就一定可以购买成功（即使购买后卡上余额为负），否则无法购买（即使金额足够）。所以大家都希望尽量使卡上的余额最少。某天，食堂中有n种菜出售，每种菜可购买一次。已知每种菜的价格以及卡上的余额，问最少可使卡上的余额为多少。Input 多组数据。对于每组数据：第一行为正整数n，表示菜的数量。n&lt;=1000。第二行包括n个正整数，表示每种菜的价格。价格不超过50。第三行包括一个正整数m，表示卡上的余额。m&lt;=1000。n=0表示数据结束。 Output 对于每组输入,输出一行,包含一个整数，表示卡上可能的最小余额。 Sample Input 1505101 2 3 2 1 1 2 3 2 1500 Sample Output -4532 Problem solving:题意就是让你尽可能多的花掉自己的钱，求余额。有一个特殊规定就是如果当前余额大于等于5，能买任何的菜，但是一旦n小于5，就什么都不能买了。也是一道01背包的问题，这里还有一点贪心的感觉就是，为了最后能达到的是最小的余额，我们拿5元出来买最贵的菜。然后就是背包，背包容量是n-5，直接套板子求出n-5的容量下能花费最多钱的情况。最后输出的时候减去最大的花费和最贵的菜即可。但是还有一点就是输入的n就有可能是小于5的。这时直接输出n就行。 Code:1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;const int tx=1005;int m[tx],dp[tx];int main()&#123; int t,n; while(cin&gt;&gt;t&amp;&amp;t) &#123; memset(dp,0,sizeof(dp)); for(int i=0;i&lt;t;i++) cin&gt;&gt;m[i]; cin&gt;&gt;n; if(n&lt;5) &#123; cout&lt;&lt;n&lt;&lt;endl; continue; &#125; sort(m,m+t); for(int i=0;i&lt;t-1;i++) for(int j=n-5;j&gt;=m[i];j--) &#123; dp[j]=max(dp[j],dp[j-m[i]]+m[i]); &#125; cout&lt;&lt;n-dp[n-5]-m[t-1]&lt;&lt;endl; &#125;&#125; CDDescription:PDF题面:戳我戳我You have a long drive by car ahead. You have a tape recorder, but unfortunately your best music is onCDs. You need to have it on tapes so the problem to solve is: you have a tape N minutes long. Howto choose tracks from CD to get most out of tape space and have as short unused space as possible.Assumptions:• number of tracks on the CD does not exceed 20• no track is longer than N minutes• tracks do not repeat• length of each track is expressed as an integer number• N is also integerProgram should find the set of tracks which fills the tape best and print it in the same sequence asthe tracks are stored on the CDInput Any number of lines. Each one contains value N, (after space) number of tracks and durations of thetracks. For example from first line in sample data: N = 5, number of tracks=3, first track lasts for 1minute, second one 3 minutes, next one 4 minutes Output Set of tracks (and durations) which are the correct solutions and string ‘sum:’ and sum of durationtimes. Sample Input 5 3 1 3 410 4 9 8 4 220 4 10 5 7 490 8 10 23 1 2 3 4 5 745 8 4 10 44 43 12 9 8 2 Sample Output 1 4 sum:58 2 sum:1010 5 4 sum:1910 23 1 2 3 4 5 7 sum:554 10 12 9 8 2 sum:45 Problem solving:这道题的意思就是给你一个数，这个就是背包容量然后给你n个数，问你这n个数怎么放能使背包容量最小，并输出这个方法。 简单的01背包问题。不简单的输出方法。在每次dp查找最优情况的时候进行标记，最后根据标记输出，并且题目要求的输出是出现在前面的就输出在前面，最后还有一点小优化，可以看一下代码注释理解。 关于这个输出路径，我也不是理解的很清楚，但是很关键的要理解的一点就是dp[j]这个数组的含义。也就是01背包中dp[i][j]的意思:从前i-1个物品中，选出来总重量不超过j的物品时，总价值的最大值 Code:123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,num;const int maxn=10005;int a[maxn],dp[maxn],flag[maxn][maxn];int main()&#123; ios::sync_with_stdio(0); cin.tie(0); while(cin&gt;&gt;n&gt;&gt;m) &#123; for(int i=0;i&lt;m;i++) cin&gt;&gt;a[i]; memset(flag,0,sizeof(flag)); memset(dp,0,sizeof(dp)); for(int i=m-1;i&gt;=0;i--)//这里倒序主要是在输出的时候方便 &#123; for(int j=n;j&gt;=a[i];j--) &#123; if(dp[j]&lt;dp[j-a[i]]+a[i])//选上了a[i]的情况 &#123; dp[j]=dp[j-a[i]]+a[i]; flag[i][j]=1;//进行标记 &#125; &#125; &#125; for(int i=0,j=n;i&lt;m;i++) &#123; if(flag[i][j])//标价到的就输出 &#123; cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; j-=a[i]; &#125; &#125; cout&lt;&lt;&quot;sum:&quot;&lt;&lt;dp[n]&lt;&lt;endl; &#125;&#125; Piggy-BankDescription:在 ACM 能够开展之前，必须准备预算，并获得必要的财力支持。该活动的主要收入来自于 Irreversibly Bound Money (IBM)。思路很简单。任何时候，某位 ACM 会员有少量的钱时，他将所有的硬币投入到小猪储钱罐中。这个过程不可逆，因为只有把小猪储钱罐打碎才能取出硬币。在足够长的时间之后，小猪储钱罐中有了足够的现金，用于支付 ACM 活动所需的花费。 但是，小猪储钱罐存在一个大的问题，即无法确定其中有多少钱。因此，我们可能在打碎小猪储钱罐之后，发现里面的钱不够。显然，我们希望避免这种不愉快的情况。唯一的可能是，称一下小猪储钱罐的重量，并尝试猜测里面的有多少硬币。假定我们能够精确判断小猪储钱罐的重量，并且我们也知道给定币种的所有硬币的重量。那么，我们可以保证小猪储钱罐中最少有多少钱。 你的任务是找出最差的情形，即判断小猪储钱罐中的硬币最少有多少钱。我们需要你的帮助。不能再贸然打碎小猪储钱罐了！ 输入 输入包含 T 组测试数据。输入文件的第一行，给出了 T 的值。对于每组测试数据，第一行包含 E 和 F 两个整数，它们表示空的小猪储钱罐的重量，以及装有硬币的小猪储钱罐的重量。两个重量的计量单位都是 g (克)。小猪储钱罐的重量不会超过 10 kg (千克)，即 1 &lt;= E &lt;= F &lt;= 10000 。每组测试数据的第二行，有一个整数 N (1 &lt;= N &lt;= 500)，提供了给定币种的不同硬币有多少种。接下来的 N 行，每行指定一种硬币类型，每行包含两个整数 P 和 W (1 &lt;= P &lt;= 50000，1 &lt;= W &lt;=10000)。P 是硬币的金额 (货币计量单位)；W 是它的重量，以 g (克) 为计量单位。 输出 对于每组测试数据，打印一行输出。每行必须包含句子 “The minimum amount of money in the piggy-bank is X.” 其中，X 表示对于给定总重量的硬币，所能得到的最少金额。如果无法恰好得到给定的重量，则打印一行 “This is impossible.” 。 示例输入 310 11021 130 5010 11021 150 301 6210 320 4 示例输出 The minimum amount of money in the piggy-bank is 60.The minimum amount of money in the piggy-bank is 100.This is impossible. Problem solving:这道题的意思是给你一个存钱罐的初始和末状态的质量，然后给定你每种硬币的质量和价值。要求这个存钱罐是否存在着能正好放满硬币的情况，如果有求出最小的情况。 每个硬币可以挑选任意次，所以这是一道完全背包的题。套板子就行，注意我们要求最小值，所以初始化成一个极大值，然后在dp的过程中取min。还有一点就是dp[0]一定要初始化为0，因为这里我们dp[i]表示的就是在i的空间下，能放人的最小的硬币的值。空间为0即不能再放硬币了，所以价值就是0了。 Code:123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int p[505],w[505],dp[10005];const int INF = 0x3f3f3f3f;int main()&#123; int t,s,e,n,cs; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;s&gt;&gt;e&gt;&gt;n; cs=e-s; for(int i=0;i&lt;=cs;i++) dp[i]=INF; for(int i=0;i&lt;n;i++) cin&gt;&gt;p[i]&gt;&gt;w[i]; dp[0]=0; for(int i=0;i&lt;n;i++) &#123; for(int j=w[i];j&lt;=cs;j++) &#123; dp[j]=min(dp[j],dp[j-w[i]]+p[i]); &#125; &#125; if(dp[cs]!=INF) cout&lt;&lt;&quot;The minimum amount of money in the piggy-bank is &quot;&lt;&lt;dp[cs]&lt;&lt;&quot;.&quot;; else cout&lt;&lt;&quot;This is impossible.&quot;; puts(&quot;&quot;); &#125;&#125; Dividing coinsDescription:PDF题面：戳我戳我It’s commonly known that the Dutch have invented copper-wire. Two Dutch men were fighting overa nickel, which was made of copper. They were both so eager to get it and the fighting was so fierce,they stretched the coin to great length and thus created copper-wire.Not commonly known is that the fighting started, after the two Dutch tried to divide a bag withcoins between the two of them. The contents of the bag appeared not to be equally divisible. The Dutchof the past couldn’t stand the fact that a division should favour one of them and they always wanteda fair share to the very last cent. Nowadays fighting over a single cent will not be seen anymore, butbeing capable of making an equal division as fair as possible is something that will remain importantforever...That’s what this whole problem is about. Not everyone is capable of seeing instantly what’s themost fair division of a bag of coins between two persons. Your help is asked to solve this problem.Given a bag with a maximum of 100 coins, determine the most fair division between two persons.This means that the difference between the amount each person obtains should be minimised. Thevalue of a coin varies from 1 cent to 500 cents. It’s not allowed to split a single coin.Input A line with the number of problems n, followed by n times:• a line with a non negative integer m (m ≤ 100) indicating the number of coins in the bag• a line with m numbers separated by one space, each number indicates the value of a coin. Output The output consists of n lines. Each line contains the minimal positive difference between the amountthe two persons obtain when they divide the coins from the corresponding bag. Sample Input 232 3 541 2 4 6 Sample Output 01 Problem solving:这道题的意思就是给你n个硬币，让你分成两堆，求所有分法中两堆价值差值最小的情况。这道题乍一看以为是要贪心，但是WA了。然后想到今天讲的是背包诶，然后脑子里灵光一现(去百度了一下)，想到可以以硬币的总价值的一半为背包容量进行01背包的处理。假设总价值为s，这时我们求出的dp[s/2]就是分成差值最小的两堆中的其中一堆，然后另一堆的价值就是s-sp[s/2],两堆价值的差值就是s-2*dp[s/2] Code:12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;const int tx=1e5+10;int m[tx],dp[tx];int main()&#123; int n,t; cin&gt;&gt;n; while(n--) &#123; cin&gt;&gt;t; memset(dp,0,sizeof(dp)); int sum=0; for(int i=0;i&lt;t;i++) cin&gt;&gt;m[i],sum+=m[i]; for(int i=0;i&lt;t;i++) &#123; for(int j=sum/2;j&gt;=m[i];j--) &#123; dp[j]=max(dp[j],dp[j-m[i]]+m[i]); &#125; &#125; cout&lt;&lt;sum-dp[sum/2]-dp[sum/2]&lt;&lt;endl; &#125; return 0;&#125; RobberiesDescription:可怜的POIUYTREWQ最近想买下dota2的商品，但是手头缺钱。他想起了之前看过的一部大片，觉得抢银行也许是个不错的选择。他认为，坏人被抓是因为没有预先规划。于是他在之前的几个月对各大银行进行了一次评估； 评估内容包括安全性和可盗窃金额： 他想知道在在某个风险系数下可以偷窃的最大金额Input 第一行给出了一个整数T, 表示有T组测试数据. 对于每一组数据，第一行给出了一个浮点数P, 表示POIUYTREWQ允许被抓的最大概率, 和一个整数N，表示他计划去抢劫的N个银行. 接下来N行, 每行给出一个整数数Mj和浮点数Pj.抢劫银行 j 可获得 Mj 百万美金, 被抓的概率是 Pj . Output 对于每组数据，每行输出一个整数，表示POIUYTREWQ在被抓概率小于P的情况下，可抢到的最多的金钱。 Notes and Constraints0 &lt; T &lt;= 1000.0 &lt;= P &lt;= 1.00 &lt; N &lt;= 1000 &lt; Mj &lt;= 1000.0 &lt;= Pj &lt;= 1.0你可以认为每家银行都是独立的。Sample Input 30.04 31 0.022 0.033 0.050.06 32 0.032 0.033 0.050.10 31 0.032 0.023 0.05 Sample Output 246 Problem solving:这道题就是先给你一个实数代表这个可怜的孩子能允许的最大的被抓的概率，意思就是你被抓的概率不能超过这个值。然后给你n个银行的获利以及被抓的概率，求最大能偷多少钱。 这是一道01背包的问题，但是不太一样的是如果我们直接以概率为背包容量的话会出现一个很尴尬的问题就是实数并不可以当做数组的下标，然后我想到了对概率乘上一个较大的数（1e6之类的）然后进行背包的dp，但是这样会WA，由此可见这道题的精度还是很高的，所以这种方法我们行不通。就得换个方向 这里可以以偷到的美金的数量为背包容量进行01背包，然后求出获得(1~n)内每个美金数量所对应的不被抓住的概率。背包容量就是可以偷到的美金的最大值——所有都偷到。dp[i]表示的就是偷了i美金之后不被抓的概率 有一点还需要注意的就是dp[0]必须初始化为1，不然后面算出来的dp都是0了。可为什么初始化的是1呢，因为我们现在用的dp数组表示的是偷了i美金之后不被抓的概率，i等于0的意思就是一点美金都没偷，不被抓的概率当然就是1(100%)了。 为什么我们要求的是不被抓住的概率呢？因为如果是被抓住的概率的话，算总的概率并不好求，可以自己想一下。如果第一次被抓住的概率是0.5，第二次被抓住的概率也是0.5~·~·~第n次被抓住的概率也是0.5，那么总共被抓住的几率并不好求，因为如果第一次被抓住了，后面的就都不用考虑了，以此类推易想到不好求。但是如果是不被抓住的概率，我们直接累乘就行了。最后我们求出对应的每个美金的数量对应的不被抓住的概率，直接O(n)查找到概率大于等于1-p(允许被抓的最大概率)的美金数量输出即可。 具体可以看一下代码在感受一下，涉及到01背包的直接套板子就行(对和我一样不太理解背包的小伙伴适用Code:123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 105;int m[maxn];double dp[100005],p[maxn];int main()&#123; ios::sync_with_stdio(0); int t; cin&gt;&gt;t; while(t--) &#123; memset(dp,0,sizeof(dp)); double pp;int n,sum=0; cin&gt;&gt;pp&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;m[i]&gt;&gt;p[i]; sum+=m[i]; p[i]=1-p[i]; &#125; dp[0]=1;//这个初始化很重要 for(int i=0;i&lt;n;i++) &#123; for(int j=sum;j&gt;=m[i];j--) &#123; dp[j]=max(dp[j],dp[j-m[i]]*p[i]); &#125; &#125; for(int i=sum;i&gt;=0;i--) &#123; if(dp[i]&gt;=1-pp) &#123; cout&lt;&lt;i&lt;&lt;endl; break; &#125; &#125; &#125; return 0;&#125; Coin ChangeDescription:PDF题面:戳我戳我Suppose there are 5 types of coins: 50-cent, 25-cent, 10-cent, 5-cent, and 1-cent. We want to makechanges with these coins for a given amount of money.For example, if we have 11 cents, then we can make changes with one 10-cent coin and one 1-centcoin, two 5-cent coins and one 1-cent coin, one 5-cent coin and six 1-cent coins, or eleven 1-cent coins.So there are four ways of making changes for 11 cents with the above coins. Note that we count thatthere is one way of making change for zero cent.Write a program to find the total number of different ways of making changes for any amount ofmoney in cents. Your program should be able to handle up to 7489 cents.Input The input file contains any number of lines, each one consisting of a number for the amount of moneyin cents. Output For each input line, output a line containing the number of different ways of making changes with theabove 5 types of coins. Sample Input 1126 Sample Output 413 Problem solving:这道题的意思就是给你5种硬币，币值都给你了，在给你一个数问有几种方法可以拼出来这个数。 这是一道完全背包的题，直接套板子就行了。 这里我第一次不知道为啥TLE了，所以加上了一个记忆化搜索，也可能是cin/cout得锅。Code:1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll ans[7500];ll solve(ll x)&#123; if(ans[x]) return ans[x]; int coins[13] = &#123; 1, 5, 10, 25, 50&#125;; ll dp[100005] = &#123; 0 &#125;; dp[0] = 1; for (int i = 0; i &lt; 6; i++) &#123; for (int j = coins[i]; j &lt;= x; j++) &#123; dp[j] = dp[j] + dp[j - coins[i]]; &#125; &#125; return ans[x]=dp[x];&#125;int main()&#123; ll t, a; ios::sync_with_stdio(0); cin.tie(0); while (cin &gt;&gt; a) &#123; cout &lt;&lt; solve(a)/2 &lt;&lt; endl; &#125;&#125; 悼念512汶川大地震遇难同胞——珍惜现在，感恩生活Description:急！灾区的食物依然短缺！为了挽救灾区同胞的生命，心系灾区同胞的你准备自己采购一些粮食支援灾区，现在假设你一共有资金n元，而市场有m种大米，每种大米都是袋装产品，其价格不等，并且只能整袋购买。请问：你用有限的资金最多能采购多少公斤粮食呢？ 后记：人生是一个充满了变数的生命过程，天灾、人祸、病痛是我们生命历程中不可预知的威胁。月有阴晴圆缺，人有旦夕祸福，未来对于我们而言是一个未知数。那么，我们要做的就应该是珍惜现在，感恩生活——感谢父母，他们给予我们生命，抚养我们成人；感谢老师，他们授给我们知识，教我们做人感谢朋友，他们让我们感受到世界的温暖；感谢对手，他们令我们不断进取、努力。同样，我们也要感谢痛苦与艰辛带给我们的财富～ Input 输入数据首先包含一个正整数C，表示有C组测试用例，每组测试用例的第一行是两个整数n和m(1&lt;=n&lt;=100, 1&lt;=m&lt;=100),分别表示经费的金额和大米的种类，然后是m行数据，每行包含3个数p，h和c(1&lt;=p&lt;=20,1&lt;=h&lt;=200,1&lt;=c&lt;=20)，分别表示每袋的价格、每袋的重量以及对应种类大米的袋数。 Output 对于每组测试数据，请输出能够购买大米的最多重量，你可以假设经费买不光所有的大米，并且经费你可以不用完。每个实例的输出占一行。 Sample Input 18 22 100 44 100 2 Sample Output 400 Problem solving:这道题的意思就是给了你最大得经费，还给了你每包米的体积以及价格和这种米的个数，问你在最优的情况下可以买到的米的体积 这是一道多重背包的题，直接套板子即可。 Code:123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;const int tx=1e3;int m[tx],p[tx],h[tx],c[tx];int main()&#123; int t,n,x; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n&gt;&gt;x; memset(m,0,sizeof(m)); for(int i=0;i&lt;x;i++) cin&gt;&gt;p[i]&gt;&gt;h[i]&gt;&gt;c[i]; for(int i=0;i&lt;x;i++) &#123; int mid=c[i]; for(int k=1;mid&gt;0;k*=2) &#123; int miid=min(k,mid); for(int j=n;j&gt;=p[i]*miid;j--) &#123; m[j]=max(m[j],m[j-p[i]*miid]+h[i]*miid); &#125; mid-=miid; &#125; &#125; cout&lt;&lt;m[n]&lt;&lt;endl; &#125; return 0;&#125; 注意，这个背包问题中如果涉及到多组输入，dp数组的初始化是很重要的。这些dp啊，背包的好多问题一看都感觉好像用贪心可以写，但是过一会你就会发现贪心并不能解决这些问题，还是老老实实学dp吧、、、]]></content>
      <categories>
        <category>Training</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>c/c++</tag>
        <tag>dp</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HPU Summer Day 14(河南理工大学暑期第十四天)]]></title>
    <url>%2Fblog%2F2019%2F07%2F30%2Fd14%2F</url>
    <content type="text"><![CDATA[今天讲了记忆化搜索，拉的题emm真让人自闭啊。 Function Run FunDescription:We all love recursion! Don&#39;t we? Consider a three-parameter recursive function w(a, b, c): if a &lt;= 0 or b &lt;= 0 or c &lt;= 0, then w(a, b, c) returns:1 if a &gt; 20 or b &gt; 20 or c &gt; 20, then w(a, b, c) returns:w(20, 20, 20) if a &lt; b and b &lt; c, then w(a, b, c) returns:w(a, b, c-1) + w(a, b-1, c-1) - w(a, b-1, c) otherwise it returns:w(a-1, b, c) + w(a-1, b-1, c) + w(a-1, b, c-1) - w(a-1, b-1, c-1) This is an easy function to implement. The problem is, if implemented directly, for moderate values of a, b and c (for example, a = 15, b = 15, c = 15), the program takes hours to run because of the massive recursion.Input The input for your program will be a series of integer triples, one per line, until the end-of-file flag of -1 -1 -1. Using the above technique, you are to calculate w(a, b, c) efficiently and print the result. Output Print the value for w(a,b,c) for each triple. Sample Input 1 1 12 2 210 4 650 50 50-1 7 18-1 -1 -1 Sample Output w(1, 1, 1) = 2w(2, 2, 2) = 4w(10, 4, 6) = 523w(50, 50, 50) = 1048576w(-1, 7, 18) = 1 Problem solving:这道题没什么好说的，按照题目上的要求来写一个递归就行了，因为是多组输入，所以要用到记忆化搜索。 Code:1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;typedef long long ll;ll a,b,c,dp[21][21][21];ll dfs(ll m,ll t,ll x)&#123; if(m&lt;=0||t&lt;=0||x&lt;=0) return 1; if(m&gt;20||t&gt;20||x&gt;20) return dfs(20,20,20); if(dp[m][t][x]) return dp[m][t][x]; if(m&lt;t&amp;&amp;t&lt;x) return dp[m][t][x]=dfs(m,t,x-1)+dfs(m,t-1,x-1)-dfs(m,t-1,x); else return dp[m][t][x]=dfs(m-1,t,x)+dfs(m-1,t-1,x)+dfs(m-1,t,x-1)-dfs(m-1,t-1,x-1);&#125;int main()&#123; while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c) &#123; if(a==-1&amp;&amp;b==-1&amp;&amp;c==-1) break; printf(&quot;w(%lld, %lld, %lld) = %lld\n&quot;,a,b,c,dfs(a,b,c)); &#125;&#125; 滑雪Description:Glory非常喜欢玩滑滑梯游戏，下面给出了一个n,m的滑道，其中的数字表示滑道的高度。Glory可以从一个点出发向下滑行，每次只能滑行到相邻的位置(上下左右)中高度严格低于当前高度的地方，不能重复划行已经滑行过的地方，但他希望在这个滑道上滑行尽量远的距离，也即是找一条最长的滑道。 Input 第一行输入两个数n,m代表滑梯范围行n和列m(1 &lt;= n,m &lt;= 100)。下面是n行，每行有m个整数，代表高度h，(0&lt;=h&lt;=20000) Output 输出一个值，代表Glory能够在滑滑梯上面滑行的最长长度是多少 Sample Input 3 39 1 25 6 78 4 3 Sample Output 4 Sample Input 4 77 6 5 4 3 2 11 5 1 1 1 1 11 4 3 1 1 1 11 5 6 7 8 1 1 Sample Output 7 hint 样例1：7-&gt;6-&gt;4-&gt;3 长度为4 Problem solving:四个方向搜索就行了。记忆化搜索要用上，不然会超时。ma[dx][dy]与ma[x][y]的大小关系判断的时候大于小于都是可以的，这个还是很好理解的吧，降序反过来就是升序。 Code:12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;using namespace std;int n,m,ma[105][105],dp[105][105];int d[4][2]=&#123;1,0,0,1,0,-1,-1,0&#125;;int dfs(int x,int y)&#123; int mid=1; if(dp[x][y]) return dp[x][y]; for(int i=0;i&lt;4;i++) &#123; int dx=x+d[i][0]; int dy=y+d[i][1]; if(dx&gt;=0&amp;&amp;dx&lt;n&amp;&amp;dy&gt;=0&amp;&amp;dy&lt;m&amp;&amp;ma[dx][dy]&lt;ma[x][y]) &#123; mid=max(mid,dfs(dx,dy)+1); &#125; &#125; return dp[x][y]=mid;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) cin&gt;&gt;ma[i][j]; int ans=0; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) ans=max(ans,dfs(i,j)); cout&lt;&lt;ans&lt;&lt;endl;&#125; 漫步校园LL最近沉迷于AC不能自拔，每天寝室、机房两点一线。由于长时间坐在电脑边，缺乏运动。他决定充分利用每次从寝室到机房的时间，在校园里散散步。整个HDU校园呈方形布局，可划分为n*n个小方格，代表各个区域。例如LL居住的18号宿舍位于校园的西北角，即方格(1,1)代表的地方，而机房所在的第三实验楼处于东南端的(n,n)。因有多条路线可以选择，LL希望每次的散步路线都不一样。另外，他考虑从A区域到B区域仅当存在一条从B到机房的路线比任何一条从A到机房的路线更近(否则可能永远都到不了机房了…)。现在他想知道的是，所有满足要求的路线一共有多少条。你能告诉他吗?Input 每组测试数据的第一行为n(2=&lt;n&lt;=50)，接下来的n行每行有n个数，代表经过每个区域所花的时间t(0&lt;t&lt;=50)(由于寝室与机房均在三楼，故起点与终点也得费时)。 Output 针对每组测试数据，输出总的路线数(小于2^63)。 Sample Input 31 2 31 2 31 2 331 1 11 1 11 1 1 Sample Output 16 Problem solving:这道题的题意也太难懂了。。。让你求最短路的条数，所以我们需要先求出最短路然后再求条数。先用bfs求出每个点到终点的最短距离然后进行记忆化搜索。（如果阁下真的是在看我的题解，当你看到这的时候，我衷心的给你道个歉，这道题为了你好还是百度吧 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n;struct node&#123; int x,y,c; bool friend operator &lt;(node a,node b) &#123; return a.c&gt;b.c; &#125;&#125;r,w;ll ma[305][305],vis[305][305],dis[305][305],dp[305][305];int d[4][2]=&#123;0,1,1,0,-1,0,0,-1&#125;;void bfs()&#123; priority_queue&lt;node&gt; q; r.x=n-1,r.y=n-1;r.c=ma[n-1][n-1]; dis[n-1][n-1]=ma[n-1][n-1]; vis[n-1][n-1]=1; q.push(r); while(!q.empty()) &#123; r=q.top(); q.pop(); for(int i=0;i&lt;4;i++) &#123; int dx=r.x+d[i][0]; int dy=r.y+d[i][1]; if(dx&lt;0||dy&lt;0||dx&gt;=n||dy&gt;=n||vis[dx][dy]) continue; w.x=dx,w.y=dy,w.c=r.c+ma[dx][dy]; vis[dx][dy]=1; q.push(w); dis[dx][dy]=w.c; &#125; &#125;&#125;ll dfs(ll x,ll y)&#123; if(x==n-1&amp;&amp;y==n-1) return 1; if(dp[x][y]!=-1) return dp[x][y]; dp[x][y]=0; for(int i=0;i&lt;4;i++) &#123; int dx=x+d[i][0]; int dy=y+d[i][1]; if(dx&lt;0||dy&lt;0||dx&gt;=n||dy&gt;=n||dis[dx][dy]&gt;=dis[x][y]) continue; dp[x][y]+=dfs(dx,dy); &#125; return dp[x][y];&#125;int main()&#123; while(cin&gt;&gt;n) &#123; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) cin&gt;&gt;ma[i][j]; memset(vis,0,sizeof(vis)); memset(dp,-1,sizeof(dp)); bfs(); cout&lt;&lt;dfs(0,0)&lt;&lt;endl; &#125;&#125; Free CandiesDescription:PDF题面:戳我戳我输入输出Problem solving:题意就是有4个盒子，每个盒子里面都放着糖果，有个最多能放5个糖果的袋子，每次只能取盒子最上面的那个糖果，如果袋子里面有两个颜色相同的糖果可以自己拿走（这道题用数字代表颜色），问你最优情况下能拿走几对糖果，注意是对（2个算一对）。我们这里可以用一个四维数组表示分别从四堆糖果中取出不同个数的糖果的时候的最优解，用一个now数组代表此时在第i堆数组拿到了第now[i]个糖果，用一个flag数组表示这个颜色的糖果是否在袋子里出现过。然后进行dfs查找，注意这里用到了很多回溯，还有记忆化搜索。可以看一下代码注释了解一下具体的dfs过程。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;int dp[45][45][45][45],n,ma[4][45];int now[4],flag[45];int dfs(int x)//x代表的就是当前袋子里放入的糖果个数&#123; int ans=0;//初始化为0 if(dp[now[0]][now[1]][now[2]][now[3]]!=-1)//记忆化搜索 return dp[now[0]][now[1]][now[2]][now[3]]; if(x==5) return 0;//袋子里有5个糖果了，不能放入更多，所以return 0 for(int i=0;i&lt;4;i++)//四堆糖果 &#123; if(now[i]==n) continue;//在这一堆如果已经取到了第n个，即最后一个，就结束这一堆糖果中的查找 int mid=ma[i][now[i]];//代表的是当前取出的糖果的颜色 now[i]++;//下一次要放入的糖果的颜色 if(flag[mid])//如果现在要放入袋子里的糖果的颜色在袋子里已经存在 &#123; flag[mid]=0;//把袋子里的颜色相同的那个糖果取出来 ans=max(ans,dfs(x-1)+1);//当前的最优值更新一下，dfs(x-1)即取出颜色相同得糖果之后的最优解，加上的1就是取出的糖果和本来准备放进袋子却没放的糖果这一对 flag[mid]=1;//回溯，把从袋子里取出的糖果再放回去 &#125; else//现在要放入袋子里的糖果的颜色在袋子里不存在 &#123; flag[mid]=1;//把这个糖果放进去 ans=max(dfs(x+1),ans);//此时袋子里的糖果数加一 flag[mid]=0;//回溯，把放进去的再取出来 &#125; now[i]--;//回溯，考虑不放这一个糖果的情况 &#125; return dp[now[0]][now[1]][now[2]][now[3]]=ans;//记忆化&#125;int main()&#123; while(cin&gt;&gt;n&amp;&amp;n) &#123; memset(dp,-1,sizeof(dp)); memset(now,0,sizeof(now)); memset(flag,0,sizeof(flag)); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;4;j++) cin&gt;&gt;ma[j][i]; cout&lt;&lt;dfs(0)&lt;&lt;endl; &#125;&#125; ZipperDescription:Given three strings, you are to determine whether the third string can be formed by combining the characters in the first two strings. The first two strings can be mixed arbitrarily, but each must stay in its original order. For example, consider forming &quot;tcraete&quot; from &quot;cat&quot; and &quot;tree&quot;: String A: catString B: treeString C: tcraete As you can see, we can form the third string by alternating characters from the two strings. As a second example, consider forming &quot;catrtee&quot; from &quot;cat&quot; and &quot;tree&quot;: String A: catString B: treeString C: catrtee Finally, notice that it is impossible to form &quot;cttaree&quot; from &quot;cat&quot; and &quot;tree&quot;.Input The first line of input contains a single positive integer from 1 through 1000. It represents the number of data sets to follow. The processing for each data set is identical. The data sets appear on the following lines, one data set per line.For each data set, the line of input consists of three strings, separated by a single space. All strings are composed of upper and lower case letters only. The length of the third string is always the sum of the lengths of the first two strings. The first two strings will have lengths between 1 and 200 characters, inclusive. Output For each data set, print:Data set n: yesif the third string can be formed from the first two, orData set n: noif it cannot. Of course n should be replaced by the data set number. See the sample output below for an example. Sample Input 3cat tree tcraetecat tree catrteecat tree cttaree Sample Output Data set 1: yesData set 2: yesData set 3: no Problem solving:匹配的时候只会有两种情况 第一个字符串当前位置的字符与第三个字符串当前位置的字符相等。 第二个字符串当前位置的字符与第三个字符串当前位置的字符相等。只有这两种情况，所以我们可以直接用dfs进行暴搜。但是这道题需要用到记忆化搜索，用一个二维的标记数组即可。每次查找完当前的一对位置就标记起来，下次遇见的时候就不需要再查找了。 Code:1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;string a,b,c;int vis[205][205],flag;void dfs(int x,int y,int z)&#123; if(flag) return ; if(z==c.size()) &#123; flag=1; return ; &#125; if(vis[x][y]) return ; vis[x][y]=1; if(a[x]==c[z]) dfs(x+1,y,z+1); if(b[y]==c[z]) dfs(x,y+1,z+1);&#125;int main()&#123; int n,now=0; cin&gt;&gt;n; while(n--) &#123; memset(vis,0,sizeof(vis)); flag=0; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; cout&lt;&lt;&quot;Data set &quot;&lt;&lt;++now&lt;&lt;&quot;: &quot;; dfs(0,0,0); if(flag) puts(&quot;yes&quot;); else puts(&quot;no&quot;); &#125;&#125; Bone CollectorDescription:Many years ago , in Teddy’s hometown there was a man who was called “Bone Collector”. This man like to collect varies of bones , such as dog’s , cow’s , also he went to the grave …The bone collector had a big bag with a volume of V ,and along his trip of collecting there are a lot of bones , obviously , different bone has different value and different volume, now given the each bone’s value along his trip , can you calculate out the maximum of the total value the bone collector can get ?Input The first line contain a integer T , the number of cases.Followed by T cases , each case three lines , the first line contain two integer N , V, (N &lt;= 1000 , V &lt;= 1000 )representing the number of bones and the volume of his bag. And the second line contain N integers representing the value of each bone. The third line contain N integers representing the volume of each bone. Output One integer per line representing the maximum of the total value (this number will be less than 2 31). Sample Input 15 101 2 3 4 55 4 3 2 1 Sample Output 14 Problem solving:这就是一道背包问题，但是换了描述。背包问题dp得写法我们还没学，今天学到的是用记忆化搜索解决的背包问题。具体的解释请看代码注释 Code:12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,a[1050],b[1050],dp[1050][1050];int dfs(int x,int y)//x代表的是收集到的骨头的个数&#123; //y代表的是当前背包剩余容量 if(x==n) return 0;//没有更多骨头可供收集了 if(dp[x][y]) return dp[x][y];//已经搜索过一次了，直接调用 int ans; if(y&lt;b[x]) ans=dfs(x+1,y);//当前骨头所占体积大于背包所剩体积，放不进去了，直接跳过 else ans=max(dfs(x+1,y),dfs(x+1,y-b[x])+a[x]);//能放进去，要分两种情况，放或不放，取最大值 return dp[x][y]=ans;&#125;int main()&#123; int t; cin&gt;&gt;t; while(t--) &#123; memset(dp,0,sizeof(dp)); cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; for(int i=0;i&lt;n;i++) cin&gt;&gt;b[i]; cout&lt;&lt;dfs(0,m)&lt;&lt;endl; &#125;&#125; FatMouse and CheeseDescription:有一种游戏是的玩法是这样的：有一个n*n的格子,每个格子有一个数字。遵循以下规则: 玩家每次可以由所在格子向上下左右四个方向进行直线移动，每次移动的距离不得超过m 玩家一开始在第一行第一列，并且已经获得该格子的分值 玩家获得每一次移动到的格子的分值 玩家下一次移动到达的格子的分值要比当前玩家所在的格子的分值要大。 游戏所有数字加起来也不大，保证所有数字的和不会超过int型整数的范围 玩家仅能在n*n的格子内移动，超出格子边界属于非法操作 当玩家不能再次移动时，游戏结束现在问你，玩家所能获得的最大得分是多少？ Input 有多组测试数据每组测试样例第一行是两个整数n,m (1≤n≤100)(1≤m≤100),当n和m都是-1时为程序结束标志，直接退出即可之后n行，每行n个数字，描述n*n的格子里的数字 Output 对于每组测试数据输出一行，这一行仅有一个整数，代表玩家所能获得的最高得分 Sample Input 3 11 2 510 11 612 12 7-1 -1 Sample Output 37 Problem solving:这道题跟滑雪那道题差不多，有一点不一样的就是这道题里面每次走的步数可以是不一样的并且范围给了我们。这样的话，仍然暴力搜索就行了。把每种步数都考虑进去可以这样实现123456789int d[4][2]=&#123;0,1,1,0,0,-1,-1,0&#125;;for(int i=0;i&lt;m;i++)&#123; for(int j=1;j&lt;=m;j++) &#123; int dx=x+d[i][0]*j; int dy=y+d[i][1]*j; &#125;&#125; 然后就跟滑雪那道题一样了。主要要用到记忆化搜索，不然会TLE Code:123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,ma[105][105],dp[105][105];int d[4][2]=&#123;1,0,0,1,-1,0,0,-1&#125;;int dfs(int x,int y)&#123; if(dp[x][y]) return dp[x][y]; int ans=0; for(int i=0;i&lt;4;i++) &#123; for(int j=1;j&lt;=m;j++) &#123; int dx=x+d[i][0]*j; int dy=y+d[i][1]*j; if(dx&gt;=0&amp;&amp;dy&gt;=0&amp;&amp;dx&lt;n&amp;&amp;dy&lt;n&amp;&amp;ma[dx][dy]&gt;ma[x][y]) &#123; ans=max(ans,dfs(dx,dy)); &#125; &#125; &#125; return dp[x][y]=ans+ma[x][y];&#125;int main()&#123; while(cin&gt;&gt;n&gt;&gt;m&amp;&amp;n!=-1&amp;&amp;m!=-1) &#123; memset(dp,0,sizeof(dp)); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) cin&gt;&gt;ma[i][j]; cout&lt;&lt;dfs(0,0)&lt;&lt;endl; &#125;&#125;]]></content>
      <categories>
        <category>Training</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>c/c++</tag>
        <tag>UVA</tag>
        <tag>dp</tag>
        <tag>dfs</tag>
        <tag>记忆化搜索</tag>
        <tag>hdu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HPU Summer Day 13(河南理工大学暑期第十三天)]]></title>
    <url>%2Fblog%2F2019%2F07%2F29%2Fd13%2F</url>
    <content type="text"><![CDATA[今天讲了一点关于DP的知识和几道例题，据说这样就算是入门了。今天的题怎么说呢？亏是之前做过，要是之前没做过，还真不知道该怎么写。dp就是玄学？今天的题很多都是需要灵光一现（或者百度解题的。具体的我也说不清，自己体会吧。（怎么能告诉你是因为我不会呢？ The King’s Ups and DownsDescription:The king has guards of all different heights. Rather than line them up in increasing or decreasing height order, he wants to line them up so each guard is either shorter than the guards next to him or taller than the guards next to him (so the heights go up and down along the line). For example, seven guards of heights 160, 162, 164, 166, 168, 170 and 172 cm. could be arranged as:or perhaps:The king wants to know how many guards he needs so he can have a different up and down order at each changing of the guard for rest of his reign. To be able to do this, he needs to know for a given number of guards, n, how many different up and down orders there are: For example, if there are four guards: 1, 2, 3,4 can be arrange as: 1324, 2143, 3142, 2314, 3412, 4231, 4132, 2413, 3241, 1423 For this problem, you will write a program that takes as input a positive integer n, the number of guards and returns the number of up and down orders for n guards of differing heights. Input The first line of input contains a single integer P, (1 &lt;= P &lt;= 1000), which is the number of data sets that follow. Each data set consists of single line of input containing two integers. The first integer, D is the data set number. The second integer, n (1 &lt;= n &lt;= 20), is the number of guards of differing heights. Output For each data set there is one line of output. It contains the data set number (D) followed by a single space, followed by the number of up and down orders for the n guards. Sample Input 41 12 33 44 20 Sample Output 1 12 43 104 740742376475050 Problem solving:这道题我是真的懵逼了。。。看这个大佬的解释吧:niuox题意是求1-n 的全排列中有多少呈现高低高低高低或者地高低高形式排列的个数。 这种排列叫做：alternating permutations 或者 Extremal Permutations 。 可以用DP做。 dp(n,k)表示：长度为n，最后一个数为k，最后两个数是递增的 排列的个数; dp2(n,k)表示：长度为n,最后一个数为k,最后两个数是递减的 排列的个数; 那么： dp(n,k) = dp2(n,n+1-k) ; 很好理解吧，比如说132(低高低)等价于312(高低高)，相对的位置加起来等于4. 那么我们针对dp[n][k]的最后一位进行如下考虑： 最后一位是k，因为dp[n][k]最后两个数字是递增的，所以第n-1位的最大值是k-1。那么我们很容易推导出DP方程： 又 所以：dp(n,k) = dp(n-1,n+1-k) + dp(n,k-1)；Code:1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=25;typedef long long ll;ll dp[maxn][maxn],ans[maxn];void init()&#123; dp[1][1]=1;ans[1]=1; for(int i=2;i&lt;=20;i++) &#123; for(int k=2;k&lt;=i;k++) &#123; dp[i][k]=dp[i-1][i+1-k]+dp[i][k-1]; ans[i]+=dp[i][k]; &#125; ans[i]*=2; &#125;&#125;int main()&#123; init(); int p,m,n; cin&gt;&gt;p; while(p--) &#123; cin&gt;&gt;m&gt;&gt;n; cout&lt;&lt;m&lt;&lt;&quot; &quot;&lt;&lt;ans[n]&lt;&lt;endl; &#125;&#125; 数塔Description:在讲述DP算法的时候，一个经典的例子就是数塔问题，它是这样描述的： 有如下所示的数塔，要求从顶层走到底层，若每一步只能走到相邻的结点，则经过的结点的数字之和最大是多少？已经告诉你了，这是个DP的题目，你能AC吗? Input 输入数据首先包括一个整数C,表示测试实例的个数，每个测试实例的第一行是一个整数N(1 &lt;= N &lt;= 100)，表示数塔的高度，接下来用N行数字表示数塔，其中第i行有个i个整数，且所有的整数均在区间[0,99]内。 Output 对于每个测试实例，输出可能得到的最大和，每个实例的输出占一行。 Sample Input 1573 88 1 02 7 4 44 5 2 6 5 Sample Output 30 Problem solving:挺简单的一道经典的dp的题。这道题我们可以倒着推，状态转移方程就是a[i][j]=max(a[i+1][j],a[i+1][j+1])+a[i][j]按照这个处理完之后直接输出a[1][1]即可 Code:1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 105;int c,n,a[maxn][maxn],ans[maxn][maxn];int main()&#123; cin&gt;&gt;c; while(c--) &#123; memset(ans,0,sizeof(ans)); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=i;j++) cin&gt;&gt;a[i][j]; &#125; for(int i=n-1;i&gt;=1;i--) &#123; for(int j=1;j&lt;=i;j++) &#123; a[i][j]=max(a[i+1][j],a[i+1][j+1])+a[i][j]; &#125; &#125; cout&lt;&lt;a[1][1]&lt;&lt;endl; &#125;&#125; 母牛的故事Description:有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛。请编程实现在第n年的时候，共有多少头母牛？Input 输入数据由多个测试实例组成，每个测试实例占一行，包括一个整数n(0&lt;n&lt;55)，n的含义如题目中描述。n=0表示输入数据的结束，不做处理。 Output 对于每个测试实例，输出在第n年的时候母牛的数量。每个输出占一行。 Sample Input 2450 Sample Output 246 Problem solving:经典题。每头小母牛从第四年开始就可以每年生一头小牛，所以第n年牛的个数即为a[n]=a[n-1]+a[n-3]即状态转移方程。a[n-1]代表的是上一年所有的母牛，a[n-3]代表的是上一年所有的母牛能生出来的小牛的个数。 Code:123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll ans[60];int main()&#123; ans[0]=0;ans[1]=1;ans[2]=2;ans[3]=3;ans[4]=4; for(int i=5;i&lt;60;i++) ans[i]=ans[i-1]+ans[i-3]; int n; while(cin&gt;&gt;n&amp;&amp;n) &#123; cout&lt;&lt;ans[n]&lt;&lt;endl; &#125;&#125; 一只小蜜蜂...Description:有一只经过训练的蜜蜂只能爬向右侧相邻的蜂房，不能反向爬行。请编程计算蜜蜂从蜂房a爬到蜂房b的可能路线数。其中，蜂房的结构如下所示。Input 输入数据的第一行是一个整数N,表示测试实例的个数，然后是N 行数据，每行包含两个整数a和b(0&lt;a&lt;b&lt;50)。 Output 对于每个测试实例，请输出蜜蜂从蜂房a爬到蜂房b的可能路线数，每个实例的输出占一行。 Sample Input 21 23 6 Sample Output 13 Problem solving:状态转移方程ans[i]=ans[i-1]+ans[i-2] 要到达一个蜂房，如果这个蜂房在第一排，只能从它左边的蜂房或者左下方的蜂房过来；如果这个蜂房在第二排，只能从它左边的蜂房或者左上方的蜂房过来。（摘自csdn） Code:1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll ans[55];int main()&#123; int n,a,b; cin&gt;&gt;n; ans[1]=1,ans[2]=1,ans[3]=2; for(int i=4;i&lt;50;i++) ans[i]=ans[i-1]+ans[i-2]; while(n--) &#123; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;ans[b-a+1]&lt;&lt;endl; &#125;&#125; 超级楼梯Description:有一楼梯共M级，刚开始时你在第一级，若每次只能跨上一级或二级，要走上第M级，共有多少种走法？Input 输入数据首先包含一个整数N，表示测试实例的个数，然后是N行数据，每行包含一个整数M（1&lt;=M&lt;=40）,表示楼梯的级数。 Output 对于每个测试实例，请输出不同走法的数量 Sample Input 223 Sample Output 12 Problem solving:每次能走一级台阶或者两级台阶。所以状态转移方程就是ans[i]=ans[i-1]+ans[i-2] Code:12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll ans[45];int main()&#123; ans[1]=0; ans[2]=1; ans[3]=2; for(int i=4;i&lt;=40;i++) ans[i]=ans[i-1]+ans[i-2]; int n,m; cin&gt;&gt;n; while(n--) &#123; cin&gt;&gt;m; cout&lt;&lt;ans[m]&lt;&lt;endl; &#125;&#125; TicketsDescription:现在有n个人要买电影票，如果知道每个人单独买票花费的时间，还有和前一个人一起买花费的时间，问最少花多长时间可以全部买完票。Input 给出 N(1&lt;=N&lt;=10)，表示有N组样例 给出K (1&lt;=K&lt;=2000)，表示有K个人买票.. 给出K个数表示这个人单独买票会花的时间..保证每个数 (0s&lt;=Si&lt;=25s) 给出K-1个数，表示这个人和前面那个人一起买票会花的时间..保证每个数 (0s&lt;=Si&lt;=50s) Output 对于每一组数据，你需要给出电影院售票结束的时间，售票开始的时间为 08:00:00 am. 时间格式为： HH:MM:SS am|pm. 具体看样例输出 Sample Input 2220 254018 Sample Output 08:00:40 am08:00:08 amProblem solving:这道题也是只要找到状态转移方程就行。状态转移方程ans[i]=min(ans[i-1]+s[i],ans[i-2]+d[i]);s[i]是一个人单独买票用的时间，d[i]是两个人一起买票用的时间 Code:1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=2005;int s[maxn],d[maxn],ans[maxn];int main()&#123; int n,k; cin&gt;&gt;n; while(n--) &#123; cin&gt;&gt;k; for(int i=1;i&lt;=k;i++) cin&gt;&gt;s[i]; for(int j=2;j&lt;=k;j++) cin&gt;&gt;d[j]; ans[1]=s[1]; for(int i=2;i&lt;=k;i++) &#123; ans[i]=min(ans[i-1]+s[i],ans[i-2]+d[i]); &#125; int time=ans[k];int h,m,s; h=time/3600; m=time%3600/60; s=time%3600%60; h+=8; if(h&lt;=12) printf(&quot;%02d:%02d:%02d am\n&quot;,h,m,s); else printf(&quot;%02d:%02d:%02d pm\n&quot;,h-12,m,s); &#125;&#125; 钱币兑换问题Description:在一个国家仅有1分，2分，3分硬币，将钱N兑换成硬币有很多种兑法。请你编程序计算出共有多少种兑法。Input 每行只有一个正整数N，N小于32768。 Output 对应每个输入，输出兑换方法数。 Sample Input 293412553 Sample Output 71883113137761 Problem solving:emm，这道题我之前在牛客上面遇见过一道类似的题。只不过那道题里面硬币的个数比这个多。直接套着板子写了、、、 这是个很基础的背包问题，怎么解释交给时间吧，等我理解了就把这个坑填上。 Code:123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=35000;ll ans[maxn];ll co[4]=&#123;1,2,3&#125;;ll solve(ll x)&#123; ans[0]=1; for(int i=0;i&lt;3;i++) &#123; for(int j=co[i];j&lt;=x;j++) &#123; ans[j]=(ans[j]+ans[j-co[i]]); &#125; &#125; return ans[x];&#125;int main()&#123; ll n; while(cin&gt;&gt;n) &#123; memset(ans,0,sizeof(ans)); cout&lt;&lt;solve(n)&lt;&lt;endl; &#125;&#125; Ignatius and the Princess IVDescription:给你n个数字，请你找出出现至少(n+1)/2次的数字。输入 本题包含多组数据，请处理到EOF：每组数据包含两行。第一行一个数字N(1&lt;=N&lt;=999999) ，保证N为奇数。第二行为N个用空格隔开的整数。 输出 对于每组数据，输出一行，表示要求找到的那个数 样例输入 51 3 2 3 3111 1 1 1 1 5 5 5 5 5 571 1 1 1 1 1 1 样例输出 351 Problem solving:这道题没啥说的，找就完了，可以边输入边查找。还有很多办法，比如说直接排序。还有dp的方法。 Code:123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;int n,flag[1000000];int main()&#123; while(cin&gt;&gt;n) &#123; int ans,a; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a; flag[a]++; if(flag[a]&gt;=(n+1)/2) ans=a; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125; 最少拦截系统Description:某国为了防御敌国的导弹袭击,发展出一种导弹拦截系统.但是这种导弹拦截系统有一个缺陷:虽然它的第一发炮弹能够到达任意的高度,但是以后每一发炮弹都不能超过前一发的高度.某天,雷达捕捉到敌国的导弹来袭.由于该系统还在试用阶段,所以只有一套系统,因此有可能不能拦截所有的导弹.怎么办呢?多搞几套系统呗!你说说倒蛮容易,成本呢?成本是个大问题啊.所以俺就到这里来求救了,请帮助计算一下最少需要多少套拦截系统.Input 输入若干组数据.每组数据包括:导弹总个数(正整数),导弹依此飞来的高度(雷达给出的高度数据是不大于30000的正整数,用空格分隔) Output 对应每组数据输出拦截所有导弹最少要配备多少套这种导弹拦截系统. Sample Input 8 389 207 155 300 299 170 158 65 Sample Output 2 Problem solving:这个题我一开始就没读懂。。。以后每一发炮弹都不能超过前一发的高度，所以这个就是求最大上升子序列的长度。给定排好序的一堆数列中，求其的LIS长度。它的LIS长度就是它非上升子序列的个数。我比较喜欢用这种nlog(n)的写法 这道题还有一个坑点就是如果此时一个数大于它前面那个数，那么拦截系统就要加一，但是并不代表前面那个系统就没用了。这样说比较抽象，举个栗子1100 60 80 20 50 我们来看一下，一开始我们选择100，大于60，换成了60，然后我们遇到了80，此时就需要一个新的系统了，然后现在是80，我们接着往下看遇到了20，再换成20，然后遇到了50，现在的50是大于20没错，但是上一个变成60的系统还可以使用，所以答案是2. 也就是因为这个所以不可以直接查找遇见大于前面那个数的情况就加一，这也是这个LIS以及dp的巧妙之处！ Code:12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5+10;const int INF = 0x3f3f3f3f;int a[maxn],dp[maxn],n;int main()&#123; int pos; while(cin&gt;&gt;pos) &#123; fill(dp,dp+pos,INF); for(int i=0;i&lt;pos;i++) cin&gt;&gt;a[i]; for(int i=0;i&lt;pos;i++) &#123; *lower_bound(dp,dp+pos,a[i])=a[i]; &#125; cout&lt;&lt;lower_bound(dp,dp+pos,INF)-dp&lt;&lt;endl; &#125;&#125;]]></content>
      <categories>
        <category>Training</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>c/c++</tag>
        <tag>DP</tag>
        <tag>HDU</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HPU Summer Day 12(河南理工大学暑期第十二天)]]></title>
    <url>%2Fblog%2F2019%2F07%2F28%2Fd12%2F</url>
    <content type="text"><![CDATA[今天休息一天，但是经过了昨天的自闭，我还是选择了在机房坐了大半天，写了不少水题，记录一下几道给我很大感触的题。 烤面包片Description:鸡尾酒最喜欢吃东北的烤面包片了。每次到东北地区的区域赛或者是秦皇岛的wannafly camp，鸡尾酒都会吃很多的烤面包片，即使比赛打铁也觉得不枉此行。 “我想吃烤面包片！！！”这不，半年没吃烤面包片的鸡尾酒看到大家都聚集在秦皇岛参加暑假camp，羡慕地发出了想要的声音。 当鸡尾酒“想要”的时候，他说的话会带三个感叹号来表示非常“想要”。至于有多“想要”，他给了你一个算式让你来体会。 给你两个整数 nn 和 modmod，输出 n!!!n!!! 对 modmod 求余的结果（每个!! 都代表一个阶乘符号） 输入描述 输入共一行包含两个整数依序为 n 和 mod，意义如题面所示。（0≤n≤1e9，1≤mod≤1e9） 输出描述 输出一个小于 mod的非负整数表示答案。 样例输入 1 2 6324 样例输出 1 2 样例输入 2 3 999999999 样例输出 2 731393874 提示 在第一个样例中，由于 2! = 22!=2，所以 2!!! = (((2!)!)!) = ((2!)!) = (2!) = 22!!!=(((2!)!)!)=((2!)!)=(2!)=2。2模了6324还是2！所以答案为2。 Problem solving:这道题一看就吓着我了，阶乘的阶乘的阶乘，这个数可以很大的。我已开始甚至想到了大数打表，但是那样的话时间复杂度也很不乐观，可是这道题过的人还那么多。 在我的师父——著名acmer——cc的讲解下我知道了这道题的解法。 如果n是1，或者是2，那么他们阶乘的阶乘就是本身。可以直接输出它本身对mod取模。n是0的情况跟n为1是一样的，因为0的阶乘是1嘛。如果n是3，按照题目中的方式计算即可。如果n&gt;=4,就会出现一个很nb的现象，4!!!是大于1e9很多的，也就是说此时的答案为0.为什么为0呢，因为n大于1e9，mod最大才是1e9，n的阶乘算的过程中一定会乘到一个跟mod相等的数，相等的数取模为0,0乘任何数都为0，所以答案是0. Code:1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll n,mod,nn=720;ll solve()&#123; if(n==0||n==1) return 1%mod; if(n==2) return 2%mod; if(n&gt;3) return 0; ll mid=1; for(ll i=1;i&lt;=nn;i++) &#123; mid*=i; mid%=mod; &#125; return mid;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;mod; n=solve(); cout&lt;&lt;n&lt;&lt;endl;&#125; 幂次方Description:任何一个正整数都可以用2的幂次方表示。例如：137=2^7+2^3+2^0同时约定方次用括号来表示，即ab可表示为a（b）。由此可知，137可表示为：2（7）+2（3）+2（0）进一步：7=2^2+2+2^0（2^1用2表示）3=2+2^0所以最后137可表示为：2（2（2）+2+2（0））+2（2+2（0））+2（0）又如：1315=2^10+2^8+2^5+2+1所以1315最后可表示为：2（2（2+2（0））+2）+2（2（2+2（0）））+2（2（2）+2（0））+2+2（0） 输入描述: 正整数（n ≤ 20000） 输出描述: 符合约定的n的0，2表示（在表示中不能有空格） 示例1输入 1315 输出 2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0) Problem solving:一开始想着用二进制形式表示，然后通过一些特殊的手段一直找1的位置，可以用bitset来实现，可是没写出来，希望如果有大佬会写的话教一下我，感激不尽。 然后我去百度了一下这道题，就被这道题巧妙地思路给震撼到了。通过递归实现。思路大概就是先找到小于当前数的最大的2的次方数，然后查找下一个2的次方数，这道题用到了递归，就会很抽象一项（像某fs一样令人脱发。不太好理解，多看看代码吧。说实话我也没很懂，啧啧啧 Code:123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;void solve(int n)&#123; if(n&gt;4) &#123; int t=1; while(pow(2,t)&lt;=n) t++; cout&lt;&lt;&quot;2(&quot;; solve(t-1); cout&lt;&lt;&quot;)&quot;; if(n!=pow(2,t-1)) cout&lt;&lt;&quot;+&quot;; solve(n-pow(2,t-1)); &#125; else switch(n) &#123; case 0:return ; case 1:cout&lt;&lt;&quot;2(0)&quot;; break; case 2:cout&lt;&lt;&quot;2&quot;; break; case 3:cout&lt;&lt;&quot;2+2(0)&quot;;break; case 4:cout&lt;&lt;&quot;2(2)&quot;; &#125;&#125;int main()&#123; int n; cin&gt;&gt;n; solve(n);&#125;]]></content>
      <categories>
        <category>Training</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>nowcoder</tag>
        <tag>Thinking </tag>
        <tag>comet oj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[河南理工大学算法协会暑期集训积分赛（二）]]></title>
    <url>%2Fblog%2F2019%2F07%2F27%2Fjifen2%2F</url>
    <content type="text"><![CDATA[积分赛，被打爆的积分赛（music 欢迎访问我校oj：hpuoj本场积分赛传送门: Uncle_drew is so handsome 再战斐波那契Description:小z 学会了斐波那契和 gcd 后，老师又给他出了个难题，求第N个和第M个斐波那契数的最大公约数，这可难倒了小z ，不过在小z 的再三请求下，老师又告诉他了个条件，gcd(N,M)∈[1,90]。可是，笨拙的小z 还是不会，于是请求你帮他解答这个问题。 已知: 输入格式输入包括 T 组，T∈[1,10].接下来 T 行,每行两个整数 N,M, 表示斐波那契的第 N 项和第 M 项，(N,M∈[1,1e18]). 输出格式输出包含 T 行,每行输出一个整数. 样例input 31 22 33 4 output 111 Problem solving:神tm签到题。。。这道题主要是有个规律斐波那契数列第M项和第N项的gcd就是斐波那契数列第gcd（m,n）项的值。即：gcd(f(m),f(n)) = f(gcd(m,n))顺便记一下long long可以存到大概第92项斐波那契数，unsigned一下会再多一项。Ps：我之前一直以为50项就爆long long了。。。如果知道这个92，那猜这个规律应该就挺简单了吧。而我是跑了N个循环找到的当时并不确定的规律。。。 Code：1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;unsigned long long a[100],x,y;int main()&#123; a[0]=0,a[1]=1; for(int i=2;i&lt;=100;i++) &#123; a[i]=a[i-1]+a[i-2]; &#125; int t; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;x&gt;&gt;y; cout&lt;&lt;a[__gcd(x,y)]&lt;&lt;endl; &#125;&#125; 恐怖的怪物Description:一天早上，Dicer一觉醒来，发现自己来到了MineCraft的世界里面，身为MineCraft游戏爱好者的他欣喜不已，于是他在地下挖了一片长方体的空间作为秘密基地，可是他发现光照亮度小于等于7时，会有恐怖的怪物出现，并且他通过查阅资料发现光源方块产生光照每一米（方格）衰减1光照等级。 此规律在坐标轴的3个方向上（东西、南北、上下）均成立。换句话来说，对角线方向的光照衰减依照“曼哈顿距离”（两个点在坐标系上的绝对轴距总和）计算。这意味着，假如地上插着一支火把（光照等级14），则在水平面上与火把相邻的4个方向的方格上光照等级均为13，而在水平面上与火把对角的4个方格上光照等级均为12（譬如，西北方格的光照等级为14-向西1级-向北1级）。 上述这种衰减特性会在光源周围产生菱形的照明。该效果会在光源周围的光源扩散呈钻石状。如果被不透明方块阻挡，光照也可以沿着复杂而弯曲的路径扩散。 如下图所示，红色为光源（亮度等级为14）,黑色为秘密物品，其余各个位置光照强度如图所示。 秘密基地为N∗M的空间，不考虑高度，初始地面光照强度为0。为了不生成恐怖的怪物，Dicer布置了一些光源，但他不知道是否仍会生成怪物，现在请你帮助Dicer判断。 注：光源及秘密物品均为不透明方块，且其上方均不会生成怪物。 输入格式第一行是一个T。（1≤T≤100）接下来有T组数据，每一组第一行是N,M,（1≤N,M≤1000）,接下来有N行，每行M个字符，代表秘密基地地面放置的方块，0代表空气，#代表秘密物品，Y代表萤石(光照等级为15)，H代表火把(光照等级为14)，F代表附魔台(光照等级为12)，R代表激活的红石火把(光照等级为7)。 输出格式输出包含T行，每行如果仍会生成怪物，输出”Yes”,否则输出”No”。 样例input 22 30Y000#3 4R00#00R00R00 output NoYes input 21 50Y0R02 4Y#0R0000 output YesNo input 15 4Y0F00000000000000000 output No Problem solving:简单？的bfs问题。就是条件有点多。。。比赛的时候写炸了 这道题给了5s，按理说只要查找写的对，就不会超时。我想了一下我的方法，应该是里面出现了死循环，咳咳。 这道题的难点就是每个点的亮度有可能源于两个点，而你肯定要取最大值。但是怎么取？我一开始直接用了max，然后就是一直tle，因为这样会出现死循环的情况，就是满足不了return的情况。后来看了学长的代码，吃了一惊，原来还可以这样写。 开三个队列，分别存储出现Y，H，F的位置。然后从存着Y的队列开始进行bfs，如果当前亮度是到了14，就把装有H的队列中的元素放入第一个队列继续bfs，12也是同理。这一点还挺好理解的。这样操作的话，每个点自然就是可以达到尽可能大的亮度。最后在判断有没有小于等于7的空地存在即可。 在今天之前我还一直以为我的bfs挺不错的。现在我觉得我连mc的资深玩家都不配当了。Code：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=1010;int t,n,m,l[maxn][maxn];char s[maxn][maxn];int d[4][2]=&#123;1,0,0,1,-1,0,0,-1&#125;;struct node&#123; int x,y;&#125;;queue&lt;node&gt; wo,yao,meizi;bool bfs()&#123; while(!wo.empty()) &#123; int x=wo.front().x; int y=wo.front().y; wo.pop(); if(l[x][y]==8) break; for(int i=0;i&lt;4;i++) &#123; int dx=x+d[i][0]; int dy=y+d[i][1]; if(dx&lt;0||dx&gt;=n||dy&lt;0||dy&gt;=m||s[dx][dy]!=&apos;0&apos;||l[dx][dy]) continue; l[dx][dy]=l[x][y]-1; wo.push(&#123;dx,dy&#125;); while(l[dx][dy]==14&amp;&amp;(!yao.empty())) &#123; wo.push(yao.front()); yao.pop(); &#125; while(l[dx][dy]==12&amp;&amp;(!meizi.empty())) &#123; wo.push(meizi.front()); meizi.pop(); &#125;// cout&lt;&lt;l[dx][dy]&lt;&lt;endl; &#125; &#125; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) if(l[i][j]&lt;=7&amp;&amp;s[i][j]==&apos;0&apos;) return 0; return 1;&#125;int main()&#123; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n&gt;&gt;m; while(!wo.empty()) wo.pop(); while(!yao.empty()) yao.pop(); while(!meizi.empty()) meizi.pop(); memset(l,0,sizeof(l)); for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;m;j++) &#123; cin&gt;&gt;s[i][j]; if(s[i][j]==&apos;Y&apos;) wo.push(&#123;i,j&#125;),l[i][j]=15; if(s[i][j]==&apos;H&apos;) yao.push(&#123;i,j&#125;),l[i][j]=14; if(s[i][j]==&apos;F&apos;) meizi.push(&#123;i,j&#125;),l[i][j]=12; &#125; &#125; if(bfs()) puts(&quot;No&quot;); else puts(&quot;Yes&quot;); &#125;&#125; 连连看Description:众所周知，《连连看》是一个老少皆宜的游戏。《连连看》是由黄兴武创作的一款PC端益智类游戏，只要将相同的两张牌用三根以内的线段连在一起就可以消除，规则简单容易上手。 现在呢，Boctorio学长突然想玩连连看了，但不是单纯的玩游戏，他想自己出一局连连看。由于Boctorio学长是一个蒟蒻，他不知道自己出的连连看是否符合能够通过多次操作将其全部消除，所以想要你帮他检查一下他出的连连看是否符合规则。 输入格式第一行输入个T,表示T组数据（1≤t≤100）每组数据第一行两个数 n,m ,表示连连看棋盘的长和宽（1≤n,m≤100）接下来 n 行，每行输入 m 个正整数aij，表示 m 个棋子 (1≤aij≤n∗m)。 每种棋子只会出现一对，因此数据保证只有一种有效结果。 输出格式每组数据输出一行。如果棋盘符合规定，输出”Yes”，否则，输出”No”（不包括引号）。 样例input 32 21 22 13 41 6 2 34 5 3 14 2 6 54 41 2 3 68 4 7 85 6 5 71 2 3 4 output NoNoYes Problem solving:暂无(毫无思路题) Code：123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * ┏┓ ┏┓ * ┏┛┗━━━━━━━┛┗━━━┓ * ┃ ┃ * ┃ ━ ┃ * ┃ ＞ ＜ ┃ * ┃ ┃ * ┃... ⌒ ... ┃ * ┃ ┃ * ┗━┓ ┏━┛ * ┃ ┃ Code is far away from bug with the animal protecting * ┃ ┃ 神兽保佑,代码无bug * ┃ ┃ * ┃ ┃ * ┃ ┃ * ┃ ┃ * ┃ ┗━━━┓ * ┃ ┣┓ * ┃ ┏┛ * ┗┓┓┏━┳┓┏┛ * ┃┫┫ ┃┫┫ * ┗┻┛ ┗┻┛ */// warm heart, wagging tail,and a smile just for you!//// _ooOoo_// o8888888o// 88&quot; . &quot;88// (| -_- |)// O\ = /O// ____/`---&apos;\____// .&apos; \| |// `.// / \||| : |||// \// / _||||| -:- |||||- \// | | \\ - /// | |// | \_| &apos;&apos;\---/&apos;&apos; | |// \ .-\__ `-` ___/-. /// ___`. .&apos; /--.--\ `. . __// .&quot;&quot; &apos;&lt; `.___\_&lt;|&gt;_/___.&apos; &gt;&apos;&quot;&quot;.// | | : `- \`.;`\ _ /`;.`/ - ` : | |// \ \ `-. \_ __\ /__ _/ .-` / /// ======`-.____`-.___\_____/___.-`____.-&apos;======// `=---=&apos;// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^// Points in rectangleDescription:在二维平面中有一个矩形，它的四个坐标点分别为(0,a),(a,0),(n,n−a),(n−a,n)。你现在有m个点，现在你想知道有多少个点是在这个矩形内的(边上的也算)。 输入格式第一行输入n,a(1≤a\&lt;n≤1e3)。第二行一个正整数m(1≤m≤1e3),代表你拥有的点的个数，接下来m行，每行一个点的坐标xi,yi(1≤xi,yi≤1e3)。 输出格式第一行输出在矩形内的点的个数，然后输出在矩形内点的坐标，横坐标大的优先，如果横坐标相同，则纵坐标大的优先。如果没有，输出−1。 样例input 6 151 21 32 33 44 5 output 44 53 42 31 2 Problem solving:也算是一道签到了吧，就是不太好想，不画一下的话。我的思路是把四条边的表达式写出来，对每个输入的x找出y的边界值然后进行比较。 如图所示，将图分为三部分，然后我们可以这样判断1.如果x，y中有一个大于n的，就说明这个点不会在矩形中2.x\&lt;a的时候，根据x的值求出直线表达式y1,y2所对应的值，此时y1的值就是下界，y2的值就是上界，如果y在y1和y2中间就说明这个点在矩阵中。3.x&gt;n-a的时候，跟上面一样不过此时上下界对应的值是y2和y44.x&gt;a &amp;&amp; x\&lt;n-a的时候，上下界对应的值是y3和y4 关于y1，y2,y3,y4的表达式本题中这个还是很好求得的y1=-x+a y2=x+ay3=-x+2*n-a y4=x-a 判断完用结构体排一下序输出即可。 Code：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;struct node&#123; int x,y;&#125;p[1005];bool cmp(node a,node b)&#123; if(a.x==b.x) return a.y&gt;b.y; return a.x&gt;b.x;&#125;int main()&#123; int n,a,m,x,y,pos=0; double s,k,sx,sy; cin&gt;&gt;n&gt;&gt;a&gt;&gt;m; for(int i=0;i&lt;m;i++) &#123; cin&gt;&gt;x&gt;&gt;y; if(x&gt;n||y&gt;n) continue; if(x&gt;=a&amp;&amp;x&lt;=n-a) &#123; if(y&gt;x+a||y&lt;x-a) continue; &#125; if(x&lt;a) &#123; if(y&gt;x+a||y&lt;-x+a) continue; &#125; if(x&gt;n-a) &#123; if(y&lt;x-a||y&gt;-x+2*n-a) continue; &#125; p[pos].x=x,p[pos].y=y; pos++; &#125; if(pos==0) puts(&quot;-1&quot;); else &#123; cout&lt;&lt;pos&lt;&lt;endl; sort(p,p+pos,cmp); for(int i=0;i&lt;pos;i++) &#123; cout&lt;&lt;p[i].x&lt;&lt;&apos; &apos;&lt;&lt;p[i].y&lt;&lt;endl; &#125; &#125;&#125; Numbers of intervalDescription: 输入格式第一行输入n,k(1≤n,k≤1e6).接下来输入n个数，第i个数为ai(1≤ai≤1e3). 输出格式输出满足条件的区间个数 样例input3 52 3 5output4 Problem solving:这道题做出来的人很多，我忘了lower_bound，用一个前缀和数组就行了。注意这道题的ans会爆int。这道题看了学长的题解和标程之后觉得自己明白的很透彻。然后跟一个同学交流这道题的时候发现自己也是没那么明白。不过现在还是很透彻的，记录一下。 主要需要理解的就是在你构造的前缀和数组中第n项到第m项的和为sum[m]-sum[n-1](注意是n-1，如果是n的话，那表示的就是第n+1项到第m项的和，因为你会把a[n]也减掉。 现在我们要查找区间和大于等于k的区间个数，因为是前缀和数组，所以构造出来的前缀和数组一定是有序的（升序。如果直接O(n*n)，1e6的数据范围肯定会超时。又正好看到数组是有序的，这时候就~很自然~的想到二分(虽然我并没有想到)。区间和大于等于k即a[m]-a[n-1]&gt;=k,所以我们先确定区间的左端点，然后二分查找到第一个使区间和大于等于k的右端点的值，此时我们找到的这个右端点的右面的每一个端点都可以跟那个确定的左端点组成一个区间和大于等于k的区间，查找所有点为左端点的情况，答案累加即可。唯一有点绕的就是sum[n]-sum[m-1]&gt;=k换成了sum[m-1]+k&lt;=sum[n]查找第一个符合要求的右端点可以这样写1lower_bound(sum+1,sum+n+1,k+a[i-1])-sum Code：1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;int a[1000050],p[1000050];int main()&#123; int n,k; cin&gt;&gt;n&gt;&gt;k; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i],p[i]=p[i-1]+a[i]; long long ans=0; for(int i=1;i&lt;=n;i++) &#123; int mid=lower_bound(p+1,p+1+n,p[i-1]+k)-p; ans+=(n-mid+1); &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125; 剪纸Description:中国剪纸是一种用剪刀或刻刀在纸上剪刻花纹，用于装点生活或配合其他民俗活动的民间艺术。在中国，剪纸具有广泛的群众基础，交融于各族人民的社会生活，是各种民俗活动的重要组成部分。其传承赓续的视觉形象和造型格式，蕴涵了丰富的文化历史信息，表达了广大民众的社会认以、道德观念、实践经验、生活理想和审美情趣，具有认知、教化、表意、抒情、娱乐、交往等多重社会价值。2006年5月20日，剪纸艺术遗产经国务院批准列入第一批国家级非物质文化遗产名录 。2009年9月28日至10月2日举行的联合国教科文组织保护非物质文化遗产政府间委员会第四次会议上，中国申报的中国剪纸项目入选“人类非物质文化遗产代表作名录”。 剪窗花最基本的操作为将剪纸进行多次对折，然后对对折之后的纸进行裁剪，展开后就是一个精美的艺术品。现在我们对问题进行化简，我们利用如下方法将一张形状矩形的纸按照对阵轴进行对折：假设剪后的形状为一个三角形，则展开效果为：现在给你一个对折两次且剪切后的图形，请你给出展开的图形形状。 输入格式多组输入，处理到文件结束。每组输入第一行两个数字n,m（1≤n,m≤100)。接下来n行，每行m个字符，表示对折且剪切后的图形。保证输入字符只包含 ‘.’ 和 ‘*’ 。 输出格式输出展开后的图形。 样例input12343 3**.*..... output123456........**...****..****...**........ Problem solving:签到题，搞清楚每个点的关系就行。（这个我写的可能是有点麻烦了，可以去看一下下面学长的标程 Code：1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;int n,m;char a[405][405];int main()&#123; while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;m)) &#123; for(int i=n;i&lt;2*n;i++) for(int j=m;j&lt;2*m;j++) cin&gt;&gt;a[i][j]; for(int i=n;i&lt;2*n;i++) &#123; for(int j=0;j&lt;m;j++) &#123; a[i][j]=a[i][2*m-j-1]; &#125; &#125; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;m;j++) &#123; a[i][j]=a[2*n-i-1][j]; &#125; &#125; for(int i=0;i&lt;n;i++) &#123; for(int j=m;j&lt;2*m;j++) &#123; a[i][j]=a[2*n-i-1][j]; &#125; &#125; for(int i=0;i&lt;2*n;i++) &#123; for(int j=0;j&lt;2*m;j++) cout&lt;&lt;a[i][j]; puts(&quot;&quot;); &#125; &#125;&#125; Fake hpuoj predictorDescription:总所周知，HPU(Harmonious and Peaceful University) Online Judge具有一个强大的的rating(积分)系统，它采用的是国际上权威的ELO等级分制度(ELO Rating System)，LOL，守望先锋,codeforces,topcoder等知名游戏的排行均是采用此制度。具体算法为：其中R(A)和R(B)为选手A和B初始的rating，那么E(A)和E(B)即为这两者进行对战后A和B各自获胜的期望。本场比赛的积分公式即为RA代表上轮比赛结束后的积分。K为积分系数,对于不同等级的选手的K是不同的。SA代表比赛实际总得分，对于每局比赛来说，每赢一个人就会加1分,输了不扣分。EAi代表A与第i个选手比赛获胜的期望。对于HPU Online Judge，用户等级表为:codancer有一个成为Grand Master的梦想，已知他的初始rating为0，他总共参加了m场比赛，对于每场比赛有一个榜单，对于codancer来说，排在他前面的人都打败了他，排在他后面的人都输给了他，因此你可以通过和每个参加比赛的选手比较计算出总得分SA和总期望∑EAi。那么最终codancer打完本场比赛后的rating为现在他打完了这m场比赛后他迫切的想知道自己的rating变为了多少(因为管理员太懒了，已经鸽了m场的rating计算了)，现在他想让你帮他写一个预测器来预测一下。 输入格式单组输入，第一行输入一个m(1≤m≤100)，代表codancer参加的比赛的数量。接下来对于每场比赛：第一行输入一个整数n代表有n(1≤n≤100)个人参加的比赛。接下来n行每行输入一个字符串和数字，代表参赛选手的用户名和他的rating，codancer即为他自己的用户名(用户名长度不超过20)，假如输入的名字为codancer,则不用输入数字(其他参赛选手的rating是不会更新的，因为管理员太懒了)。 输出格式输出codancer最终的rating，向上取整。 样例input 35tourist 2000capryang 1900boctorio 1800dicer 1800codancer2codancerrookie 2002wzy 1500codancer output 12 提示每计算完一场都需要向上取整，建议参与运算的变量都使用double。 Problem solving:这道题的难点就是读题。读懂了之后直接模拟就行了。学长说：写了就能过。。。然后我无限wa。最后借了学长的代码看了一下。也没发现有啥不一样的，可能就是精度问题吧。 Code：123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;double find(double x)&#123; if(x&lt;=1349) return 15; if(x&lt;=1499) return 20; if(x&lt;=1599) return 25; if(x&lt;=1699) return 30; if(x&lt;=1799) return 35; return 50;&#125;int main()&#123; int t; cin&gt;&gt;t; string s; double ra=0,rb; while(t--) &#123; int n; cin&gt;&gt;n; double ea=0,sum=0; double k=find(ra),sa=0; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;s; if(s==&quot;codancer&quot;) &#123; sa=n-i; continue; &#125; cin&gt;&gt;rb; ea=1.0/(1+pow(10,(rb-ra)/400)); sum+=ea; &#125; ra=ceil(ra+k*(sa-sum)); &#125; printf(&quot;%.0lf\n&quot;,ra);&#125; 花花与三猫CatliveDescription:“大佬”中分和“呆B”李白正在玩一个游戏，游戏规则是这样的： 游戏刚开始的时候，中分和李白相距L步，相对而望。 老父亲和老母亲手中各有一个M个面的均匀骰子。（也就是说可以随机生成[1,m]内的任意一个数字，且概率均等） 在每个回合开始的时候，老父亲和老母亲都会掷一下手中的骰子。 当老父亲的骰子掷到1的时候，中分可以向李白走一步。 当老母亲的骰子掷到m的时候，李白可以向中分走一步。 当中分和李白相遇的时候，游戏结束。 可是老父亲和老母亲刚刚拍完新节目，他们太累了，不想做这个游戏，但是他们还很想知道，这个游戏平均需要多少次才能结束。聪明的你，能告诉他们吗？ 结果是一个实数s，可以证明s能被表示成一个分数 qp，请输出q⋅p−1，其中q−1表示q在模109+7意义下的逆元。 输入格式第一行是一个正整数 T(1≤T≤1000)，表示测试样例的组数。接下来T行，每行两个正整数L,M(1≤L,M≤1000)，含义如题面描述。 输出格式输出包括T行，每行一个答案。 样例input 21 22 1 output 11 提示2在模109+7意义下的逆元是500000004Problem solving:这道题比赛的时候嫌题面太长我就没看。后来发现这就是一道水题。。。题意就是两个人的距离给出了是L，用一个m面的骰子掷一下，如果是1或者m，就会有人走一步，不用管是谁走，效果都是一样的。所以每次有人走一步的概率就是2/m，总共要走l步，让输出的就是l/（2/m），即l*m/2表面上这道题还让你求逆元，实际上这里我们用到的只有2的逆元，而且还给出了2在模1e9+7意义下的逆元。所以，是个水题。以后这种看见题面太长就不想看的坏毛病必须得改一下了。 Code：12345678910111213#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int t; cin&gt;&gt;t; long long n,m; while(t--) &#123; cin&gt;&gt;n&gt;&gt;m; cout&lt;&lt;n*m*500000004%1000000007&lt;&lt;endl; &#125;&#125; Same StringDescription:有两个只由小写字母组成的长度为n的字符串s1,s2和m组字母对应关系，每一组关系由两个字母c1和c2组成，代表c1可以直接变成c2,你需要判断s1是否可以通过这m组关系转换为s2。 输入格式第一行输入一个n(1≤n≤100)，代表字符串的长度。第二行和第三行输入两个字符串s1,s2。第四行输入一个m(1≤m≤325)，代表有m组关系。接下来m行，第i行两个字符ui,vi,代表ui可以直接变为vi。 输出格式如果s1可以通过这些m组关系转化变为s2，输出”YES”，否则输出”NO”。 样例input 6aabbcccdbcad4a cc aa db c output YES 提示可以转换多次，比如a可以转换为b，而b可以转换为c，则a可以转换为c。样例一：aabbcc-&gt;cabbcc-&gt;cdbbcc-&gt;cdbccc-&gt;cdbcac-&gt;cdbcaa-&gt;cdbcadProblem solving:这道题我是用存图做的，跟昨天专练里面的一道题很像，就不详细讲了。这道题还有另一种算法，可以看下面学长的标程Code：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;int mmp[50][50],vis[50];bool bfs(int x,int y)&#123; queue&lt;int&gt; q; q.push(x);vis[x]=1; while(!q.empty()) &#123; x=q.front();q.pop(); if(x==y) return 1; for(int i=0;i&lt;=26;i++) &#123; if(mmp[x][i]&amp;&amp;vis[i]==0) &#123; q.push(i); vis[i]=1; &#125; &#125; &#125; return 0;&#125;int main()&#123; int n,m;string a,b; char c,d; cin&gt;&gt;n&gt;&gt;a&gt;&gt;b&gt;&gt;m; for(int i=0;i&lt;m;i++) &#123; cin&gt;&gt;c&gt;&gt;d; int x=c-&apos;a&apos;,y=d-&apos;a&apos;; mmp[x][y]=1; &#125; int flag=0; for(int i=0;i&lt;n;i++) &#123; memset(vis,0,sizeof(vis)); if(bfs(a[i]-&apos;a&apos;,b[i]-&apos;a&apos;)==0) &#123; flag=1; break; &#125; &#125; if(flag) puts(&quot;NO&quot;); else puts(&quot;YES&quot;);&#125; 学长标程和题解再战斐波那契Problem solving:打表找规律会发现GCD(F(N),F(M))=F(GCD(N,M)) Code：1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longll f[10000];int main()&#123; ll n,m; f[1]=f[2]=1; for(int i=3;i&lt;=100;i++) f[i]=f[i-1]+f[i-2]; int t; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; scanf(&quot;%lld %lld&quot;,&amp;n,&amp;m); printf(&quot;%lld\n&quot;,f[__gcd(n,m)]); &#125; return 0;&#125; 恐怖的怪物Problem solving:对于每个有光源的点暴力的BFS每次BFS 更新各点光源的最大值不透明方块不需要更新 Code：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define pii pair&lt;int,int&gt;const int inf=0x3f3f3f3f;const ll INF=0x3f3f3f3f3f3f3f3f;const int maxn=1000+10;int t,n,m;char mp[maxn][maxn];int vis[maxn][maxn];int d[4][2]=&#123;1,0,-1,0,0,1,0,-1&#125;;queue&lt;pii&gt;H,F;queue&lt;pii&gt;que;void init()&#123; while(!que.empty()) que.pop(); while(!H.empty()) H.pop(); while(!F.empty()) F.pop(); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) vis[i][j]=0;&#125;bool BFS()&#123; while(!que.empty())&#123; int x=que.front().first; int y=que.front().second; que.pop(); if(vis[x][y]==8) break; for(int i=0;i&lt;4;i++)&#123; int xx=x+d[i][0]; int yy=y+d[i][1]; if(xx&lt;=0 || xx&gt;n || yy&lt;=0 || yy&gt;m || vis[xx][yy] || mp[xx][yy]!=&apos;0&apos;) continue; vis[xx][yy]=vis[x][y]-1; que.push(pii(xx,yy)); while(vis[xx][yy]==14 &amp;&amp; (!H.empty()))&#123; que.push(H.front()); H.pop(); &#125; while(vis[xx][yy]==12 &amp;&amp; (!F.empty()))&#123; que.push(F.front()); F.pop(); &#125; &#125; &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) if(vis[i][j]&lt;=7 &amp;&amp; mp[i][j]==&apos;0&apos;) return false; return true;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); init(); for(int i=1;i&lt;=n;i++)&#123; scanf(&quot;%s&quot;,mp[i]+1); for(int j=1;j&lt;=m;j++)&#123; if(mp[i][j]==&apos;Y&apos;) que.push(pii(i,j)),vis[i][j]=15 ;//15 if(mp[i][j]==&apos;H&apos;) H.push(pii(i,j)),vis[i][j]=14;//14 if(mp[i][j]==&apos;F&apos;) F.push(pii(i,j)),vis[i][j]=12;//12 &#125; &#125; if(BFS()) printf(&quot;No\n&quot;); else printf(&quot;Yes\n&quot;); &#125; return 0;&#125; 连连看Problem solving:dfs 瞎胡找即可，保存上一步的位置，上一步的方向，上一步为止的拐角数，然后处理一些复杂的情况可。由于只有三个条直线，只能拐两个弯，dfs 能够剪枝至很低的复杂度，标程大约为0.3s。（由于年代久远，其实出题人也不太记得这个题是不是有什么坑了。 Code：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint mp[200][200];int n,m;int sx,sy;int dir[4][2]=&#123;&#123;1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;;//分别对应下，右，左，上int check(int x,int y)&#123; if(x&lt;0 || x&gt;n+1 || y&lt;0 || y&gt;m+1) return 1; return 0;&#125;bool judge(int x,int y,int step,int pos)&#123;//pos表示上一步方向 if(step&gt;3) return 0;//如果超过了三步，不符合规则 if(mp[x][y]==mp[sx][sy] &amp;&amp; pos!=-1)&#123;//如果两个字符相等并且不是同一个（由于下面有方向限制，所以两个值不可能相等） mp[x][y]=0;//删去配对字符 mp[sx][sy]=0; return 1; &#125; if(mp[x][y]!=0 &amp;&amp; pos!=-1) return 0;//如果不相等并且不是通路，不符合规则 int i,x1,y1; for(i=0;i&lt;4;i++)&#123; if(i+pos==3) continue;//不能有正相反的方向 (0.下 3.上) (1.右 2.左) x1=x+dir[i][0]; y1=y+dir[i][1]; if(check(x1,y1)) continue;//检查是否越界 if(judge(x1,y1,step+(pos==i?0:1),i))&#123;//找到一个就返回 return 1; &#125; &#125; return 0;&#125;int main()&#123; int t,times,sum; int i,j; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); memset(mp,0,sizeof(mp)); for(i=1;i&lt;=n;i++)&#123; for(j=1;j&lt;=m;j++)&#123; scanf(&quot;%d&quot;,&amp;mp[i][j]); &#125; &#125; sum=0; times=0;//times表示查找的次数，大于等于n*m相当于查找一遍还没有找到 i=j=1; while(sum&lt;n*m &amp;&amp; times&lt;n*m)&#123; for(i=1;i&lt;=n;i++)&#123; for(j=1;j&lt;=m;j++)&#123; times++; sx=i,sy=j; if(mp[i][j]!=0 &amp;&amp; judge(i,j,0,-1))&#123; sum+=2; times=0; &#125; &#125; &#125; &#125; if(sum==n*m)&#123; printf(&quot;Yes\n&quot;); &#125; else&#123; printf(&quot;No\n&quot;); &#125; &#125; return 0;&#125; Points in rectangleProblem solving:对于给定的矩形，求出四个边的直线方程对于给定的点判断和四条直线的关系即可O(1) 的判断是否在矩形内统计完直接排序即可 Code：123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 2e3+100;struct point&#123; long long x,y; bool friend operator&lt;(point a,point b)&#123; if(a.x==b.x) return a.y&gt;b.y; return a.x&gt;b.x; &#125;&#125;p[N];long long n,a;bool check(point P)&#123; return -P.x+a&lt;=P.y&amp;&amp;-P.x+2*n-a&gt;=P.y&amp;&amp;P.x-a&lt;=P.y&amp;&amp;P.x+a&gt;=P.y;&#125;int main()&#123; //freopen(&quot;17.in&quot;,&quot;r&quot;,stdin); //freopen(&quot;17.out&quot;,&quot;w&quot;,stdout); vector&lt;point&gt; re; cin&gt;&gt;n&gt;&gt;a; int m; cin&gt;&gt;m; for(int i=1;i&lt;=m;i++)&#123; cin&gt;&gt;p[i].x&gt;&gt;p[i].y; if(check(p[i])) re.push_back(p[i]); &#125; sort(re.begin(),re.end()); if(re.empty())&#123; cout&lt;&lt;-1&lt;&lt;endl; &#125; else&#123; cout&lt;&lt;re.size()&lt;&lt;endl; for(auto v:re) cout&lt;&lt;v.x&lt;&lt;&apos; &apos;&lt;&lt;v.y&lt;&lt;endl; &#125; return 0;&#125; Numbers of intervalProblem solving:构造前缀和数组sum枚举l 然后二分最小的r，那么r 及其右边的都满足条件线性枚举即可, 复杂度O(nlog(n)) Code：12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6+100;typedef long long ll;long long a[N],sum[N];int main()&#123; int n,k; cin&gt;&gt;n&gt;&gt;k; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i],sum[i]=sum[i-1]+a[i]; long long ans=0; for(int l=1;l&lt;=n;l++)&#123; int id=lower_bound(sum+1,sum+n+1,k+sum[l-1])-sum; ans+=(n-id+1); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 剪纸Problem solving:开一个二维数组构造即可 Code：12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1000+10;int n,m,a;char str[1000+10][1000+10];int main()&#123; while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;m))&#123; for(int i=n;i&lt;n*2;i++)&#123; scanf(&quot;%s&quot;,str[i]+m); &#125; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; str[i][j]=str[n*2-1-i][j]=str[i][m*2-1-j]=str[n*2-1-i][m*2-1-j]; &#125; &#125; for(int i=0;i&lt;n*2;i++)&#123; for(int j=0;j&lt;m*2;j++)&#123; printf(&quot;%c&quot;,str[i][j]); &#125; printf(&quot;\n&quot;); &#125; &#125; return 0;&#125; Fake hpuoj predictorProblem solving:暴力算出codancer 实际的得分和期望得分根据他当前的rating 使用不同的K 更新rating每次更新完rating 向上取整 Code：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1000+10;int n,m,a;struct node&#123; char name[30]; double rating;&#125;p[maxn];double cal(double rating)&#123; if(rating&lt;1350) return 15.0; else if(rating&lt;1500) return 20.0; else if(rating&lt;1600) return 25.0; else if(rating&lt;1700) return 30.0; else if(rating&lt;1800) return 35.0; else return 50.0;&#125;double Rating(double rating)&#123; double k=cal(rating); double ea=0,sa=0; for(int i=0;i&lt;n;i++)&#123; if(strcmp(p[i].name,&quot;codancer&quot;)==0) continue; ea+=1.0/(1.0+pow(10,(p[i].rating-rating)/400.0)); &#125; for(int i=0;i&lt;n;i++)&#123; if(strcmp(p[i].name,&quot;codancer&quot;)==0)&#123; sa=n-1-i; break; &#125; &#125; double now_rating=rating+k*(sa-ea);// return now_rating; return ceil(now_rating);&#125;int main()&#123; int m; scanf(&quot;%d&quot;,&amp;m); double codancerNB_rating=0.0; while(m--)&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf(&quot;%s&quot;,p[i].name); if(strcmp(p[i].name,&quot;codancer&quot;)==0)&#123; p[i].rating=codancerNB_rating; continue; &#125; scanf(&quot;%lf&quot;,&amp;p[i].rating); &#125; codancerNB_rating=Rating(codancerNB_rating); &#125; printf(&quot;%.0lf\n&quot;,ceil(codancerNB_rating)); return 0;&#125; 花花与三猫CatliveProblem solving:每次每只猫能够向前走一步的概率为2/M答案即为L/（2/m）= LM/2 Code：1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;const int MOD = 1e9 + 7;int qpow(int a, int b, int mod)&#123; int res = 1; while(b)&#123; if(b&amp;1) res = 1LL * res * a % mod; a = 1LL * a * a % mod; b &gt;&gt;= 1; &#125; return res;&#125;int inv(int p, int mod)&#123; return qpow(p, mod - 2, mod);&#125;int main()&#123; int T; scanf(&quot;%d&quot;, &amp;T); int L, M; while(T--)&#123; scanf(&quot;%d %d&quot;, &amp;L, &amp;M); printf(&quot;%lld\n&quot;, 1LL * L * M * 500000004 % MOD); &#125;&#125; Same StringProblem solving:解法一: 对于m 组关系建好图，每次判断某个字母可否到达另一个字母解法二: 利用Warshall 可以O(263) 求出传递闭包然后O(1的判断可达性 Code：123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6+100;typedef long long ll;bool f[26][26];int main()&#123; // for(int it=1;it&lt;=40;it++)&#123; // memset(f,0,sizeof(f)); // Create_InFiles(it); // Create_OutFiles(it); int n,m; string s1,s2; cin&gt;&gt;n&gt;&gt;s1&gt;&gt;s2; cin&gt;&gt;m; char u,v; for(int i=1;i&lt;=m;i++)&#123; cin&gt;&gt;u&gt;&gt;v; f[u-&apos;a&apos;][v-&apos;a&apos;]=1; &#125; for(int j=0;j&lt;26;j++)&#123; for(int i=0;i&lt;26;i++)&#123; for(int k=0;k&lt;26;k++)&#123; f[i][k]|=(f[i][j]&amp;f[j][k]); &#125; &#125; &#125; bool check=0; for(int i=0;i&lt;n;i++)&#123; if(s1[i]!=s2[i])&#123; if(f[s1[i]-&apos;a&apos;][s2[i]-&apos;a&apos;]==0)&#123; check=1;break; &#125; &#125; &#125; if(check)&#123; puts(&quot;NO&quot;); &#125; else puts(&quot;YES&quot;); // &#125; return 0;&#125;]]></content>
      <categories>
        <category>Training</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>greedy</tag>
        <tag>inverse-modulo</tag>
        <tag>BFS</tag>
        <tag>gcd</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HPU Summer Day 11(河南理工大学暑期第十一天)]]></title>
    <url>%2Fblog%2F2019%2F07%2F27%2Fd11%2F</url>
    <content type="text"><![CDATA[一不留神，暑期集训的三分之一就过去了。开始集训的第十一天，举办了第二次积分赛，这次学长还开了网上的同步赛，打完也是挺自闭的。唉，好好学习，明天休息，收拾一下，没啥事还是敲代码吧。。。]]></content>
      <categories>
        <category>Training</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HPU Summer Training Day 10(河南理工大学暑期第十天)]]></title>
    <url>%2Fblog%2F2019%2F07%2F26%2Fd10%2F</url>
    <content type="text"><![CDATA[今天没讲题，加练，没啥好说的，除了脑仁疼就是脑仁疼。还有两道似乎是用到DFS的是真的写不出来了。慢慢补吧。 Knight MovesDescription:BackgroundMr Somurolov, fabulous chess-gamer indeed, asserts that no one else but him can move knights from one position to another so fast. Can you beat him?The ProblemYour task is to write a program to calculate the minimum number of moves needed for a knight to reach one point from another, so that you have the chance to be faster than Somurolov.For people not familiar with chess, the possible knight moves are shown in Figure 1. Input The input begins with the number n of scenarios on a single line by itself.Next follow n scenarios. Each scenario consists of three lines containing integer numbers. The first line specifies the length l of a side of the chess board (4 &lt;= l &lt;= 300). The entire board has size l l. The second and third line contain pair of integers {0, ..., l-1}\{0, ..., l-1} specifying the starting and ending position of the knight on the board. The integers are separated by a single blank. You can assume that the positions are valid positions on the chess board of that scenario. Output For each scenario of the input you have to calculate the minimal amount of knight moves which are necessary to move from the starting point to the ending point. If starting point and ending point are equal,distance is zero. The distance must be written on a single line. Sample Input 380 07 01000 030 50101 11 1 Sample Output 5280 Problem solving:简单的BFS模板题，8个方向查找即可。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;struct node&#123; int x,y;&#125;;const int maxn=305;int vis[maxn][maxn];int step[maxn][maxn];int n,m,sx,sy,ex,ey;int d[8][2]=&#123;2,1,1,2,-1,2,-2,1,-2,-1,-1,-2,1,-2,2,-1&#125;;void bfs()&#123; queue&lt;node&gt; q; node now,mid; vis[sx][sy]=1; now.x=sx,now.y=sy; q.push(now); while(!q.empty()) &#123; mid=q.front(); q.pop(); for(int i = 0 ;i&lt;8;i++) &#123; now.x=mid.x+d[i][0]; now.y=mid.y+d[i][1]; if(now.x&lt;0||now.x&gt;=m||now.y&lt;0||now.y&gt;=m||vis[now.x][now.y]) continue; vis[now.x][now.y]=1; step[now.x][now.y]=step[mid.x][mid.y]+1; q.push(now); &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n; while(n--) &#123; memset(vis,0,sizeof(vis)); memset(step,0,sizeof(step)); cin&gt;&gt;m&gt;&gt;sx&gt;&gt;sy&gt;&gt;ex&gt;&gt;ey; bfs(); cout&lt;&lt;step[ex][ey]&lt;&lt;endl; &#125;&#125; 变形课Description:呃......变形课上Harry碰到了一点小麻烦,因为他并不像Hermione那样能够记住所有的咒语而随意的将一个棒球变成刺猬什么的,但是他发现了变形咒语的一个统一规律:如果咒语是以a开头b结尾的一个单词,那么它的作用就恰好是使A物体变成B物体.Harry已经将他所会的所有咒语都列成了一个表,他想让你帮忙计算一下他是否能完成老师的作业,将一个B(ball)变成一个M(Mouse),你知道,如果他自己不能完成的话,他就只好向Hermione请教,并且被迫听一大堆好好学习的道理.Input 测试数据有多组。每组有多行，每行一个单词,仅包括小写字母,是Harry所会的所有咒语.数字0表示一组输入结束. Output 如果Harry可以完成他的作业,就输出&quot;Yes.&quot;,否则就输出&quot;No.&quot;(不要忽略了句号) Sample Input sosoonrivergoesthemgotmoonbeginbig0 Sample Output Yes. Harry 可以念这个咒语:&quot;big-got-them&quot;. Problem solving:这道题我的想法是用邻接表存图，把输入的每一个单词的首字母与最后一个字母当成两个节点，并且是有向边，然后bfs以&#39;b&#39;为起点查找如果能找到&#39;m&#39;与它相连，就输出Yes，反之输出&#39;No&#39;.这道题还有一个很难受的地方就是输入、、、多组套多组，里面的多组还有结束条件。不过写完这道题也算是学会了，这样写就行。1234567while(cin&gt;&gt;s)&#123; while(s!=&apos;0&apos;) &#123; cin&gt;&gt;s; &#125;&#125; Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;int ma[100][100],vis[100];bool bfs(int x)&#123; queue&lt;int&gt; q; q.push(x); vis[x]=1; while(!q.empty()) &#123; x=q.front(); if(x==&apos;m&apos;-&apos;0&apos;) return 1; q.pop(); for(int i=&apos;a&apos;-&apos;0&apos;;i&lt;=&apos;z&apos;-&apos;0&apos;;i++) &#123; if(ma[x][i]==1&amp;&amp;!vis[i]) &#123; vis[i]=1;// cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;endl;// cout&lt;&lt;ma[x][i]&lt;&lt;&quot;?&quot;&lt;&lt;ma[i][x]&lt;&lt;endl; q.push(i); &#125; &#125; &#125; return 0;&#125;int main()&#123; string s; while(cin&gt;&gt;s) &#123; memset(ma,0,sizeof(ma)); memset(vis,0,sizeof(vis)); while(s!=&quot;0&quot;) &#123; char sx=s[0],ex=s[s.size()-1];// cout&lt;&lt;sx-&apos;0&apos;&lt;&lt;&quot; &quot;&lt;&lt;ex-&apos;0&apos;&lt;&lt;endl; ma[sx-&apos;0&apos;][ex-&apos;0&apos;]=1; cin&gt;&gt;s; &#125; if(bfs(&apos;b&apos;-&apos;0&apos;)) puts(&quot;Yes.&quot;); else puts(&quot;No.&quot;); &#125;&#125; PetDescription:一天早上小明醒来时发现他的宠物仓鼠不见了。 他在房间寻找但是没找到仓鼠。 他想用奶酪诱饵去找回仓鼠。 他把奶酪诱饵放在房间并且等待了好几天。 但是可怜的小明除了老鼠和蟑螂没见到任何东西。 他找到学校的地图发现地图上没有环路，并且学校里的每个站点都可以从他的房间到达。 奶酪诱饵的手册提到在距离D之内宠物必定会被吸引回来. 你的任务是帮助小明从给定的地图中有多少可能的站点是仓鼠的藏身处. 假定仓鼠一直藏在学校的某个站点并且两个相邻站点间的距离都是1个单位。Input 输入包含多组数据。 第一行一个整数T (0&lt;T&lt;=10), 表示测试数据的组数。 每组数据, 第一行包含两个整数 N (0&lt;N&lt;=100000) 和 D(0&lt;D&lt;N). N 是学校里的站点数， D 是诱饵的影响距离。 下面 N-1行为地图描述, 每行一对 x 和 y(0&lt;=x,y&lt;N), 用一个空格隔开, 表示x和y两个站点是相邻的。小明的房间用0表示。 Output 对于每组数据，输出可能找到仓鼠的站点数。Sample Input110 20 10 20 31 41 52 63 74 86 9 Sample Output 2 Problem solving:题意还挺好理解的，就是问你一个图距离顶点距离大于某一值得点有多少个。构建一个图，因为现在已经知道了0是顶点，直接从0开始bfs查找，找出每个点距离0的最远距离，与给的定值进行比较即可。注意多组输入每次需要初始化（我因为这个WA了一发。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int maxn=1e5+10;vector&lt;int&gt; v[maxn];int dis[maxn],vis[maxn],ans;using namespace std;int n,d,t,x,y;void bfs(int x)&#123; queue&lt;int&gt; q; q.push(x); vis[x]=1;dis[x]=0; while(!q.empty()) &#123; x=q.front(); q.pop(); for(int i=0;i&lt;v[x].size();i++) &#123; if(v[x][i]&amp;&amp;!vis[v[x][i]]) &#123; q.push(v[x][i]); vis[v[x][i]]=1; dis[v[x][i]]=dis[x]+1; &#125; &#125; &#125;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; memset(vis,0,sizeof(vis)); memset(dis,0,sizeof(dis)); ans=0; scanf(&quot;%d %d&quot;,&amp;n,&amp;d); for(int i=0;i&lt;n;i++) v[i].clear(); for(int i=1;i&lt;n;i++) &#123; scanf(&quot;%d %d&quot;,&amp;x,&amp;y); v[x].push_back(y); v[y].push_back(x); &#125; bfs(0); for(int i=0;i&lt;n;i++) &#123; if(dis[i]&gt;d) ans++; &#125; printf(&quot;%d\n&quot;,ans); &#125;&#125; 蜘蛛牌Description:蜘蛛牌是windows xp操作系统自带的一款纸牌游戏，游戏规则是这样的：只能将牌拖到比她大一的牌上面（A最小，K最大），如果拖动的牌上有按顺序排好的牌时，那么这些牌也跟着一起移动，游戏的目的是将所有的牌按同一花色从小到大排好，为了简单起见，我们的游戏只有同一花色的10张牌，从A到10，且随机的在一行上展开，编号从1到10，把第i号上的牌移到第j号牌上，移动距离为abs(i-j)，现在你要做的是求出完成游戏的最小移动距离。Input 第一个输入数据是T，表示数据的组数。每组数据有一行，10个输入数据，数据的范围是[1,10]，分别表示A到10，我们保证每组数据都是合法的。 Output 对应每组数据输出最小移动距离。 Sample Input 11 2 3 4 5 6 7 8 9 10 Sample Output 9 Problem solving:暂无（毫无思路题，据说是dfs） Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * ┏┓ ┏┓ * ┏┛┗━━━━━━━┛┗━━━┓ * ┃ ┃ * ┃ ━ ┃ * ┃ ＞ ＜ ┃ * ┃ ┃ * ┃... ⌒ ... ┃ * ┃ ┃ * ┗━┓ ┏━┛ * ┃ ┃ Code is far away from bug with the animal protecting * ┃ ┃ 神兽保佑,代码无bug * ┃ ┃ * ┃ ┃ * ┃ ┃ * ┃ ┃ * ┃ ┗━━━┓ * ┃ ┣┓ * ┃ ┏┛ * ┗┓┓┏━┳┓┏┛ * ┃┫┫ ┃┫┫ * ┗┻┛ ┗┻┛ */// warm heart, wagging tail,and a smile just for you!//// _ooOoo_// o8888888o// 88&quot; . &quot;88// (| -_- |)// O\ = /O// ____/`---&apos;\____// .&apos; \| |// `.// / \||| : |||// \// / _||||| -:- |||||- \// | | \\ - /// | |// | \_| &apos;&apos;\---/&apos;&apos; | |// \ .-\__ `-` ___/-. /// ___`. .&apos; /--.--\ `. . __// .&quot;&quot; &apos;&lt; `.___\_&lt;|&gt;_/___.&apos; &gt;&apos;&quot;&quot;.// | | : `- \`.;`\ _ /`;.`/ - ` : | |// \ \ `-. \_ __\ /__ _/ .-` / /// ======`-.____`-.___\_____/___.-`____.-&apos;======// `=---=&apos;// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^// 逃离迷宫Description:给定一个m × n (m行, n列)的迷宫，迷宫中有两个位置，gloria想从迷宫的一个位置走到另外一个位置，当然迷宫中有些地方是空地，gloria可以穿越，有些地方是障碍，她必须绕行，从迷宫的一个位置，只能走到与它相邻的4个位置中,当然在行走过程中，gloria不能走到迷宫外面去。令人头痛的是，gloria是个没什么方向感的人，因此，她在行走过程中，不能转太多弯了，否则她会晕倒的。我们假定给定的两个位置都是空地，初始时，gloria所面向的方向未定，她可以选择4个方向的任何一个出发，而不算成一次转弯。gloria能从一个位置走到另外一个位置吗？Input 第1行为一个整数t (1 ≤ t ≤ 100),表示测试数据的个数，接下来为t组测试数据，每组测试数据中， 第1行为两个整数m, n (1 ≤ m, n ≤ 100),分别表示迷宫的行数和列数，接下来m行，每行包括n个字符，其中字符&#39;.&#39;表示该位置为空地，字符&#39;*&#39;表示该位置为障碍，输入数据中只有这两种字符，每组测试数据的最后一行为5个整数k, x 1, y 1, x 2, y 2 (1 ≤ k ≤ 10, 1 ≤ x 1, x 2 ≤ n, 1 ≤ y 1, y 2 ≤ m),其中k表示gloria最多能转的弯数，(x 1, y 1), (x 2, y 2)表示两个位置，其中x 1，x 2对应列，y 1, y 2对应行。 Output 每组测试数据对应为一行，若gloria能从一个位置走到另外一个位置，输出“yes”，否则输出“no”。 Sample Input 25 5...*................1 1 1 1 35 5...** .*........... ....2 1 1 1 3 Sample Output noyes Problem solving:这也是一道查找的题，给了你起点和终点和最大拐弯次数，问你能不能从起点走到终点。我选择了bfs，其实是一道挺简单的题，难点就是如何得到当前转弯的次数。我一开始想着用x，y坐标的差值来表示，但是又麻烦又不好理解。然后我在网上看到了一种写法。就是在bfs的过程中，每选择了一个方向就按照这个方向一直走下去直到越界或者到了走不了的点。这一步描述的如果你不是很懂，可以参考一下下面代码我加上的注释。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,t,sx,sy,ex,ey,k;char s[105][105];int vis[105][105];struct node&#123; int x,y,flag;//flag就是用来存当前的拐弯次数&#125;;int d[4][2]=&#123;1,0,0,1,0,-1,-1,0&#125;;bool bfs()&#123; queue&lt;node&gt; q; node now,mid; now.x=sx,now.y=sy,now.flag=-1;//初始的转弯次数设为-1是因为第一次走是不算入转弯次数的 vis[sx][sy]=1; q.push(now); while(!q.empty()) &#123;// cout&lt;&lt;&quot;?&quot;; now=q.front(); q.pop(); if(now.flag&gt;=k) continue;//如果此时转弯次数已经大于k了，就没有走下去的必要了。这一点在这种写法中很重要 for(int i=0;i&lt;4;i++) &#123; mid.x=now.x+d[i][0]; mid.y=now.y+d[i][1]; mid.flag=now.flag+1;//此时你选择了一个方向 while(1)//沿着这个方向一直走下去 &#123; if(mid.x&lt;0||mid.x&gt;=n||mid.y&lt;0||mid.y&gt;=m||s[mid.x][mid.y]==&apos;*&apos;) break;//如果越界了或者不能走了，就说明沿着这个方向一直走走不下去了，break就行 if(mid.x==ex&amp;&amp;mid.y==ey) return 1;//如果当前走到的点与终点相等，就说明可以走到，返回true if(vis[mid.x][mid.y]==0) &#123; vis[mid.x][mid.y]=1; q.push(mid); &#125; mid.x+=d[i][0];//沿着这个方向更新到下一个走到的点的x，y坐标 mid.y+=d[i][1]; &#125; &#125; &#125; return 0;&#125;int main()&#123; cin&gt;&gt;t; while(t--) &#123; memset(vis,0,sizeof(vis)); cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) cin&gt;&gt;s[i]; cin&gt;&gt;k&gt;&gt;sy&gt;&gt;sx&gt;&gt;ey&gt;&gt;ex;//这有个坑，它先输入的是y的值 sx--,sy--,ex--,ey--; if(bfs()) puts(&quot;yes&quot;); else puts(&quot;no&quot;); &#125;&#125; Kaitou Kid - The Phantom Thief (2)Description:破解字迷之后，你得知Kid将会在展览开始后T分钟内盗取至少一颗宝石，并离开展馆。整个展馆呈矩形分布，划分为N*M个区域，有唯一的入口和出口（不能从出口进入，同样不能从入口出去）。由某个区域可直接移动至相邻四个区域中的一个，且最快需要一分钟。假设Kid进入放有宝石的区域即可盗取宝石，无需耗时。问至少要封锁几个区域（可以封锁放有宝石的区域，但不能封锁入口和出口）才能保证Kid无法完成任务。Input 输入的第一行有一个整数C，代表有C组测试数据。每组测试数据的第一行有三个整数N，M，T(2&lt;=N,M&lt;=8,T&gt;0)。接下来N行M列为展馆布置图，其中包括：&#39;S&#39;：入口&#39;E&#39;：出口&#39;J&#39;：放有宝石的区域，至少出现一次&#39;.&#39;：空白区域&#39;#&#39;：墙 Output 对每组测试数据，输出至少要封锁的区域数。 Sample Input 25 5 5SJJJJ..##J.JJJJ.J...EJ...5 5 6SJJJJ..##J.JJJJ.J...EJ... Sample Output 02 Problem solving:暂无（据说是bfs+dfs） Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * ┏┓ ┏┓ * ┏┛┗━━━━━━━┛┗━━━┓ * ┃ ┃ * ┃ ━ ┃ * ┃ ＞ ＜ ┃ * ┃ ┃ * ┃... ⌒ ... ┃ * ┃ ┃ * ┗━┓ ┏━┛ * ┃ ┃ Code is far away from bug with the animal protecting * ┃ ┃ 神兽保佑,代码无bug * ┃ ┃ * ┃ ┃ * ┃ ┃ * ┃ ┃ * ┃ ┗━━━┓ * ┃ ┣┓ * ┃ ┏┛ * ┗┓┓┏━┳┓┏┛ * ┃┫┫ ┃┫┫ * ┗┻┛ ┗┻┛ */// warm heart, wagging tail,and a smile just for you!//// _ooOoo_// o8888888o// 88&quot; . &quot;88// (| -_- |)// O\ = /O// ____/`---&apos;\____// .&apos; \| |// `.// / \||| : |||// \// / _||||| -:- |||||- \// | | \\ - /// | |// | \_| &apos;&apos;\---/&apos;&apos; | |// \ .-\__ `-` ___/-. /// ___`. .&apos; /--.--\ `. . __// .&quot;&quot; &apos;&lt; `.___\_&lt;|&gt;_/___.&apos; &gt;&apos;&quot;&quot;.// | | : `- \`.;`\ _ /`;.`/ - ` : | |// \ \ `-. \_ __\ /__ _/ .-` / /// ======`-.____`-.___\_____/___.-`____.-&apos;======// `=---=&apos;// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^// A计划Description:可怜的公主在一次次被魔王掳走一次次被骑士们救回来之后，而今，不幸的她再一次面临生命的考验。魔王已经发出消息说将在T时刻吃掉公主，因为他听信谣言说吃公主的肉也能长生不老。年迈的国王正是心急如焚，告招天下勇士来拯救公主。不过公主早已习以为常，她深信智勇的骑士LJ肯定能将她救出。现据密探所报，公主被关在一个两层的迷宫里，迷宫的入口是S（0，0，0），公主的位置用P表示，时空传输机用#表示，墙用*表示，平地用.表示。骑士们一进入时空传输机就会被转到另一层的相对位置，但如果被转到的位置是墙的话，那骑士们就会被撞死。骑士们在一层中只能前后左右移动，每移动一格花1时刻。层间的移动只能通过时空传输机，且不需要任何时间。Input 输入的第一行C表示共有C个测试数据，每个测试数据的前一行有三个整数N，M，T。 N，M迷宫的大小NM（1 &lt;= N,M &lt;=10)。T如上所意。接下去的前NM表示迷宫的第一层的布置情况，后N*M表示迷宫第二层的布置情况。 Output 如果骑士们能够在T时刻能找到公主就输出“YES”，否则输出“NO”。 Sample Input 15 5 14S#..#........**....#...*.P #...**...... .#.. Sample Output YES Problem solving:哇，这道题坑的一批。最后玄学过题就是个三维的bfs，而且给定了只有两层。因为遇到传送门进行传送的时候是不需要耗费时间的，所以传送门那需要特殊处理一下（可以想一下，如果传送门传送过去的位置还是传送门，就成死循环了。如果传送门传送过去是墙，也可以直接看做这个传送门是一堵墙） Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;using namespace std;int c,n,m,t;struct node&#123; int x,y,z,step;&#125;;int d[4][2]=&#123;1,0,0,1,0,-1,-1,0&#125;,vis[2][15][15],flag;char s[2][15][15];node now,mid,meizi;void bfs()&#123; queue&lt;node&gt; q; q.push(now); vis[now.x][now.y][now.z]=1; while(!q.empty()) &#123; mid=q.front(); q.pop(); if(s[mid.x][mid.y][mid.z]==&apos;P&apos;&amp;&amp;mid.step&lt;=t) &#123; flag=1; return ; &#125; for(int i=0;i&lt;4;i++) &#123; meizi=mid; meizi.y+=d[i][0]; meizi.z+=d[i][1]; meizi.step+=1; if(meizi.step&gt;t||meizi.y&lt;0||meizi.y&gt;=n||meizi.z&lt;0||meizi.z&gt;=m||vis[meizi.x][meizi.y][meizi.z]||s[meizi.x][meizi.y][meizi.z]==&apos;*&apos;) continue; vis[meizi.x][meizi.y][meizi.z]=1; if(s[meizi.x][meizi.y][meizi.z]==&apos;#&apos;&amp;&amp;s[(meizi.x+1)%2][meizi.y][meizi.z]!=&apos;*&apos;&amp;&amp;!vis[(meizi.x+1)%2][meizi.y][meizi.z]) meizi.x=(meizi.x+1)%2; q.push(meizi); &#125; &#125;&#125;int main()&#123; cin&gt;&gt;c; while(c--) &#123; memset(vis,0,sizeof(vis)); cin&gt;&gt;n&gt;&gt;m&gt;&gt;t; for(int i=0;i&lt;2;i++) &#123; for(int j=0;j&lt;n;j++) &#123; for(int k=0;k&lt;m;k++) &#123; cin&gt;&gt;s[i][j][k]; if(s[i][j][k]==&apos;S&apos;) &#123; now.x=i,now.y=j,now.z=k,now.step=0; &#125; &#125; &#125; &#125; for(int j=0;j&lt;n;j++) &#123; for(int k=0;k&lt;m;k++) &#123; if(s[0][j][k]==&apos;#&apos;&amp;&amp;s[1][j][k]==&apos;*&apos;) &#123; s[0][j][k]=s[1][j][k]=&apos;*&apos;; &#125; if(s[0][j][k]==&apos;*&apos;&amp;&amp;s[1][j][k]==&apos;#&apos;) &#123; s[0][j][k]=s[1][j][k]=&apos;*&apos;; &#125; if(s[0][j][k]==&apos;#&apos;&amp;&amp;s[1][j][k]==&apos;#&apos;) &#123; s[0][j][k]=s[1][j][k]=&apos;*&apos;; &#125; &#125; &#125; flag=0; bfs(); if(flag) puts(&quot;YES&quot;); else puts(&quot;NO&quot;); &#125;&#125; NightmareDescription:Ignatius had a nightmare last night. He found himself in a labyrinth with a time bomb on him. The labyrinth has an exit, Ignatius should get out of the labyrinth before the bomb explodes. The initial exploding time of the bomb is set to 6 minutes. To prevent the bomb from exploding by shake, Ignatius had to move slowly, that is to move from one area to the nearest area(that is, if Ignatius stands on (x,y) now, he could only on (x+1,y), (x-1,y), (x,y+1), or (x,y-1) in the next minute) takes him 1 minute. Some area in the labyrinth contains a Bomb-Reset-Equipment. They could reset the exploding time to 6 minutes. Given the layout of the labyrinth and Ignatius&#39; start position, please tell Ignatius whether he could get out of the labyrinth, if he could, output the minimum time that he has to use to find the exit of the labyrinth, else output -1. Here are some rules: We can assume the labyrinth is a 2 array. Each minute, Ignatius could only get to one of the nearest area, and he should not walk out of the border, of course he could not walk on a wall, too. If Ignatius get to the exit when the exploding time turns to 0, he can&#39;t get out of the labyrinth. If Ignatius get to the area which contains Bomb-Rest-Equipment when the exploding time turns to 0, he can&#39;t use the equipment to reset the bomb. A Bomb-Reset-Equipment can be used as many times as you wish, if it is needed, Ignatius can get to any areas in the labyrinth as many times as you wish. The time to reset the exploding time can be ignore, in other words, if Ignatius get to an area which contain Bomb-Rest-Equipment, and the exploding time is larger than 0, the exploding time would be reset to 6.Input The input contains several test cases. The first line of the input is a single integer T which is the number of test cases. T test cases follow.Each test case starts with two integers N and M(1&lt;=N,Mm=8) which indicate the size of the labyrinth. Then N lines follow, each line contains M integers. The array indicates the layout of the labyrinth.There are five integers which indicate the different type of area in the labyrinth:0: The area is a wall, Ignatius should not walk on it.1: The area contains nothing, Ignatius can walk on it.2: Ignatius&#39; start position, Ignatius starts his escape from this position.3: The exit of the labyrinth, Ignatius&#39; target position.4: The area contains a Bomb-Reset-Equipment, Ignatius can delay the exploding time by walking to these areas. Output For each test case, if Ignatius can get out of the labyrinth, you should output the minimum time he needs, else you should just output -1. Sample Input 33 32 1 11 1 01 1 34 82 1 1 0 1 1 1 01 0 4 1 1 0 4 11 0 0 0 0 0 0 11 1 1 4 1 1 1 35 81 2 1 1 1 1 1 41 0 0 0 1 0 0 11 4 1 0 1 1 0 11 0 0 0 0 3 0 11 1 4 1 1 1 1 1 Sample Output 4-113 Problem solving:这道题我是用bfs来做的，跟一种题很像，就是给你规定一个时间看能否走出迷宫之类的问题。但是这道题有一种新的规则，就是如果走到某些特殊的点。时间会更新一次。0是墙，不可以走1是路2是起点3是终点4是可以重置时间的点刚开始看到这里的时候我想着肯定要经过很负责的处理。但是后来发现其实我们只需要知道这两点就可以了。并且题目中规定如果时间为0就不能继续走下去了。 每个点都是可以重复访问的 可以刷新时间的点我们只走一次第一点到不需要怎么理解，就是第二点我们该如何理解呢？如果同一个位置的炸弹你第二次走到了它上面就说明此时已经不是最优解了。所以每个刷新时间的点我们每次走完之后就把它存为0——即墙。 关于第二点的理解还有另一种解释方式:上同一位置是bomb离explode的时间长短来标记。简言之，如果第二次踏上一个位置，那么找出路已用的时间肯定是增加了，那为啥还要走上这条路呢？唯一的追求就是bomb离爆炸的时间增大了。所以可以利用这个条件来标记了。每次在入队前检查下爆炸时间是否比上次在同一位置的大，若是，则入队；反之，入队无意义了。从以上的分析中可以引出另一思路，也就是只要进入位置4，那么bomb就会延时到6分钟，最大的延时时间。换句话说，下次再进入该4位置，也不会获得更大的延时时间了。所以，只要访问过位置4了，就可以直接标记为0位置，表明下次不可在访问。详见代码二。转载于：clouddyx 其实想一下也确实是，假设我们现在走到了一个可以重置时间的点，如果下次在走到这，是不是就一直循环下去了，所以按照这个理解也可以。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,a[10][10];struct node&#123; int x,y,step,time;&#125;;int d[4][2]=&#123;1,0,0,1,0,-1,-1,0&#125;;int ans;node now,mid;void bfs()&#123; queue&lt;node&gt; q; q.push(now); while(!q.empty()) &#123;// cout&lt;&lt;&quot;?&quot;&lt;&lt;endl; now=q.front(); q.pop(); if(now.time&lt;=0) continue; if(a[now.x][now.y]==3) &#123; ans=now.step; return ; &#125; for(int i=0;i&lt;4;i++) &#123; mid.x=now.x+d[i][0]; mid.y=now.y+d[i][1]; mid.step=now.step+1; mid.time=now.time-1; if(mid.x&lt;0||mid.x&gt;=n||mid.y&lt;0||mid.y&gt;=m||mid.time&lt;=0||a[mid.x][mid.y]==0) continue; if(a[mid.x][mid.y]==4) &#123; a[mid.x][mid.y]=0; mid.time=6; &#125; q.push(mid); &#125; &#125;&#125;int main()&#123; int t; cin&gt;&gt;t; while(t--) &#123; ans=-1; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;m;j++) &#123; cin&gt;&gt;a[i][j]; if(a[i][j]==2) &#123; now.x=i,now.y=j,now.step=0,now.time=6; &#125; &#125; &#125; bfs(); cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125; 胜利大逃亡Description:Ignatius被魔王抓走了,有一天魔王出差去了,这可是Ignatius逃亡的好机会. 魔王住在一个城堡里,城堡是一个ABC的立方体,可以被表示成A个B*C的矩阵,刚开始Ignatius被关在(0,0,0)的位置,离开城堡的门在(A-1,B-1,C-1)的位置,现在知道魔王将在T分钟后回到城堡,Ignatius每分钟能从一个坐标走到相邻的六个坐标中的其中一个.现在给你城堡的地图,请你计算出Ignatius能否在魔王回来前离开城堡(只要走到出口就算离开城堡,如果走到出口的时候魔王刚好回来也算逃亡成功),如果可以请输出需要多少分钟才能离开,如果不能则输出-1.Input 输入数据的第一行是一个正整数K,表明测试数据的数量.每组测试数据的第一行是四个正整数A,B,C和T(1&lt;=A,B,C&lt;=50,1&lt;=T&lt;=1000),它们分别代表城堡的大小和魔王回来的时间.然后是A块输入数据(先是第0块,然后是第1块,第2块......),每块输入数据有B行,每行有C个正整数,代表迷宫的布局,其中0代表路,1代表墙.(如果对输入描述不清楚,可以参考Sample Input中的迷宫描述,它表示的就是上图中的迷宫)特别注意:本题的测试数据非常大,请使用scanf输入,我不能保证使用cin能不超时.在本OJ上请使用Visual C++提交. Output 对于每组测试数据,如果Ignatius能够在魔王回来前离开城堡,那么请输出他最少需要多少分钟,否则输出-1. Sample Input 13 3 4 200 1 1 10 0 1 10 1 1 11 1 1 11 0 0 10 1 1 10 0 0 00 1 1 00 1 1 0 Sample Output 11 Problem solving:简单的三维bfs，直接写就行了，六个方向。注意多组输入需要初始化，我又是这WA了一次。。。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;using namespace std;int a,b,c,k;int s[51][51][51];int vis[51][51][51];struct node&#123; int x,y,z,step;&#125;;node mz,mid,ne;int d[6][3]=&#123;1,0,0, -1,0,0, 0,1,0, 0,-1,0, 0,0,1,0,0,-1&#125;,ans;void bfs()&#123; mz.x=mz.y=mz.z=mz.step=0; queue&lt;node&gt; q; q.push(mz); vis[0][0][0]=1; while(!q.empty()) &#123; mid=q.front(); q.pop(); if(mid.step&gt;k) &#123; return ; &#125; if(mid.x==a-1&amp;&amp;mid.y==b-1&amp;&amp;mid.z==c-1&amp;&amp;mid.step&lt;=k) &#123; ans=mid.step; return ; &#125; for(int i=0;i&lt;6;i++) &#123; ne.x=mid.x+d[i][0]; ne.y=mid.y+d[i][1]; ne.z=mid.z+d[i][2]; if(ne.x&lt;0||ne.x&gt;=a||ne.y&lt;0||ne.y&gt;=b||ne.z&lt;0||ne.z&gt;=c||vis[ne.x][ne.y][ne.z]||s[ne.x][ne.y][ne.z]==1) continue; ne.step=mid.step+1; vis[ne.x][ne.y][ne.z]=1; q.push(ne); &#125; &#125;&#125;int main()&#123; int t;scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; memset(vis,0,sizeof(vis)); ans=-1; scanf(&quot;%d %d %d %d&quot;,&amp;a,&amp;b,&amp;c,&amp;k); for(int i=0;i&lt;a;i++) &#123; for(int j=0;j&lt;b;j++) &#123; for(int k=0;k&lt;c;k++) &#123; scanf(&quot;%1d&quot;,&amp;s[i][j][k]); &#125; &#125; &#125; bfs(); printf(&quot;%d\n&quot;,ans); &#125;&#125; A strange liftDescription:计院有一个bug电梯，可能是hyk造的，很多bug，电梯只有两个按钮，“上”和“下”，电梯每层都可以停，每层都有一个数字Ki（0&lt;=Ki&lt;=n），当你在一层楼，你按“上”键会到1+K1层，你按“下”键会到1-K1层。当然，电梯不能升到N以上，也不能降到1以下。例如，有一个五层楼的建筑，k1=3，k2=3，k3=1，k4=2，k5=5。从第一层开始，你可以按“上”按钮，然后你就上到第四层，如果在第一层按“下”按钮，电梯就不能做到，因为你知道它不能下到负二层。负二楼不存在。那么，你想从A层到B层，你至少要按多少次“上”或“下”按钮呢？ Input 输入由几个测试用例组成，每个测试用例包含两行。第一行包含三个整数n，a，b（1&lt;=n，a，b&lt;=200），如上文所述，第二行包含n个整数k1，k2，….kn。单个0表示输入的结束。 Output 对于每种情况下的输入输出一个整数，当你在A层，你必须按下按钮的最少次数，你想去B层。如果你不能到达B层，打印“-1”。 Sample Input 5 1 53 3 1 2 50 Sample Output 3 Problem solving:也是一道存图的题。每次存的时候注意判断第二个点与0跟n的大小关系。也是有向图。注意初始化！！！又是这样WA了一次。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;int n,a,b,meizi;int s[250][250],ans;int vis[250],step[250];void bfs(int x)&#123; queue&lt;int&gt; q; q.push(x); vis[x]=1,step[x]=0; while(!q.empty()) &#123; int mid=q.front(); q.pop();// cout&lt;&lt;mid&lt;&lt;endl; if(mid==b) &#123;// cout&lt;&lt;&quot;?&quot;&lt;&lt;endl; ans=step[mid]; return ; &#125; for(int i=1;i&lt;=n;i++) &#123;// cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;s[x][i]&lt;&lt;endl; if(s[mid][i]&amp;&amp;vis[i]==0) &#123; q.push(i); vis[i]=1; step[i]=step[mid]+1; &#125; &#125; &#125;&#125;int main()&#123; while(cin&gt;&gt;n&amp;&amp;n) &#123; memset(vis,0,sizeof(vis)); memset(step,0,sizeof(step)); memset(s,0,sizeof(s)); ans=-1; cin&gt;&gt;a&gt;&gt;b; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;meizi; if(i+meizi&gt;=1&amp;&amp;i+meizi&lt;=n) s[i][meizi+i]=1; if(i-meizi&gt;=1&amp;&amp;i-meizi&lt;=n) s[i][i-meizi]=1; &#125; bfs(a); cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125;]]></content>
      <categories>
        <category>Training</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>c/c++</tag>
        <tag>DFS</tag>
        <tag>HDU</tag>
        <tag>poj</tag>
        <tag>STL</tag>
        <tag>BFS</tag>
        <tag>邻接表</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树的直径以及邻接表，链式前向星的存图]]></title>
    <url>%2Fblog%2F2019%2F07%2F25%2Fmapsave%2F</url>
    <content type="text"><![CDATA[今天的学习及刷题的过程中遇到了一些新的知识——树的直径，和前几天学到但没使用过的邻接表存图以及链式前向星存图。内容也不少，所以特意新开一篇文章进行介绍。 先来了解一下什么是树：树（tree）是包含n（n&gt;0）个结点的有穷集，其中： 每个元素称为结点（node）； 有一个特定的结点被称为根结点或树根（root）； 除根结点之外的其余数据元素被分为m（m≥0）个互不相交的集合T1，T2，…Tm-1，其中每一个集合Tm-1（1≤i≤m）本身也是一棵树，被称作原树的子树（subtree）。 树中距离最大的两个结点之间的距离称为树的直径。 树的直径的求法： 两次dfs或bfs。第一次任意选一个点进行dfs(bfs)找到离它最远的点，此点就是最长路的一个端点，再以此点进行dfs（bfs），找到离它最远的点，此点就是最长路的另一个端点，于是就找到了树的直径。 证明：假设此树的最长路径是从s到t,我们选择的点为u。反证法：假设搜到的点是v。1、v在这条最长路径上，那么dis[u,v]&gt;dis[u,v]+dis[v,s],显然矛盾。2、v不在这条最长路径上，我们在最长路径上选择一个点为po，则dis[u,v]&gt;dis[u,po]+dis[po,t]，那么有dis[s,v]=dis[s,po]+dis[po,u]+dis[u,v]&gt;dis[s,po]+dis[po,t]=dis[s,t],即dis[s,v]&gt;dis[s,t],矛盾。也许你想说u本身就在最长路径，或则其它的一些情况，但其实都能用类似于上面的反证法来证明的。综上所述，你两次dfs(bfs)就可以求出最长路径的两个端点和路径长度。 以上内容参考与学长的PDF 其实证明看不太懂得话问题不大，就是随便找一个位置先进行dfs或者bfs到达一个端点，再以这个端点为起点dfs或者bfs到达另一个端点即可。 有的题它让你处理的就是字符串组成的图，但是有的题就不会这么好心了，他会给出你节点，边，甚至有的还会给你出权值。此时我们就需要自己存图。 说到存图，一般都有三种方法。 二维数组用二维数组进行存图，这个是最普通的办法，但是有一个致命的缺点就是当题目数据中的点比较多的时候有极高的空间复杂度，会爆内存。不过数据范围小的时候用二维数组来存图。还是很简单的。举个栗子：5个点 4条边对每条边输入三个数，两个端点以及这条边的权值1 2 22 3 44 5 11 4 21 5 31234567char s[maxn][maxn];for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;x&gt;&gt;y&gt;&gt;p; s[x][y]=p; s[y][x]=p;//如果是有向图的话，就不需要这一句了 &#125; 访问的时候直接s[i][j]就行了 邻接表法邻接表法就是用vector来进行存储，这个也挺好理解，跟二维数组可以一样的理解。举个栗子：5个点 4条边对每条边输入三个数，两个端点以及这条边的权值1 2 22 3 44 5 11 4 21 5 312345678//无权值vector&lt;int&gt; v[maxn];for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;x&gt;&gt;y; v[x].push_back(y); v[y].push_back(x);//有向边的话不需要者一句&#125; 12345678//有权值vector&lt;pair&lt;int,int&gt; &gt; v[maxn]；fot(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; v[x].push_back(make_pair(y,z)); v[y].push_back(make_pair(x,z));//有向边的话不需要者一句&#125; 访问每条边的时候需要这样写1234567for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;v[i].size();j++) &#123; cout&lt;&lt;v[i][j].first&lt;&lt;&quot;-&gt;&quot;&lt;&lt;v[i][j].second; &#125;&#125; 链式前向星链式前向星是一种很巧妙地方法。首先建立一个结构体123456struct Edge&#123; int e;//表示第i条边的终点 int w;//权值 int next;//表示同起点的下一条边&#125;; 加边12345678cnt=0,head=-1;void add ( int u, int v, int w)&#123;edge [cnt ].w = w;edge [cnt ]. to = v;edge [cnt ]. next = head [u];head [u] = cnt ++;&#125; 边的遍历1234for (int i= head [u];~i;i= edge [i]. next )&#123;cout &lt;&lt;u&lt;&lt;&quot; -&gt;&quot; &lt;&lt;edge [i].e&lt;&lt; endl ;&#125; 链式前向星不会遍历到不存在的边。内存利用率高，相比vector实现的邻接表而言，可以准确开辟最多边数的内存，不像vector实现的邻接表有爆内存的风险。 如果有兴趣深入理解存图的话可以参考一下这几篇博客：https://blog.csdn.net/acdreamers/article/details/16902023 https://jzqt.github.io/2015/07/21/ACM%E5%9B%BE%E8%AE%BA%E4%B9%8B%E5%AD%98%E5%9B%BE%E6%96%B9%E5%BC%8F/ 三种存图方式的介绍就到这里了，我最喜欢用的是第二种，好理解又方便写，但是不得不承认链式前向星的优秀，还是应该会用的。 说完了存图，我还想说一下用邻接表存了图之后该如何进行搜索（这里以bfs为例）。 我们只需要对每个顶点进行搜索即可，即bfs传递的参数为邻接表中的第一个元素。直接上代码吧无权值得1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 1e5+10;int dis[maxn],ans,vis[maxn],n,a,b;vector&lt;int&gt; v[maxn];int bfs(int x)&#123; memset(vis,0,sizeof(vis)); memset(dis,0,sizeof(dis)); queue&lt;int&gt; q; q.push(x); vis[x]=1,dis[x]=0; int point; while(!q.empty()) &#123; x=q.front(); q.pop(); if(dis[x]&gt;ans) &#123; ans=dis[x]; point=x; &#125; for(int i=0;i&lt;v[x].size();i++) &#123; if(!vis[v[x][i]]) &#123; vis[v[x][i]]=1; dis[v[x][i]]=dis[x]+1; q.push(v[x][i]); &#125; &#125; &#125; return point;&#125;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;n;i++) &#123; cin&gt;&gt;a&gt;&gt;b; v[a].push_back(b); v[b].push_back(a); &#125; ans=0; int point=bfs(1); ans=0; bfs(point); cout&lt;&lt;ans&lt;&lt;endl;&#125; 有权值的12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;int a,b,c,ans;const int maxn = 1e5+10;int vis[maxn],dis[maxn];//dis数组储存的就是当前点能向一个确定的方向走的最大的距离。vis就是一个标记数组防止重复访问。vector&lt;pair&lt;int,int&gt; &gt; v[maxn]; //用来存图，可以看成是一个二维数组,因为是有权值的，所以在vector中套用了一个pairint bfs(int x)&#123; memset(vis,0,sizeof(vis));//因为要进行多次bfs，所以每次都要清空一下数组 memset(dis,0,sizeof(dis)); vis[x]=1;//已经访问过的节点标记为1 int point=0;//用来储存当前所能走到的最远的点 queue&lt;int&gt; q;//用来实现bfs的队列 q.push(x); while(!q.empty()) &#123; x=q.front(); q.pop(); if(dis[x]&gt;ans)//如果当前点能走的最大的步数大于ans，ans初始为0，如果大于就更新ans和point的值 &#123; ans=dis[x]; point=x; &#125; pair&lt;int,int&gt; mid; for(int i=0;i&lt;v[x].size();i++)//对v[x]中的每一个元素进行bfs &#123; mid=v[x][i]; if(!vis[mid.first])//没访问过就继续 &#123; vis[mid.first]=1;//标记成已经访问过的 dis[mid.first]=dis[x]+mid.second;//这个点的能走的最大的距离多了一个dis[x] q.push(mid.first);//放进队列以进行bfs &#125; &#125; &#125; return point;//把当前走到的最远的点返回&#125;int main()&#123; while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c) &#123; v[a].push_back(make_pair(b,c));//存图 v[b].push_back(make_pair(a,c)); &#125; ans=0;//初始化 int point=bfs(1); ans=0; bfs(point);//第二次以某一端点位起点的bfs cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 这里只需要看一下对邻接表中vector下标的使用即可。]]></content>
      <categories>
        <category>Training</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>BFS</tag>
        <tag>树的直径</tag>
        <tag>邻接表</tag>
        <tag>“链式前向星”</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HPU Summer Training Day 9（河南理工大学暑期第九天）]]></title>
    <url>%2Fblog%2F2019%2F07%2F25%2Fd9%2F</url>
    <content type="text"><![CDATA[今天主要讲了树的直径，是用bfs和dfs实现的，但是我的dfs，emm，一言难尽，所以我只用了bfs。关于今天刷题遇到的主要的知识，请去这里查看。 -------------------------------------&gt;戳这里&lt;------------------------------------- LabyrinthDescription:The northern part of the Pyramid contains a very large and complicated labyrinth. The labyrinth is divided into square blocks, each of them either filled by rock, or free. There is also a little hook on the floor in the center of every free block. The ACM have found that two of the hooks must be connected by a rope that runs through the hooks in every block on the path between the connected ones. When the rope is fastened, a secret door opens. The problem is that we do not know which hooks to connect. That means also that the neccessary length of the rope is unknown. Your task is to determine the maximum length of the rope we could need for a given labyrinth.Input The input consists of T test cases. The number of them (T) is given on the first line of the input file. Each test case begins with a line containing two integers C and R (3 &lt;= C,R &lt;= 1000) indicating the number of columns and rows. Then exactly R lines follow, each containing C characters. These characters specify the labyrinth. Each of them is either a hash mark (#) or a period (.). Hash marks represent rocks, periods are free blocks. It is possible to walk between neighbouring blocks only, where neighbouring blocks are blocks sharing a common side. We cannot walk diagonally and we cannot step out of the labyrinth. The labyrinth is designed in such a way that there is exactly one path between any two free blocks. Consequently, if we find the proper hooks to connect, it is easy to find the right path connecting them.OutputYour program must print exactly one line of output for each test case. The line must contain the sentence &quot;Maximum rope length is X.&quot; where Xis the length of the longest path between any two free blocks, measured in blocks. Sample Input 23 3 ### #.# ###7 6 ####### #.#.### #.#.### #.#.#.# #.....# ####### Sample Output Maximum rope length is 0.Maximum rope length is 8. Hint Huge input, scanf is recommended.If you use recursion, maybe stack overflow. and now C++/c &#39;s stack size is larger than G++/gcc Problem solving:这一题是最简单的求树的直径的题，bfs两次即可，注意虽然第一次开始查找的位置可以是任意的，但是第二次开始的位置应该是第一次查找到最后的那个位置，还有就是两个bfs之间不要忘了memset。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;int dis[1005][1005];int vis[1005][1005];char s[1005][1005];int d[4][2]=&#123;1,0,0,1,-1,0,0,-1&#125;;struct node&#123; int x,y;&#125;;int n,c,r,sx,sy;int bfs(int x,int y)&#123; node now,mid; queue&lt;node&gt; que; now.x=x;now.y=y; que.push(now); vis[x][y]=1;dis[x][y]=0; while(!que.empty()) &#123; now=que.front(); que.pop(); for(int i=0;i&lt;4;i++) &#123; mid.x=now.x+d[i][0]; mid.y=now.y+d[i][1]; if(mid.x&lt;0||mid.x&gt;=r||mid.y&lt;0||mid.y&gt;=c||s[mid.x][mid.y]==&apos;#&apos;||vis[mid.x][mid.y]) continue; vis[mid.x][mid.y]=1; dis[mid.x][mid.y]=dis[now.x][now.y]+1; que.push(mid); &#125; &#125;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); while(n--) &#123; memset(vis,0,sizeof(vis)); memset(dis,0,sizeof(dis)); scanf(&quot;%d %d&quot;,&amp;c,&amp;r); int flag=0; for(int i=0;i&lt;r;i++) scanf(&quot;%s&quot;,s[i]); for(int i=0;i&lt;r;i++) &#123; for(int j=0;j&lt;c;j++) &#123; if(s[i][j]==&apos;.&apos;) &#123; sx=i,sy=j; flag=1; break; &#125; if(flag) break; &#125; &#125; bfs(sx,sy);int px=0; for(int i=0;i&lt;r;i++) &#123; for(int j=0;j&lt;c;j++) &#123; if(dis[i][j]&gt;px) &#123; sx=i; sy=j; px=dis[i][j]; &#125; &#125; &#125; memset(vis,0,sizeof(vis)); memset(dis,0,sizeof(dis)); bfs(sx,sy); int ans=0; for(int i=0;i&lt;r;i++) &#123; for(int j=0;j&lt;c;j++) &#123; ans=max(ans,dis[i][j]); &#125; &#125; printf(&quot;Maximum rope length is %d.\n&quot;,ans); &#125;&#125; Cow MarathonDescription:After hearing about the epidemic of obesity in the USA, Farmer John wants his cows to get more exercise, so he has committed to create a bovine marathon for his cows to run. The marathon route will include a pair of farms and a path comprised of a sequence of roads between them. Since FJ wants the cows to get as much exercise as possible he wants to find the two farms on his map that are the farthest apart from each other (distance being measured in terms of total length of road on the path between the two farms). Help him determine the distances between this farthest pair of farms.有n个农田和m条路，以及每条路的方向（方向在这道题中没有用），求最长的一条路，也就是两点间的最大距离，即树的直径.Input Lines 1.....: Same input format as &quot;Navigation Nightmare&quot;. Output Line 1: An integer giving the distance between the farthest pair of farms. Sample Input 7 61 6 13 E6 3 9 E3 5 7 S4 1 3 N2 4 20 W4 7 2 S Sample Output 52 Hint The longest marathon runs from farm 2 via roads 4, 1, 6 and 3 to farm 5 and is of length 20+3+13+9+7=52. Problem solving:这道题就是一道带权的无向图求树的最大直径。直接套模板即可。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;int a,b,c,ans,n,m;const int maxn = 1e5+10;int vis[maxn],dis[maxn];char s;vector&lt;pair&lt;int,int&gt; &gt; v[maxn];int bfs(int x)&#123; memset(vis,0,sizeof(vis)); memset(dis,0,sizeof(dis)); vis[x]=1; int point=0; queue&lt;int&gt; q; q.push(x); while(!q.empty()) &#123; x=q.front(); q.pop(); if(dis[x]&gt;ans) &#123; ans=dis[x]; point=x; &#125; pair&lt;int,int&gt; mid; for(int i=0;i&lt;v[x].size();i++) &#123; mid=v[x][i]; if(!vis[mid.first]) &#123; vis[mid.first]=1; dis[mid.first]=dis[x]+mid.second; q.push(mid.first); &#125; &#125; &#125; return point;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; while(m--) &#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;s; v[a].push_back(make_pair(b,c)); v[b].push_back(make_pair(a,c)); &#125; ans=0; int point=bfs(1); ans=0; bfs(point); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; Roads in the NorthDescription:Building and maintaining roads among communities in the far North is an expensive business. With this in mind, the roads are build such that there is only one route from a village to a village that does not pass through some other village twice.Given is an area in the far North comprising a number of villages and roads among them such that any village can be reached by road from any other village. Your job is to find the road distance between the two most remote villages in the area. The area has up to 10,000 villages connected by road segments. The villages are numbered from 1.Input Input to the problem is a sequence of lines, each containing three positive integers: the number of a village, the number of a different village, and the length of the road segment connecting the villages in kilometers. All road segments are two-way. Output You are to output a single integer: the road distance between the two most remote villages in the area. Sample Input 5 1 61 4 56 3 92 6 86 1 7 Sample Output 22 Problem solving:同B，直接套模板即可。这里是输入组数不确定，所以直接while(cin)即可。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;int a,b,c,ans;const int maxn = 1e5+10;int vis[maxn],dis[maxn];vector&lt;pair&lt;int,int&gt; &gt; v[maxn];int bfs(int x)&#123; memset(vis,0,sizeof(vis)); memset(dis,0,sizeof(dis)); vis[x]=1; int point=0; queue&lt;int&gt; q; q.push(x); while(!q.empty()) &#123; x=q.front(); q.pop(); if(dis[x]&gt;ans) &#123; ans=dis[x]; point=x; &#125; pair&lt;int,int&gt; mid; for(int i=0;i&lt;v[x].size();i++) &#123; mid=v[x][i]; if(!vis[mid.first]) &#123; vis[mid.first]=1; dis[mid.first]=dis[x]+mid.second; q.push(mid.first); &#125; &#125; &#125; return point;&#125;int main()&#123; while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c) &#123; v[a].push_back(make_pair(b,c)); v[b].push_back(make_pair(a,c)); &#125; ans=0; int point=bfs(1); ans=0; bfs(point); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; ComputerDescription:一所学校不久前买了第一台电脑（所以这台电脑的ID是1）。近年来，学校购买了N-1新电脑。每台新电脑都连接到一台先前安装的电脑上。学校的管理人员担心网络运行缓慢，希望知道第i台计算机需要发送信号的最大距离si（即到最远计算机的电缆长度）。您需要提供此信息。 提示：示例输入与此图对应。从图中，你可以看到计算机4离1最远，所以s1=3。计算机4和5是距离2最远的，所以s2=2。计算机5是离3最远的，所以s3=3。我们也得到了s4=4，s5=4。输入 输入文件包含多组测试样例。在每组样例中，第一行中都有自然数n（n&lt;=10000），然后是（n-1）行，其中包含对计算机的描述。第i行包含两个自然数-第i计算机所连接的计算机和用于连接的电缆长度。电缆总长度不超过1e9。输入行中的数字用空格分隔。 输出 对于每组样例，输出n行。第i行第i台计算机的到其他计算机的最大长度Si（1&lt;=i&lt;=n）。 样例输入 51 12 13 11 1 样例输出 32344 提示 示例输入与此图对应。从图中，你可以看到计算机4离1最远，所以s1=3。计算机4和5是距离2最远的，所以s2=2。计算机5是离3最远的，所以s3=3。我们也得到了s4=4，s5=4。 Problem solving:这道题应该是今天最难的题了。一开始毫无思路，但是后来听了学长一句话。离某个点最远的一定是树的直径的端点。我们第一次bfs结束时的点是这个树的两个端点之一，再以这个端点就行bfs结束的时候就到了另外一个端点，而且我们在查找的过程中使用的dis数组就是当前位置距离将要到达的！！端点！！的距离，所以就在bfs一次，与上一次得到的距离去max最大值即可。总结一下就是三次bfs。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const long long maxn=1e5;long long n,a,b,ans;long long vis[maxn],dis[maxn],dis2[maxn];vector&lt;pair&lt;long long,long long&gt; &gt; v[maxn];long long bfs(long long x)&#123; memset(vis,0,sizeof(vis)); memset(dis,0,sizeof(dis)); ans=0; queue&lt;long long&gt; q; q.push(x); vis[x]=1; long long point; while(!q.empty()) &#123; x=q.front(); q.pop(); if(dis[x]&gt;ans) &#123; ans=dis[x]; point=x; &#125; pair&lt;long long,long long&gt; mid; for(long long i=0;i&lt;v[x].size();i++) &#123; mid=v[x][i]; if(!vis[mid.first]) &#123; vis[mid.first]=1; dis[mid.first]=dis[x]+mid.second; q.push(mid.first); &#125; &#125; &#125; return point;&#125;int main()&#123; while(cin&gt;&gt;n) &#123; memset(v,0,sizeof(v)); for(long long i=2;i&lt;=n;i++) &#123; cin&gt;&gt;a&gt;&gt;b; v[a].push_back(make_pair(i,b)); v[i].push_back(make_pair(a,b)); &#125; long long point=bfs(1); long long next=bfs(point); for(long long i=1;i&lt;=n;i++) dis2[i]=dis[i]; bfs(next); for(long long i=1;i&lt;=n;i++) &#123; cout&lt;&lt;max(dis2[i],dis[i])&lt;&lt;endl;; &#125; &#125;&#125; Farthest Nodes in a TreeDescription:Given a tree (a connected graph with no cycles), you have to find the farthest nodes in the tree. The edges of the tree are weighted and undirected. That means you have to find two nodes in the tree whose distance is maximum amongst all nodes. Input Input starts with an integer T (≤ 10), denoting the number of test cases.Each case starts with an integer n (2 ≤ n ≤ 30000) denoting the total number of nodes in the tree. The nodes are numbered from 0 to n-1. Each of the next n-1 lines will contain three integers u v w (0 ≤ u, v &lt; n, u ≠ v, 1 ≤ w ≤ 10000) denoting that node u and v are connected by an edge whose weight is w. You can assume that the input will form a valid tree. Output For each case, print the case number and the maximum distance. Sample Input 240 1 201 2 302 3 5050 2 202 1 100 3 290 4 50 Sample Output Case 1: 100Case 2: 80 Problem solving:同BC，直接套模板就行。然后就是输出格式的控制 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;vector&gt;const int maxn= 1e5+10;using namespace std;int dis[maxn],ans;bool vis[maxn];vector&lt;pair&lt;int,int&gt; &gt; v[maxn];int bfs(int x)&#123; memset(dis,0,sizeof(dis)); memset(vis,0,sizeof(vis)); queue&lt;int&gt; que; que.push(x);vis[x]=1; int point=0; while(!que.empty()) &#123; int f=que.front(); que.pop(); if(dis[f]&gt;ans) &#123; ans=dis[f]; point=f; &#125; pair&lt;int,int&gt; t; for(int i=0;i&lt;v[f].size();i++) &#123; t=v[f][i]; if(vis[t.first]==0) &#123; vis[t.first]=1; dis[t.first]=dis[f]+t.second; que.push(t.first); &#125; &#125; &#125; return point;&#125;int main()&#123; int n,m,x,y,z,flag=0; cin&gt;&gt;n; while(n--) &#123; memset(v,0,sizeof(v)); cin&gt;&gt;m; for(int i=1;i&lt;m;i++) &#123; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; v[x].push_back(make_pair(y,z)); v[y].push_back(make_pair(x,z)); &#125; ans=0; int point=bfs(1); ans=0; bfs(point); printf(&quot;Case %d: %d\n&quot;,++flag,ans); &#125;&#125; 51nod 2602 树的直径Description:一棵树的直径就是这棵树上存在的最长路径。现在有一棵n个节点的树，现在想知道这棵树的直径包含的边的个数是多少？ 如图所示的数据，这棵树的直径为(1-2-3-6-9)这条路径，包含的边的个数为4，所以答案是4。 输入 第1行：一个整数n，表示树上的节点个数。(1&lt;=n&lt;=100000)第2-n行：每行有两个整数u,v,表示u与v之间有一条路径。(1&lt;=u,v&lt;=n) 输出 输出一个整数，表示这棵树直径所包含的边的个数。 输入样例 101 22 33 43 53 63 73 106 86 9 输出样例 4 Problem solving:求树的直径的模板题。不过无权值。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 1e5+10;int dis[maxn],ans,vis[maxn],n,a,b;vector&lt;int&gt; v[maxn];int bfs(int x)&#123; memset(vis,0,sizeof(vis)); memset(dis,0,sizeof(dis)); queue&lt;int&gt; q; q.push(x); vis[x]=1,dis[x]=0; int point; while(!q.empty()) &#123; x=q.front(); q.pop(); if(dis[x]&gt;ans) &#123; ans=dis[x]; point=x; &#125; for(int i=0;i&lt;v[x].size();i++) &#123; if(!vis[v[x][i]]) &#123; vis[v[x][i]]=1; dis[v[x][i]]=dis[x]+1; q.push(v[x][i]); &#125; &#125; &#125; return point;&#125;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;n;i++) &#123; cin&gt;&gt;a&gt;&gt;b; v[a].push_back(b); v[b].push_back(a); &#125; ans=0; int point=bfs(1); ans=0; bfs(point); cout&lt;&lt;ans&lt;&lt;endl;&#125; 模板上面有三道题我都直接说得套模板。那么求树的直径的模板是什么呢？这里只写上带权的吧，不带权的可以类比得出。或者去这里看：------------------------------&gt;戳这里&lt;------------------------------ 在这里我结合代码想详细的分析一下这个模板。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;int a,b,c,ans;const int maxn = 1e5+10;int vis[maxn],dis[maxn];//dis数组储存的就是当前点能向一个确定的方向走的最大的距离。vis就是一个标记数组防止重复访问。vector&lt;pair&lt;int,int&gt; &gt; v[maxn]; //用来存图，可以看成是一个二维数组,因为是有权值的，所以在vector中套用了一个pairint bfs(int x)&#123; memset(vis,0,sizeof(vis));//因为要进行多次bfs，所以每次都要清空一下数组 memset(dis,0,sizeof(dis)); vis[x]=1;//已经访问过的节点标记为1 int point=0;//用来储存当前所能走到的最远的点 queue&lt;int&gt; q;//用来实现bfs的队列 q.push(x); while(!q.empty()) &#123; x=q.front(); q.pop(); if(dis[x]&gt;ans)//如果当前点能走的最大的步数大于ans，ans初始为0，如果大于就更新ans和point的值 &#123; ans=dis[x]; point=x; &#125; pair&lt;int,int&gt; mid; for(int i=0;i&lt;v[x].size();i++)//对v[x]中的每一个元素进行bfs &#123; mid=v[x][i]; if(!vis[mid.first])//没访问过就继续 &#123; vis[mid.first]=1;//标记成已经访问过的 dis[mid.first]=dis[x]+mid.second;//这个点的能走的最大的距离多了一个dis[x] q.push(mid.first);//放进队列以进行bfs &#125; &#125; &#125; return point;//把当前走到的最远的点返回&#125;int main()&#123; while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c) &#123; v[a].push_back(make_pair(b,c));//存图 v[b].push_back(make_pair(a,c)); &#125; ans=0;//初始化 int point=bfs(1); ans=0; bfs(point);//第二次以某一端点位起点的bfs cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 学长标程学长写的代码比我的好看多了。。。贴一下 Labyrinth1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;int N,M,u,v,ans;int dir[4][2]=&#123;1,0,0,1,-1,0,0,-1&#125;;char MAP[1200][1200];bool vis[1200][1200];void dfs(int x,int y,int res)&#123; for(int i=0;i&lt;4;i++)&#123; int nx=dir[i][0]+x; int ny=dir[i][1]+y; if(nx&gt;=0&amp;&amp;nx&lt;N&amp;&amp;ny&gt;=0&amp;&amp;ny&lt;M&amp;&amp;vis[nx][ny]==0&amp;&amp;MAP[nx][ny]==&apos;.&apos;)&#123; vis[nx][ny]=1; dfs(nx,ny,res+1); &#125; &#125; if(res&gt;=ans)&#123; u=x;v=y;ans=res; &#125;&#125;int main()&#123; int T; scanf(&quot;%d&quot;,&amp;T); while(T--)&#123; scanf(&quot;%d%d&quot;,&amp;M,&amp;N); for(int i=0;i&lt;N;i++)&#123; scanf(&quot;%s&quot;,&amp;MAP[i]); &#125; memset(vis,0,sizeof(vis)); ans=0; for(int i=0;i&lt;N;i++)&#123; for(int j=0;j&lt;M;j++)&#123; if(MAP[i][j]==&apos;.&apos;)&#123; dfs(i,j,0); &#125; &#125; &#125; memset(vis,0,sizeof(vis)); dfs(u,v,0); cout&lt;&lt;&quot;Maximum rope length is &quot;&lt;&lt;ans&lt;&lt;&apos;.&apos;&lt;&lt;endl; &#125; return 0;&#125; Cow Marathon12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;int N,M,X,Y,Z,ans;int dis[40020];bool vis[40020];vector&lt;pair&lt;int,int&gt; &gt;V[40020];int bfs(int n)&#123; memset(dis,0,sizeof(dis)); memset(vis,0,sizeof(vis)); queue&lt;int&gt;Q; Q.push(n); vis[n]=1; ans=0; int point=0,t; while(!Q.empty())&#123; t=Q.front(); Q.pop(); if(dis[t]&gt;ans)&#123; ans=dis[t]; point=t; &#125; for(int i=0;i&lt;V[t].size();i++)&#123; if(vis[V[t][i].first]==0)&#123; vis[V[t][i].first]=1; dis[V[t][i].first]=dis[t]+V[t][i].second; Q.push(V[t][i].first); &#125; &#125; &#125; return point;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;N,&amp;M); for(int i=0;i&lt;M;i++)&#123; scanf(&quot;%d%d%d %*c&quot;,&amp;X,&amp;Y,&amp;Z); V[X].push_back(make_pair(Y,Z)); V[Y].push_back(make_pair(X,Z)); &#125; bfs(bfs(1)); printf(&quot;%d\n&quot;,ans); return 0;&#125; Roads in the North1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;int N,M,X,Y,Z,ans;int dis[40020];bool vis[40020];vector&lt;pair&lt;int,int&gt; &gt;V[40020];int bfs(int n)&#123; memset(dis,0,sizeof(dis)); memset(vis,0,sizeof(vis)); queue&lt;int&gt;Q; Q.push(n); vis[n]=1; ans=0; int point=0,t; while(!Q.empty())&#123; t=Q.front(); Q.pop(); if(dis[t]&gt;ans)&#123; ans=dis[t]; point=t; &#125; for(int i=0;i&lt;V[t].size();i++)&#123; if(vis[V[t][i].first]==0)&#123; vis[V[t][i].first]=1; dis[V[t][i].first]=dis[t]+V[t][i].second; Q.push(V[t][i].first); &#125; &#125; &#125; return point;&#125;int main()&#123; while(scanf(&quot;%d%d%d&quot;,&amp;X,&amp;Y,&amp;Z)!=EOF)&#123; V[X].push_back(make_pair(Y,Z)); V[Y].push_back(make_pair(X,Z)); &#125; bfs(bfs(1)); printf(&quot;%d\n&quot;,ans); return 0;&#125; Computer12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;int N,M,X,Y,Z,ans;int dis[40020];int diss[40020];bool vis[40020];vector&lt;pair&lt;int,int&gt; &gt;V[40020];int bfs(int n)&#123; memset(dis,0,sizeof(dis)); memset(vis,0,sizeof(vis)); queue&lt;int&gt;Q; Q.push(n); vis[n]=1; ans=0; int point,t; while(!Q.empty())&#123; t=Q.front(); Q.pop(); if(dis[t]&gt;ans)&#123; ans=dis[t]; point=t; &#125; for(int i=0;i&lt;V[t].size();i++)&#123; if(vis[V[t][i].first]==0)&#123; vis[V[t][i].first]=1; dis[V[t][i].first]=dis[t]+V[t][i].second; Q.push(V[t][i].first); &#125; &#125; &#125; return point;&#125;int main()&#123; while(scanf(&quot;%d&quot;,&amp;N)!=EOF)&#123; for(int i=0;i&lt;=N;i++)V[i].clear(); for(int i=1;i&lt;N;i++)&#123; scanf(&quot;%d%d&quot;,&amp;X,&amp;Z); V[i+1].push_back(make_pair(X,Z)); V[X].push_back(make_pair(i+1,Z)); &#125; int point=bfs(bfs(1)); for(int i=1;i&lt;=N;i++)&#123; diss[i]=dis[i]; &#125; bfs(point); for(int i=1;i&lt;=N;i++)&#123; printf(&quot;%d\n&quot;,max(dis[i],diss[i])); &#125; &#125; return 0;&#125; Farthest Nodes in a Tree123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;int N,M,X,Y,Z,ans;int dis[40020];bool vis[40020];vector&lt;pair&lt;int,int&gt; &gt;V[40020];int bfs(int n)&#123; memset(dis,0,sizeof(dis)); memset(vis,0,sizeof(vis)); queue&lt;int&gt;Q; Q.push(n); vis[n]=1; ans=0; int point,t; while(!Q.empty())&#123; t=Q.front(); Q.pop(); if(dis[t]&gt;ans)&#123; ans=dis[t]; point=t; &#125; for(int i=0;i&lt;V[t].size();i++)&#123; if(vis[V[t][i].first]==0)&#123; vis[V[t][i].first]=1; dis[V[t][i].first]=dis[t]+V[t][i].second; Q.push(V[t][i].first); &#125; &#125; &#125; return point;&#125;int main()&#123; int T,Case=1; scanf(&quot;%d&quot;,&amp;T); while(T--)&#123; scanf(&quot;%d&quot;,&amp;N); for(int i=0;i&lt;N;i++)V[i].clear(); for(int i=1;i&lt;N;i++)&#123; scanf(&quot;%d%d%d&quot;,&amp;X,&amp;Y,&amp;Z); V[X].push_back(make_pair(Y,Z)); V[Y].push_back(make_pair(X,Z)); &#125; bfs(bfs(0)); printf(&quot;Case %d: %d\n&quot;,Case++,ans); &#125; return 0;&#125; 树的直径12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;int N,M,X,Y,Z,ans;int dis[100020];bool vis[100020];vector&lt;pair&lt;int,int&gt; &gt;V[100020];int bfs(int n)&#123; memset(dis,0,sizeof(dis)); memset(vis,0,sizeof(vis)); queue&lt;int&gt;Q; Q.push(n); vis[n]=1; ans=0; int point,t; while(!Q.empty())&#123; t=Q.front(); Q.pop(); if(dis[t]&gt;ans)&#123; ans=dis[t]; point=t; &#125; for(int i=0;i&lt;V[t].size();i++)&#123; if(vis[V[t][i].first]==0)&#123; vis[V[t][i].first]=1; dis[V[t][i].first]=dis[t]+V[t][i].second; Q.push(V[t][i].first); &#125; &#125; &#125; return point;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;N); for(int i=1;i&lt;N;i++)&#123; scanf(&quot;%d%d&quot;,&amp;X,&amp;Y); V[X].push_back(make_pair(Y,1)); V[Y].push_back(make_pair(X,1)); &#125; bfs(bfs(1)); printf(&quot;%d\n&quot;,ans); return 0;&#125;]]></content>
      <categories>
        <category>Training</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>HDU</tag>
        <tag>51nod</tag>
        <tag>poj</tag>
        <tag>BFS</tag>
        <tag>树的直径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HPU Summer Training Day 8（河南理工大学暑期第八天）]]></title>
    <url>%2Fblog%2F2019%2F07%2F24%2Fd8%2F</url>
    <content type="text"><![CDATA[今天主要讲的是递归和DFS，因为涉及到递归，很抽象，所以比较难理解。题也很难做。 Oil DepositsDescription：The GeoSurvComp geologic survey company is responsible for detecting underground oil deposits. GeoSurvComp works with one large rectangular region of land at a time, and creates a grid that divides the land into numerous square plots. It then analyzes each plot separately, using sensing equipment to determine whether or not the plot contains oil. A plot containing oil is called a pocket. If two pockets are adjacent, then they are part of the same oil deposit. Oil deposits can be quite large and may contain numerous pockets. Your job is to determine how many different oil deposits are contained in a grid.InputThe input file contains one or more grids. Each grid begins with a line containing m and n, the number of rows and columns in the grid, separated by a single space. If m = 0 it signals the end of the input; otherwise 1 &lt;= m &lt;= 100 and 1 &lt;= n &lt;= 100. Following this are m lines of n characters each (not counting the end-of-line characters). Each character corresponds to one plot, and is either `*&#39;, representing the absence of oil, or `@&#39;, representing an oil pocket. Output For each grid, output the number of distinct oil deposits. Two different pockets are part of the same oil deposit if they are adjacent horizontally, vertically, or diagonally. An oil deposit will not contain more than 100 pockets. Sample Input1234567891011121314151 1*3 5*@*@***@***@*@*1 8@@****@*5 5****@*@@*@*@**@@@@*@@@**@0 0 Sample Output 0122 Problem solving:简单题，输入一个图，@表示油田，*表示没有油田，@只要是相邻的都可以算成是一个，所以就是八个方向上dfs就行，访问过的@就换成*或者其他的字符就行只要不是@.(如果这样写的话其实就不需要标记数组了) Code:123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;char s[105][105];int vis[105][105];int m,n,ans;int d[8][2]=&#123;1,0,0,1,0,-1,-1,0,1,1,1,-1,-1,-1,-1,1&#125;;void dfs(int x,int y)&#123; vis[x][y]=1; if(x&lt;0||x&gt;=m||y&lt;0||y&gt;=n) return ; for(int i=0;i&lt;8;i++) &#123; int dx=x+d[i][0]; int dy=y+d[i][1]; if(dx&gt;=0&amp;&amp;dx&lt;m&amp;&amp;dy&gt;=0&amp;&amp;dy&lt;n&amp;&amp;!vis[dx][dy]&amp;&amp;s[dx][dy]==&apos;@&apos;) &#123; s[dx][dy]=&apos;*&apos;; dfs(dx,dy); &#125; &#125;&#125;int main()&#123; while(cin&gt;&gt;m&gt;&gt;n&amp;&amp;m) &#123; memset(vis,0,sizeof(vis)); ans=0; for(int i=0;i&lt;m;i++) cin&gt;&gt;s[i]; for(int i=0;i&lt;m;i++) &#123; for(int j=0;j&lt;n;j++) &#123; if(s[i][j]==&apos;@&apos;) &#123; dfs(i,j); ans++; &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125; How Many Equations Can You FindDescription：Now give you an string which only contains 0, 1 ,2 ,3 ,4 ,5 ,6 ,7 ,8 ,9.You are asked to add the sign ‘+’ or ’-’ between the characters. Just like give you a string “12345”, you can work out a string “123+4-5”. Now give you an integer N, please tell me how many ways can you find to make the result of the string equal to N .You can only choose at most one sign between two adjacent characters.Input Each case contains a string s and a number N . You may be sure the length of the string will not exceed 12 and the absolute value of N will not exceed 999999999999. Output The output contains one line for each data set : the number of ways you can find to make the equation. Sample Input 123456789 321 1 Sample Output 181 Problem solving:每两个数中间都有两种可能，一种是加号一种是减号，并且能放入操作符的位置我们也是知道的，所以只需要查找每个位置放上不同的运算符之后得到的所有结果，看有几个与n相等即可。查找的过程用dfs来实现。 Code:1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;string s;int n,ans;void dfs(int x,int now)//x代表的是当前要进行操作的位置，now代表当前得到的值&#123; if(x==s.size())//如果x已经跟字符串的长度相等说明这一次遍历已经结束了 &#123; if(now==n) ans++;//如果得到的值跟n相等，答案就加一// cout&lt;&lt;now&lt;&lt;endl; return ; &#125; for(int i=x;i&lt;s.size();i++) &#123; int mid=0; for(int j=x;j&lt;=i;j++) &#123; mid=mid*10+s[j]-&apos;0&apos;;//得到运算符左边字符串所代表数的大小// cout&lt;&lt;mid&lt;&lt;&quot;?&quot;&lt;&lt;now&lt;&lt;endl; &#125; dfs(i+1,now+mid);//去访问下一个位置，并且此时的值加上上面得到的运算符左边字符串所代表的数 if(x) dfs(i+1,now-mid);//减号不能放在最前面，所以要有一个x不为0的判断 &#125;&#125;int main()&#123; while(cin&gt;&gt;s&gt;&gt;n) &#123; ans=0; dfs(0,0);//从s[0]开始，当前值为0 cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125; N皇后问题Description：在N*N的方格棋盘放置了N个皇后，使得它们不相互攻击（即任意2个皇后不允许处在同一排，同一列，也不允许处在与棋盘边框成45角的斜线上。你的任务是，对于给定的N，求出有多少种合法的放置方法。 Input 共有若干行，每行一个正整数N≤10，表示棋盘和皇后的数量；如果N=0，表示结束。 Output 共有若干行，每行一个正整数，表示对应输入行的皇后的不同放置数量。 Sample Input 1850 Sample Output 19210 Problem solving:从第一行开始放，然后放下一行，如果出现了在同一行的或者同一列的或者同一条斜线上的就return，如果放进去的个数等于n，答案就加一。这道题N虽然小于等于10，但是是多组输入，如果每次输入都计算一次并且输入数据很多的话，肯定会TLE。所以需要打表，就是如果这个计算过了就把它的结果记录下来，如果下次又要求这个的结果直接调用就行。也可以直接从输入前就先计算好存进数组。 Code:12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;int n,mid;int ans[12],mmp[12];void dfs(int x)&#123; if(x==n+1) &#123; mid++; return ; &#125; for(int i=1;i&lt;=n;i++) &#123; int flag=1; mmp[x]=i; for(int j=1;j&lt;x;j++) &#123; if(mmp[j]==i||(abs(j-x)==abs(mmp[j]-mmp[x]))) &#123; flag=0; break; &#125; &#125; if(flag) dfs(x+1); &#125;&#125;int main()&#123; for(n=1;n&lt;=10;n++) &#123; mid=0; dfs(1); ans[n]=mid; &#125; int t; while(cin&gt;&gt;t&amp;&amp;t) &#123; cout&lt;&lt;ans[t]&lt;&lt;endl; &#125;&#125; Fox And Two DotsDescription：Fox Ciel is playing a mobile puzzle game called &quot;Two Dots&quot;. The basic levels are played on a board of size n × m cells, like this: Each cell contains a dot that has some color. We will use different uppercase Latin characters to express different colors. The key of this game is to find a cycle that contain dots of same color. Consider 4 blue dots on the picture forming a circle as an example. Formally, we call a sequence of dots d1, d2, ..., dk a cycle if and only if it meets the following condition: These k dots are different: if i ≠ j then di is different from dj. k is at least 4. All dots belong to the same color. For all 1 ≤ i ≤ k - 1: di and di + 1 are adjacent. Also, dk and d1 should also be adjacent. Cells x and y are called adjacent if they share an edge. Determine if there exists a cycle on the field.Input The first line contains two integers n and m (2 ≤ n, m ≤ 50): the number of rows and columns of the board.Then n lines follow, each line contains a string consisting of m characters, expressing colors of dots in each line. Each character is an uppercase Latin letter. Output Output &quot;Yes&quot; if there exists a cycle, and &quot;No&quot; otherwise. ExamplesInput 3 4AAAAABCAAAAA Output Yes Input 3 4AAAAABCAAADA Output No Input 4 4YYYRBYBYBBBYBBBY Output Yes Input 7 6AAAAABABBBABABAAABABABBBABAAABABBBABAAAAAB Output Yes Input 2 13ABCDEFGHIJKLMNOPQRSTUVWXYZ Output No NoteIn first sample test all &#39;A&#39; form a cycle. In second sample there is no such cycle. The third sample is displayed on the picture above (&#39;Y&#39; = Yellow, &#39;B&#39; = Blue, &#39;R&#39; = Red).Problem solving:这道题的意思就是输入一个由大写字母组成的图，如果相同的字母可以组成一个环，就输出Yes，否则输出No。这道题跟昨天的那个机器人有点类似，不过那个机器人每次走的方向是定的，而这个是可以随意走的。所以如何进行判断会不会有环的存在呢？我们只需要在每次进行dfs的查找之前把最初的初始位置记录一下，然后开始dfs查找，上下左右四个方向，遇到与当前字母一样的字母就以这个为初始位置继续dfs，并且记录下来当前走的步数。如果在dfs结束之前遇到了一个(dx,dy)与我们记录的最初始的初始位置相等并且步数大于等于4的情况，就说明存在环，输出&#39;Yes&#39;即可，反之输出&#39;No&#39;。 Code:12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;char s[60][60];int vis[60][60],flag,n,m,sx,sy;int d[4][2]=&#123;1,0,0,1,-1,0,0,-1&#125;;void dfs(int x,int y,int step)&#123; if(flag) return ; vis[x][y]=1; for(int i=0;i&lt;4;i++) &#123; int dx=x+d[i][0]; int dy=y+d[i][1]; if(dx==sx&amp;&amp;dy==sy&amp;&amp;step&gt;=4) &#123; flag=1; return ; &#125; if(dx&gt;=0&amp;&amp;dx&lt;n&amp;&amp;dy&gt;=0&amp;&amp;dy&lt;m&amp;&amp;!vis[dx][dy]&amp;&amp;s[dx][dy]==s[x][y]) &#123; dfs(dx,dy,step+1); &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) cin&gt;&gt;s[i]; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;m;j++) &#123; memset(vis,0,sizeof(vis)); sx=i,sy=j; dfs(sx,sy,1); &#125; &#125; if(flag) puts(&quot;Yes&quot;); else puts(&quot;No&quot;);&#125; 棋盘问题Description：在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。Input 输入含有多组测试数据。每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n &lt;= 8 , k &lt;= n当为-1 -1时表示输入结束。随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。 Output 对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C\&lt;2^31）。 Sample Input1234567892 1#..#4 4...#..#..#..#...-1 -1 Sample Output 21 Problem solving:跟n皇后很像的一个问题。判断条件还少了一个。注意回溯就行。 Code:1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int n,k,vis[10],ans,now;char s[10][10];void dfs(int x)&#123; if(now==k) &#123; ans++; return ; &#125; if(x&gt;=n) return ; for(int j=0;j&lt;n;j++) &#123; if(!vis[j]&amp;&amp;s[x][j]==&apos;#&apos;) &#123; vis[j]=1; now++; dfs(x+1); now--; vis[j]=0; &#125; &#125; dfs(x+1);&#125;int main()&#123; while(scanf(&quot;%d %d&quot;,&amp;n,&amp;k)&amp;&amp;n!=-1&amp;&amp;k!=-1) &#123; memset(vis,0,sizeof(vis)); for(int i=0;i&lt;n;i++) cin&gt;&gt;s[i]; ans=0,now=0; dfs(0); cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125; SudokuDescription：Sudoku is a very simple task. A square table with 9 rows and 9 columns is divided to 9 smaller squares 3x3 as shown on the Figure. In some of the cells are written decimal digits from 1 to 9. The other cells are empty. The goal is to fill the empty cells with decimal digits from 1 to 9, one digit per cell, in such way that in each row, in each column and in each marked 3x3 subsquare, all the digits from 1 to 9 to appear. Write a program to solve a given Sudoku-task. Input The input data will start with the number of the test cases. For each test case, 9 lines follow, corresponding to the rows of the table. On each line a string of exactly 9 decimal digits is given, corresponding to the cells in this line. If a cell is empty it is represented by 0. Output For each test case your program should print the solution in the same format as the input data. The empty cells have to be filled according to the rules. If solutions is not unique, then the program may print any one of them. Sample Input 1103000509002109400000704000300502006060000050700803004000401000009205800804000107 Sample Output 143628579572139468986754231391542786468917352725863914237481695619275843854396127 Problem solving:这道题的处理方式很巧妙。dfs中的参数只设置一个n(n就是代表着这是第几个数)就够了，就是当前的位置，在dfs中每次加一，如果当前位置不为0，就直接查找下一个位置。否则就从1～9中选一个数放进去，看同一行同一列以及同一小方格的同一行同一列有没有与之相同的，如果没有，就将当前位置的数更新成这个没有重复出现过的数。知道查找到n&gt;=81的时候，即每个位置都查找完了，结束查找输出即可。注意在查找的过程中需要用到回溯，因为如果这一条路行不通而返回上一条路的时候，此时当前位置还应该是0.思路还是很清晰的，难点主要有两个 如何用n来表示当前的位置 如何判断同一行同一列以及同一小方格的同一行同一列有没有与之相同的数 n/9代表的就是当前位置的行，n%9代表的就是当前位置的列。n/9/3*3表示的就是当前位置在小方格里的行，n%9/3*3代表的就是当前位置在小方格里的列。 位置都能表示出来了，那么判断也就简单了。分别确定二维数组的第一个和第二个坐标进行判断就行了。这一点可能说的不是很好理解，可以看看代码，还是很好理解的。 这里还用到了一个很巧妙的输入scanf(&quot;%1d&quot;,&amp;a);这样的话就不用输入字符再转换成整型了。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int a[10][10],flag;bool check(int n,int now)&#123; for(int i=0;i&lt;9;i++) &#123; int j=n%9; if(a[i][j]==now) return 0; &#125; for(int j=0;j&lt;9;j++) &#123; int i=n/9; if(a[i][j]==now) return 0; &#125; int di=n/9/3*3; int dj=n%9/3*3; for(int i =di;i&lt;di+3;i++) &#123; for(int j=dj;j&lt;dj+3;j++) &#123; if(a[i][j]==now) return 0; &#125; &#125; return 1;&#125;int dfs(int n)&#123; if(n&gt;=81) &#123; flag=1; return 0; &#125; if(a[n/9][n%9]!=0) dfs(n+1); else &#123; for(int i=1;i&lt;=9;i++) &#123; if(check(n,i)==1) &#123; a[n/9][n%9]=i; dfs(n+1); if(flag==1) return 0; a[n/9][n%9]=0;//回溯 &#125; &#125; &#125;// cout&lt;&lt;&quot;?&quot;&lt;&lt;endl;&#125;int main()&#123; int t; cin&gt;&gt;t; while(t--) &#123; flag=0; for(int i=0;i&lt;9;i++) for(int j=0;j&lt;9;j++) scanf(&quot;%1d&quot;,&amp;a[i][j]); dfs(0); for(int i=0;i&lt;9;i++) &#123; for(int j=0;j&lt;9;j++) printf(&quot;%d&quot;,a[i][j]); puts(&quot;&quot;); &#125; &#125; return 0;&#125; 放苹果Description：把M个同样的苹果放在N个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？（用K表示）5，1，1和1，5，1 是同一种分法。Input 第一行是测试数据的数目t（0 &lt;= t &lt;= 20）。以下每行均包含二个整数M和N，以空格分开。1&lt;=M，N&lt;=10。 Output 对输入的每组数据M和N，用一行输出相应的K。 Sample Input 17 3 Sample Output 8 Problem solving:思维题。(让我说也说不清，还是借用一下大佬的解释吧)设f(m,n) 为m个苹果，n个盘子的放法数目，则先对n作讨论， 当n&gt;m：必定有n-m个盘子永远空着，去掉它们对摆放苹果方法数目不产生影响。即if(n&gt;m) f(m,n) = f(m,m) 当n&lt;=m：不同的放法可以分成两类： 1、有至少一个盘子空着，即相当于f(m,n) = f(m,n-1); 2、所有盘子都有苹果，相当于可以从每个盘子中拿掉一个苹果，不影响不同放法的数目，即f(m,n) = f(m-n,n). 而总的放苹果的放法数目等于两者的和，即 f(m,n) =f(m,n-1)+f(m-n,n) 递归出口条件说明： 当n=1时，所有苹果都必须放在一个盘子里，所以返回１； 当没有苹果可放时，定义为１种放法； 递归的两条路，第一条n会逐渐减少，终会到达出口n==1; 第二条m会逐渐减少，因为n&gt;m时，我们会return f(m,m) 所以终会到达出口m==0．此解释源于：https://blog.csdn.net/jason0539/article/details/12183817 Code:1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;int t,n,m,ans;int dfs(int x,int y)&#123; if(x==0||y==1)&#123; return 1; &#125; else if(x&lt;y) return dfs(x,x); return dfs(x,y-1)+dfs(x-y,y);&#125;int main()&#123; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;m&gt;&gt;n; cout&lt;&lt;dfs(m,n)&lt;&lt;endl; &#125;&#125; Tempter of the BoneDescription：小明做了一个很久很久的梦，醒来后他竟发现自己和朋友在一个摇摇欲坠的大棋盘上，他们必须得想尽一切办法逃离这里。经过长时间的打探，小明发现，自己所在的棋盘格子上有个机关，上面写着“你只有一次机会，出发后t秒大门会为你敞开”，而他自己所在的棋盘是大小为 N*M 的长方形，他可以向上下左右四个方向移动（不可走有障碍点）。棋盘中有一扇门。根据机关的提示，小明顿时明白了，他和朋友必须在第 t 秒到门口。而这一切，没有回头路！因为一旦他移动了，他刚才所在的点就会消失，并且他不能在一个点上停留超过一秒，不然格子会爆炸。大逃亡开始了，请问小明和朋友能安全的逃出这奇怪的棋盘吗？ Input 输入多组测试数据。每个测试用例的第一行包含三个整数 N、M 和 T ( 1 &lt; N , M &lt; 7 ; 0 &lt; T &lt; 50 )，分别表示棋盘的大小和门打开的时间。接下来的N行给出棋盘布局，每一行包含M个字符。其中&quot;.&quot;: 无障碍点&quot;X&quot;: 障碍点&quot;S&quot;: 起点&quot;D&quot;: 门输入以 3 个 0 结束。这个测试用例不需要处理。输入数据中的空格有些问题，请不要使用getchar()，如果一定要用可以选择scanf(&quot;%s&quot;,) 自动忽略空格 Output 对于每组样例输出一行。如果小明能够安全逃出，输出 &quot;YES&quot; ，否则输出 &quot;NO&quot;。 Sample Input123456789104 4 5S.X...X...XD....3 4 5S.X...X....D0 0 0 Sample Output NOYES Problem solving:注意题目中要求的是当你走到D的时候你走的步数与它开门的时间即T相等，所以需要用DFS查找每一条到达D的路，看与T相等的值是否存在。因为要查询到每一条路，这道题可能会超时。所以会用到一种很神奇的剪枝——奇偶剪枝除去这个剪枝的难度的话这道题就很简单了。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,t,sx,sy,ex,ey,ti,flag;char s[10][10];int vis[10][10];int d[4][2]=&#123;0,1,0,-1,1,0,-1,0&#125;;void dfs(int x,int y)&#123; if(x&lt;0||x&gt;=n||y&lt;0||y&gt;=m||ti&gt;t) return ; if(flag) return ; if(s[x][y]==&apos;D&apos;&amp;&amp;ti==t) &#123;// cout&lt;&lt;ti&lt;&lt;endl; flag=1; return ; &#125; int temp1 = abs(ex-x) + abs(ey-y); int temp2 = abs(t-ti); int temp = abs(temp1-temp2); if(temp%2!=0) return ; vis[x][y]=1; for(int i=0;i&lt;4;i++) &#123; int dx=x+d[i][0]; int dy=y+d[i][1]; if(dx&gt;=0&amp;&amp;dx&lt;n&amp;&amp;dy&gt;=0&amp;&amp;dy&lt;m&amp;&amp;!vis[dx][dy]&amp;&amp;s[dx][dy]!=&apos;X&apos;) &#123;// cout&lt;&lt;ti&lt;&lt;&quot;--&gt;&quot;&lt;&lt;dx&lt;&lt;&quot; --&gt;&quot;&lt;&lt;dy&lt;&lt;&quot;\n&quot;; ti++; dfs(dx,dy); vis[dx][dy]=0; ti--; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(0); while(cin&gt;&gt;n&gt;&gt;m&gt;&gt;t) &#123; if(n==0&amp;&amp;m==0&amp;&amp;t==0) break; flag=0,ti=0; memset(vis,0,sizeof(vis)); for(int i=0;i&lt;n;i++) cin&gt;&gt;s[i]; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) if(s[i][j]==&apos;S&apos;) &#123; sx=i,sy=j; &#125; else if(s[i][j]==&apos;D&apos;) &#123; ex=i,ey=j; &#125; dfs(sx,sy); if(flag) puts(&quot;YES&quot;); else puts(&quot;NO&quot;); &#125;&#125; Red and BlackDescription：There is a rectangular room, covered with square tiles. Each tile is colored either red or black. A man is standing on a black tile. From a tile, he can move to one of four adjacent tiles. But he can&#39;t move on red tiles, he can move only on black tiles. Write a program to count the number of black tiles which he can reach by repeating the moves described above.Input The input consists of multiple data sets. A data set starts with a line containing two positive integers W and H; W and H are the numbers of tiles in the x- and y- directions, respectively. W and H are not more than 20.There are H more lines in the data set, each of which includes W characters. Each character represents the color of a tile as follows.&#39;.&#39; - a black tile&#39;#&#39; - a red tile&#39;@&#39; - a man on a black tile(appears exactly once in a data set) Output For each data set, your program should output a line which contains the number of tiles he can reach from the initial tile (including itself). Sample Input1234567891011121314151617181920212223242526272829303132333435366 9....#......#..............................#@...#.#..#.11 9.#..........#.#######..#.#.....#..#.#.###.#..#.#..@#.#..#.#####.#..#.......#..#########............11 6..#..#..#....#..#..#....#..#..###..#..#..#@...#..#..#....#..#..#..7 7..#.#....#.#..###.###...@...###.###..#.#....#.#..0 0 Sample Output 4559613 Problem solving:对没错就是昨天那道题，用bfs可以写，用dfs也可以写。太强了。只要下一个还是可以走得就一直dfs查找下去就行。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;char s[25][25];int vis[25][25];int a,b,ans;int d[4][2]=&#123;1,0,0,1,0,-1,-1,0&#125;;void dfs(int x,int y)&#123; vis[x][y]=1; if(x&lt;0||x&gt;=b||y&lt;0||y&gt;=a) return ; for(int i=0;i&lt;4;i++) &#123; int dx=x+d[i][0]; int dy=y+d[i][1]; if(dx&gt;=0&amp;&amp;dx&lt;b&amp;&amp;dy&gt;=0&amp;&amp;dy&lt;a&amp;&amp;!vis[dx][dy]&amp;&amp;s[dx][dy]!=&apos;#&apos;) &#123; ans++; dfs(dx,dy); &#125; &#125;&#125;int main()&#123; while(cin&gt;&gt;a&gt;&gt;b) &#123; if(a==0&amp;&amp;b==0) break; ans=1; memset(vis,0,sizeof(vis)); for(int i=0;i&lt;b;i++) &#123; for(int j=0;j&lt;a;j++) &#123; cin&gt;&gt;s[i][j]; &#125; &#125; for(int i=0;i&lt;b;i++) for(int j=0;j&lt;a;j++) &#123; if(s[i][j]==&apos;@&apos;) dfs(i,j); &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125;]]></content>
      <categories>
        <category>Training</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>c/c++</tag>
        <tag>HDU</tag>
        <tag>CodeForces</tag>
        <tag>poj</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HPU Summer Training Day 7（河南理工大学暑期第七天）]]></title>
    <url>%2Fblog%2F2019%2F07%2F23%2Fd7%2F</url>
    <content type="text"><![CDATA[今天主要讲了BFS和DFS，还有存图和链式前向星，后面这两个在今天刷题的过程中还没有遇到，晚会把他们加到我的模板里面。 RescueDescription:Angel was caught by the MOLIGPY! He was put in prison by Moligpy. The prison is described as a N * M (N, M &lt;= 200) matrix. There are WALLs, ROADs, and GUARDs in the prison. Angel&#39;s friends want to save Angel. Their task is: approach Angel. We assume that &quot;approach Angel&quot; is to get to the position where Angel stays. When there&#39;s a guard in the grid, we must kill him (or her?) to move into the grid. We assume that we moving up, down, right, left takes us 1 unit time, and killing a guard takes 1 unit time, too. And we are strong enough to kill all the guards. You have to calculate the minimal time to approach Angel. (We can move only UP, DOWN, LEFT and RIGHT, to the neighbor grid within bound, of course.)Input First line contains two integers stand for N and M.Then N lines follows, every line has M characters. &quot;.&quot; stands for road, &quot;a&quot; stands for Angel, and &quot;r&quot; stands for each of Angel&#39;s friend.Process to the end of the file. Output For each test case, your program should output a single integer, standing for the minimal time needed. If such a number does no exist, you should output a line containing &quot;Poor ANGEL has to stay in the prison all his life.&quot; Sample Input123456787 8#.#####.#.a#..r.#..#x.....#..#.##...##...#.............. Sample Output 13 Problem solving:注意是多组输入，这里用到了运算符重载和优先队列，这两个东西最近在刷题的过程中出现的频率很高。因为这道题中r可能有多个所以我们用a去寻找r，用结构体存点的坐标，用优先队列存结构体实现BFS，先定义一个ans变量用来存放答案，初始化为-1，如果可以找到符合条件的点就更新ans的值并结束查找。查找结束之后，如果ans仍是-1，那么输出Poor ANGEL has to stay in the prison all his life.，否则就输出ans的值，查找过程就是bfs的模板，但是用的是优先队列。我们遇到X的时候只需要+2即可。其他的判断条件都挺好理解，可以直接看代码。 结构体如果想套到优先队列中就需要运算符重载。运算符重载的方法有好几种，这里我就会这一种。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;char s[205][205];int d[4][2]=&#123;-1,0,0,1,1,0,0,-1&#125;;struct node&#123; int x,y,step; friend bool operator &lt; (node a,node b) &#123; return a.step&gt;b.step; &#125;&#125;;int n,m;int vis[205][205];void bfs(int x,int y,int xx,int yy)&#123; int ans=-1; memset(vis,0,sizeof(vis)); priority_queue&lt;node&gt; q; node mid,mmp; mid.x=x,mid.y=y,mid.step=0; vis[x][y]=1; q.push(mid); while(!q.empty()) &#123; mid=q.top(); q.pop(); if(mid.x==xx&amp;&amp;mid.y==yy) &#123; ans=mid.step; break; &#125; for(int i=0;i&lt;4;i++) &#123; mmp.x=mid.x+d[i][0]; mmp.y=mid.y+d[i][1]; if(mmp.x&lt;0||mmp.x&gt;=n||mmp.y&lt;0||mmp.y&gt;=m||vis[mmp.x][mmp.y]==1||s[mmp.x][mmp.y]==&apos;#&apos;) continue; if(s[mmp.x][mmp.y]==&apos;x&apos;) mmp.step=mid.step+2; else mmp.step=mid.step+1; q.push(mmp); vis[mmp.x][mmp.y]=1; &#125; &#125; if(ans==-1) puts(&quot;Poor ANGEL has to stay in the prison all his life.&quot;); else cout&lt;&lt;ans&lt;&lt;endl;&#125;int main()&#123; int sx,sy,ex,ey; while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;m)) &#123; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;m;j++) &#123; cin&gt;&gt;s[i][j]; if(s[i][j]==&apos;a&apos;) &#123; sx=i; sy=j; &#125; if(s[i][j]==&apos;r&apos;) &#123; ex=i; ey=j; &#125; &#125; &#125; bfs(sx,sy,ex,ey); &#125;&#125; Red and BlackDescription:There is a rectangular room, covered with square tiles. Each tile is colored either red or black. A man is standing on a black tile. From a tile, he can move to one of four adjacent tiles. But he can&#39;t move on red tiles, he can move only on black tiles. Write a program to count the number of black tiles which he can reach by repeating the moves described above.Input The input consists of multiple data sets. A data set starts with a line containing two positive integers W and H; W and H are the numbers of tiles in the x- and y- directions, respectively. W and H are not more than 20.There are H more lines in the data set, each of which includes W characters. Each character represents the color of a tile as follows.&#39;.&#39; - a black tile&#39;#&#39; - a red tile&#39;@&#39; - a man on a black tile(appears exactly once in a data set) Output For each data set, your program should output a line which contains the number of tiles he can reach from the initial tile (including itself). Sample Input1234567891011121314151617181920212223242526272829303132333435366 9....#......#..............................#@...#.#..#.11 9.#..........#.#######..#.#.....#..#.#.###.#..#.#..@#.#..#.#####.#..#.......#..#########............11 6..#..#..#....#..#..#....#..#..###..#..#..#@...#..#..#....#..#..#..7 7..#.#....#.#..###.###...@...###.###..#.#....#.#..0 0 Sample Output 4559613 Problem solving:简单的BFS模板题，注意答案要加上一开始所处位置的点。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;char s[25][25];int vis[25][25];int d[4][2]=&#123;1,0,0,1,0,-1,-1,0&#125;;struct node&#123; int x,y;&#125;;int w,h;queue&lt;node&gt; que;void bfs(int x,int y)&#123; memset(vis,0,sizeof(vis)); node mid,now,mmp; int ans=0; mid.x=x; mid.y=y; vis[x][y]=1; que.push(mid); while(!que.empty()) &#123; now=que.front(); que.pop(); for(int i=0;i&lt;4;i++) &#123; mmp.x=now.x+d[i][0]; mmp.y=now.y+d[i][1]; if(mmp.x&lt;0||mmp.x&gt;=h||mmp.y&lt;0||mmp.y&gt;=w||vis[mmp.x][mmp.y]==1||s[mmp.x][mmp.y]==&apos;#&apos;) continue; ans++; vis[mmp.x][mmp.y]=1; que.push(mmp); s[mmp.x][mmp.y]=&apos;?&apos;; &#125; &#125; cout&lt;&lt;ans+1&lt;&lt;endl;&#125;int main()&#123; int sx,sy; while(scanf(&quot;%d %d&quot;,&amp;w,&amp;h)&amp;&amp;w&amp;&amp;h) &#123; for(int i=0;i&lt;h;i++) &#123; for(int j=0;j&lt;w;j++) &#123; cin&gt;&gt;s[i][j]; if(s[i][j]==&apos;@&apos;) &#123; sx=i; sy=j; &#125; &#125; &#125;// cout&lt;&lt;sx&lt;&lt;&quot; &quot;&lt;&lt;sy&lt;&lt;endl; bfs(sx,sy);// for(int i=0;i&lt;h;i++)// &#123;// for(int j=0;j&lt;w;j++)// &#123;// cout&lt;&lt;s[i][j];// &#125;// puts(&quot;&quot;);// &#125; &#125;&#125; Battle CityDescription:Many of us had played the game &quot;Battle city&quot; in our childhood, and some people (like me) even often play it on computer now.What we are discussing is a simple edition of this game. Given a map that consists of empty spaces, rivers, steel walls and brick walls only. Your task is to get a bonus as soon as possible suppose that no enemies will disturb you (See the following picture).Your tank can&#39;t move through rivers or walls, but it can destroy brick walls by shooting. A brick wall will be turned into empty spaces when you hit it, however, if your shot hit a steel wall, there will be no damage to the wall. In each of your turns, you can choose to move to a neighboring (4 directions, not 8) empty space, or shoot in one of the four directions without a move. The shot will go ahead in that direction, until it go out of the map or hit a wall. If the shot hits a brick wall, the wall will disappear (i.e., in this turn). Well, given the description of a map, the positions of your tank and the target, how many turns will you take at least to arrive there? Input The input consists of several test cases. The first line of each test case contains two integers M and N (2 &lt;= M, N &lt;= 300). Each of the following M lines contains N uppercase letters, each of which is one of &#39;Y&#39; (you), &#39;T&#39; (target), &#39;S&#39; (steel wall), &#39;B&#39; (brick wall), &#39;R&#39; (river) and &#39;E&#39; (empty space). Both &#39;Y&#39; and &#39;T&#39; appear only once. A test case of M = N = 0 indicates the end of input, and should not be processed. Output For each test case, please output the turns you take at least in a separate line. If you can&#39;t arrive at the target, output &quot;-1&quot; instead. Sample Input 3 4YBEBEERESSTE0 0 Sample Output 8 Problem solving:这道题跟A很像。用优先队列进行BFS查找。判断条件也很简单。不懂的话，可以直接看代码 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;int m,n;char s[305][305];int vis[305][305];struct node&#123; int x,y,step; friend bool operator &lt; (node a,node b) &#123; return a.step&gt;b.step; &#125;&#125;;int d[4][2]=&#123;1,0,0,1,-1,0,0,-1&#125;;void bfs(int x,int y,int xx,int yy)&#123; int ans=-1; memset(vis,0,sizeof(vis)); node mid,now; priority_queue&lt;node&gt; q; mid.x=x;mid.y=y;mid.step=0; q.push(mid); vis[x][y]=1; while(!q.empty()) &#123; mid=q.top(); if(mid.x==xx&amp;&amp;mid.y==yy) &#123;// cout&lt;&lt;mid.x&lt;&lt;&quot; &quot;&lt;&lt;mid.y&lt;&lt;endl; ans=mid.step; break; &#125; q.pop(); for(int i=0;i&lt;8;i++) &#123; now.x=mid.x+d[i][0]; now.y=mid.y+d[i][1]; if(now.x&lt;0||now.x&gt;=m||now.y&lt;0||now.y&gt;=n||s[now.x][now.y]==&apos;S&apos;||s[now.x][now.y]==&apos;R&apos;||vis[now.x][now.y]==1) continue; if(s[now.x][now.y]==&apos;B&apos;) now.step=mid.step+2; else now.step=mid.step+1; vis[now.x][now.y]=1; s[now.x][now.y]=now.step+&apos;0&apos;; q.push(now); &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125;int main()&#123; int sx,sy,ex,ey; while(scanf(&quot;%d %d&quot;,&amp;m,&amp;n)&amp;&amp;m&amp;&amp;n) &#123; for(int i=0;i&lt;m;i++) &#123; for(int j=0;j&lt;n;j++) &#123; cin&gt;&gt;s[i][j]; if(s[i][j]==&apos;Y&apos;) &#123; sx=i; sy=j; &#125; if(s[i][j]==&apos;T&apos;) &#123; ex=i; ey=j; &#125; &#125; &#125; bfs(sx,sy,ex,ey);// for(int i=0;i&lt;m;i++)// &#123;// for(int j=0;j&lt;n;j++)// &#123;// cout&lt;&lt;s[i][j];// &#125;// puts(&quot;&quot;);// &#125; &#125;&#125; Catch That CowDescription:农夫知道一头牛的位置，想要抓住它。农夫和牛都于数轴上 ，农夫起始位于点 N(0&lt;=N&lt;=100000) ，牛位于点 K(0&lt;=K&lt;=100000) 。农夫有两种移动方式： 1、从 X移动到 X-1或X+1 ，每次移动花费一分钟 2、从 X移动到 2\X ，每次移动花费一分钟 假设牛没有意识到农夫的行动，站在原地不。最少要花多少时间才能抓住牛？Input一行: 以空格分隔的两个字母: N 和 KOutput一行: 农夫抓住牛需要的最少时间，单位分钟Sample Input 5 17 Sample Output 4 Hint农夫使用最短时间抓住牛的方案如下: 5-10-9-18-17, 需要4分钟. Problem solving:经典的BFS例题。每次往下扩展队列的时候只有3种情况。就像是经常在图里面用到的四个方向一样。判断条件中要有一个最大值，不然就有可能会一直查找下去。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;int vis[1000000];int step[1000000];void bfs(int x,int y)&#123; memset(vis,0,sizeof(vis)); queue&lt;int&gt; q; q.push(x); step[x]=0; vis[x]=1; while(!q.empty()) &#123; int mid=q.front(),mmp; q.pop(); if(mid==y) &#123; cout&lt;&lt;step[y]&lt;&lt;endl; break; &#125; for(int i=0;i&lt;3;i++) &#123; if(i==0) mmp=mid-1; if(i==1) mmp=mid+1; if(i==2) mmp=mid*2; if(mmp&gt;=0&amp;&amp;mmp&lt;1000000&amp;&amp;vis[mmp]==0) &#123; q.push(mmp); step[mmp]=step[mid]+1; vis[mmp]=1; &#125; &#125; &#125;&#125;int main()&#123; int n,k; while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;k)) &#123; if(n&gt;=k) cout&lt;&lt;n-k&lt;&lt;endl; else bfs(n,k); &#125;&#125; Dungeon MasterDescription:[NWUACM]你被困在一个三维的空间中,现在要寻找最短路径逃生！空间由立方体单位构成你每次向上下前后左右移动一个单位需要一分钟你不能对角线移动并且四周封闭是否存在逃出生天的可能性？如果存在，则需要多少时间？ Input输入第一行是一个数表示空间的数量。每个空间的描述的第一行为L，R和C（皆不超过30）。L表示空间的高度。R和C分别表示每层空间的行与列的大小。随后L层地牢，每层R行，每行C个字符。每个字符表示空间的一个单元。&#39;#&#39;表示不可通过单元，&#39;.&#39;表示空白单元。你的起始位置在&#39;S&#39;，出口为&#39;E&#39;。每层空间后都有一个空行。L，R和C均为0时输入结束。 Output - 输出每个空间对应一行输出。如果可以逃生，则输出如下Escaped in x minute(s).x为最短脱离时间。如果无法逃生，则输出如下Trapped! Sample Input123456789101112131415161718192021223 4 5S.....###..##..###.#############.####...###########.#######E1 3 3S###E####0 0 0 Sample Output Escaped in 11 minute(s).Trapped! Problem solving:三维中的BFS，跟平常用到的差不多。不过是6个方向，上下左右前后，然后开三位数组进行BFS就好了 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;char map[30][30][30]; int sta[30][30][30]; int base[6][3] = &#123; &#123;-1,0,0&#125;,&#123;1,0,0&#125;,&#123;0,-1,0&#125;,&#123;0,1,0&#125;,&#123;0,0,-1&#125;,&#123;0,0,1&#125; &#125;;int L, R, C;struct Piont&#123; int x, y, z; int step; &#125;;struct Piont s; struct Piont e; struct Piont curp; bool success(struct Piont cur)&#123; if (cur.x == e.x &amp;&amp; cur.y == e.y &amp;&amp; cur.z == e.z) return true; else return false;&#125;bool check(int x, int y, int z)&#123; if ((x &gt;= 0) &amp;&amp; (x &lt; L) &amp;&amp; (y &gt;= 0) &amp;&amp; (y &lt; R) &amp;&amp; (z &gt;= 0) &amp;&amp; (z &lt; C) &amp;&amp; (!sta[x][y][z]) &amp;&amp; (map[x][y][z] == &apos;.&apos; || map[x][y][z] == &apos;E&apos;)) return true; else return false;&#125;void bfs()&#123; struct Piont next; queue&lt;Piont&gt;q; q.push(s); while (!q.empty()) &#123; curp = q.front(); q.pop(); if (success(curp)) return; else &#123; sta[curp.x][curp.y][curp.z] = 1; for (int i = 0; i &lt; 6; i++) &#123; next.x = curp.x + base[i][0]; next.y = curp.y + base[i][1]; next.z = curp.z + base[i][2]; if (check(next.x, next.y, next.z)) &#123; next.step = curp.step + 1; sta[next.x][next.y][next.z] = 1; q.push(next); &#125; &#125; &#125; &#125;&#125;int main()&#123; while (scanf(&quot;%d%d%d&quot;, &amp;L, &amp;R, &amp;C)) &#123; if((L == 0) &amp;&amp; (R == 0) &amp;&amp; (C == 0)) break; memset(sta, 0, sizeof(sta)); for (int i = 0; i &lt; L; i++) &#123; getchar(); for (int j = 0; j &lt; R; j++) &#123; for (int k = 0; k &lt; C; k++) &#123; scanf(&quot;%c&quot;, &amp;map[i][j][k]); if (map[i][j][k] == &apos;S&apos;) &#123; s.x = i; s.y = j; s.z = k; s.step = 0; &#125; else if (map[i][j][k] == &apos;E&apos;) &#123; e.x = i; e.y = j; e.z = k; &#125; &#125; getchar(); &#125; &#125; bfs(); if (curp.x == e.x &amp;&amp; curp.y == e.y &amp;&amp; curp.z == e.z) printf(&quot;Escaped in %d minute(s).\n&quot;, curp.step); else printf(&quot;Trapped!\n&quot;); &#125; return 0;&#125; Robot MotionDescription:A robot has been programmed to follow the instructions in its path. Instructions for the next direction the robot is to move are laid down in a grid. The possible instructions are N north (up the page)S south (down the page)E east (to the right on the page)W west (to the left on the page) For example, suppose the robot starts on the north (top) side of Grid 1 and starts south (down). The path the robot follows is shown. The robot goes through 10 instructions in the grid before leaving the grid. Compare what happens in Grid 2: the robot goes through 3 instructions only once, and then starts a loop through 8 instructions, and never exits. You are to write a program that determines how long it takes a robot to get out of the grid or how the robot loops around.Input There will be one or more grids for robots to navigate. The data for each is in the following form. On the first line are three integers separated by blanks: the number of rows in the grid, the number of columns in the grid, and the number of the column in which the robot enters from the north. The possible entry columns are numbered starting with one at the left. Then come the rows of the direction instructions. Each grid will have at least one and at most 10 rows and columns of instructions. The lines of instructions contain only the characters N, S, E, or W with no blanks. The end of input is indicated by a row containing 0 0 0. Output For each grid in the input there is one line of output. Either the robot follows a certain number of instructions and exits the grid on any one the four sides or else the robot follows the instructions on a certain number of locations once, and then the instructions on some number of locations repeatedly. The sample input below corresponds to the two grids above and illustrates the two forms of output. The word &quot;step&quot; is always immediately followed by &quot;(s)&quot; whether or not the number before it is 1. Sample Input 3 6 5NEESWEWWWESSSNWWWW4 5 1SESWEEESNWNWEENEWSEN0 0 0 Sample Output 10 step(s) to exit3 step(s) before a loop of 8 step(s) Problem solving:这道题我是CSDN上搜的，一开始有思路不知道怎么实现。但是我们可以发现这个里面每个点就会决定自己下一步是往哪里走，所以情况是唯一的。可以直接模拟。这个模拟方式很巧妙地就是标记了走到任意一个位置需要的步数，如果是走出去了，直接调用中间用来存放步数的变量的值进行输出就行。如果在循环的过程中发现下一个要去到的点对应的步数的数组已经有值了就说明此时是在里面刚好转了一圈了。而转圈之前走的步数正好是从开始走走到这个点用到的步数减一，每次转圈的长度就可以用存放步数的变量的值减去到达转圈的第一个点所需要的步数来得到（可以看着代码理解，模拟一下。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;char s[12][12];int vis[12][12];int main()&#123; int a,b,c; while(scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c)) &#123; if(a==0&amp;&amp;b==0&amp;&amp;c==0) break; for(int i=0;i&lt;a;i++) for(int j=0;j&lt;b;j++) cin&gt;&gt;s[i][j]; int x=0,y=c-1,step=0; memset(vis,0,sizeof(vis)); while(true) &#123; step++; if(s[x][y]==&apos;N&apos;&amp;&amp;!vis[x][y]) &#123; vis[x][y]=step; x--; &#125; else if(s[x][y]==&apos;S&apos;&amp;&amp;!vis[x][y]) &#123; vis[x][y]=step; x++; &#125; else if(s[x][y]==&apos;W&apos;&amp;&amp;!vis[x][y]) &#123; vis[x][y]=step; y--; &#125; else if(s[x][y]==&apos;E&apos;&amp;&amp;!vis[x][y]) &#123; vis[x][y]=step; y++; &#125; if(x&lt;0||x==a||y&lt;0||y==b) &#123; printf(&quot;%d step(s) to exit\n&quot;,step); break; &#125; else if(vis[x][y]) &#123; printf(&quot;%d step(s) before a loop of %d step(s)\n&quot;,vis[x][y]-1,step+1-vis[x][y]); break; &#125; &#125; &#125;&#125; Number TransformationDescription:In this problem, you are given an integer number s. You can transform any integer number A to another integer number B by adding x to A. This x is an integer number which is a prime factor of A (please note that 1 and A are not being considered as a factor of A). Now, your task is to find the minimum number of transformations required to transform s to another integer number t. Input Input starts with an integer T (≤ 500), denoting the number of test cases.Each case contains two integers: s (1 ≤ s ≤ 100) and t (1 ≤ t ≤ 1000). Output For each case, print the case number and the minimum number of transformations needed. If it&#39;s impossible, then print -1. Sample Input 26 126 13 Sample Output Case 1: 2Case 2: -1 Problem solving:暴力解决就行，数据范围很小。先对素数打表，然后再进行BFS查找即可。BFS中扩展队列的方式对输入的s，求出s的每个质因子加上它本身之后放进队列，如果出现了与t相同的情况，退出查找即可。关于特殊情况的判定我们还用A题的方式，定义一个ans变量初始值设为-1，如果出现了相等的就对ans进行更新即可。注意，如果在扩展队列的过程中遇到了之前已经出现过的数或者这个数已经大于了t，就不需要再把这个数放进队列了。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;const int maxn = 2005;int p[2005];int vis[2005];void init()&#123; p[1]=p[0]=1; for(int i=2;i&lt;sqrt(maxn);i++) &#123; for(int j=i*2;j&lt;maxn;j+=i) p[j]=1; &#125;&#125;struct node&#123; int x,step;&#125;;int flag;void bfs(int x,int y)&#123; memset(vis,0,sizeof(vis)); flag=-1; queue&lt;node&gt; q; node now,mid; now.x=x;now.step=0; vis[x]=1; q.push(now); int ans=-1; while(!q.empty()) &#123; now=q.front(); q.pop(); for(int i=2;i&lt;now.x;i++) &#123; if(now.x%i==0&amp;&amp;!p[i]) &#123; mid.x=now.x+i; if(vis[mid.x]||mid.x&gt;y) continue; vis[mid.x]=1; mid.step=now.step+1; if(mid.x==y) &#123; flag=mid.step; return ; &#125; q.push(mid); &#125; &#125; &#125;&#125;int main()&#123; int n,a,b; cin&gt;&gt;n; init(); int cnt=1; while(n--) &#123; int a,b; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;&quot;Case &quot;&lt;&lt;cnt++&lt;&lt;&quot;: &quot;; if(a==b) &#123; puts(&quot;0&quot;); continue; &#125; bfs(a,b); cout&lt;&lt;flag&lt;&lt;endl; &#125;&#125; Knight MovesDescription:A friend of you is doing research on the Traveling Knight Problem (TKP) where you are to find the shortest closed tour of knight moves that visits each square of a given set of n squares on a chessboard exactly once. He thinks that the most difficult part of the problem is determining the smallest number of knight moves between two given squares and that, once you have accomplished this, finding the tour would be easy.Of course you know that it is vice versa. So you offer him to write a program that solves the &quot;difficult&quot; part. Your job is to write a program that takes two squares a and b as input and then determines the number of knight moves on a shortest route from a to b.Input The input file will contain one or more test cases. Each test case consists of one line containing two squares separated by one space. A square is a string consisting of a letter (a-h) representing the column and a digit (1-8) representing the row on the chessboard. Output For each test case, print one line saying &quot;To get from xx to yy takes n knight moves.&quot;. Sample Input e2 e4a1 b2b2 c3a1 h8a1 h7h8 a1b1 c3f6 f6 Sample Output To get from e2 to e4 takes 2 knight moves.To get from a1 to b2 takes 4 knight moves.To get from b2 to c3 takes 2 knight moves.To get from a1 to h8 takes 6 knight moves.To get from a1 to h7 takes 5 knight moves.To get from h8 to a1 takes 6 knight moves.To get from b1 to c3 takes 1 knight moves.To get from f6 to f6 takes 0 knight moves. Problem solving:这道题就是一道简单的BFS模板题，只不过题不太好懂，这里我找到一张图可以参考一下。就是马走日的问题，分8个方向进行查找即可。从图上就可以以看出输入的字符串如何处理成坐标的形式。即123while(~scanf(&quot;%s %s&quot;,a,b)) &#123; sx=a[0]-&apos;a&apos;+1;sy=a[1]-&apos;0&apos;;ex=b[0]-&apos;a&apos;+1;ey=b[1]-&apos;0&apos;; Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;int vis[10][10],sx,sy,ex,ey;struct node&#123; int x,y,step;&#125;;int d[8][2]=&#123;-2,-1, -1,-2, 1,-2, 2,-1, 2,1, 1,2, -1,2, -2,1&#125;;int bfs(int x,int y)&#123; memset(vis,0,sizeof(vis)); queue&lt;node&gt; que; vis[x][y]=1; node now,mid; now.x=x;now.y=y;now.step=0; que.push(now); while(!que.empty()) &#123; now=que.front();que.pop(); if(now.x==ex&amp;&amp;now.y==ey) &#123; return now.step; &#125; for(int i=0;i&lt;8;i++) &#123; mid.x=now.x+d[i][0]; mid.y=now.y+d[i][1]; if(mid.x&lt;=0||mid.x&gt;8||mid.y&lt;=0||mid.y&gt;8||vis[mid.x][mid.y]) continue; vis[mid.x][mid.y]=1; mid.step=now.step+1; que.push(mid); &#125; &#125;&#125;int main()&#123; char a[3],b[3]; while(~scanf(&quot;%s %s&quot;,a,b)) &#123; int m; sx=a[0]-&apos;a&apos;+1;sy=a[1]-&apos;0&apos;;ex=b[0]-&apos;a&apos;+1;ey=b[1]-&apos;0&apos;;// cout&lt;&lt;sx&lt;&lt;sy&lt;&lt;ex&lt;&lt;ey&lt;&lt;endl; m=bfs(sx,sy); cout&lt;&lt;&quot;To get from &quot;&lt;&lt;a&lt;&lt;&quot; to &quot;&lt;&lt;b&lt;&lt;&quot; takes &quot;&lt;&lt;m&lt;&lt;&quot; knight moves.&quot;&lt;&lt;endl; &#125;&#125;//To get from e2 to e4 takes 2 knight moves.]]></content>
      <categories>
        <category>Training</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>DFS</tag>
        <tag>Thinking</tag>
        <tag>Simulation</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HPU Summer Training Day 6（河南理工大学暑期第六天）]]></title>
    <url>%2Fblog%2F2019%2F07%2F22%2Fd6%2F</url>
    <content type="text"><![CDATA[今天主要讲的是二分和贪心，题有点难。已经开始了不能写完题的日子了 PieDescription:My birthday is coming up and traditionally I&#39;m serving pie. Not just one pie, no, I have a number N of them, of various tastes and of various sizes. F of my friends are coming to my party and each of them gets a piece of pie. This should be one piece of one pie, not several small pieces since that looks messy. This piece can be one whole pie though. My friends are very annoying and if one of them gets a bigger piece than the others, they start complaining. Therefore all of them should get equally sized (but not necessarily equally shaped) pieces, even if this leads to some pie getting spoiled (which is better than spoiling the party). Of course, I want a piece of pie for myself too, and that piece should also be of the same size. What is the largest possible piece size all of us can get? All the pies are cylindrical in shape and they all have the same height 1, but the radii of the pies can be different.InputOne line with a positive integer: the number of test cases. Then for each test case:---One line with two integers N and F with 1 &lt;= N, F &lt;= 10 000: the number of pies and the number of friends.---One line with N integers ri with 1 &lt;= ri &lt;= 10 000: the radii of the pies.OutputFor each test case, output one line with the largest possible volume V such that me and my friends can all get a pie piece of size V. The answer should be given as a floating point number with an absolute error of at most 10^(-3).Sample Input 33 34 3 31 24510 51 4 2 3 4 5 6 5 4 2 Sample Output 25.13273.141650.2655 Problem solving:注意到人数也得算得上自己，然后因为每个人分到的pie必须是一块（所以不可以平均分），这个时候就用到二分答案了。二分中检测是否满足题意的判断方法是，用一个for循环计算出以每人分到mid面积时可以分给多少人，跟需要分到的人数进行比较就行了。Code:123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;const double pi = acos(-1.0);double s[10005];int main()&#123; int n; cin &gt;&gt; n; while (n--) &#123; int a, b, x; double sum = 0, pm = 0; cin &gt;&gt; a &gt;&gt; b; b += 1; for (int i = 0; i &lt; a; i++) &#123; cin &gt;&gt; x; s[i] = x * x * pi; sum += s[i]; pm = max(pm, s[i]); &#125; double l = 0, r = sum / b, mid; while (r - l &gt; 0.000001) &#123; mid = (r + l) / 2; int now = 0; for (int i = 0; i &lt; a; i++) &#123; now += int(s[i] / mid); &#125; if (now &lt; b) r = mid; else l = mid; &#125; printf(&quot;%.4lf\n&quot;, mid); &#125;&#125; Best Cow LineDescription:FJ is about to take his N (1 ≤ N ≤ 2,000) cows to the annual&quot;Farmer of the Year&quot; competition. In this contest every farmer arranges his cows in a line and herds them past the judges. The contest organizers adopted a new registration scheme this year: simply register the initial letter of every cow in the order they will appear (i.e., If FJ takes Bessie, Sylvia, and Dora in that order he just registers BSD). After the registration phase ends, every group is judged in increasing lexicographic order according to the string of the initials of the cows&#39; names. FJ is very busy this year and has to hurry back to his farm, so he wants to be judged as early as possible. He decides to rearrange his cows, who have already lined up, before registering them. FJ marks a location for a new line of the competing cows. He then proceeds to marshal the cows from the old line to the new one by repeatedly sending either the first or last cow in the (remainder of the) original line to the end of the new line. When he&#39;s finished, FJ takes his cows for registration in this new order. Given the initial order of his cows, determine the least lexicographic string of initials he can make this way. Input Line 1: A single integer: N Lines 2: N+1: Line i+1 contains a single initial (&#39;A&#39;..&#39;Z&#39;) of the cow in the ith position in the original line OutputThe least lexicographic string he can make. Every line (except perhaps the last one) contains the initials of 80 cows (&#39;A&#39;..&#39;Z&#39;) in the new line. Sample Input 6ACDBCB Sample Output ABCBCD Problem solving:白书原题，经典贪心问题。先比较当前的第一个和最后一个字符，如果想等就比较第二个和倒数第二个字符，以此找到前后字符的大小关系，然后进行删除和添加的操作就行了。具体看代码。注意，每输出80个字符就得换行！！！ Code:1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int n;char a[2005];void solve()&#123; int p=0,x=0,b=n-1; while(x&lt;=b) &#123; int flag=0; for(int i=0;x+i&lt;=b;i++) &#123; if(a[x+i]&lt;a[b-i]) &#123; flag=1; break; &#125; else if(a[x+i]&gt;a[b-i]) &#123; flag=0; break; &#125; &#125; if(flag) putchar(a[x++]); else putchar(a[b--]); p++; if(p%80==0) puts(&quot;&quot;); &#125; puts(&quot;&quot;);&#125;int main()&#123; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; solve(); return 0;&#125; Trailing Zeroes (III)Description:You task is to find minimal natural number N, so that N! contains exactly Q zeroes on the trail in decimal notation. As you know N! = 12...*N. For example, 5! = 120, 120 contains one zero on the trail. InputInput starts with an integer T (≤ 10000), denoting the number of test cases. Each case contains an integer Q (1 ≤ Q ≤ 1e8) in a line. OutputFor each case, print the case number and N. If no solution is found then print &#39;impossible&#39;. Sample Input 3125 Sample Output Case 1: 5Case 2: 10Case 3: impossible Problem solving:求n的阶乘的0的个数，只需要求得n中5得个数即可。因为只有2*5=10，所以每一个0都对应着一个2和一个5，而二的个数多于5，所以我们只要找到5得个数就是0得个数。123456789101112\\找5得个数得方法long long co(long long x)&#123; long long ans = 0; while (x) &#123; ans += x / 5; x /= 5; &#125; return ans;&#125; 剩下的就是二分答案。注意这道题存在着“impossible”得情况，所以在二分得过程中如果遇到了满足题意得mid，一定要记录下来。方便后面判断。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;long long co(long long x)&#123; long long ans = 0; while (x) &#123; ans += x / 5; x /= 5; &#125; return ans;&#125;int main()&#123; long long t, q; cin &gt;&gt; t; long long cas = 1; while (t--) &#123; cin &gt;&gt; q; long long flag = 0; long long l = 1, r = 1000000000000, mid; while (l &lt;= r) &#123; mid = (l + r) / 2; if (co(mid) == q) &#123; flag = mid; r = mid - 1; &#125; else if (co(mid) &gt; q) r = mid - 1; else l = mid + 1; &#125; if (flag) cout &lt;&lt; &quot;Case &quot; &lt;&lt; cas++ &lt;&lt; &quot;: &quot; &lt;&lt; flag &lt;&lt; endl; else cout &lt;&lt; &quot;Case &quot; &lt;&lt; cas++ &lt;&lt; &quot;: &quot; &lt;&lt; &quot;impossible&quot; &lt;&lt; endl; &#125;&#125; The Frog&#39;s GamesDescription:The annual Games in frogs&#39; kingdom started again. The most famous game is the Ironfrog Triathlon. One test in the Ironfrog Triathlon is jumping. This project requires the frog athletes to jump over the river. The width of the river is L (1&lt;= L &lt;= 1000000000). There are n (0&lt;= n &lt;= 500000) stones lined up in a straight line from one side to the other side of the river. The frogs can only jump through the river, but they can land on the stones. If they fall into the river, theyare out. The frogs was asked to jump at most m (1&lt;= m &lt;= n+1) times. Now the frogs want to know if they want to jump across the river, at least what ability should they have. (That is the frog&#39;s longest jump distance).InputThe input contains several cases. The first line of each case contains three positive integer L, n, and m.Then n lines follow. Each stands for the distance from the starting banks to the nth stone, two stone appear in one place is impossible.OutputFor each case, output a integer standing for the frog&#39;s ability at least they should have.Sample Input 6 1 2225 3 311218 Sample Output 411 Problem solving:题意就是让你找到青蛙得最大的最小弹跳力，即每次可以跳的最远距离。左边界时每个石头间距的最大值，右边界是河的宽度，然后进行二分。每次二分的时候，找到处于当前位置位置的青蛙跳一次mid的距离刚好最小到达的点，然后进行下一次循环（具体看代码吧）Code:1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=500005;int a[maxn];int main()&#123; int i,L,n,m; while(scanf(&quot;%d%d%d&quot;,&amp;L,&amp;n,&amp;m)!=EOF) &#123; memset(a,0,sizeof(a)); for(i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); a[n+1]=L; sort(a+1,a+n+2); int maxx=0; for(i=1;i&lt;=n+1;i++) &#123; if(a[i]-a[i-1]&gt;maxx) maxx=a[i]-a[i-1]; &#125; int l=maxx,r=L; while(l&lt;=r) &#123; int ans=0,pos=0; int mid=(l+r)/2; for(i=1;i&lt;=n;i++) &#123; if(a[i]-a[pos]&lt;=mid&amp;&amp;a[i+1]-a[pos]&gt;mid)//i即为青蛙跳一次之后到达的最远的石头 &#123; pos=i; ans++; &#125; &#125; ans++; if(ans&lt;=m) r=mid-1; else l=mid+1; &#125; printf(&quot;%d\n&quot;,l); &#125; return 0;&#125; 湫湫系列故事——消灭兔子Description:湫湫减肥 越减越肥！ 最近，减肥失败的湫湫为发泄心中郁闷，在玩一个消灭免子的游戏。 游戏规则很简单，用箭杀死免子即可。 箭是一种消耗品，已知有M种不同类型的箭可以选择，并且每种箭都会对兔子造成伤害，对应的伤害值分别为Di（1 &lt;= i &lt;= M），每种箭需要一定的QQ币购买。 假设每种箭只能使用一次，每只免子也只能被射一次，请计算要消灭地图上的所有兔子最少需要的QQ币。Input输入数据有多组，每组数据有四行；第一行有两个整数N，M（1 &lt;= N, M &lt;= 100000），分别表示兔子的个数和箭的种类；第二行有N个正整数，分别表示兔子的血量Bi（1 &lt;= i &lt;= N）；第三行有M个正整数，表示每把箭所能造成的伤害值Di（1 &lt;= i &lt;= M）；第四行有M个正整数，表示每把箭需要花费的QQ币Pi（1 &lt;= i &lt;= M）。 特别说明：1、当箭的伤害值大于等于兔子的血量时，就能将兔子杀死；2、血量Bi，箭的伤害值Di，箭的价格Pi，均小于等于100000。Output如果不能杀死所有兔子，请输出”No”，否则，请输出最少的QQ币数，每组输出一行。Sample Input 3 31 2 32 3 41 2 33 41 2 31 2 3 41 2 3 1 Sample Output 64 Problem solving:将兔子的血量进行降序排序，然后将剑按照攻击力降序排列，如果攻击力相等就按照qq币的花费降序排列。要用到优先队列，对降序排列的兔子，找到攻击力大于它的剑，放进优先队列，直到攻击力小于兔子的血量，然后答案加上优先队列顶部的qq消费。如果兔子还没杀完队列就为空了，就输出no。贪心的思想。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+10;struct node&#123; int d,p; friend bool operator &lt; (node a,node b) &#123; return a.p&gt;b.p; &#125;&#125;x[maxn];int b[maxn];bool cmp2(int x,int y)&#123; return x&gt;y;&#125;bool cmp(node a,node b)&#123; if(a.d==b.d) return a.p&gt;b.p; return a.d&gt;b.d;&#125;int main()&#123; int n,m; while(cin&gt;&gt;n&gt;&gt;m) &#123; for(int i=0;i&lt;n;i++) cin&gt;&gt;b[i]; sort(b,b+n,cmp2); for(int i=0;i&lt;m;i++) cin&gt;&gt;x[i].d; for(int i=0;i&lt;m;i++) cin&gt;&gt;x[i].p; sort(x,x+m,cmp); priority_queue&lt;node&gt; sta; int pos=0; long long ans=0; int flag=0; for(int i=0;i&lt;n;i++) &#123; while(x[pos].d&gt;=b[i]&amp;&amp;pos&lt;m) &#123; sta.push(x[pos]);// cout&lt;&lt;x[pos].d&lt;&lt;&quot; &quot;&lt;&lt;x[pos].p&lt;&lt;endl; pos++; &#125; if(sta.empty()) &#123; flag=1; break; &#125;// cout&lt;&lt;sta.top().p&lt;&lt;&quot;?\n&quot;; ans+=sta.top().p; sta.pop(); &#125; if(flag) puts(&quot;No&quot;); else cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125; Strange fuctionDescription:Now, here is a fuction: F(x) = 6 x^7+8x^6+7x^3+5x^2-y*x (0 &lt;= x &lt;=100)Can you find the minimum value when x is between 0 and 100.InputThe first line of the input contains an integer T(1&lt;=T&lt;=100) which means the number of test cases. Then T lines follow, each line has only one real numbers Y.(0 &lt; Y &lt;1e10)OutputJust the minimum value (accurate up to 4 decimal places),when x is between 0 and 100.Sample Input 2100200 Sample Output -74.4291-178.8534 Problem solving:简单的数学题，求函数极值，对函数求一阶导，另它为0即可，因为本题中二次导之后函数恒大于0所以一阶导为0求出来的极值就是极小值。确定x的值得时候用二分确定 Code:1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int t; double y; cin &gt;&gt; t; while (t--) &#123; cin &gt;&gt; y; double l = 0, r = 100, x; while (r - l &gt; 0.000001) &#123; x = (l + r) / 2; double mmp; mmp = 42 * pow(x, 6) + 48 * pow(x, 5) + 21 * pow(x, 2) + 10 * x; if (mmp &lt; y) l = x; else r = x; &#125; double ans = 6 * pow(x, 7) + 8 * pow(x, 6) + 7 * pow(x, 3) + 5 * x * x - y * x; printf(&quot;%.4lf\n&quot;, ans); &#125; return 0;&#125; Can you find it?Description:Give you three sequences of numbers A, B, C, then we give you a number X. Now you need to calculate if you can find the three numbers Ai, Bj, Ck, which satisfy the formula Ai+Bj+Ck = X.InputThere are many cases. Every data case is described as followed: In the first line there are three integers L, N, M, in the second line there are L integers represent the sequence A, in the third line there are N integers represent the sequences B, in the forth line there are M integers represent the sequence C. In the fifth line there is an integer S represents there are S integers X to be calculated. 1&lt;=L, N, M&lt;=500, 1&lt;=S&lt;=1000. all the integers are 32-integers.OutputFor each case, firstly you have to print the case number as the form &quot;Case d:&quot;, then for the S queries, you calculate if the formula can be satisfied or not. If satisfied, you print &quot;YES&quot;, otherwise print &quot;NO&quot;.Sample Input 3 3 31 2 31 2 31 2 331410 Sample Output Case 1:NOYESNO Problem solving:优雅的暴力之后再二分查找。把前两个数组可以组成的所有的和用一个数组存下来（这一步最坏的情况的复杂度也才O（2e5），显然不会超时。然后对接下来输入的需要判断的每个值进行查找，对第三个数组中的每一个数使用二分查找去找两者的差值再上一步得到的新数组中有没有存在。有即YES，否则就是NO。Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 505;int a[maxn], b[maxn], c[maxn], d[250005];int main()&#123; int l, n, m, cas = 0; while (~scanf(&quot;%d %d %d&quot;, &amp;l, &amp;n, &amp;m)) &#123; for (int i = 0; i &lt; l; i++) cin &gt;&gt; a[i]; for (int j = 0; j &lt; n; j++) cin &gt;&gt; b[j]; for (int k = 0; k &lt; m; k++) cin &gt;&gt; c[k]; int pos = 0; sort(a, a + l); sort(b, b + n); for (int i = 0; i &lt; l; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; d[pos++] = a[i] + b[j]; &#125; &#125; sort(d, d + pos); sort(c, c + m); cout &lt;&lt; &quot;Case &quot; &lt;&lt; ++cas &lt;&lt; &quot;:\n&quot;; int p, mid; cin &gt;&gt; p; while (p--) &#123; int flag = 0; cin &gt;&gt; mid; for (int i = 0; i &lt; m; i++) &#123; if (binary_search(d, d + pos, mid - c[i])) &#123; flag = 1; break; &#125; &#125; if (flag) puts(&quot;YES&quot;); else puts(&quot;NO&quot;); &#125; &#125;&#125; pairsDescription:John has n points on the X axis, and their coordinates are (x[i],0),(i=0,1,2,…,n−1). He wants to know how many pairs&lt;a,b&gt; that |x[b]−x[a]|≤k.(a&lt;b)InputThe first line contains a single integer T (about 5), indicating the number of cases.Each test case begins with two integers n,k(1≤n≤100000,1≤k≤1e9).Next n lines contain an integer xi(−1e9≤x[i]≤1e9), means the X coordinates.OutputFor each case, output an integer means how many pairs&lt;a,b&gt; that |x[b]−x[a]|≤k.Sample Input 25 5-10001001011025 300-1000100101102 Sample Output 310 Problem solving:排序之后直接进行二分查找，用lower_bound()或者手写也行，复杂度是O(N) Code:12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;const long long maxn=1e5+7;long long p[maxn];int main()&#123; long long t,a,b; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;a&gt;&gt;b; for(long long i=0;i&lt;a;i++ ) cin&gt;&gt;p[i]; sort(p,p+a); long long ans=0,pos=0; for(long long i=0;i&lt;a;i++) &#123; while(p[pos]-p[i]&lt;=b&amp;&amp;pos&lt;a) pos++; ans+=pos-i-1; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125; Radar InstallationDescription:Assume the coasting is an infinite straight line. Land is in one side of coasting, sea in the other. Each small island is a point locating in the sea side. And any radar installation, locating on the coasting, can only cover d distance, so an island in the sea can be covered by a radius installation, if the distance between them is at most d. We use Cartesian coordinate system, defining the coasting is the x-axis. The sea side is above x-axis, and the land side below. Given the position of each island in the sea, and given the distance of the coverage of the radar installation, your task is to write a program to find the minimal number of radar installations to cover all the islands. Note that the position of an island is represented by its x-y coordinates. Figure A Sample Input of Radar Installations InputThe input consists of several test cases. The first line of each case contains two integers n (1&lt;=n&lt;=1000) and d, where n is the number of islands in the sea and d is the distance of coverage of the radar installation. This is followed by n lines each containing two integers representing the coordinate of the position of each island. Then a blank line follows to separate the cases. The input is terminated by a line containing pair of zerosOutputFor each test case output one line consisting of the test case number followed by the minimal number of radar installations needed. &quot;-1&quot; installation means no solution for that case.Sample Input 3 21 2-3 12 11 20 20 0 Sample Output Case 1: 2Case 2: 1 Problem solving:这道题跟暑假不AC很像（在前几天的训练中做过），对每个岛的坐标求出来以它为圆心，雷达探测半径为半径的圆与x的两个交点，然后对得到的每组左右端点进行贪心。（我的代码这里写的有点麻烦了，直接输入求交点就行，不用存岛的坐标）。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;struct node&#123; int x,y; double l,r;&#125;p[1005];bool cmp(node x,node y)&#123; if(x.r==y.r) return x.l&gt;y.l; return x.r&lt;y.r;&#125;int main()&#123; int n,d,i=0; while(scanf(&quot;%d %d&quot;,&amp;n,&amp;d)&amp;&amp;n&amp;&amp;d) &#123; int flag=0; for(int i=0;i&lt;n;i++) cin&gt;&gt;p[i].x&gt;&gt;p[i].y; for(int i=0;i&lt;n;i++) &#123; if(p[i].y&gt;d) &#123; flag=1; &#125; double mid; mid=sqrt(d*d-p[i].y*p[i].y); p[i].l=p[i].x-mid; p[i].r=p[i].x+mid; &#125; if(flag) cout&lt;&lt;&quot;Case &quot;&lt;&lt;++i&lt;&lt;&quot;: -1&quot;&lt;&lt;endl; else &#123; sort(p,p+n,cmp); int ans=1;double ri=p[0].r; for(int i=1;i&lt;n;i++) &#123; if(p[i].l&gt;ri) &#123; ans++; ri=p[i].r; &#125; &#125; cout&lt;&lt;&quot;Case &quot;&lt;&lt;++i&lt;&lt;&quot;: &quot;&lt;&lt;ans&lt;&lt;endl; &#125; &#125;&#125; Aggressive cowsDescription:Farmer John has built a new long barn, with N (2 &lt;= N &lt;= 100,000) stalls. The stalls are located along a straight line at positions x1,...,xN (0 &lt;= xi &lt;= 1,000,000,000). His C (2 &lt;= C &lt;= N) cows don&#39;t like this barn layout and become aggressive towards each other once put into a stall. To prevent the cows from hurting each other, FJ want to assign the cows to the stalls, such that the minimum distance between any two of them is as large as possible. What is the largest minimum distance?Input Line 1: Two space-separated integers: N and C Lines 2..N+1: Line i+1 contains an integer stall location, xiOutput Line 1: One integer: the largest minimum distance Sample Input 5 312849 Sample Output 3 HintOUTPUT DETAILS: FJ can put his 3 cows in the stalls at positions 1, 4 and 8, resulting in a minimum distance of 3. Huge input data,scanf is recommended. Problem solving:白书原题，经典二分题，二分答案，对mid的检测方法是看它能不能满足以mid为最小的距离时能住下的牛的个数大于等于要求的个数。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;typedef long long ll;ll n,c;ll a[100005];bool check(ll x)&#123; ll mmp=0; for(int i=1;i&lt;c;i++) &#123; ll mid=mmp+1; while(mid&lt;n&amp;&amp;a[mid]-a[mmp]&lt;x) &#123; mid++; &#125; if(mid==n) return 0; mmp=mid; &#125; return 1;&#125;int main()&#123; scanf(&quot;%lld %lld&quot;,&amp;n,&amp;c); for(ll i=0;i&lt;n;i++) &#123; scanf(&quot;%lld&quot;,&amp;a[i]); &#125; sort(a,a+n); ll l=0,r=1e18,mid; while(r-l&gt;1) &#123; mid=(l+r)/2; if(check(mid)) &#123; l=mid; &#125; else r=mid; &#125; printf(&quot;%lld\n&quot;,l);&#125; River HopscotchDescription:Every year the cows hold an event featuring a peculiar version of hopscotch that involves carefully jumping from rock to rock in a river. The excitement takes place on a long, straight river with a rock at the start and another rock at the end, L units away from the start (1 ≤ L ≤ 1,000,000,000). Along the river between the starting and ending rocks, N (0 ≤ N ≤ 50,000) more rocks appear, each at an integral distance Di from the start (0 &lt; Di &lt; L). To play the game, each cow in turn starts at the starting rock and tries to reach the finish at the ending rock, jumping only from rock to rock. Of course, less agile cows never make it to the final rock, ending up instead in the river. Farmer John is proud of his cows and watches this event each year. But as time goes by, he tires of watching the timid cows of the other farmers limp across the short distances between rocks placed too closely together. He plans to remove several rocks in order to increase the shortest distance a cow will have to jump to reach the end. He knows he cannot remove the starting and ending rocks, but he calculates that he has enough resources to remove up to M rocks (0 ≤ M ≤ N). FJ wants to know exactly how much he can increase the shortest distance before he starts removing the rocks. Help Farmer John determine the greatest possible shortest distance a cow has to jump after removing the optimal set of M rocks. InputLine 1: Three space-separated integers: L, N, and MLines 2.. N+1: Each line contains a single integer indicating how far some rock is away from the starting rock. No two rocks share the same position.OutputLine 1: A single integer that is the maximum of the shortest distance a cow has to jump after removing M rocksSample Input 25 5 2214112117 Sample Output 4 HintBefore removing any rocks, the shortest jump was a jump of 2 from 0 (the start) to 2. After removing the rocks at 2 and 14, the shortest required jump is a jump of 4 (from 17 to 21 or from 21 to 25). Problem solving:一开始以为这道题用贪心，但是涉及到删除这个操作就很烦。后来发现者就是一道二分答案的题，套板子就行。check函数里面判断的条件就是当最小距离已知时，求出它对应的需要拿走石头的值，与输入的进行比较。（一开始直接循环判断样例都不过，后来才想到不能直接判断，因为有可能一次跳两个石头。所以需要这样写12345678int mid=0,pos=0;for(int i=1;i&lt;=n+1;i++)&#123; if(a[i]-a[pos]&lt;x) mid++; else pos=i;&#125; mid即为当前假设的最小距离所对应的需要拿走的石头个数，然后二分答案就行了。 Code:1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=50005;int a[maxn];int l,n,m;bool check(int x)&#123; int mid=0,pos=0; for(int i=1;i&lt;=n+1;i++) &#123; if(a[i]-a[pos]&lt;x) mid++; else pos=i; &#125; if(mid&gt;m) return 0; return 1;&#125;int main()&#123; cin&gt;&gt;l&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; &#125; sort(a+1,a+n+1); a[n+1]=l,a[0]=0; int l=0,r=1e9,mid; while(l&lt;=r) &#123; mid=(l+r)/2; if(check(mid)) l=mid+1; else r=mid-1; &#125; cout&lt;&lt;l-1&lt;&lt;endl;&#125;]]></content>
      <categories>
        <category>Training</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Greedy</tag>
        <tag>STL</tag>
        <tag>Binary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HPU Summer Training Day 5（河南理工大学暑期第五天）]]></title>
    <url>%2Fblog%2F2019%2F07%2F21%2Fd5%2F</url>
    <content type="text"><![CDATA[昨天积分赛的结束给今天带来了一天的休息，虽然机房开放而且好多同学都在刻苦学习，但是我以为放假就应该休息（其实就是懒跟几个玩的不错的朋友去看了银河补习班，一开始朋友邀请我去看的时候我是拒绝的，但一听说是邓超演的我就同意了，还是很喜欢邓超的。这个电影看之前就听说让自备纸巾，还是很有自信心的。一开始演的还不错，影片就是讲述了一个成功的儿子是如何在爸爸的帮助下变得成功的。看到后来有些无聊，不过还是很值的去看的，虽然我自己带的纸巾也没用上，主要是我泪点高？没有刷题的一天，按理说应该挺开心的，但是看到旁边的人都在刷题，唉，这可能就是我菜的原因吧Orz。]]></content>
      <categories>
        <category>Training</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>movie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HPU Summer Training Day 4（河南理工大学暑期第四天）]]></title>
    <url>%2Fblog%2F2019%2F07%2F20%2Fd4%2F</url>
    <content type="text"><![CDATA[第四天啦。又是自闭的一天，第一次积分赛暗淡收场，这种被打爆的感觉没人会喜欢的吧，好好补题，好好学习。刷题日记：http://blog.cndrew.cn/blog/2019/07/20/jifen/]]></content>
      <categories>
        <category>Training</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>c/c++</tag>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[河南理工大学算法协会暑期集训积分赛（一）]]></title>
    <url>%2Fblog%2F2019%2F07%2F20%2Fjifen%2F</url>
    <content type="text"><![CDATA[积分赛，被打爆的积分赛（music Nth power of nDescripition:求 nn 的个位数。 输入格式多组输入，处理到文件结束。每组数据输入一个 n。(1≤n≤1e9) 输出格式输出 nn 的个位数。 样例input123output147Problem solving:快速幂的板子题，对10取模即可。Code:1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll poww(ll x,ll y)&#123; ll ans=1; while(y) &#123; if(y&amp;1) ans=ans*x%10; x=x*x%10; y/=2; &#125; return ans;&#125;int main()&#123; ll n; while(~scanf(&quot;%lld&quot;,&amp;n)) &#123; cout&lt;&lt;poww(n,n)&lt;&lt;endl; &#125; return 0;&#125; 复读机的力量Descripition:Codancer: “我好菜啊！”Dicer: “我好菜啊！”Todest: “我好菜啊！”CaprYang: “我好菜啊！”…大佬们又开始装弱了，真正的菜鸡瑟瑟发抖不敢说话。 我们规定一个人是复读机当且仅当他说的每一句话都是复读前一个人说的话。我们规定一个人是复读机当且仅当他说的每一句话都是复读前一个人说的话。我们规定一个人是复读机当且仅当他说的每一句话都是复读前一个人说的话。规定一个复读机的熟练度为复读数量的多少。现在给你一段聊天记录，请你找出其中的复读机们。规定一个复读机的熟练度为复读数量的多少。现在给你一段聊天记录，请你找出其中的复读机们。规定一个复读机的熟练度为复读数量的多少。现在给你一段聊天记录，请你找出其中的复读机们。 输入格式输入T组,(1≤T≤10)每组第一行输入一个正整数N,表示聊天记录的长度（1≤N≤10000）。接下来N行，每行两个字符串，前一个字符串为姓名，后一个字符为聊天记录。保证所有字符串长度不超过50，保证所有字符串只包含小写字母. 输出格式如果没有复读机，输出 “Unbelievable!”(不包含引号）否则按照熟练度从大到小输出所有的复读机，如果熟练度相同，按照字典序从小到大输出。 样例input14codancer iamsovegetabledicer iamsovegetabletodest iamsovegetablecapryang iamsovegetableoutputcapryangdicertodest提示数据保证上面大佬们说的话都是瞎话。 Problem solving:不难，但是是一道送命题。需要注意的是当一个人说的每一句话都是复读的上一个人说的话的时候他才能算得上是复读机。然后就是map，结构体，set之类的使用。具体可以看代码 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;struct node&#123; string x,y;&#125;p[10005];struct nod&#123; string na; int fo;&#125;pp[10005];bool cmp(nod m,nod n)&#123; if(m.fo==n.fo) return m.na&lt;n.na; return m.fo&gt;n.fo;&#125;int main()&#123; int t,n; cin&gt;&gt;t; string x,y; while(t--) &#123; cin&gt;&gt;n; set&lt;string&gt; se; map&lt;string,int&gt; ma; map&lt;string,int&gt; mp; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;p[i].x&gt;&gt;p[i].y; se.insert(p[i].x); ma[p[i].x]=1; &#125; ma[p[0].x]=0; for(int i=1;i&lt;n;i++) &#123; if(p[i].y==p[i-1].y) mp[p[i].x]++; if(p[i].y!=p[i-1].y) ma[p[i].x]=0; &#125; int pos=0; for(set&lt;string&gt;::iterator it=se.begin();it!=se.end();it++) &#123; if(ma[*it]) &#123; pp[pos].na=*it; pp[pos].fo=mp[*it]; pos++; &#125; &#125; if(pos==0) puts(&quot;Unbelievable!&quot;); else &#123; sort(pp,pp+pos,cmp); for(int i=0;i&lt;pos;i++) &#123; cout&lt;&lt;pp[i].na&lt;&lt;endl; &#125; &#125; &#125;&#125; 无穷的小数Descripition:在十进制下，我们能够很轻易地判断一个小数的位数是有穷的或无穷的，但是把这个小数用二进制表示出的情况下其有穷性和无穷性就会发生改变，比如 十进制下的 0.5 ,在二进制下的值为 0.1 ；十进制下的 0.75 ,在二进制下的值为 0.11 ；十进制下的 0.6 ,在二进制下的值为 0.1001100...... 给你一个十进制的小数，判断其在二进制表示下小数位数是否无穷。 输入格式多组输入，处理到文件结束每组数据输入一个六位的小数 n.(0≤n\&lt;1) 输出格式如果在二进制下小数位数是有穷的，输出”YES”,否则输出”NO”. 样例input0.5000000.6000000.750000outputYESNOYES Problem solving:我拿了一血，主要是一开始大佬们没有注意到这个水题233.模拟就行了，小数转换成二进制就是每次乘以2直到等于1.如果一个小数在二进制表示下小数位数是无穷的，意思就是无论它承几次2，都不会正好等于1。我们只需要乘以2一定的次数，如果出现1，就不是无穷的，反之即无穷的。这个次数我写的时候用的100，后来结束后各种测试发现最小改成6也能过Orz。官方题解里面说会有精度问题，但是我没遇到哈，double过了。 Code:12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; double s; while(~scanf(&quot;%lf&quot;,&amp;s)) &#123; int i=0,flag=0; while(i&lt;=6) &#123; s*=2; if(s==int(s)) flag=1; i++; &#125; if(!flag) cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; else puts(&quot;YES&quot;); &#125; return 0;&#125; Special StringDescripition:我们定义一个字符串S为Special String只要这个字符串满足下面这些条件:1.这个串是回文的，即把这个字符串正着读和反着读相同，如abba和aca，而ba和abca则不是。2.26个小写字母必须全部出现3.这个串的长度为偶数。对于给定的S,判断它是否是Special String. 输入格式输入一个只由小写字母组成的字符串S。(1≤|S|≤1e5) 输出格式如果这个字符串是Special String，输出”YE5”,否则输出”N0” 样例inputaaaaoutputN0inputabcdefghijklmnopqrstuvwxyzzyxwvutsrqponmlkjihgfedcbaoutputYE5 Problem solving:这道题，很厉害，很难！三个条件的判断：回文串的判断可以通过可以翻转之后比较或者比较对称位置上的字符是否相等来实现26个字母都必须出现的判断，因为保证输入是小写字母，用一个set就行，最后看set的大小是否为26.长度为偶数这个就不用说了。 最难的地方来了，是&#39;YE5&#39;和&#39;N0&#39;，不是&#39;YES&#39;和&#39;NO&#39;。。。学长tql。 Code:123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string s,mid; cin&gt;&gt;s; set&lt;char&gt; se; int flag=0,len=s.size(); if(len%2==0) flag++; for(int i=0;i&lt;len;i++) se.insert(s[i]); if(se.size()==26) flag++; mid=s; reverse(s.begin(),s.end()); if(mid==s) flag++; if(flag==3) puts(&quot;YE5&quot;); else puts(&quot;N0&quot;); return 0;&#125; Max GcdDescripition:一个数组a，现在你需要删除某一项使得它们的gcd最大，求出这个最大值。 输入格式第一行输入一个正整数n，表示数组的大小，接下来一行n个数，第i个数为ai。(2≤n≤1e5,1≤ai≤1e9) 输出格式输出删除掉某个数以后的gcd的最大值。 样例input42 4 8 1output2input41 2 3 4output1提示样例一：删除第四个元素后，2,4,8的最大公因子为2。样例二：无论删除哪一个，最大公因子都为1。 Problem solving:比赛的时候这题毫无思路，，，完了之后了解到，是使用了一个前缀gcd数组和一个后缀gcd数组来实现求去掉第I位数字之后剩余所有数字的gcd。b为前缀gcd数组，c为后缀gcd数组那么去点第I位的数字之后剩余所有数字的gcd就是gcd（b[i-1],c[i+1]）这种思想是真的巧妙。我师父还想到了一种贪心的解法，但是我没听太懂233，总之很强就对了。 Code:123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;int a[200005];int b[200005];int c[200005];int main()&#123; int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; b[0]=a[0]; for(int i=1;i&lt;n;i++) &#123; b[i]=__gcd(b[i-1],a[i]);// cout&lt;&lt;b[i]&lt;&lt;endl; &#125; c[0]=a[n-1]; for(int i=n-1;i&gt;=0;i--) &#123; c[i]=__gcd(c[i+1],a[i]); &#125; int ans=0; for(int i=0;i&lt;n;i++) &#123; if(i==0) ans=max(ans,c[1]); else if(i==n-1) ans=max(ans,b[n-2]); else ans=max(ans,__gcd(b[i-1],c[i+1])); &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125; Count Prime PairsDescripition:对于数组a，如果i≠j并且ai+aj是一个质数，那么我们就称(i,j)为质数对，计算数组中质数对的个数。 输入格式第一行输入一个n，表示数组的长度,接下来n个整数，第i个数代表ai。(1≤n≤100000,0≤ai≤100) 输出格式输出数组中质数对的个数。 样例input31 2 3output4提示样例说明：a1+a2,a2+a1,a2+a3,a3+a2都为质数，总共有四对。Problem solving:其实比赛的时候想到了这样去暴力，但是没实现。题目中最大的素数是199，每个素数对所有出现过的数进行判断看差值是否出现过，就行了。先来个素数打表，还有就是用map统计每个数出现的次数。假设1出现了2次，2出现了2次，那么和为3的次数就是2*2=4次假设1出现了4次，那么和为2出现的次数就是4*（4-1）/2=6次按照这上面两种进行统计输出就行。 Code:123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;int t[205];int p[205];int main()&#123; p[0]=p[1]=1; for(int i=2;i&lt;=205;i++) &#123; for(int j=i*2;j&lt;=205;j+=i) p[j]=1; &#125; int n,a; cin&gt;&gt;n; while(n--) &#123; cin&gt;&gt;a; t[a]++; &#125; int ans=0; for(int i=0;i&lt;=100;i++) &#123; for(int j=i+1;j&lt;=100;j++) &#123; if(i==j) continue; if(!p[i+j]) &#123; ans+=t[i]*t[j]; &#125; &#125; &#125; cout&lt;&lt;ans*2+t[1]*(t[1]-1)&lt;&lt;endl;&#125; 平行线Descripition:“大猩猩为什么不喜欢平行线？”“因为平行线没有相交”哈哈哈哈哈哈哈哈哈 为了管理动物园不听话的大猩猩们，动物管理员Boctorio 决定去远方的ACM之城找一些平行线，当他逛到一个神奇的店铺时，他发现了一副黑色的图，上面依稀可见一些白色的点。Boctorio 询问店铺老板这幅画是什么，老板说：“天机不可泄露”。等Boctorio仔细端详了一会这幅画后，他惊讶的发现其中所蕴含的奥秘。向店铺老板道谢后，他拿着刚买的这幅画，就连忙赶回动物园。 输入格式输入一个数 n(1≤n≤1000)，表示点的个数。接下来n行，每行两个整数 xi,yi(1≤xi,yi≤1e9),表示第i个点。数据保证没有重复的点 输出格式输出用这些点所能表示出来的平行线段的对数。（两条不同的线段重合也算为平行） 样例input60 01 01 13 13 35 4output10 Problem solving:两线平行的条件就是斜率相等（也可以用向量做）统计每个斜率出现的次数即可斜率不能直接用double存，会爆精度，可以用一个pair来存，但是注意，分数要进行约分，同时除以它们的gcd就行了 Code:12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1005;int x[maxn],y[maxn];int main()&#123; int n; cin&gt;&gt;n; set&lt;pair&lt;int,int&gt; &gt; se; map&lt;pair&lt;int,int&gt; ,int&gt; ma; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;x[i]&gt;&gt;y[i]; &#125; for(int i=0;i&lt;n;i++) &#123; for(int j=i+1;j&lt;n;j++) &#123; int dx=x[j]-x[i]; int dy=y[j]-y[i]; int mid=__gcd(dx,dy); dx/=mid; dy/=mid; ma[&#123;dx,dy&#125;]++; se.insert(&#123;dx,dy&#125;); &#125; &#125; int ans=0; for(set&lt;pair&lt;int,int&gt; &gt;::iterator it=se.begin();it!=se.end();it++) &#123; ans+=(ma[*it]*(ma[*it]-1))/2; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125; Area of polygonsDescripition:现在有a个边长为1的正方形，b个半径为1的圆，c个边长为1的等边三角形，现在你随机拿出一个图形，求这个图形面积的期望。 输入格式第一行输入一个T,代表输入的组数。(1≤T≤100)接下来T行，每行三个数字a,b,c(1≤a,b,c≤1000)。 输出格式输出T行，对于每一组输入，输出面积的期望，小数点后保留三位小数。 样例input31 2 34 5 67 8 9output1.4301.4871.501提示圆周率为3.1415926535897 Problem solving:简单数学题期望即平均值 Code:123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;#define PI 3.1415926535897int main()&#123; double t,a,b,c; cin&gt;&gt;t; while(t--) &#123; double sum=0; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; sum+=a+PI*b+sqrt(3)*c/4; printf(&quot;%.3lf\n&quot;,sum/(a+b+c)); &#125;&#125; 双色球Descripition:双色球投注区分为红色球号码区和蓝色球号码区，红色球号码区由1-33共三十三个号码组成，蓝色球号码区由1-16共十六个号码组成。投注时选择6个红色球号码和1个蓝色球号码组成一注进行单式投注。其中奖规则为： 一等奖（6+1）二等奖（6+0）三等奖（5+1）四等奖（5+0、4+1）五等奖（4+0、3+1）六等奖（2+1、1+1、0+1）其中(a+b)即为有a个红色球，b个蓝色球与开奖某个数字相同（只与数字有关，与位置无关）。现在你有 n 张双色球彩票，以及本场彩票开奖结果，请你求出这 n 张彩票获得的最高奖。 输入格式第一行输入一个 n ，表示 n 张彩票接下来 n 行，每行 7 个数字，表示每张彩票的选号，其中前六个位红色球，后一个为蓝色球。接下来一行，输入 7 个数字，表示开奖结果，其中前六个为红色球，后一个为蓝色球。 输出格式输出所有彩票中能获得的最高等级奖，若无，则输出”0”。 样例input52 17 21 28 30 32 102 12 17 29 30 31 159 10 19 25 26 30 126 8 18 29 30 31 1013 14 21 22 27 32 86 7 12 19 27 28 12output6input32 17 21 28 30 32 102 12 17 29 30 31 159 10 19 25 26 30 126 8 18 29 30 31 10output6提示彩票六个红色球数字均为从小到大排列Problem solving:看懂题意后直接暴力模拟就行 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;struct node&#123; int ball[10];&#125;p[100];int re[10];int main()&#123; int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;7;j++) cin&gt;&gt;p[i].ball[j]; &#125; for(int i=0;i&lt;7;i++) cin&gt;&gt;re[i]; int ans,mmp=7,mmm=7; for(int i=0;i&lt;n;i++) &#123; ans=0; int flag=0; for(int j=0;j&lt;6;j++) &#123; if(binary_search(re,re+6,p[i].ball[j])) ans++; &#125; if(p[i].ball[6]==re[6]) flag=1; if(ans==1&amp;flag) mmm=6; else if(ans==0&amp;&amp;flag) mmm=6; else if(ans==2&amp;&amp;flag) mmm=6; else if(ans==3&amp;&amp;flag==1) mmm=5; else if(ans==4) &#123; if(!flag) mmm=5; else mmm=4; &#125; else if(ans==5) &#123; if(!flag) mmm=4; else mmm=3; &#125; else if(ans==6) &#123; if(!flag) mmm=2; else mmm=1; &#125; mmp=min(mmm,mmp); &#125; cout&lt;&lt;mmp%7&lt;&lt;endl;&#125; Remainder Minimization 2019Descripition:给你一个区间[L,R],在这个区间内找到两个不同的数字i,j，使得(i∗j)%2019的值最小。 输入格式输入两个数 L,R,(1≤L\&lt;R≤1e9） 输出格式如题 样例input4 5output20input2020 2040output2Problem solving:区间内只要出现2019的倍数，那么答案就是0。所以我们只需要判断区间大小与2019的关系，如果大于2019，直接输出0就行，反之直接两个for循环就行，因为这时区间长度小于2019，时间复杂度也不高。注意要用long long。 Code:12345678910111213a,b=input().split()a=eval(a)b=eval(b)ans=1111111111111for i in range(a,b): for j in range(a+1,b+1): mid = i*j % 2019 ans = min(ans,mid) if ans==0: break if ans==0: breakprint(ans) 学长标程 &amp;&amp; 题解我的代码会显得有点笨拙，因为还是不够熟练，所以把学长的代码也放在这里吧。 B 只要有一次某个人不是复读的就不是复读机 第一个人一定不是复读机 使用 map&lt;string,bool&gt; 判断这个人是否是复读机 使用 map&lt;string,int&gt; 记录这个人复读的次数 用结构体记录排序 复杂度 O(n∗log(n)) Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6+100;struct peo&#123; string name; int num;&#125;;vector&lt;peo&gt; all;map&lt;string,bool&gt; jud;map&lt;string,int&gt; num;string a[N],b[N];set&lt;string&gt; name;bool cmp(peo a,peo b)&#123; if(a.num==b.num) return a.name&lt;b.name; return a.num&gt;b.num;&#125;int main()&#123; int T; cin&gt;&gt;T; while(T--)&#123; int n; jud.clear();num.clear();name.clear();all.clear(); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]&gt;&gt;b[i],jud[a[i]]=1,num[a[i]]=0,name.insert(a[i]); jud[a[1]]=0; for(int i=2;i&lt;=n;i++)&#123; if(b[i]!=b[i-1])&#123; jud[a[i]]=0; &#125; num[a[i]]++; &#125; for(auto v:name)&#123; if(jud[v]) all.push_back(&#123;v,num[v]&#125;); &#125; sort(all.begin(),all.end(),cmp); if(all.size()==0)&#123; cout&lt;&lt;&quot;Unbelievable!&quot;&lt;&lt;endl; &#125; else&#123; for(auto v:all) cout&lt;&lt;v.name&lt;&lt;endl; &#125; &#125; return 0;&#125; C 由于只有后六位，先乘上 106 防止爆精度。 按照最普通的算法，每次乘以 2 再对 106 取余 当循环次数超过某一个值时，即可判定为无 Code: 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; double y; while(scanf(&quot;%lf&quot;,&amp;y)!=EOF)&#123; y*=10000000; bool flag=0; long long x=(long long)y; int num=0; while(1)&#123; if(x==0) break; if(num&gt;=200)&#123; flag=1;break; &#125; num++; x=2*x; if(x&gt;=10000000) x-=10000000; if(x==0) break; &#125; if(flag) puts(&quot;NO&quot;); else puts(&quot;YES&quot;); &#125; return 0;&#125; DCode:12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;bool check(string s)&#123; string c=s; reverse(c.begin(), c.end()); return s==c;&#125;pair&lt;int,int&gt; pii;int main()&#123; pii.first=1; pii.second=2; pii=make_pair(1,2); //cout&lt;&lt;pii.first&lt;&lt;&apos; &apos;&lt;&lt;pii.second&lt;&lt;endl; string s; cin&gt;&gt;s; bool flag=0; int l=s.length(); if(l&amp;1) flag=1; if(!check(s)) flag=1; int num[27]; memset(num,0,sizeof(num)); for(int i=0;i&lt;l;i++)&#123; num[s[i]-&apos;a&apos;]++; &#125; for(int i=0;i&lt;26;i++)&#123; if(num[i]==0)&#123; flag=1;break; &#125; &#125; if(flag) cout&lt;&lt;&quot;N0&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;YE5&quot;&lt;&lt;endl; return 0;&#125; E 维护前缀 gcd 数组 pre 和后缀 gcd 数组 od 删除第 i 个数之后剩余数的 gcd 即为 gcd(pre[i−1],od[i+1]) 线性枚举即可, 复杂度 O(n) Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//前缀后缀解法#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5+100;long long a[N];long long pre[N],sa[N];int main()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; pre[1]=a[1];sa[n]=a[n]; for(int i=2;i&lt;=n;i++) pre[i]=__gcd(pre[i-1],a[i]); for(int i=n-1;i&gt;=1;i--) sa[i]=__gcd(sa[i+1],a[i]); long long ans=max(sa[2],pre[n-1]); for(int i=2;i&lt;=n-1;i++) ans=max(ans,__gcd(pre[i-1],sa[i+1])); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;//贪心解法//#include&lt;bits/stdc++.h&gt;//using namespace std;//const int maxn = 1e5 + 10;//int a[maxn];//bool cmp(int x,int y)//&#123;// return x &gt; y;//&#125;//int gcd(int a,int b)//&#123;// return b ? gcd(b,a % b) : a;//&#125;//int main()//&#123;// int n;// scanf(&quot;%d&quot;,&amp;n);// for (int i = 0;i &lt; n;i ++)// scanf(&quot;%d&quot;,&amp;a[i]);// sort(a,a + n,cmp);// int ans = a[0],now = a[0];// for (int i = 1;i &lt; n;i ++)// &#123;// ans = max(gcd(ans,a[i]),now);// now = gcd(now,a[i]);// &#125;// printf(&quot;%d\n&quot;,ans);// return 0;//&#125; F 注意到 ai 的范围很小，我们可以先打出 [1,200] 以内的质数 表 O(n) 或 O(nlog(n)) 的统计每个数出现的次数 对于第 i 个质数 pi，和数组中第 j 个元素 aj，答案应该累加 上 pi−aj 出现的次数 注意 pi = 2∗aj 的情况，应该加上 aj 出现的次数减去 1 Code:1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6+100;bool check(int x)&#123; if(x==1) return 0; if(x==2) return 1; for(int i=2;i*i&lt;=x;i++)&#123; if(x%i==0) return 0; &#125; return 1;&#125;vector&lt;int&gt; pr;void init()&#123; for(int i=1;i&lt;=250;i++)&#123; if(check(i)) pr.push_back(i); &#125;&#125;int a[N];int vis[300];int main()&#123; init(); memset(vis,0,sizeof(vis)); long long ans=0; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i],vis[a[i]]++; for(int i=0;i&lt;(int)pr.size();i++)&#123; int now=pr[i]; for(int j=1;j&lt;=n;j++)&#123; if(now&gt;=a[j])&#123; if(now==(a[j]*2)) ans+=vis[a[j]]-1; else&#123; if(vis[a[j]]&amp;&amp;vis[now-a[j]]) ans+=vis[now-a[j]]; &#125; &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; G 对 yi−yj/xi−xj 用 gcd 约分后用 pair 存储 利用 map 统计每个斜率的线段条数, 假设为 num, 那么斜率 k 的贡献即为 num∗(num−1)/2 累加不同的斜率的贡献即可 复杂度 O(n2log(n2)) Code:123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 2000;typedef long long ll;int x[N],y[N];int main()&#123; int n; cin&gt;&gt;n; map&lt;pair&lt;int,int&gt; ,int&gt; k; set&lt;pair&lt;long long,long long&gt;&gt; all; long long ans=0; for(int i=1;i&lt;=n;i++) cin&gt;&gt;x[i]&gt;&gt;y[i]; for(int i=1;i&lt;=n;i++)&#123; for(int j=i+1;j&lt;=n;j++)&#123; int dx=x[j]-x[i]; int dy=y[j]-y[i]; if(dx&lt;0&amp;&amp;dy&lt;0)&#123; dx=-dx; dy=-dy; &#125; long long gc=__gcd(dx,dy); dx/=gc;dy/=gc; k[&#123;dx,dy&#125;]++; all.insert(&#123;dx,dy&#125;); &#125; &#125; for(auto v:all)&#123; ans+=(k[v]*(k[v]-1)/2); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; HCode:1234567891011121314#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int T; cin&gt;&gt;T; while(T--)&#123; double a,b,c; scanf(&quot;%lf %lf %lf&quot;,&amp;a,&amp;b,&amp;c); double all=(a+b+c); printf(&quot;%.3lf\n&quot;,(a+M_PI*b+sqrt(3)*c/4)/(a+b+c)); &#125; return 0;&#125; ICode:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;pair&lt;int,int&gt; solve(vector&lt;int&gt; a,vector&lt;int&gt; b)&#123; int num[34]; memset(num,0,sizeof(num)); int r=0; int bl=0; for(int i=0;i&lt;6;i++)&#123; num[a[i]]++; &#125; for(int i=0;i&lt;6;i++)&#123; if(num[b[i]]) r++; &#125; if(a[6]==b[6]) bl=1; return &#123;r,bl&#125;;&#125;int cal(pair&lt;int,int&gt; pii)&#123; if(pii.first==6&amp;&amp;pii.second==1) return 1; if(pii.first==6&amp;&amp;pii.second==0) return 2; if(pii.first==5&amp;&amp;pii.second==1) return 3; if((pii.first==5&amp;&amp;pii.second==0)||(pii.first==4&amp;&amp;pii.second==1)) return 4; if((pii.first==4&amp;&amp;pii.second==0)||(pii.first==3&amp;&amp;pii.second==1)) return 5; if((pii.first==2&amp;&amp;pii.second==1)||(pii.first==1&amp;&amp;pii.second==1)||(pii.first==0&amp;&amp;pii.second==1)) return 6; return 99999;&#125;const int N = 1e3+100;vector&lt;int&gt; a[N];int main()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; int x; for(int j=0;j&lt;7;j++)&#123; cin&gt;&gt;x; a[i].push_back(x); &#125; &#125; int ans=7; vector&lt;int&gt; b(7); for(int i=0;i&lt;7;i++) cin&gt;&gt;b[i]; for(int i=1;i&lt;=n;i++) &#123; ans=min(ans,cal(solve(a[i],b))); &#125; if(ans==7) ans=0; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; J 当 L 和 R 的差值大于 2019 的时候，其中必定含有 2019 的 倍数，此时答案为 0 否则暴力枚举 Code:123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; long long L,R; cin&gt;&gt;L&gt;&gt;R; if(R-L&gt;2019) cout&lt;&lt;0&lt;&lt;endl; else&#123; int ans=9999; for(int i=L;i&lt;=R;i++)&#123; for(int j=i+1;j&lt;=R;j++)&#123; ans=min(ans,((i%2019)*(j%2019))%2019); &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; 今天的题确实不算太难吧，就过了6题，还罚时巨高，主要还是自己的原因。STL和结构体的使用能力还有点欠缺，另外用map统计出现次数这个真的是很有用的东西，set去重，这些都知道的东西用不到平常写题的过程中太亏了。继续加油，Fighting！！！]]></content>
      <categories>
        <category>Training</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>c/c++</tag>
        <tag>STL</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stringstream(常见函数及其常见用法)]]></title>
    <url>%2Fblog%2F2019%2F07%2F19%2Fsstream%2F</url>
    <content type="text"><![CDATA[Give me three minutes,I will make you learn more about stringstream. Some common usageData type conversion(数据类型的转换)For example:123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string a = &quot;521&quot;, b; int c, d = 1314; stringstream x, y; x &lt;&lt; a; y &lt;&lt; d; x &gt;&gt; c; y &gt;&gt; b; cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl &lt;&lt; c &lt;&lt; d &lt;&lt; endl; cout &lt;&lt; &quot;The size of b is &quot; &lt;&lt; sizeof(b) &lt;&lt; &quot;\nThe size of c is &quot; &lt;&lt; sizeof(c) &lt;&lt; endl;&#125; Output: 52113145211314The size of b is 24The size of c is 4 In this case,we transform a string to int and an int to string through stringstream. Can be used to split strings separated by spaces etc.(可以分割被空格分割的字符串)For example:1234567891011#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string s = &quot;521 1314&quot;,mid; stringstream x(s); while (x &gt;&gt; mid) &#123; cout &lt;&lt; mid &lt;&lt; endl; &#125;&#125; Output: 5211314 This part is always useful in some type. Official explanationCPP: http://www.cplusplus.com/reference/sstream/stringstream/ As far as I know,If you can grasp the common usage,it&#39;s enough in ACM.]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>functions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HPU Summer Training Day 3（河南理工暑期集训第三天）]]></title>
    <url>%2Fblog%2F2019%2F07%2F19%2Fd3%2F</url>
    <content type="text"><![CDATA[今天主要讲了点基本的STL的用法。题写的有点吃力了，以后可能就写不完了，然后攒着写不完的题一天比一天多。Nothing can change my love for you,even you. Today&#39;s problem I spent too much wrong on the format,I should be more careful. Windows Message QueueDescription:Message queue is the basic fundamental of windows system. For each process, the system maintains a message queue. If something happens to this process, such as mouse click, text change, the system will add a message to the queue. Meanwhile, the process will do a loop for getting message from the queue according to the priority value if it is not empty. Note that the less priority value means the higher priority. In this problem, you are asked to simulate the message queue for putting messages to and getting message from the message queue.Input There&#39;s only one test case in the input. Each line is a command, &quot;GET&quot; or &quot;PUT&quot;, which means getting message or putting message. If the command is &quot;PUT&quot;, there&#39;re one string means the message name and two integer means the parameter and priority followed by. There will be at most 60000 command. Note that one message can appear twice or more and if two messages have the same priority, the one comes first will be processed first.(i.e., FIFO for the same priority.) Process to the end-of-file. Output For each &quot;GET&quot; command, output the command getting from the message queue with the name and parameter in one line. If there&#39;s no message in the queue, output &quot;EMPTY QUEUE!&quot;. There&#39;s no output for &quot;PUT&quot; command. Sample Input GETPUT msg1 10 5PUT msg2 10 4GETGETGET Sample Output EMPTY QUEUE!msg2 10msg1 10EMPTY QUEUE! Problem solving:Through a special queue with a struct and Operator overloading.The main question is understand this,oh my poor English.Code:123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;struct node&#123; string s; int p, q, id;&#125; n[6005];bool operator &lt;(const node &amp;x, const node &amp;y)//Operator overloading.&#123; if (x.q == y.q) return x.id &gt; y.id; return x.q &gt; y.q;&#125;priority_queue&lt;node&gt; que;int main()&#123; string s; int k = 0; while (cin &gt;&gt; s) &#123; if (s[0] == &apos;G&apos;) &#123; if (que.empty()) puts(&quot;EMPTY QUEUE!&quot;); else &#123; cout &lt;&lt; que.top().s &lt;&lt; &quot; &quot; &lt;&lt; que.top().p &lt;&lt; endl; que.pop(); &#125; &#125; if (s[0] == &apos;P&apos;) &#123; cin &gt;&gt; n[0].s &gt;&gt; n[0].p &gt;&gt; n[0].q; n[0].id = k; k++; que.push(n[0]); &#125; &#125;&#125; Train Problem IDescription:As the new term comes, the Ignatius Train Station is very busy nowadays. A lot of student want to get back to school by train(because the trains in the Ignatius Train Station is the fastest all over the world ^v^). But here comes a problem, there is only one railway where all the trains stop. So all the trains come in from one side and get out from the other side. For this problem, if train A gets into the railway first, and then train B gets into the railway before train A leaves, train A can&#39;t leave until train B leaves. The pictures below figure out the problem. Now the problem for you is, there are at most 9 trains in the station, all the trains has an ID(numbered from 1 to n), the trains get into the railway in an order O1, your task is to determine whether the trains can get out in an order O2.Input The input contains several test cases. Each test case consists of an integer, the number of trains, and two strings, the order of the trains come in:O1, and the order of the trains leave:O2. The input is terminated by the end of file. More details in the Sample Input. Output The output contains a string &quot;No.&quot; if you can&#39;t exchange O2 to O1, or you should output a line contains &quot;Yes.&quot;, and then output your way in exchanging the order(you should output &quot;in&quot; for a train getting into the railway, and &quot;out&quot; for a train getting out of the railway). Print a line contains &quot;FINISH&quot; after each test case. More details in the Sample Output. Sample Input 3 123 3213 123 312 Sample Output Yes.inininoutoutoutFINISHNo.FINISH For the first Sample Input, we let train 1 get in, then train 2 and train 3.So now train 3 is at the top of the railway, so train 3 can leave first, then train 2 and train 1.In the second Sample input, we should let train 3 leave first, so we have to let train 1 get in, then train 2 and train 3.Now we can let train 3 leave.But after that we can&#39;t let train 1 leave before train 2, because train 2 is at the top of the railway at the moment.So we output &quot;No.&quot;.Problem solving:An easy problem.Use a stack to simulate this process and a queue to record &#39;in&#39; or &#39;out&#39;.Judge if we can pop or push.Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n; while (~scanf(&quot;%d&quot;, &amp;n)) &#123; int flag = 0; string a, b; cin &gt;&gt; a &gt;&gt; b; stack&lt;char&gt; s; queue&lt;string&gt; q; for (int i = 0, j = 0; i &lt; n &amp;&amp; j &lt;= n;) &#123; if (s.empty() || s.top() != b[i]) &#123; if (j == n) &#123; cout &lt;&lt; &quot;No.\nFINISH\n&quot;; flag = 1; break; &#125; s.push(a[j]); j++; q.push(&quot;in&quot;); &#125; else &#123; s.pop(); q.push(&quot;out&quot;); i++; &#125; &#125; if (flag) continue; else &#123; cout &lt;&lt; &quot;Yes.\n&quot;; while (!q.empty()) &#123; cout &lt;&lt; q.front() &lt;&lt; endl; q.pop(); &#125; &#125; cout &lt;&lt; &quot;FINISH\n&quot;; &#125;&#125; RailsDescription:There is a famous railway station in PopPush City. Country there is incredibly hilly. The station was built in last century. Unfortunately, funds were extremely limited that time. It was possible to establish only a surface track. Moreover, it turned out that the station could be only a dead-end one (see picture) and due to lack of available space it could have only one track.The local tradition is that every train arriving from the direction A continues in the direction B with coaches reorganized in some way. Assume that the train arriving from the direction A has N &lt;= 1000 coaches numbered in increasing order 1, 2, ..., N. The chief for train reorganizations must know whether it is possible to marshal coaches continuing in the direction B so that their order will be a1, a2, ..., aN. Help him and write a program that decides whether it is possible to get the required order of coaches. You can assume that single coaches can be disconnected from the train before they enter the station and that they can move themselves until they are on the track in the direction B. You can also suppose that at any time there can be located as many coaches as necessary in the station. But once a coach has entered the station it cannot return to the track in the direction A and also once it has left the station in the direction B it cannot return back to the station. Input The input consists of blocks of lines. Each block except the last describes one train and possibly more requirements for its reorganization. In the first line of the block there is the integer N described above. In each of the next lines of the block there is a permutation of 1, 2, ..., N. The last line of the block contains just 0.The last block consists of just one line containing 0. Output The output contains the lines corresponding to the lines with permutations in the input. A line of the output contains Yes if it is possible to marshal the coaches in the order required on the corresponding line of the input. Otherwise it contains No. In addition, there is one empty line after the lines corresponding to one block of the input. There is no line in the output corresponding to the last null&#39; block of the input. Sample Input 51 2 3 4 55 4 1 2 3066 5 4 3 2 100 Sample Output1234YesNoYes Problem solving:An easy stack question.Code:12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;stack&gt;#include&lt;cstring&gt;using namespace std;int a[1005];int main()&#123; int n; while (scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n) &#123; while (1) &#123; int flag = 0; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; if (a[i] == 0) &#123; flag = 1; break; &#125; &#125; if (flag) break; stack&lt;int&gt; sta; int pos = 0; for (int i = 1; i &lt;= n; i++) &#123; sta.push(i); while (!sta.empty() &amp;&amp; sta.top() == a[pos]) &#123; sta.pop(); pos++; &#125; &#125; if (sta.empty()) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; puts(&quot;&quot;); &#125;&#125; D - {A} + {B}Description:给你两个集合，要求{A} + {B}.注:同一个集合中不会有两个相同的元素.Input 每组输入数据分为三行,第一行有两个数字n,m(0&lt;n,m&lt;=10000),分别表示集合A和集合B的元素个数.后两行分别表示集合A和集合B.每个元素为不超出int范围的整数,每个元素之间有一个空格隔开. Output 针对每组数据输出一行数据,表示合并后的集合,要求从小到大输出,每个元素之间有一个空格隔开. Sample Input 1 212 31 211 2 Sample Output 1 2 31 2 Problem solving:An easy set question.Code:1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n, m, a; while (~scanf(&quot;%d %d&quot;, &amp;n, &amp;m)) &#123; set&lt;int&gt; s; for (int i = 0; i &lt; n + m; i++) &#123; cin &gt;&gt; a; s.insert(a); &#125; for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++) &#123; if (it == s.begin()) cout &lt;&lt; *it; else cout &lt;&lt; &quot; &quot; &lt;&lt; *it; &#125; cout &lt;&lt; endl; &#125;&#125; 水果Description:夏天来了好开心啊,呵呵,好多好多水果Joe经营着一个不大的水果店.他认为生存之道就是经营最受顾客欢迎的水果.现在他想要一份水果销售情况的明细表,这样Joe就可以很容易掌握所有水果的销售情况了.Input 第一行正整数N(0&lt;N&lt;=10)表示有N组测试数据.每组测试数据的第一行是一个整数M(0&lt;M&lt;=100),表示工有M次成功的交易.其后有M行数据,每行表示一次交易,由水果名称(小写字母组成,长度不超过80),水果产地(小写字母组成,长度不超过80)和交易的水果数目(正整数,不超过100)组成. Output 对于每一组测试数据,请你输出一份排版格式正确(请分析样本输出)的水果销售情况明细表.这份明细表包括所有水果的产地,名称和销售数目的信息.水果先按产地分类,产地按字母顺序排列;同一产地的水果按照名称排序,名称按字母顺序排序.两组测试数据之间有一个空行.最后一组测试数据之后没有空行. Sample Input 15apple shandong 3pineapple guangdong 1sugarcane guangdong 1pineapple guangdong 3pineapple guangdong 1 Sample Output guangdong |----pineapple(5) |----sugarcane(1)shandong |----apple(3) Problem solving:An unusual problem.We can ues a map in map.And then the iterator is a little different now.Just see the Code.Luckily,map can automatic sorting makes this problem is not so hard.Code:12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n, m, p; string x, y; cin &gt;&gt; n; int xxxx=0; while (n--) &#123; if(xxxx!=0) puts(&quot;&quot;); xxxx=1; int i = 0; map&lt;string, map&lt;string, int&gt; &gt; ma; cin &gt;&gt; m; while (m--) &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; p; ma[y][x] += p; &#125; map&lt;string, int&gt;::iterator iit; for (map&lt;string, map&lt;string, int&gt; &gt;::iterator it = ma.begin(); it != ma.end(); it++) &#123; cout &lt;&lt; it-&gt;first &lt;&lt; endl; for (iit = it-&gt;second.begin(); iit != it-&gt;second.end(); iit++) &#123; cout &lt;&lt; &quot; |----&quot; &lt;&lt; iit-&gt;first &lt;&lt; &quot;(&quot; &lt;&lt; iit-&gt;second &lt;&lt; &quot;)&quot; &lt;&lt; endl; &#125; &#125; &#125;&#125; Let the Balloon RiseDescription:Contest time again! How excited it is to see balloons floating around. But to tell you a secret, the judges&#39; favorite time is guessing the most popular problem. When the contest is over, they will count the balloons of each color and find the result.This year, they decide to leave this lovely job to you.Input Input contains multiple test cases. Each test case starts with a number N (0 &lt; N &lt;= 1000) -- the total number of balloons distributed. The next N lines contain one color each. The color of a balloon is a string of up to 15 lower-case letters.A test case with N = 0 terminates the input and this test case is not to be processed. Output For each case, print the color of balloon for the most popular problem on a single line. It is guaranteed that there is a unique solution for each test case. Sample Input 5greenredblueredred3pinkorangepink0 Sample Output redpink Problem solving:An easy map problem.Code:1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n; string s; while (cin &gt;&gt; n) &#123; map&lt;string, int&gt; ma; if (n == 0) break; while (n--) &#123; cin &gt;&gt; s; ma[s]++; &#125; int mid = 0; string ans; for (map&lt;string, int&gt;::iterator it = ma.begin(); it != ma.end(); it++) &#123; if (it-&gt;second &gt; mid) &#123; ans = it-&gt;first; mid = it-&gt;second; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125; 不重复数字Description:给出N个数，要求把其中重复的去掉，只保留第一次出现的数。例如，给出的数为1 2 18 3 3 19 2 3 6 5 4，其中2和3有重复，去除后的结果为1 2 18 3 19 6 5 4。 Input 输入第一行为正整数T，表示有T组数据。接下来每组数据包括两行，第一行为正整数N，表示有N个数。第二行为要去重的N个正整数。 Output 对于每组数据，输出一行，为去重后剩下的数字，数字之间用一个空格隔开。 Sample Input 2111 2 18 3 3 19 2 3 6 5 461 2 3 4 5 6 Sample Output 1 2 18 3 19 6 5 41 2 3 4 5 6 Hint 对于30%的数据，1 &lt;= N &lt;= 100，给出的数不大于100，均为非负整数；对于50%的数据，1 &lt;= N &lt;= 10000，给出的数不大于10000，均为非负整数；对于100%的数据，1 &lt;= N &lt;= 50000，给出的数在32位有符号整数范围内。提示:由于数据量很大，使用C++的同学请使用scanf和printf来进行输入输出操作，以免浪费不必要的时间。 Problem solving:We can&#39;t use set here because set will automatic sort.I wanted to ues a flag array to know the number has appread or not.But always RE.So I choose a set to know if the number has already appeared.Code:1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int t; scanf(&quot;%d&quot;, &amp;t); while (t--) &#123; int n, a; scanf(&quot;%d&quot;, &amp;n); set&lt;int&gt; s; int mid = s.size(); queue&lt;int&gt; q; while (n--) &#123; scanf(&quot;%d&quot;, &amp;a); s.insert(a); if (s.size() != mid) &#123; q.push(a); mid = s.size(); &#125; &#125; while (!q.empty()) &#123; cout &lt;&lt; q.front() &lt;&lt; &quot; &quot;; q.pop(); &#125; puts(&quot;&quot;); &#125;&#125; Andy&#39;s First DictionaryDescription:Andy, 8, has a dream - he wants to produce his very own dictionary. This is not an easy task for him, as the number of words that he knows is, well, not quite enough. Instead of thinking up all the words himself, he has a briliant idea. From his bookshelf he would pick one of his favourite story books, from which he would copy out all the distinct words. By arranging the words inalphabetical order, he is done! Of course, it is a really time-consuming job, and this is where a computer program is helpful.You are asked to write a program that lists all the different words in the input text. In this problem, a word is defined as a consecutive sequence of alphabets, in upper and/or lower case. Words with only one letter are also to be considered. Furthermore, your program must be CaSe InSeNsItIvE. For example, words like “Apple”, “apple” or “APPLE” must be considered the same.Input The input file is a text with no more than 5000 lines. An input line has at most 200 characters. Inputis terminated by EOF. Output Your output should give a list of different words that appears in the input text, one in a line. Thewords should all be in lower case, sorted in alphabetical order. You can be sure that he number ofdistinct words in the text does not exceed 5000. Sample Input Adventures in DisneylandTwo blondes were going to Disneyland when they came to a fork in theroad. The sign read: &quot;Disneyland Left.&quot;So they went home. Sample Output aadventuresblondescamedisneylandforkgoinghomeinleftreadroadsignsothetheytotwowentwerewhen Problem solving:I know a new useful function through this problem--Stringstream.I will write a new artical about this these days.It&#39;s amazing,suitable for us who is lazy.About this problem,you just know what you should do: Turn uppercase letter to lower case letters. Delete the char which is not a letter. Code:1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string s; set&lt;string&gt; se; while (cin &gt;&gt; s) &#123; for (int i = 0; i &lt; s.size(); i++) &#123; if (s[i] &gt;= &apos;A&apos; &amp;&amp; s[i] &lt;= &apos;Z&apos;) s[i] += 32; else if (s[i] &gt;= &apos;a&apos; &amp;&amp; s[i] &lt;= &apos;z&apos;) s[i] = s[i]; else s[i] = &apos; &apos;; &#125; string mi; stringstream mid(s); while (mid &gt;&gt; mi) &#123; se.insert(mi); &#125; &#125; for (set&lt;string&gt;::iterator it = se.begin(); it != se.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; endl; &#125;&#125; A and B and Compilation ErrorsDescription:A and B are preparing themselves for programming contests. B loves to debug his code. But before he runs the solution and starts debugging, he has to first compile the code. Initially, the compiler displayed n compilation errors, each of them is represented as a positive integer. After some effort, B managed to fix some mistake and then another one mistake. However, despite the fact that B is sure that he corrected the two errors, he can not understand exactly what compilation errors disappeared — the compiler of the language which B uses shows errors in the new order every time! B is sure that unlike many other programming languages, compilation errors for his programming language do not depend on each other, that is, if you correct one error, the set of other error does not change. Can you help B find out exactly what two errors he corrected? Input The first line of the input contains integer n (3 ≤ n ≤ 105) — the initial number of compilation errors.The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 109) — the errors the compiler displayed for the first time.The third line contains n - 1 space-separated integers b1, b2, ..., bn - 1 — the errors displayed at the second compilation. It is guaranteed that the sequence in the third line contains all numbers of the second string except for exactly one.The fourth line contains n - 2 space-separated integers с1, с2, ..., сn - 2 — the errors displayed at the third compilation. It is guaranteed that the sequence in the fourth line contains all numbers of the third line except for exactly one. Output Print two numbers on a single line: the numbers of the compilation errors that disappeared after B made the first and the second correction, respectively. ExamplesInput 51 5 8 123 7123 7 5 15 1 7 Output 8123 Input 61 4 3 3 5 73 7 5 4 34 3 7 5 Output 13 Note In the first test sample B first corrects the error number 8, then the error number 123.In the second test sample B first corrects the error number 1, then the error number 3. Note that if there are multiple errors with the same number, B can correct only one of them in one step. Problem solving:Through reding,you will kown the first line we output is the different number between the second line and the third line we input,and the second line we output is the different number between the third line and the fourth line we input.I choose a force way but easy to understand.Code:123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n, a; cin &gt;&gt; n; map&lt;int, int&gt; ma; map&lt;int, int&gt; ma1; map&lt;int, int&gt; ma2; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a; ma[a]++; &#125; for (int i = 0; i &lt; n - 1; i++) &#123; cin &gt;&gt; a; ma1[a]++; &#125; for (int i = 0; i &lt; n - 2; i++) &#123; cin &gt;&gt; a; ma2[a]++; &#125; int x = 0, y = 0; for (map&lt;int, int&gt;::iterator it = ma.begin(); it != ma.end(); it++) &#123; int mid = it-&gt;first; if (ma[mid] != ma1[mid]) cout &lt;&lt; mid &lt;&lt; endl; &#125; for (map&lt;int, int&gt;::iterator it = ma1.begin(); it != ma1.end(); it++) &#123; int mid = it-&gt;first; if (ma2[mid] != ma1[mid]) cout &lt;&lt; mid &lt;&lt; endl; &#125; return 0;&#125; 排列2Description:Ray又对数字的列产生了兴趣：现有四张卡片，用这四张卡片能排列出很多不同的4位数，要求按从小到大的顺序输出这些4位数。Input 每组数据占一行，代表四张卡片上的数字（0&lt;=数字&lt;=9），如果四张卡片都是0，则输入结束。 Output 对每组卡片按从小到大的顺序输出所有能由这四张卡片组成的4位数，千位数字相同的在同一行，同一行中每个四位数间用空格分隔。每组输出数据间空一行，最后一组数据后面没有空行。 Sample Input 1 2 3 41 1 2 30 1 2 30 0 0 0 Sample Output1234567891011121234 1243 1324 1342 1423 14322134 2143 2314 2341 2413 24313124 3142 3214 3241 3412 34214123 4132 4213 4231 4312 43211123 1132 1213 1231 1312 13212113 2131 23113112 3121 32111023 1032 1203 1230 1302 13202013 2031 2103 2130 2301 23103012 3021 3102 3120 3201 3210 Problem solving:An easy problem through &#39;next_permutation()&#39;.The most disgusting place is the format.Code:123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;int a[5];int main()&#123; int mid, x = 0; while (scanf(&quot;%d %d %d %d&quot;, &amp;a[0], &amp;a[1], &amp;a[2], &amp;a[3]) != EOF) &#123; sort(a, a + 4); if (a[0] == 0 &amp;&amp; a[1] == 0 &amp;&amp; a[2] == 0 &amp;&amp; a[3] == 0) break; if (x) cout &lt;&lt; endl; x = 1; int flag = 1; do &#123; if (a[0] == 0) continue; if (flag) &#123; cout &lt;&lt; a[0] &lt;&lt; a[1] &lt;&lt; a[2] &lt;&lt; a[3]; flag = 0; &#125; else if (mid == a[0]) cout &lt;&lt; &quot; &quot; &lt;&lt; a[0] &lt;&lt; a[1] &lt;&lt; a[2] &lt;&lt; a[3]; else &#123; cout &lt;&lt; endl; cout &lt;&lt; a[0] &lt;&lt; a[1] &lt;&lt; a[2] &lt;&lt; a[3]; &#125; mid = a[0]; &#125; while (next_permutation(a, a + 4)); puts(&quot;&quot;); &#125;&#125; I have too much PE before I passed this problem. Ignatius and the Princess IIDescription:Now our hero finds the door to the BEelzebub feng5166. He opens the door and finds feng5166 is about to kill our pretty Princess. But now the BEelzebub has to beat our hero first. feng5166 says, &quot;I have three question for you, if you can work them out, I will release the Princess, or you will be my dinner, too.&quot; Ignatius says confidently, &quot;OK, at last, I will save the Princess.&quot; &quot;Now I will show you the first problem.&quot; feng5166 says, &quot;Given a sequence of number 1 to N, we define that 1,2,3...N-1,N is the smallest sequence among all the sequence which can be composed with number 1 to N(each number can be and should be use only once in this problem). So it&#39;s easy to see the second smallest sequence is 1,2,3...N,N-1. Now I will give you two numbers, N and M. You should tell me the Mth smallest sequence which is composed with number 1 to N. It&#39;s easy, isn&#39;t is? Hahahahaha......&quot;Can you help Ignatius to solve this problem?Input The input contains several test cases. Each test case consists of two numbers, N and M(1&lt;=N&lt;=1000, 1&lt;=M&lt;=10000). You may assume that there is always a sequence satisfied the BEelzebub&#39;s demand. The input is terminated by the end of file. Output For each test case, you only have to output the sequence satisfied the BEelzebub&#39;s demand. When output a sequence, you should print a space between two numbers, but do not output any spaces after the last number. Sample Input 6 411 8 Sample Output 1 2 3 5 6 41 2 3 4 5 6 7 9 8 11 10 Problem solving:An easy problem through &#39;next_permutation()&#39;.Code:123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;int a[1005];int main()&#123; int n, m; while (~scanf(&quot;%d %d&quot;, &amp;n, &amp;m)) &#123; for (int i = 1; i &lt;= n; i++) &#123; a[i] = i; &#125; int flag = 0; do &#123; flag++; if (flag == m) break; &#125; while (next_permutation(a + 1, a + n + 1)); for (int i = 1; i &lt; n; i++) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; a[n] &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>Training</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>c/c++</tag>
        <tag>Thinking</tag>
        <tag>HDU</tag>
        <tag>CodeForces</tag>
        <tag>poj</tag>
        <tag>STL</tag>
        <tag>UVA</tag>
        <tag>math</tag>
        <tag>Stack</tag>
        <tag>Queue</tag>
        <tag>Stringstream</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HPU Summer Training Day x（河南理工大学暑期第x天）]]></title>
    <url>%2Fblog%2F2019%2F07%2F18%2Fdx%2F</url>
    <content type="text"><![CDATA[主要学的是快速幂，gcdI don&#39;t know what day this is,just record it. Pseudoprime numbersDescription:Fermat&#39;s theorem states that for any prime number p and for any integer a &gt; 1, ap = a (mod p). That is, if we raise a to the pth power and divide by p, the remainder is a. Some (but not very many) non-prime values of p, known as base-a pseudoprimes, have this property for some a. (And some, known as Carmichael Numbers, are base-a pseudoprimes for all a.) Given 2 &lt; p ≤ 1000000000 and 1 &lt; a &lt; p, determine whether or not p is a base-a pseudoprime. Input Input contains several test cases followed by a line containing &quot;0 0&quot;. Each test case consists of a line containing p and a. Output For each test case, output &quot;yes&quot; if p is a base-a pseudoprime; otherwise output &quot;no&quot;. Sample Input 3 210 3341 2341 31105 21105 30 0 Sample Output nonoyesnoyesyes Problem solving:First judge p is a prime number or not,if p is a prime number output &#39;no&#39;,else then judge a^p%p is equal to a or not,if not equal output &#39;no&#39;.We should use fast power to avoid TLE.Code:123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;#include&lt;math.h&gt;int s(long long a)&#123; if(a==2) return 1; for(int i=2;i*i&lt;=a;i++) if(a%i==0) return 0; return 1;&#125;long long f(long long a,long long b,long long c)//快速幂模板&#123; long long t=1; a=a%c; while(b&gt;0) &#123; if(b%2==1) t=t*a%c; b=b/2; a=a*a%c; &#125; return t;&#125;int main()&#123; long long a,p; while(~scanf(&quot;%lld%lld&quot;,&amp;p,&amp;a)&amp;&amp;!(a==0&amp;&amp;p==0)) &#123; if(s(p)) printf(&quot;no\n&quot;); else &#123; if(f(a,p,p)==a) printf(&quot;yes\n&quot;); else printf(&quot;no\n&quot;); &#125; &#125; return 0;&#125; Raising Modulo NumbersDescription:People are different. Some secretly read magazines full of interesting girls&#39; pictures, others create an A-bomb in their cellar, others like using Windows, and some like difficult mathematical games. Latest marketing research shows, that this market segment was so far underestimated and that there is lack of such games. This kind of game was thus included into the KOKODáKH. The rules follow: Each player chooses two numbers Ai and Bi and writes them on a slip of paper. Others cannot see the numbers. In a given moment all players show their numbers to the others. The goal is to determine the sum of all expressions Ai Bi from all players including oneself and determine the remainder after division by a given number M. The winner is the one who first determines the correct result. According to the players&#39; experience it is possible to increase the difficulty by choosing higher numbers. You should write a program that calculates the result and is able to find out who won the game. Input The input consists of Z assignments. The number of them is given by the single positive integer Z appearing on the first line of input. Then the assignements follow. Each assignement begins with line containing an integer M (1 &lt;= M &lt;= 45000). The sum will be divided by this number. Next line contains number of players H (1 &lt;= H &lt;= 45000). Next exactly H lines follow. On each line, there are exactly two numbers Ai and Bi separated by space. Both numbers cannot be equal zero at the same time. Output For each assingnement there is the only one line of output. On this line, there is a number, the result of expression Sample Input 31642 33 44 55 63612312374859 30293821713 18132 Sample Output 21319513 Problem solving:I don&#39;t understand this problem clearly first time,and then I find a little hint in the output,so it&#39;s easy now.Code:123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;typedef long long ll;ll poww(ll x, ll y, ll maxn)&#123; ll res = 1; while (y) &#123; if (y % 2 != 0) res = res * x % maxn; x = x * x % maxn; y /= 2; &#125; return res % maxn;&#125;int main()&#123; ll n; cin &gt;&gt; n; ll a, b, c, d, e; while (n--) &#123; ll sum = 0; cin &gt;&gt; a &gt;&gt; b; while (b--) &#123; cin &gt;&gt; d &gt;&gt; e; sum += poww(d, e, a); sum %= a; &#125; cout &lt;&lt; sum &lt;&lt; endl; &#125;&#125; Wolf and RabbitDescription:There is a hill with n holes around. The holes are signed from 0 to n-1.A rabbit must hide in one of the holes. A wolf searches the rabbit in anticlockwise order. The first hole he get into is the one signed with 0. Then he will get into the hole every m holes. For example, m=2 and n=6, the wolf will get into the holes which are signed 0,2,4,0. If the rabbit hides in the hole which signed 1,3 or 5, she will survive. So we call these holes the safe holes.Input The input starts with a positive integer P which indicates the number of test cases. Then on the following P lines,each line consists 2 positive integer m and n(0&lt;m,n&lt;2147483648). Output For each input m n, if safe holes exist, you should output &quot;YES&quot;, else output &quot;NO&quot; in a single line. Sample Input 21 22 2 Sample Output NOYES Problem solving:Nothing to say,just judge the gcd of m and n is equal to 1 or not.Code:123456789101112131415#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int n,a,b; scanf(&quot;%d&quot;,&amp;n); while(n--) &#123; scanf(&quot;%d %d&quot;,&amp;a,&amp;b); if(__gcd(a,b)==1) puts(&quot;NO&quot;); else puts(&quot;YES&quot;); &#125;&#125; CakeDescription:一次生日Party可能有p人或者q人参加,现准备有一个大蛋糕.问最少要将蛋糕切成多少块(每块大小不一定相等),才能使p人或者q人出席的任何一种情况,都能平均将蛋糕分食.Input 每行有两个数p和q. Output 输出最少要将蛋糕切成多少块. Sample Input 2 3 Sample Output 4 Hint 将蛋糕切成大小分别为1/3,1/3,1/6,1/6的四块即满足要求.当2个人来时，每人可以吃1/3+1/6=1/2 , 1/2块。当3个人来时，每人可以吃1/6+1/6=1/3 , 1/3, 1/3块。 Code:12345678910#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int p, q; while (~scanf(&quot;%d %d&quot;, &amp;p, &amp;q)) &#123; cout &lt;&lt; p + q - __gcd(p, q) &lt;&lt; endl; &#125;&#125; 又见GCDDescription:有三个正整数a,b,c(0&lt;a,b,c&lt;10^6)，其中c不等于b。若a和c的最大公约数为b，现已知a和b，求满足条件的最小的c。Input 第一行输入一个n，表示有n组测试数据，接下来的n行，每行输入两个正整数a,b。 Output 输出对应的c，每组测试数据占一行。 Sample Input 26 212 4 Sample Output 48 Problem solving:What we would like to find is the smallest c,so begin with 2*b.Code:123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n, a, b; cin &gt;&gt; n; while (n--) &#123; cin &gt;&gt; a &gt;&gt; b; for (int i = b * 2; ; i += b) &#123; if (__gcd(a, i) == b) &#123; cout &lt;&lt; i &lt;&lt; endl; break; &#125; &#125; &#125;&#125; 最小公倍数Description:给定两个正整数，计算这两个数的最小公倍数。Input 输入包含多组测试数据，每组只有一行，包括两个不大于1000的正整数. Output 对于每个测试用例，给出这两个数的最小公倍数，每个实例输出一行。 Sample Input 10 14 Sample Output 70 Code:1234567891011#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; ll n, a, b; while (~scanf(&quot;%lld %lld&quot;, &amp;a, &amp;b)) &#123; cout &lt;&lt; a * b / __gcd(a, b) &lt;&lt; endl; &#125;&#125; 素数判定Description:对于表达式n^2+n+41，当n在（x,y）范围内取整数值时（包括x,y）(-39&lt;=x&lt;y&lt;=50)，判定该表达式的值是否都为素数。Input 输入数据有多组，每组占一行，由两个整数x，y组成，当x=0,y=0时，表示输入结束，该行不做处理。 Output 对于每个给定范围内的取值，如果表达式的值都为素数，则输出&quot;OK&quot;,否则请输出“Sorry”,每组输出占一行。 Sample Input 0 10 0 Sample Output OK Code:12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;bool check(ll x)&#123; if (x == 2) return 0; for (int i = 2; i &lt; sqrt(x + 1); i++) &#123; if (x % i == 0) return 1; &#125; return 0;&#125;int main()&#123; ll n, a, b; while (scanf(&quot;%lld %lld&quot;, &amp;a, &amp;b)) &#123; int flag = 0; if (a == 0 &amp;&amp; b == 0) break; for (ll i = a; i &lt;= b; i++) &#123; ll mid = i*i+ i + 41; if (check(mid)) &#123; flag = 1; break; &#125; &#125; if (flag) puts(&quot;Sorry&quot;); else puts(&quot;OK&quot;); &#125;&#125; 分拆素数和Description:把一个偶数拆成两个不同素数的和，有几种拆法呢？Input 输入包含一些正的偶数，其值不会超过10000，个数不会超过500，若遇0，则结束。 Output 对应每个偶数，输出其拆成不同素数的个数，每个结果占一行。 Sample Input 30260 Sample Output 32 Code:12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e4 + 7;int p[maxn];int main()&#123; for (int i = 0; i &lt; maxn; i++) p[i] = 1; p[0] = p[1] = 0; for (int i = 2; i &lt;= sqrt(maxn + 1); i++) &#123; for (int j = i + i; j &lt; maxn; j += i) &#123; p[j] = 0; &#125; &#125; ll n, a, b; while (scanf(&quot;%lld&quot;, &amp;n)) &#123; if (n == 0) break; int ans = 0; for (int i = 2; i &lt;n / 2; i++) &#123; if (p[i] &amp;&amp; p[n - i]) ans++; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125; 美素数Description:小明对数的研究比较热爱，一谈到数，脑子里就涌现出好多数的问题，今天，小明想考考你对素数的认识。 问题是这样的：一个十进制数，如果是素数，而且它的各位数字和也是素数，则称之为“美素数”，如29，本身是素数，而且2+9 = 11也是素数，所以它是美素数。 给定一个区间，你能计算出这个区间内有多少个美素数吗？Input 第一行输入一个正整数T，表示总共有T组数据(T &lt;= 10000)。接下来共T行，每行输入两个整数L，R(1&lt;= L &lt;= R &lt;= 1000000)，表示区间的左值和右值。 Output 对于每组数据，先输出Case数，然后输出区间内美素数的个数（包括端点值L,R）。每组数据占一行，具体输出格式参见样例。 Sample Input 31 1002 23 19 Sample Output Case #1: 14Case #2: 1Case #3: 4 Problem solving:Just By meter(打表).Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+7;typedef long long ll;ll p[maxn];ll a[maxn];bool check(ll x)&#123; if(p[x]) return 0; ll mid=0; while(x) &#123; mid+=x%10;x/=10; &#125; if(p[mid]) return 0; else return 1;&#125;int main()&#123; p[0]=p[1]=1; for(ll i=2;i&lt;sqrt(maxn);i++) &#123; for(ll j=i*2;j&lt;maxn;j+=i) &#123; p[j]=1; &#125; &#125; a[0]=0; for(int i=1;i&lt;maxn;i++) &#123; if(check(i)) a[i]=a[i-1]+1; else a[i]=a[i-1]; &#125; ll t,l,r; while(~scanf(&quot;%lld&quot;,&amp;t)) &#123; for(int i=1;i&lt;=t;i++) &#123; scanf(&quot;%lld %lld&quot;,&amp;l,&amp;r); printf(&quot;Case #%lld: %lld\n&quot;,i,a[r]-a[l-1]); &#125; &#125; return 0;&#125; Key SetDescription:soda has a set S with n integers {1,2,…,n}. A set is called key set if the sum of integers in the set is an even number. He wants to know how many nonempty subsets of S are key set.Input There are multiple test cases. The first line of input contains an integer T (1≤T≤1e5), indicating the number of test cases. For each test case:The first line contains an integer n (1≤n≤1e9), the number of integers in the set. Output For each test case, output the number of key sets modulo 1000000007. Sample Input 41234 Sample Output 0137 Problem solving:The answer is 2^(a-1)-1Code:1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1000000007;ll poww(ll x, ll y)&#123; ll res = 1; while (y) &#123; if (y % 2 != 0) res = res * x % maxn; x = x * x % maxn; y /= 2; &#125; return res % maxn;&#125;int main()&#123; int n, a, b; cin &gt;&gt; n; while (n--) &#123; cin &gt;&gt; a; cout &lt;&lt; poww(2, a - 1) - 1 &lt;&lt; endl; &#125;&#125; 人见人爱A^BDescription:求A^B的最后三位数表示的整数。说明：A^B的含义是“A的B次方”Input 输入数据包含多个测试实例，每个实例占一行，由两个正整数A和B组成（1&lt;=A,B&lt;=10000），如果A=0, B=0，则表示输入数据的结束，不做处理。 Output 对于每个测试实例，请输出A^B的最后三位表示的整数，每个输出占一行。 Sample Input 2 312 66789 100000 0 Sample Output 89841 Problem solving:Fast power.Code:1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll poww(ll x, ll y, ll z)&#123; ll ans = 1, base = x; while (y != 0) &#123; if (y &amp; 1 != 0) ans = ans * base % z; base = (base % z) * (base % z) % z; y &gt;&gt;= 1; &#125; return ans;&#125;int main()&#123; ll a, b; while (scanf(&quot;%lld %lld&quot;, &amp;a, &amp;b)) &#123; if (a == 0 &amp;&amp; b == 0) break; cout &lt;&lt; poww(a, b, 1000) &lt;&lt; endl; &#125;&#125; Rightmost DigitDescription:Given a positive integer N, you should output the most right digit of N^N.Input The input contains several test cases. The first line of the input is a single integer T which is the number of test cases. T test cases follow.Each test case contains a single positive integer N(1&lt;=N&lt;=1,000,000,000). Output For each test case, you should output the rightmost digit of N^N. Sample Input 234 Sample Output 76 Hint In the first case, 3 3 3 = 27, so the rightmost digit is 7.In the second case, 4 4 4 * 4 = 256, so the rightmost digit is 6. Problem solving:Fast power.Code:1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll poww(ll x, ll y, ll z)&#123; ll ans = 1, base = x; while (y != 0) &#123; if (y &amp; 1 != 0) ans = ans * base % z; base = (base % z) * (base % z) % z; y &gt;&gt;= 1; &#125; return ans;&#125;int main()&#123; ll n, a; cin &gt;&gt; n; while (n--) &#123; cin &gt;&gt; a; cout &lt;&lt; poww(a, a, 10) &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>Training</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>c/c++</tag>
        <tag>math</tag>
        <tag>Fast power</tag>
        <tag>prime</tag>
        <tag>gcd</tag>
        <tag>lcm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Something about __gcd]]></title>
    <url>%2Fblog%2F2019%2F07%2F18%2Fsp-gcd%2F</url>
    <content type="text"><![CDATA[I have written an article about gcd and lcm,I meet a new way to calculate gcd these days.My past gcd aritical: https://cndrew.cn/blog/2019/03/26/GCD-LCM/For example:1234567891011#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; int a=199,b=199*2; printf(&quot;%d\n&quot;,__gcd(a,b));&#125;output:199 The header file of __gcd is &#39;algorithm&#39;.How about the Time complexity(时间复杂度) of it.I found the source code for its implementation in the source file.Just like Division algorithm(辗转相除法).12345678910111213141516 /** * This is a helper function for the rotate algorithm specialized on RAIs. * It returns the greatest common divisor of two integer values. */ template&lt;typename _EuclideanRingElement&gt; _EuclideanRingElement __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n) &#123; while (__n != 0)&#123; _EuclideanRingElement __t = __m % __n; __m = __n; __n = __t;&#125; return __m; &#125; Now it&#39;s clear that the Time complexity(时间复杂度) of it is log(n).About this function,many people say it&#39;s probably forbidden in some test,and gcd is not so hard to write,just get too know it.]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HPU Summer Training Day 2（河南理工暑期集训第二天）]]></title>
    <url>%2Fblog%2F2019%2F07%2F18%2Fd2%2F</url>
    <content type="text"><![CDATA[今天主要学习了sort，结构体的sort。第一天算是结束了，还是有点累的，但是也很有收获，趁着这些题还都勉强能做出来，赶紧多写点吧. 前m大的数Description:还记得Gardon给小希布置的那个作业么？（上次比赛的1005）其实小希已经找回了原来的那张数表，现在她想确认一下她的答案是否正确，但是整个的答案是很庞大的表，小希只想让你把答案中最大的M个数告诉她就可以了。给定一个包含N(N&lt;=3000)个正整数的序列，每个数不超过5000，对它们两两相加得到的N*(N-1)/2个和，求出其中前M大的数(M&lt;=1000)并按从大到小的顺序排列。Input 输入可能包含多组数据，其中每组数据包括两行：第一行两个数N和M，第二行N个数，表示该序列。 Output 对于输入的每组数据，输出M个数，表示结果。输出应当按照从大到小的顺序排列。 Sample Input 4 41 2 3 44 55 3 6 4 Sample Output 7 6 5 511 10 9 9 8 Problem solving:I have nothing to say about this *** problem,just do it without thinking. Code:123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1e7;int a[maxn],b[4000];int main()&#123; int n,m; while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;m)) &#123; int k=0; for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;b[i]); for(int i=0;i&lt;n-1;i++) &#123; for(int j=i+1;j&lt;n;j++) &#123; a[k]=b[i]+b[j]; k++; &#125; &#125; sort(a,a+k); for(int i=k-1;i&gt;0;i--) &#123; if(m==0) break; if(i==k-1) cout&lt;&lt;a[i]; else cout&lt;&lt;&quot; &quot;&lt;&lt;a[i]; m--; &#125; puts(&quot;&quot;); &#125;&#125; 稳定排序Description:大家都知道，快速排序是不稳定的排序方法。如果对于数组中出现的任意a[i],aj,其中a[i]==a[j]，在进行排序以后a[i]一定出现在a[j]之前，则认为该排序是稳定的。 某高校招生办得到一份成绩列表，上面记录了考生名字和考生成绩。并且对其使用了某排序算法按成绩进行递减排序。现在请你判断一下该排序算法是否正确，如果正确的话，则判断该排序算法是否为稳定的。Input 本题目包含多组输入，请处理到文件结束。对于每组数据，第一行有一个正整数N(0&lt;N&lt;300)，代表成绩列表中的考生数目。接下来有N行，每一行有一个字符串代表考生名字(长度不超过50，仅包含&#39;a&#39;~&#39;z&#39;),和一个整数代表考生分数(小于500)。其中名字和成绩用一个空格隔开。再接下来又有N行，是上述列表经过某排序算法以后生成的一个序列。格式同上。 Output 对于每组数据，如果算法是正确并且稳定的，就在一行里面输出&quot;Right&quot;。如果算法是正确的但不是稳定的，就在一行里面输出&quot;Not Stable&quot;，并且在下面输出正确稳定排序的列表，格式同输入。如果该算法是错误的，就在一行里面输出&quot;Error&quot;,并且在下面输出正确稳定排序的列表，格式同输入。注意，本题目不考虑该排序算法是错误的，但结果是正确的这样的意外情况。 Sample Input 3aa 10bb 10cc 20cc 20bb 10aa 103aa 10bb 10cc 20cc 20aa 10bb 103aa 10bb 10cc 20aa 10bb 10cc 20 Sample Output Not Stablecc 20aa 10bb 10RightErrorcc 20aa 10bb 10 Problem solving:Attention: we&#39;d better make the order in which it arrears.And then just sort for structures.Compare the second input with the right and stable result.If the score&#39;s order is wrong,output &#39;Error&#39;,if the name&#39;s order is wrong,output &#39;Not Stable&#39;,if all order are right,output &#39;Right&#39;. Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;struct node&#123; string na; int s,i;&#125;p[305],pp[305];bool cmp(node x,node y)&#123; if(x.s==y.s) return x.i&lt;y.i; return x.s&gt;y.s;&#125;int main()&#123; int n; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;p[i].na&gt;&gt;p[i].s; p[i].i=i; &#125; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;pp[i].na&gt;&gt;pp[i].s; &#125; sort(p,p+n,cmp); int flag=0; for(int i=0;i&lt;n-1;i++) &#123; if(pp[i].s&lt;pp[i+1].s) &#123; flag=1; break; &#125; &#125; if(flag) &#123; puts(&quot;Error&quot;); for(int i=0;i&lt;n;i++) &#123; cout&lt;&lt;p[i].na&lt;&lt;&quot; &quot;&lt;&lt;p[i].s&lt;&lt;&quot;\n&quot;; &#125; &#125; else &#123; for(int i=0;i&lt;n;i++) &#123; if(p[i].na!=pp[i].na) &#123; flag=1; break; &#125; &#125; if(flag) &#123; puts(&quot;Not Stable&quot;); for(int i=0;i&lt;n;i++) &#123; cout&lt;&lt;p[i].na&lt;&lt;&quot; &quot;&lt;&lt;p[i].s&lt;&lt;&quot;\n&quot;; &#125; &#125; else &#123; puts(&quot;Right&quot;); &#125; &#125; &#125; return 0;&#125; 开门人和关门人Description:每天第一个到机房的人要把门打开，最后一个离开的人要把门关好。现有一堆杂乱的机房签到、签离记录，请根据记录找出当天开门和关门的人。Input 测试输入的第一行给出记录的总天数N ( &gt; 0 )。下面列出了N天的记录。每天的记录在第一行给出记录的条目数M ( &gt; 0 )，下面是M行，每行的格式为证件号码 签到时间 签离时间其中时间按“小时:分钟:秒钟”（各占2位）给出，证件号码是长度不超过15的字符串。 Output 对每一天的记录输出1行，即当天开门和关门人的证件号码，中间用1空格分隔。注意：在裁判的标准测试输入中，所有记录保证完整，每个人的签到时间在签离时间之前，且没有多人同时签到或者签离的情况。 Sample Input 31ME3021112225321 00:00:00 23:59:592EE301218 08:05:35 20:56:35MA301134 12:35:45 21:40:423CS301111 15:30:28 17:00:10SC3021234 08:00:00 11:25:25CS301133 21:45:00 21:58:40 Sample Output ME3021112225321 ME3021112225321EE301218 MA301134SC3021234 CS301133 Problem solving:The earliest person and the lastest person is what we should output.The way we get these two person&#39;s name is sort,sort for structures.The best thing is we can find this efficient through sort string.You can look my code carefully to understand this.Code:12345678910111213141516171819202122232425262728293031323334#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;struct node&#123; string n,b,e;&#125;p[1000];bool cmp(node x,node y)&#123; return x.b&lt;y.b;&#125;bool ccmp(node x,node y)&#123; return x.e&gt;y.e;&#125;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); while(n--) &#123; int m; scanf(&quot;%d&quot;,&amp;m); for(int i=0;i&lt;m;i++) &#123; cin&gt;&gt;p[i].n&gt;&gt;p[i].b&gt;&gt;p[i].e; &#125; sort(p,p+m,cmp); cout&lt;&lt;p[0].n&lt;&lt;&quot; &quot;; sort(p,p+m,ccmp); cout&lt;&lt;p[0].n; puts(&quot;&quot;); &#125;&#125; EXCEL排序Description:Excel可以对一组纪录按任意指定列排序。现请你编写程序实现类似功能。Input 测试输入包含若干测试用例。每个测试用例的第1行包含两个整数 N (&lt;=100000) 和 C，其中 N 是纪录的条数，C 是指定排序的列号。以下有 N行，每行包含一条学生纪录。每条学生纪录由学号（6位数字，同组测试中没有重复的学号）、姓名（不超过8位且不包含空格的字符串）、成绩（闭区间[0, 100]内的整数）组成，每个项目间用1个空格隔开。当读到 N=0 时，全部输入结束，相应的结果不要输出。 Output 对每个测试用例，首先输出1行“Case i:”，其中 i 是测试用例的编号（从1开始）。随后在 N 行中输出按要求排序后的结果，即：当 C=1 时，按学号递增排序；当 C=2时，按姓名的非递减字典序排序；当 C=3时，按成绩的非递减排序。当若干学生具有相同姓名或者相同成绩时，则按他们的学号递增排序。 Sample Input 3 1000007 James 85000010 Amy 90000001 Zoe 604 2000007 James 85000010 Amy 90000001 Zoe 60000002 James 984 3000007 James 85000010 Amy 90000001 Zoe 60000002 James 900 0 Sample Output Case 1:000001 Zoe 60000007 James 85000010 Amy 90Case 2:000010 Amy 90000002 James 98000007 James 85000001 Zoe 60Case 3:000001 Zoe 60000007 James 85000002 James 90000010 Amy 90 Problem solving:Look the problem description carefully,and sort for structures.Easy.Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;struct node&#123; string id,na; int s;&#125;p[100008];bool cmp1(node x,node y)&#123; return x.id&lt;y.id;&#125;bool cmp2(node x,node y)&#123; if(x.na==y.na) return x.id&lt;y.id; return x.na&lt;y.na;&#125;bool cmp3(node x,node y)&#123; if(x.s==y.s) return x.id&lt;y.id; return x.s&lt;y.s;&#125;int main()&#123; int n,c,j=0; while(scanf(&quot;%d %d&quot;,&amp;n,&amp;c)&amp;&amp;n) &#123; j++; for(int i=0;i&lt;n;i++) cin&gt;&gt;p[i].id&gt;&gt;p[i].na&gt;&gt;p[i].s; if(c==1) &#123; sort(p,p+n,cmp1); &#125; if(c==2) &#123; sort(p,p+n,cmp2); &#125; if(c==3) &#123; sort(p,p+n,cmp3); &#125; printf(&quot;Case %d:\n&quot;,j); for(int i=0;i&lt;n;i++) cout&lt;&lt;p[i].id&lt;&lt;&quot; &quot;&lt;&lt;p[i].na&lt;&lt;&quot; &quot;&lt;&lt;p[i].s&lt;&lt;endl; &#125;&#125; 统计同成绩学生人数Description:读入N名学生的成绩，将获得某一给定分数的学生人数输出。Input 测试输入包含若干测试用例，每个测试用例的格式为第1行：N第2行：N名学生的成绩，相邻两数字用一个空格间隔。第3行：给定分数当读到N=0时输入结束。其中N不超过1000，成绩分数为（包含）0到100之间的一个整数。 Output 对每个测试用例，将获得给定分数的学生人数输出。 Sample Input 380 60 9060285 660560 75 90 55 75750 Sample Output 102 Problem solving:We can solve this by loop for,but I think map is exciting.Code:123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n,a,m; while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n) &#123; map&lt;int,int&gt; ma; for(int i=0;i&lt;n;i++) &#123; scanf(&quot;%d&quot;,&amp;a); ma[a]++; &#125; scanf(&quot;%d&quot;,&amp;m); printf(&quot;%d\n&quot;,ma[m]); &#125; return 0;&#125; What Is Your Grade?Description:“Point, point, life of student!”This is a ballad（歌谣）well known in colleges, and you must care about your score in this exam too. How many points can you get? Now, I told you the rules which are used in this course.There are 5 problems in this final exam. And I will give you 100 points if you can solve all 5 problems; of course, it is fairly difficulty for many of you. If you can solve 4 problems, you can also get a high score 95 or 90 (you can get the former(前者) only when your rank is in the first half of all students who solve 4 problems). Analogically（以此类推）, you can get 85、80、75、70、65、60. But you will not pass this exam if you solve nothing problem, and I will mark your score with 50.Note, only 1 student will get the score 95 when 3 students have solved 4 problems.I wish you all can pass the exam!Come on!Input Input contains multiple test cases. Each test case contains an integer N (1&lt;=N&lt;=100, the number of students) in a line first, and then N lines follow. Each line contains P (0&lt;=P&lt;=5 number of problems that have been solved) and T（consumed time）. You can assume that all data are different when 0\&lt;p.A test case starting with a negative integer terminates the input and this test case should not to be processed. Output Output the scores of N students in N lines for each case, and there is a blank line after each case. Sample Input 45 06:30:174 07:31:274 08:12:124 05:23:1315 06:30:17-1 Sample Output 100909095100 Problem solving:&#39;only when your rank is in the first half of all students who solve 4 problems&#39;-&gt;This is important.What we should pay more attention to is the meaning of this problem.Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;struct node&#123; int na; string t; int s; int i;&#125;p[105];bool cmp(node x,node y)&#123; if(x.s==y.s) return x.t&lt;y.t; return x.s&gt;y.s;&#125;bool cmp1(node x,node y)&#123; return x.i&lt;y.i;&#125;int main()&#123; int n; while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n&gt;0) &#123; int mid=0,aa=0,bb=0,cc=0,dd=0; for(int i=0;i&lt;n;i++) &#123; p[i].i=i; cin&gt;&gt;p[i].na&gt;&gt;p[i].t; if(p[i].na==5) p[i].s=100; if(p[i].na==0) p[i].s=50; if(p[i].na==4) &#123;p[i].s=90;aa++;&#125; if(p[i].na==3) &#123;p[i].s=80;bb++;&#125; if(p[i].na==2) &#123;p[i].s=70;cc++;&#125; if(p[i].na==1) &#123;p[i].s=60;dd++;&#125; &#125; aa/=2; bb/=2; cc/=2; dd/=2; sort(p,p+n,cmp); for(int i=0;i&lt;n;i++) &#123; if(p[i].s==90&amp;&amp;aa) &#123; p[i].s=95; aa--; &#125; if(p[i].s==80&amp;&amp;bb) &#123; p[i].s=85; bb--; &#125; if(p[i].s==70&amp;&amp;cc) &#123; p[i].s=75; cc--; &#125; if(p[i].s==60&amp;&amp;dd) &#123; p[i].s=65; dd--; &#125; &#125; sort(p,p+n,cmp1); for(int i=0;i&lt;n;i++)&#123; cout&lt;&lt;p[i].s&lt;&lt;&quot;\n&quot;; &#125; puts(&quot;&quot;); &#125;&#125; Magical BamboosDescription:In a magical forest, there exists N bamboos that don&#39;t quite get cut down the way you would expect. Originally, the height of the ith bamboo is equal to hi. In one move, you can push down a bamboo and decrease its height by one, but this move magically causes all the other bamboos to increase in height by one. If you can do as many moves as you like, is it possible to make all the bamboos have the same height? Input The first line of input is T – the number of test cases.The first line of each test case contains an integer N (1 ≤ N ≤ 105) - the number of bamboos.The second line contains N space-separated integers hi (1 ≤ hi ≤ 105) - the original heights of the bamboos. Output For each test case, output on a single line &quot;yes” (without quotes), if you can make all the bamboos have the same height, and &quot;no&quot; otherwise. Example Input232 4 221 2 Outputyesno Problem solving:Sorted this array fist.If the difference of two adjacent numbers have odd,output &#39;no&#39;,otherwise,output &#39;yes&#39;.Code:123456789101112131415161718192021222324252627282930#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1e5+7;int a[maxn];int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); while(n--) &#123; int m,flag=0; scanf(&quot;%d&quot;,&amp;m); for(int i=0;i&lt;m;i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; for(int i=0;i&lt;m-1;i++) &#123; if((a[i+1]-a[i])%2!=0) &#123; flag=1; break; &#125; &#125; if(flag) puts(&quot;no&quot;); else puts(&quot;yes&quot;); &#125; return 0;&#125; Bear and Three BallsDescription:Limak is a little polar bear. He has n balls, the i-th ball has size ti. Limak wants to give one ball to each of his three friends. Giving gifts isn&#39;t easy — there are two rules Limak must obey to make friends happy: No two friends can get balls of the same size.No two friends can get balls of sizes that differ by more than 2.For example, Limak can choose balls with sizes 4, 5 and 3, or balls with sizes 90, 91 and 92. But he can&#39;t choose balls with sizes 5, 5 and 6 (two friends would get balls of the same size), and he can&#39;t choose balls with sizes 30, 31 and 33 (because sizes 30 and 33 differ by more than 2). Your task is to check whether Limak can choose three balls that satisfy conditions above. Input The first line of the input contains one integer n (3 ≤ n ≤ 50) — the number of balls Limak has.The second line contains n integers t1, t2, ..., tn (1 ≤ ti ≤ 1000) where ti denotes the size of the i-th ball. Output Print &quot;YES&quot; (without quotes) if Limak can choose three balls of distinct sizes, such that any two of them differ by no more than 2. Otherwise, print &quot;NO&quot; (without quotes). Examples Input418 55 16 17 OutputYES Input 640 41 43 44 44 44 Output NO Input 85 972 3 4 1 4 970 971 Output YES Note In the first sample, there are 4 balls and Limak is able to choose three of them to satisfy the rules. He must must choose balls with sizes 18, 16 and 17.In the second sample, there is no way to give gifts to three friends without breaking the rules.In the third sample, there is even more than one way to choose balls: Choose balls with sizes 3, 4 and 5. Choose balls with sizes 972, 970, 971. Problem solving:If there have three numbers which are adjacent,output &#39;yes&#39;,otherwise ouput&#39;no&#39;.Code:123456789101112131415161718192021222324#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int a[100];int main()&#123; int n,flag=0; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; sort(a,a+n); for(int i=0;i&lt;n;i++) &#123; if(binary_search(a,a+n,a[i]+1)&amp;&amp;binary_search(a,a+n,a[i]+2)) &#123; flag=1; break; &#125; &#125; if(flag) puts(&quot;YES&quot;); else puts(&quot;NO&quot;);&#125; 今年暑假不ACDescription:“今年暑假不AC？”“是的。”“那你干什么呢？”“看世界杯呀，笨蛋！”“@#\$%^&amp;*%...” 确实如此，世界杯来了，球迷的节日也来了，估计很多ACMer也会抛开电脑，奔向电视了。作为球迷，一定想看尽量多的完整的比赛，当然，作为新时代的好青年，你一定还会看一些其它的节目，比如新闻联播（永远不要忘记关心国家大事）、非常6+7、超级女生，以及王小丫的《开心辞典》等等，假设你已经知道了所有你喜欢看的电视节目的转播时间表，你会合理安排吗？（目标是能看尽量多的完整节目）Input 输入数据包含多个测试实例，每个测试实例的第一行只有一个整数n(n&lt;=100)，表示你喜欢看的节目的总数，然后是n行数据，每行包括两个数据Ti_s,Ti_e (1&lt;=i&lt;=n)，分别表示第i个节目的开始和结束时间，为了简化问题，每个时间都用一个正整数表示。n=0表示输入结束，不做处理。 Output 对于每个测试实例，输出能完整看到的电视节目的个数，每个测试实例的输出占一行。 Sample Input 121 33 40 73 815 1915 2010 158 186 125 104 142 90 Sample Output 5 Problem solving:Greedy,sort by the end time,and then start counting.Code:123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 105;struct node&#123; int b,s;&#125;x[maxn];bool cmp(node q,node w)&#123; return q.s&lt;w.s;&#125;int main()&#123; int n; while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n) &#123; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;x[i].b&gt;&gt;x[i].s; &#125; sort(x,x+n,cmp); int o=x[0].s,ans=1; for(int i=0;i&lt;n;i++) &#123; if(x[i].b&gt;=o) &#123; ans++; o=x[i].s; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; The sum problemDescription:Given a sequence 1,2,3,......N, your job is to calculate all the possible sub-sequences that the sum of the sub-sequence is M.Input Input contains multiple test cases. each case contains two integers N, M( 1 &lt;= N, M &lt;= 1000000000).input ends with N = M = 0. Output For each test case, print all the possible sub-sequence that its sum is M.The format is show in the sample below.print a blank line after each test case. Sample Input 20 1050 300 0 Sample Output [1,4][10,10][4,8][6,9][9,11][30,30] Problem solving:Sum Formula of Equal Difference Sequences.Code:123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n,m; while(scanf(&quot;%d %d&quot;,&amp;n,&amp;m)) &#123; if(m==0&amp;&amp;m==0) break; for(int i=sqrt(2*m);i&gt;=1;i--) &#123; int a=(m-i*(i-1)/2)/i; if((a*i)+i*(i-1)/2==m) printf(&quot;[%d,%d]\n&quot;,a,a+i-1); &#125; puts(&quot;&quot;); &#125;return 0;&#125;]]></content>
      <categories>
        <category>Training</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>c/c++</tag>
        <tag>Thinking</tag>
        <tag>HDU</tag>
        <tag>CodeForces</tag>
        <tag>STL</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HPU Summer Training Day 1（河南理工大学暑期第一天）]]></title>
    <url>%2Fblog%2F2019%2F07%2F17%2Fd1%2F</url>
    <content type="text"><![CDATA[盼望着，盼望着，暑假集训来了，希望集训完自己能变的厉害点吧。不然这丢失的40天左右的假期还真是浪费了啊。]]></content>
      <categories>
        <category>Training</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>c/c++</tag>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 572 (Div. 2)]]></title>
    <url>%2Fblog%2F2019%2F07%2F06%2FCodeforces-572%2F</url>
    <content type="text"><![CDATA[About this match,I have no idea about how to describe my thought,so I just paste my passed code here.Link: Codeforces Round 572 A Keanu ReevesDescription:After playing Neo in the legendary &quot;Matrix&quot; trilogy, Keanu Reeves started doubting himself: maybe we really live in virtual reality? To find if this is true, he needs to solve the following problem. Let&#39;s call a string consisting of only zeroes and ones good if it contains different numbers of zeroes and ones. For example, 1, 101, 0000 are good, while 01, 1001, and 111000 are not good. We are given a string s of length n consisting of only zeroes and ones. We need to cut s into minimal possible number of substrings s1,s2,…,sk such that all of them are good. More formally, we have to find minimal by number of strings sequence of good strings s1,s2,…,sk such that their concatenation (joining) equals s, i.e. s1+s2+⋯+sk=s. For example, cuttings 110010 into 110 and 010 or into 11 and 0010 are valid, as 110, 010, 11, 0010 are all good, and we can&#39;t cut 110010 to the smaller number of substrings as 110010 isn&#39;t good itself. At the same time, cutting of 110010 into 1100 and 10 isn&#39;t valid as both strings aren&#39;t good. Also, cutting of 110010 into 1, 1, 0010 isn&#39;t valid, as it isn&#39;t minimal, even though all 3 strings are good. Can you help Keanu? We can show that the solution always exists. If there are multiple optimal answers, print any. InputThe first line of the input contains a single integer n (1≤n≤100) — the length of the string s. The second line contains the string s of length n consisting only from zeros and ones. OutputIn the first line, output a single integer k (1≤k) — a minimal number of strings you have cut s into. In the second line, output k strings s1,s2,…,sk separated with spaces. The length of each string has to be positive. Their concatenation has to be equal to s and all of them have to be good. If there are multiple answers, print any. Examplesinput 11 output 11 input 210 output 21 0 input 6100011 output 2100 011 Note In the first example, the string 1 wasn&#39;t cut at all. As it is good, the condition is satisfied.In the second example, 1 and 0 both are good. As 10 isn&#39;t good, the answer is indeed minimal.In the third example, 100 and 011 both are good. As 100011 isn&#39;t good, the answer is indeed minimal. Code:12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;int o[105], z[105];int main()&#123; int n, a, b; a = b = 0; string s; cin &gt;&gt; n &gt;&gt; s; for (int i = 0; i &lt; s.size(); i++) &#123; if (s[i] == &apos;1&apos;) a++; if (s[i] == &apos;0&apos;) b++; o[i] = a; z[i] = b; &#125; int ans = 0; if (a != b) &#123; cout &lt;&lt; &quot;1\n&quot; &lt;&lt; s &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;2\n&quot;; for (int i = 0; i &lt; s.size()-1; i++) cout &lt;&lt; s[i]; cout &lt;&lt; &quot; &quot; &lt;&lt; s[s.size() - 1] &lt;&lt; endl; &#125;&#125; B Number CircleDescription:You are given n numbers a1,a2,…,an. Is it possible to arrange them in a circle in such a way that every number is strictly less than the sum of its neighbors? For example, for the array [1,4,5,6,7,8], the arrangement on the left is valid, while arrangement on the right is not, as 5≥4+1 and 8&gt;1+6.InputThe first line contains a single integer n (3≤n≤105) — the number of numbers. The second line contains n integers a1,a2,…,an (1≤ai≤109) — the numbers. The given numbers are not necessarily distinct (i.e. duplicates are allowed). OutputIf there is no solution, output &quot;NO&quot; in the first line. If there is a solution, output &quot;YES&quot; in the first line. In the second line output n numbers — elements of the array in the order they will stay in the circle. The first and the last element you output are considered neighbors in the circle. If there are multiple solutions, output any of them. You can print the circle starting with any element. Examplesinput 32 4 3 output YES4 2 3 input 51 2 3 4 4 output YES4 4 2 1 3 input 313 8 5 output NO input 41 10 100 1000 output NO Note One of the possible arrangements is shown in the first example:4&lt;2+3;2&lt;4+3;3&lt;4+2.One of the possible arrangements is shown in the second example.No matter how we arrange 13,8,5 in a circle in the third example, 13 will have 8 and 5 as neighbors, but 13≥8+5.There is no solution in the fourth example. Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 10;typedef long long ll;ll a[maxn];int main()&#123; queue&lt;ll&gt; f; stack&lt;ll&gt; e; ll n; cin &gt;&gt; n; for (ll i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; sort(a, a + n); if (a[n - 1] &gt;= (a[n - 3] + a[n - 2])) &#123; puts(&quot;NO&quot;); return 0; &#125; puts(&quot;YES&quot;); int flag = 1; for (int i = n - 1; i &gt;= 0; i--) &#123; if (flag) &#123; f.push(a[i]); if (a[i - 1] != a[i]) flag = 0; &#125; else &#123; e.push(a[i]); if (a[i - 1] != a[i]) flag = 1; &#125; &#125; while (!f.empty()) &#123; cout &lt;&lt; f.front() &lt;&lt; &quot; &quot;; f.pop(); &#125; while (!e.empty()) &#123; cout &lt;&lt; e.top() &lt;&lt; &quot; &quot;; e.pop(); &#125;&#125;]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>Thinking</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[筱玛爱地理]]></title>
    <url>%2Fblog%2F2019%2F07%2F06%2Fnowcoder-946-A%2F</url>
    <content type="text"><![CDATA[I have heared Inverse-modulo(逆元) before,I can&#39;t understand it clearly that time till I met this problem yesterday. nowcoder-946-A 筱玛爱地理Link: nowcoder-946-ADescription:筱玛是一个热爱地理的好筱玛。最近，在《地理II》作业本上，筱玛学到了“贝塔指数”的概念： 在经济地理学中，交通的联结度表示交通网络的发达程度，通常用贝塔指数来计算与比较。若用V表示一个交通网络中结点的数量，用E表示边的数量，则贝塔指数的计算方式为：β=E/V。 “实践是检验真理的唯一标准”。作为一个热爱地理的好筱玛，她马上就把新学的知识应用到实践当中去。筱玛一口气出了n张交通网络规划图，其中第i张交通网络Gi有Vi个结点和Ei条边。筱玛一眼就看出了哪张图好、哪张图坏。但是作为一个负责任的好筱玛，她必须带领同学们一起进步。因此，她需要你将所有的n张图按照贝塔指数排序，并求出它们各自的贝塔指数在模1e9+7意义下的值。 输入描述:第一行一个整数n，表示交通网络规划图的数量。 接下来n行，每行两个整数Vi和Ei，分别表示图Gi中的结点数量和边的数量。 输出描述:输出共n行，每行一个数，表示贝塔指数第i大的交通网络的贝塔指数在模1e9+7意义下的值。如果不能整除，输出分数取模后的结果。示例1输入 11 3 输出 3 说明 显然此时β=E/V=3。 备注: 对于100%的数据，保证1≤n≤2×1e5，1≤Vi,Ei≤1e9。 Problem solving:Obviously,we can solve this problem through sort.But there has a unusual situation is fractional modulo.So we use Inverse-modulo(逆元) here. Click to see Chinese Intentional analysis显然是一个sort就可以解决的问题，但是更难得在于要对分数取模，这个时候就会用到逆元。Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e9 + 7;struct node&#123; ll x, y; double z;&#125; a[200005];bool cmp(node x, node y)&#123; return x.z &lt; y.z;&#125;const int mod = 1e9 + 7;long long quickpow(long long a, long long b)&#123; if (b &lt; 0) return 0; long long ret = 1; a %= mod; while (b) &#123; if (b &amp; 1) ret = (ret * a) % mod; b &gt;&gt;= 1; a = (a * a) % mod; &#125; return ret;&#125;long long inv(long long a)&#123; return quickpow(a, mod - 2);&#125;int main()&#123; ll n; cin &gt;&gt; n; for (ll i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i].x &gt;&gt; a[i].y; a[i].z = a[i].y * 1.0 / a[i].x; &#125; sort(a, a + n, cmp); for (ll i = n - 1; i &gt;= 0; i--) cout &lt;&lt;a[i].y * inv(a[i].x) % maxn &lt;&lt; endl;&#125; About Inverse-modulo(逆元)There are many ways to find it.But I love this way,it&#39;s easy to understand and remember.That is Fermat&#39;s little theorem,we can ues this when the mode is a prime number.The Inverse-modulo(逆元) of a in mode p isa ^ (p-2).Code:1234567891011121314151617181920const int mod = 1e9 + 7;long long quickpow(long long a, long long b)&#123; if (b &lt; 0) return 0; long long ret = 1; a %= mod; while (b) &#123; if (b &amp; 1) ret = (ret * a) % mod; b &gt;&gt;= 1; a = (a * a) % mod; &#125; return ret;&#125;long long inv(long long a)&#123; return quickpow(a, mod - 2);&#125; So (a/b)%p=a*inv(b)%p.]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>c/c++</tag>
        <tag>nowcoder</tag>
        <tag>inverse-modulo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Past About]]></title>
    <url>%2Fblog%2F2019%2F07%2F04%2Foldabout%2F</url>
    <content type="text"><![CDATA[I find my old about page is not so serious these days,so I will make a new about page and the old page will paste on here. My blogPurpose：1.It is to record what i have learned, and it is convenient to go back to review.2.Get to know more friends through this exploration.3.Enhance your hands-on ability, language organization skills, etc. Contact meqq: 1120437716G-mial: miaodrew@gmail.com Some sharing of Baiduyun c++API帮助文档提取码：hyco python学习参考资料提取码：2k84 Continuous update... My favorite music Relax for a moment丷泰戈尔 生如夏花我听见回声，来自山谷和心间以寂寞的镰刀收割空旷的灵魂不断地重复决绝，又重复幸福终有绿洲摇曳在沙漠我相信自己生来如同璀璨的夏日之花不凋不败，妖治如火承受心跳的负荷和呼吸的累赘乐此不疲我听见音乐，来自月光和胴体辅极端的诱饵捕获飘渺的唯美一生充盈着激烈，又充盈着纯然总有回忆贯穿于世间我相信自己死时如同静美的秋日落叶不盛不乱，姿态如烟即便枯萎也保留丰肌清骨的傲然玄之又玄我听见爱情，我相信爱情爱情是一潭挣扎的蓝藻如同一阵凄微的风穿过我失血的静脉驻守岁月的信念我相信一切能够听见甚至预见离散，遇见另一个自己而有些瞬间无法把握任凭东走西顾，逝去的必然不返请看我头置簪花，一路走来一路盛开频频遗漏一些，又深陷风霜雨雪的感动般若波罗蜜，一声一声生如夏花，死如秋叶还在乎拥有什么 当时光已逝假如时光已逝，鸟儿不再歌唱，风儿也吹倦了，那就用黑暗的厚幕把我盖上，如同黄昏时节你用睡眠的衾被裹住大地，又轻轻合上睡莲的花瓣。路途未完，行囊已空,衣裳破裂污损，人已精疲力竭。你驱散了旅客的羞愧和困窘，使他在你仁慈的夜幕下，如花朵般焕发生机。在你慈爱的夜幕下苏醒。 不要不辞而别，我爱不要不辞而别，我爱。我看望了一夜，现在我脸上睡意重重。只恐我在睡中把你丢失了。不要不辞而别，我爱。我惊起伸出双手去摸触你，我问自己说：“这是一个梦么？”但愿我能用我的心系住你的双足，紧抱在胸前！不要不辞而别，我爱。 永恒的爱情我以数不清的方式爱你我的痴心永远为你编织歌之花环亲爱的，接受我的奉献世世代代以各种方式挂在你的胸前我听过的许多古老爱情的故事充满聚首的欢乐和离别的悲郁纵观无始的往昔我看见你像永世难忘的北斗穿透岁月的黑暗姗姗来到我的面前从洪荒时代的心源出发你我泛舟顺流而下你我在亿万爱侣中间嬉戏分离时辛酸的眼泪和团圆时甜蜜的羞涩里古老的爱情孕育了新意陈腐的爱情而今化为你脚下的灰尘一切心灵的爱欲、悲喜一切爱情传说，历史诗人写的恋歌歌词全部融合在你我新型的爱情里 林徽因 深夜里听到乐声这一定又是你的手指，轻弹着，在这深夜，稠密的悲思；我不禁颊边泛上了红，静听着，这深夜里弦子的生动。一声听从我心底穿过，忒凄凉我懂得，但我怎能应和？生命早描定她的式样，太薄弱是人们的美丽的想象。除非在梦里有这么一天，你和我同来攀动那根希望的弦。选自《新月诗选》（1931年9月） 山中一个夏夜山中一个夏夜，深得象没有底一样；黑影，松林密密的；周围没有点光亮。对山闪着只一盏灯———两盏象夜的眼，夜的眼在看！满山的风全蹑着脚象是走路一样；躲过了各处的枝叶各处的草，不响。单是流水，不断的在山谷上石头的心，石头的口在唱。均匀的一片静，罩下象张软垂的幔帐。疑问不见了，四角里模糊，是梦在窥探？夜象在祈祷，无声的在期望幽郁的虔诚在无声里布漫。选自《新月》四卷七期（1933年6月） 那一晚那一晚我的船推出了河心，澄蓝的天上托着密密的星。那一晚你的手牵着我的手，迷惘的星夜封锁起重愁。那一晚你和我分定了方向，两人各认取个生活的模样。到如今我的船仍然在海面飘，细弱的桅杆常在风涛里摇。到如今太阳只在我背后徘徊，层层的阴影留守在我周围。到如今我还记着那一晚的天，星光、眼泪、白茫茫的江边！到如今我还想念你岸上的耕种：红花儿黄花儿朵朵的生动。那一天我希望要走到了顶层，蜜一般酿出那记忆的滋润。那一天我要跨上带羽翼的箭，望着你花园里射一个满弦。那一天你要听到鸟般的歌唱，那便是我静候着你的赞赏。那一天你要看到零乱的花影，那便是我私闯入当年的边境！ 六毛纠纷数不清的繁星点亮勾勒出，你的脸庞你是我的繁星在无尽的黑夜发光数不清的鲜花绽放显现出，我的念想你是我的鲜花在我的心中为王。但我知道，我只是一片最普通，最平凡的土壤配不上任何一朵花的芳香我知道，我只是一片虚无与黑暗相随不值得任何繁星点亮。你不必反复强调我们的关系，我只会与你保持应有的距离。 鹰的独白Ⅰ——古寺·远方我曾经 是只雄鹰如今 失去了翅膀慵懒的如古寺中的老僧唯一的消遣是抬头看看太阳我梳理着身上的羽毛回忆着它疯狂拼搏的曾经厌倦着它如今的闪闪发光我是一只雄鹰却渴望在远方有种宝藏 叫翅膀我曾经知道努力懂得疯狂待尘埃落尽 换回的却是百孔千疮蹒跚着 我走向那远方没有意料中的翅膀只有一种力量助我飞翔叫 坚强！ 鹰的独白Ⅱ——沉思我再次获得了飞翔的力量我拼命煽动着这双不会感到疲惫的翅膀无翼的牢笼不在束缚着我取而代之的是 古寺让我牵挂无奈我是一只多情的鹰纵然飞了起来也只是换了一个地方 晒晒太阳我最终选择了离去来到异地他乡这里的新奇模样让我忘却了忧伤可这并不长久我思念起了古寺想起故乡沉默我看着自己的翅膀怀念那时纵然不会飞时的 四处游荡我渴望回到过去即使不再可以飞翔 鹰的独白Ⅲ——终篇·轮回我回到了这里我朝思暮想的地方美人鱼失去声音换来幸福我失去了翅膀与记忆换来轮回无穷无尽我在这世间游荡古寺远方我都曾有印象我不敢继续回想只是害怕发现无法发承受的真相我是一只雄鹰我失去过翅膀我是一只雄鹰曾经也可以自由自在的翱翔因为轮回我忘却了一切脑海中唯一留下的是我是一只雄鹰古寺远方永远都是我的信仰2017 无题独自在街头散步昏黄的灯光照亮前方的路是否有人在梅花盛开之际陪我一起守候看灯火通明无奈无人伴我左右盛开的梅花凋零以久孤守黑暗的阁楼凄凉的月光照进我的心头彷徨在无人的山头观望梅花依旧起身醉吟梦回沙场战争彼此挥刀舞剑只为去留大雨留下漫天印记阴沉的乌云遮蔽万丈晴空自以为是斑出一副小丑阿谀奉承未讨倾心却痛了心头悲痛不知结局已定心中的纠结像尘埃一样充满在空中仿佛一切的源头都来自似血般浓稠的朋友却问如何继续伪装翅膀早已鲜血淋淋再无法飞上天际消解心中的痛俯身抚摸自己的影子到底该如何决定是去是留缠绵在悲伤的季节仰望天空浑然只剩悲愁牵手好像无法跨越的壕沟只有望洋兴叹看落英近在崖口枯树逢春便萌发生命强劲不知春早不如旧转身看人海茫茫寻一人天长地久再次贸然决定还是停留2015.1.29 好友投稿专区QQQiang.那些毫不留情告诉你不可能的女孩子，上辈子一定是天使，才会如此善良。虽然当时她像是用一颗铁钉将你穿破，其实后来想起，还有美好的回忆，还能记起曾喜欢过的感觉，甚至还要谢谢她，那么绝情，那么美。那些在你准备离去的时候假装热情的女孩子，用一种名为“希望”的泡沫，在你的心上划下了一刀又一刀，放空了你心里所有的温柔，落得满是伤痕，千疮百孔。回忆起来，竟然只剩下憎恨，憎恨她，憎恨喜欢她的自己。年少的时候，喜欢来了，你就欢喜，你就庆幸，然后你才苦恼，你才纠结。年长了以后，喜欢来了，你先否定，你先假设，然后你才承认，你才相信。这世界上不是每个人都值得我们温柔以待。这个世界上却还有一些人让我愿意满腔温柔。愿你遇见那个，会对你的温柔回报以歌的女孩。想必她在你眼里，耀眼得像颗恒星。编辑于 2018-06-22文章来源于知乎@柒岁安 程阳你不是赵雷的南方姑娘不是马頓的傲雪不是宋冬野的董小姐不是李志的港岛妹妹不是海龟的玛卡瑞纳不是二百的玫瑰不是尧十三的北方女王不是花粥的良人不是低苦艾的小花花不是陈粒的祝星你是青岛春天的海你是南京路边的梧桐你是苏州水摊上的姑娘你是武汉长江上的船你是郑州夜晚的孩子你是太原路上的琴声你是我失去的爱人摘自：酷狗音乐《北方女王》热评 四景浩荡录我题诗中乾坤 白日犹见月，闲游青川走马 使我不收砚三山五岳 纵巍峨绝险 不过在人间四景天河浩荡 尽在我画卷我行江湖沧浪 独揽寒山月兴来足点竹稍 我便似神仙鸟鸣花间 纵千里不绝 不过此山间天下清风雨露 皆为我拭剑以江作镜自照 拂拭天地变笑我收剑平事 出剑慨世间挥毫江山 落笔回春野 悬砚为风月四景天河浩荡 尽在我画卷同行江湖沧浪 诗酒书一篇逐松风且放歌 再吹绿山野以笔作剑 开星与点月 踏遍扬州雪四景天河浩荡 皆共我揽结题诗中乾坤 行江湖沧浪16岁的仙生日快乐！@流仙]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>Poetry</tag>
        <tag>Music</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A 3D-Album]]></title>
    <url>%2Fblog%2F2019%2F07%2F02%2Fthree%2F</url>
    <content type="text"><![CDATA[Html is amazing.Demo: 3D-AlbumReprinted on: https://blog.csdn.net/u014346301/article/details/53447712Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;3D相册&lt;/title&gt; &lt;style&gt; .container&#123; width:800px; height: 400px; margin:0 auto; perspective: 1000px; &#125; .box&#123; position: relative; width: 100%; height: 100%; -webkit-transform-style: preserve-3d; -moz-transform-style: preserve-3d; -ms-transform-style: preserve-3d; transform-style: preserve-3d; -webkit-animation:animate 12s linear infinite; -o-animation:animate 12s linear infinite; animation:animate 12s linear infinite; &#125; .img&#123; position: absolute; width:300px; height: 200px; background: #8959a8; top: 100px; left:250px; box-shadow: inset 0 0 5px #bbbbbb; &#125; .img1&#123; background: url(&quot;../img/1.jpg&quot;) no-repeat; -webkit-background-size:cover; background-size:cover; transform: rotateY(0deg) translateZ(300px); &#125; .img2&#123; background: url(&quot;../img/2.jpg&quot;) no-repeat; -webkit-background-size:cover; background-size:cover; transform: rotateY(60deg) translateZ(300px); &#125; .img3&#123; background: url(&quot;../img/3.jpg&quot;) no-repeat; -webkit-background-size:cover; background-size:cover; transform: rotateY(120deg) translateZ(300px); &#125; .img4&#123; background: url(&quot;../img/4.jpg&quot;) no-repeat; -webkit-background-size:cover; background-size:cover; transform: rotateY(180deg) translateZ(300px); &#125; .img5&#123; background: url(&quot;../img/5.jpg&quot;) no-repeat; -webkit-background-size:cover; background-size:cover; transform: rotateY(240deg) translateZ(300px); &#125; .img6&#123; background: url(&quot;../img/6.jpg&quot;) no-repeat; -webkit-background-size:cover; background-size:cover; transform: rotateY(300deg) translateZ(300px); &#125; @keyframes animate &#123; 0%&#123; transform: rotateY(0deg); &#125; 100%&#123; transform: rotateY(360deg); &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;box&quot; id=&quot;box&quot;&gt; &lt;div class=&quot;img img1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;img img2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;img img3&quot;&gt;&lt;/div&gt; &lt;div class=&quot;img img4&quot;&gt;&lt;/div&gt; &lt;div class=&quot;img img5&quot;&gt;&lt;/div&gt; &lt;div class=&quot;img img6&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>Tutorial</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>Tutorial</tag>
        <tag>Useful</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How to use rss.]]></title>
    <url>%2Fblog%2F2019%2F06%2F29%2Frss%2F</url>
    <content type="text"><![CDATA[The first time I knew that rss was building a blog in a fool-like way.I didn&#39;t know what rss was for at the time, but just generated it with the tutorial.I learned about these days, I also searched the Internet, found a very useful article about rss, and found a favorite rss reader for myself. 如何使用RSS作者： 阮一峰日期： 2006年1月 8日 一、 自从我发现很多人不知道什么是RSS以后，我就一直想向大家介绍它，因为它太有用了，将来会和电子邮件一样重要。不懂得RSS，上网的效率和乐趣都要大打折扣。我在网上找不到简明易懂的介绍文章，只好下决心自己来写。虽然我不是这方面的专业人士，但是我相信你只要耐心读完这篇文章，你就会基本搞懂RSS以及它的使用方法。 二、 在解释RSS是什么之前，让我先来打一个比方。 读大学的时候，我有个习惯，就是每天要去看食堂后面的海报栏。在那里，会贴出各种各样最新的消息，比如哪个系要开讲座了、星期二晚上的电影放什么、二手货转让等等。只要看一下海报栏，就会对学校的各种活动心中有数。 如果没有海报栏的话，要想知道这些消息就会很麻烦。讲座消息会贴在各个系自己的公告栏里，电影排片表是贴在电影院里的，二手货消息则会贴在各幢宿舍的楼道里。我所在的大学有20几个系，一万多人，要想知道所有这些消息的话，即使是可能的话，也会相当的麻烦。 从这个例子出发，让我们来考虑一下互联网。 互联网是什么？最直观的说，就是一个杂乱无章的巨大信息源，其丰富和杂乱的程度，不仅是巨大的，而且几乎是无限的。 一个使用者，要想及时掌握的互联网上出现的最新信息，有办法吗？ 答案是没有办法，他只有一个网站一个网站的打开，去看有什么最新内容，就好比每天都必须去每一个系里走一遍，看有什么最新讲座。如果是几个网站，哪倒也不难，都去看一遍也花不了多少时间。但是随着你关注的网站数量上升，这项工作会迅速的变为&quot;Mission Impossible&quot;。想象一下，如果你每天关注几十个、甚至几百个网站，会是怎样的情景。光是打开它们的首页，就要花费多少时间啊，更别说浏览花去的时间了。 也许有人会说，普通人的话，谁会关心那么多网站啊？ 我要说，哪怕你只是一个网络的初级或最单纯的使用者，与你发生关系的网站数量也在急剧增加，因为Blog出现了。越来越多的人开始写作网络日志（Blog），把自己的想法和生活在网上展示，其中也必然包括你的朋友，或者其他你感兴趣的人。你想知道他/她的最新动向，就势必要留心他/她的Blog。所以，你的网站浏览清单总有一天会和你的电话本、MSN Message好友列表一样多，甚至更多。 那时，你会发现浏览网站会变成一种困难和低效率的行为。 有没有办法找到互联网上的&quot;海报栏&quot;，只去一个地方就知道你所想知道的所有最新内容？ 有，那就是RSS。 三 准确的说，RSS就像一个网站的海报，里面包括这个网站的最新内容，会自动更新。所以，我们只要订阅了RSS，就不会错过自己喜欢的网站的更新了。 但是光有海报还不行，还必须有海报栏，也就是说必须有RSS阅读器才行。因为RSS只是数据源，它本身是写给程序看的，必须经过阅读器转换，才能成为可以浏览的格式。 RSS阅读器多种多样，大致分为两种，一种是桌面型的，需要安装；另一种是在线型，直接使用浏览器进行阅读。 四 在浏览器中订阅RSS，就必须先知道RSS的地址。一般来说，各个网站的首页都会用显著位置标明。名称可能会有些不同，比如RSS、XML、FEED，大家知道它们指的都是同样的东西就可以了。有时RSS后面还会带有版本号，比如2.0、1.0，甚至0.92，这个不必理会，它们只是内部格式不同，内容都是一样。 将RSS地址复制下来以后，你就可以在在线阅读器中添加。 以后，只用打开这一个网页，就可以看到所有你喜欢的网站的最新内容了。 （完） Reprinted on: 阮一峰的网络日志 A rss reader--Newsflow.You can download it and use it to achieve rss subscription locally.I will not make a specific introduction.If you are interested, you can explore it yourself.]]></content>
      <categories>
        <category>Tutorial</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>Tutorial</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How to download images on instagram]]></title>
    <url>%2Fblog%2F2019%2F06%2F29%2Finstagram%2F</url>
    <content type="text"><![CDATA[I have been on the ins for a long time these day.As we all know,there are many high quality images on the instagram.But saving the image directly is forbidden.As the saying goes,there must be a road before the car goes to the mountain.There have been many ways to download images on instagram.Such as a plugin or a WeChat public number.I tried all these methods, but the results did not satisfy me.And then I found a easy and useful way. Such as,we are willing to download this image.First,right click to find this option - view the page source code.After you click in,you may be scared by a lot of things you don&#39;t understand.Calm down,use the shortcut key Ctrl+u to bring up the search box.And then input jpg,the first result of the search results is the url of the image we are looking for(Look at where I draw).So now we know the url of this image is:1https://scontent-nrt1-1.cdninstagram.com/vp/ff449eed1ee7a9806334532d0e3dcbb9/5DA3D2C0/t51.2885-15/e35/58721835_156199248745005_4328502816718543045_n.jpg?_nc_ht=scontent-nrt1-1.cdninstagram.com Copy this url to the address box of the browser,then you can Right click -&gt; Save as image. Finally,I want to share a very interesting thing with you.When I was in high school, I learned a star online and found a beautiful photo of her, but when I wanted to see it again these two days, I found out that I couldn’t find it. I suddenly thought of ins and turned over about 500 photos,then I found this and I am very happy.Here is the photo]]></content>
      <categories>
        <category>Tutorial</category>
      </categories>
      <tags>
        <tag>Tutorial</tag>
        <tag>instagram</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Make your own template by mkdocs.]]></title>
    <url>%2Fblog%2F2019%2F06%2F29%2Ftemple-mkdocs%2F</url>
    <content type="text"><![CDATA[This tutorial I will use Chinese to finish,because there are so many English document of mkdocs and I can describe clearly enough through my mother tongue.一次偶然的机回，接触到了mkdocs，被它的分明的层次直接就震住了，又想起来本蒻蒻最好自己总结一个ACM的模板（毕竟自己的能更好的看懂。再加上很强的探(zhuang)索(b)精神，就去谷歌百度各种关于mkdocs的介绍及使用，也是成功的搭好了自己的模板（内容尚未完成。Demo: Uncle drew&#39;s template 安装mkdocs安装有很多方式。例如apt-get，dnf，homebrew， yum，chocolatey等。但是我一个都没见过，不过mkdocs也可以使用python（中的pip）安装。安装mkdocs的命令1pip install mkdocs 运行这一行命令之后等一会，会有安装成功的提示。这里因为我之前已经安装过了，所以安装成功的提示我也截不到图，相信你应该是可以看懂successful的。 建立一个基本的页面安装好mkdocs之后，我们首先要创立一个自己的项目1mkdocs new my-project(项目名可以自定义) 执行完之后，会显示123INFO - Creating project directory: my-projectINFO - Writing config file: my-project\mkdocs.ymlINFO - Writing initial docs: my-project\docs\index.md 然后我们再去你创建新项目的文件夹中就可以看到 这时候最基础的一个网页你就生成好了，你可以选择1mkdocs serve 这行命令实现本地预览（注意，要去到my-projrct的根目录，即有mkdocs.yml的地方运行这一行命令）。运行成功的话可以看到12345INFO - Building documentation...INFO - Cleaning site directory[I 190629 07:29:38 server:296] Serving on http://127.0.0.1:8000[I 190629 07:29:38 handlers:62] Start watching changes[I 190629 07:29:38 handlers:64] Start detecting changes 然后你就可以去浏览器输入http://127.0.0.1:8000进行本地预览。效果如下 添加新的页面这里以添加about页面为例。在docs里面新建一个文件&#39;about.md&#39;即可。以此为例，可以添加你想添加的页面，以markdown的格式编辑即可。 建立网站如果你想把你的mkdocs搭建的东西托管在github（诸如此类）的地方，接着看下去。执行这个命令1mkdocs build 成功的话会有提示信息12INFO - Cleaning site directoryINFO - Building documentation to directory: E:\mkdocs\my-project\site 然后在你的mkdocs根目录中会出现一个新的文件夹&#39;site&#39;,里面的文件大致上是这样的 上传到github这个跟hexo还不一样，但是你需要github上面存在一个仓库用于存放mkdocs的相关文件。只要把site文件夹里面的文件全部上传到github上的仓库里面，github pages就可以直接使用了。或者你可以直接使用命令1mkdocs gh-deploy 这个命令我现在还有点懵，推荐大家可以去看看这篇博客： https://blog.keybrl.com/professional/2018-05-19-mkdocs-blog.html不过我只是用mkdocs做出来一个模板，也不是写个人博客。上传频率不高，手动copy完全可以满足我的需要（要是能弄好自动部署，谁还愿意手动啊，卑微。 主题推荐第一次看到mkdocs的demo，十分中意它两边的目录，可是自己弄了之后发现不是这样的，后来搜索了一番才知道那是另一个主题——mkdocs-material。安装之后就可以出现很炫酷（个人认为 的双目录了。 我的mkdocs.yml文档关于一些mkdocs的配置，以及这个主题的配置，可以看看我的yml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104site_name: Templatesite_author: Uncle_drewrepo_url: https://github.com/Drew233site_url: https://github.com/Drew233site_description: My own template.theme: language: &apos;zh&apos; feature: tabs: true name: &apos;material&apos; palette: primary: &apos;indigo&apos; accent: &apos;indigo&apos; font: text: &apos;Ubuntu&apos; code: &apos;Ubuntu Mono&apos; include_search_page: false search_index_only: trueextra: search: language: &apos;zh&apos; social: - type: &apos;github&apos; link: &apos;https://github.com/Drew233&apos;markdown_extensions: - admonition - codehilite: guess_lang: false - toc: permalink: trueextra_css: - &apos;_static/extra.css&apos;nav: - 介绍: index.md - 关于: about.md - 数学: - 素数: math/prime.md - 快速幂: math/poww.md - 大数: math/bign.md - 斐波那契(大数): math/Fibo.md - 字符串: - 最长回文字串: string/Manacher.md - 图论: - 最小生成树: Graph/kruskal.md - 最短路: Graph/Dijkstra.md - 搜索: - BFS: search/bfs.md - DFS: search/dfs.md - 动态规划: - 编辑距离: dp/distance.md - 最长公共子序列: dp/LS.md - 最长递增子序列: dp/LIS.md - 最大子段和: dp/Maxsum.md - 换零钱(背包): dp/pack.md - 几何: - 求多边形面积: geometric/s.mdextra_javascript: - &apos;https://cdn.jsdelivr.net/gh/ethantw/Han@3.3.0/dist/han.min.js&apos; - &apos;_static/js/extra.js?v=10&apos; - &apos;https://cdnjs.loli.net/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML&apos;extra_css: - &apos;https://cdn.jsdelivr.net/npm/ah@1.5.0/han.min.css&apos; - &apos;_static/css/extra.css?v=11&apos;# Extensionsmarkdown_extensions: - admonition - codehilite: guess_lang: false linenums: true - def_list - footnotes - meta - toc: permalink: true - pymdownx.arithmatex - pymdownx.caret - pymdownx.critic - pymdownx.details - pymdownx.emoji: emoji_generator: !!python/name:pymdownx.emoji.to_svg - pymdownx.inlinehilite - pymdownx.keys - pymdownx.magiclink - pymdownx.mark - pymdownx.progressbar - pymdownx.smartsymbols - pymdownx.superfences: custom_fences: - name: math class: arithmatex format: !!python/name:pymdownx.arithmatex.fence_mathjax_format - pymdownx.tasklist: custom_checkbox: true - pymdownx.tilde 不支持中文搜索另外，mkdocs自带的搜索功能似乎只是支持英文搜索，网上有解决的办法，有兴趣的可以去看下。]]></content>
      <categories>
        <category>Tutorial</category>
      </categories>
      <tags>
        <tag>Tutorial</tag>
        <tag>MkDocs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Getting started-MkDocs]]></title>
    <url>%2Fblog%2F2019%2F06%2F28%2Fmkdocs%2F</url>
    <content type="text"><![CDATA[MkDocs&#39;s Introduction. Reprinted from: https://squidfunk.github.io/mkdocs-material/ Getting startedInstallationInstalling MkDocsBefore installing MkDocs, you need to make sure you have Python and pip– the Python package manager – up and running. You can verify if you&#39;re alreadygood to go with the following commands: 1234python --version# Python 2.7.13pip --version# pip 9.0.1 Installing and verifying MkDocs is as simple as: 12pip install mkdocs &amp;&amp; mkdocs --version# mkdocs, version 0.17.1 Material requires MkDocs &gt;= 0.17.1. Installing Materialusing pipMaterial can be installed with pip: 1pip install mkdocs-material using chocoIf you&#39;re on Windows you can use Chocolatey to install Material: 1choco install mkdocs-material This will install all required dependencies like Python and MkDocs. cloning from GitHubMaterial can also be used without a system-wide installation by cloning therepository into a subfolder of your project&#39;s root directory: 1git clone https://github.com/squidfunk/mkdocs-material.git This is especially useful if you want to extend the theme andoverride some parts of the theme. The theme will reside in the foldermkdocs-material/material. Troubleshooting!!! warning &quot;Installation on macOS&quot; When you&apos;re running the pre-installed version of Python on macOS, `pip` tries to install packages in a folder for which your user might not have the adequate permissions. There are two possible solutions for this: 1. **Installing in user space** (recommended): Provide the `--user` flag to the install command and `pip` will install the package in a user-site location. This is the recommended way. 2. **Switching to a homebrewed Python**: Upgrade your Python installation to a self-contained solution by installing Python with Homebrew. This should eliminate a lot of problems you may be having with `pip`. !!! failure &quot;Error: unrecognized theme &#39;material&#39;&quot; If you run into this error, the most common reason is that you installed MkDocs through some package manager (e.g. Homebrew or `apt-get`) and the Material theme through `pip`, so both packages end up in different locations. MkDocs only checks its install location for themes. Alternative: Using DockerIf you&#39;re familiar with Docker, the official Docker image for Materialcomes with all dependencies pre-installed and ready-to-use with the latestversion published on PyPI, packaged in a very small image. Pull it with: 1docker pull squidfunk/mkdocs-material The mkdocs executable is provided as an entrypoint, serve is the defaultcommand. Start the development server in your project root with: 1docker run --rm -it -p 8000:8000 -v $&#123;PWD&#125;:/docs squidfunk/mkdocs-material If you&#39;re using Windows command prompt (cmd.exe), substitute ${PWD} with&quot;%cd%&quot;. UsageIn order to enable the theme just add one of the following lines to yourproject&#39;s mkdocs.yml. If you installed Material using a package manager: 12theme: name: 'material' If you cloned Material from GitHub: 123theme: name: null custom_dir: 'mkdocs-material/material' MkDocs includes a development server, so you can review your changes as you go.The development server can be started with the following command: 1mkdocs serve Now you can point your browser to http://localhost:8000 and the Materialtheme should be visible. From here on, you can start writing your documentation,or read on and customize the theme. ConfigurationColor paletteA default hue is defined for every primary and accent color on Google&#39;sMaterial Design color palette, which makes it very easy to change theoverall look of the theme. Just set the primary and accent colors using thefollowing variables: 1234theme: palette: primary: 'indigo' accent: 'indigo' Color names are case-insensitive, but must match the names of the MaterialDesign color palette. Valid values are: red, pink, purple, deep purple,indigo, blue, light blue, cyan, teal, green, light green, lime,yellow, amber, orange, deep orange, brown, grey, blue grey andwhite. The last four colors can only be used as a primary color. If the color is set via this configuration, an additional CSS file thatdefines the color palette is automatically included. If you want to keep thingslean, clone the repository and recompile the theme with your custom colors set.See the guide on customization for more information. Primary colors Default: indigo Click on a tile to change the primary color of the theme: RedPinkPurpleDeep PurpleIndigoBlueLight BlueCyanTealGreenLight GreenLimeYellowAmberOrangeDeep OrangeBrownGreyBlue GreyWhite var buttons = document.querySelectorAll("button[data-md-color-primary]"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener("click", function() { document.body.dataset.mdColorPrimary = this.dataset.mdColorPrimary; }) }) Accent colors Default: indigo Click on a tile to change the accent color of the theme: RedPinkPurpleDeep PurpleIndigoBlueLight BlueCyanTealGreenLight GreenLimeYellowAmberOrangeDeep Orange var buttons = document.querySelectorAll("button[data-md-color-accent]"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener("click", function() { document.body.dataset.mdColorAccent = this.dataset.mdColorAccent; }) }) Font family Default: Roboto and Roboto Mono By default the Roboto font family is included with the theme, specificallythe regular sans-serif type for text and the monospaced type for code. Bothfonts are loaded from Google Fonts and can be changed to other fonts,like for example the Ubuntu font family: 1234theme: font: text: 'Ubuntu' code: 'Ubuntu Mono' The text font will be loaded in weights 400 and 700, the monospaced fontin regular weight. If you want to load fonts from other destinations or don&#39;twant to use the Google Fonts loading magic, just set font to false: 12theme: font: false Logo Default icon: school Your logo should have rectangular shape with a minimum resolution of 128x128,leave some room towards the edges and be composed of high contrast areas on atransparent ground, as it will be placed on the colored header bar and drawer.Simply create the folder docs/images, add your logo and embed it with: 12theme: logo: 'images/logo.svg' Additionally, the default icon can be changed by setting an arbitrary ligature(or Unicode code point) from the Material Design icon font, e.g. 123theme: logo: icon: 'cloud' Language!!! info &quot;Call for Contributions: Add languages/translations to Material&quot; Help translate Material into more languages - it&apos;s just **one click** and takes approximately **2 minutes**: [click here](http://bit.ly/2EbzFc8) Localization Default: en Material for MkDocs supports internationalization (i18n) and providestranslations for all template variables and labels in the following languages: Available languages ar / Arabic ca / Catalan cs / Czech da / Danish nl / Dutch en / English fi / Finnish fr / French gl / Galician de / German gr / Greek he / Hebrew hi / Hindi hr / Croatian hu / Hungarian id / Indonesian it / Italian ja / Japanese kr / Korean no / Norwegian nn / Norwegian (Nynorsk) fa / Persian pl / Polish pt / Portugese ru / Russian sr / Serbian sh / Serbo-Croatian sk / Slovak si / Slovenian es / Spanish sv / Swedish tr / Turkish uk / Ukrainian vi / Vietnamese zh / Chinese (Simplified) zh-Hant / Chinese (Traditional) zh-TW / Chinese (Taiwanese) Submit a new language Specify the language with: 12theme: language: 'en' If the language is not specified, Material falls back to English. To create atranslation for another language, copy the localization file of an existinglanguage, name the new file using the 2-letter language code and adjustall translations: 1cp partials/language/en.html partials/language/jp.html Text direction Default: best match for given theme language, automatically set Material supports both, left-to-right (ltr) and right-to-left (rtl) textdirection. This enables more languages like Arabic, Hebrew, Syriac and othersto be used with the theme: 12theme: direction: 'rtl' Site search Default: best match for given theme language, automatically set Site search is implemented using lunr.js, which includes stemmers for theEnglish language by default, while stemmers for other languages are includedwith lunr-languages, both of which are integrated with this theme.Material selects the matching (or best-matching) stemmer for the given themelanguage. Multilingual search can be activated in your project&#39;s mkdocs.ymlby explicitly defining the search language(s): 123extra: search: language: 'en, de, ru' At the time of writing, the following languages are supported: Available language stemmers da / Danish du / Dutch en / English fi / Finnish fr / French de / German hu / Hungarian it / Italian ja / Japanese no / Norwegian pt / Portugese ro / Romanian ru / Russian es / Spanish sv / Swedish tr / Turkish !!! warning &quot;MkDocs 1.0 compatibility&quot; While MkDocs 1.0 supports prebuilding the search index, Material currently doesn&apos;t support this setting as the default search behavior of the original theme was heavily modified for the sake of a better UX. Integration is possible, but a small subset of the features Material provides will not be portable to the prebuilt index mainly due to missing localization. !!! warning &quot;Only specify the languages you really need&quot; Be aware that including support for other languages increases the general JavaScript payload by around 20kb (without gzip) and by another 15-30kb per language. The separator for tokenization can be customized which makes it possibleto index parts of words that are separated by - or .: 123extra: search: tokenizer: '[\s\-\.]+' Favicon Default: assets/images/favicon.png The default favicon can be changed by setting the favicon variable to an.ico or image file: 12theme: favicon: 'assets/images/favicon.ico' FeaturesTabs Default: false By default, the entire navigation is rendered on the left side using collapsiblesections (different from the default MkDocs theme which renders the top-levelsections in the header), because horizontal navigation is often problematic onsmaller screens. However, for large documentation projects it&#39;s sometimesdesirable to add another navigation layer to separate top-level sections.Material achieves this with the tabs feature, which can be enabled by settingthe respective feature flag to true: 123theme: feature: tabs: true When tabs are enabled, top-level sections will be rendered in an additionallayer directly below the header. The navigation on the left side will onlyinclude the pages contained within the selected section. Furthermore, top-levelpages defined inside your project&#39;s mkdocs.yml will be grouped under thefirst tab which will receive the title of the first page. CustomizationAdding a source repositoryTo include a link to the repository of your project within your documentation,set the following variables via your project&#39;s mkdocs.yml: 12repo_name: 'squidfunk/mkdocs-material'repo_url: 'https://github.com/squidfunk/mkdocs-material' The name of the repository will be rendered next to the search bar on bigscreens and as part of the main navigation drawer on smaller screen sizes.Furthermore, if repo_url points to a GitHub, BitBucket or GitLab repository,the respective service logo will be shown next to the name of the repository.Additionally, for GitHub, the number of stars and forks is shown. If the repository is hosted in a private environment, the service logo can beset explicitly by setting extra.repo_icon to github, gitlab orbitbucket. !!! question &quot;Why is there an edit button at the top of every article?&quot; If the `repo_url` is set to a GitHub or BitBucket repository, and the `repo_name` is set to *GitHub* or *BitBucket* (implied by default), an edit button will appear at the top of every article. This is the automatic behavior that MkDocs implements. See the [MkDocs documentation][19] on more guidance regarding the `edit_uri` attribute, which defines whether the edit button is shown or not. Adding social linksSocial accounts can be linked in the footer of the documentation using theautomatically included FontAwesome webfont. The type must denote thename of the social service, e.g. github, twitter or linkedin and thelink must contain the URL you want to link to: 12345678extra: social: - type: 'github' link: 'https://github.com/squidfunk' - type: 'twitter' link: 'https://twitter.com/squidfunk' - type: 'linkedin' link: 'https://linkedin.com/in/squidfunk' The links are generated in order and the type of the links must match thename of the FontAwesome glyph. The fa is automatically added, so githubwill result in fa fa-github. Adding a Web App ManifestA Web App Manifest is a simple JSON file that tells the browser about yourweb application and how it should behave when installed on the user&#39;s mobiledevice or desktop. You can specify a manifest in your mkdocs.yml: 12extra: manifest: 'manifest.webmanifest' More advanced customization If you want to change the general appearance of the Material theme, see this article for more information on advanced customization. IntegrationsGoogle AnalyticsMkDocs makes it easy to integrate site tracking with Google Analytics.Besides basic tracking, clicks on all outgoing links can be tracked as well ashow site search is used. Tracking can be activated in your project&#39;smkdocs.yml: 123google_analytics: - 'UA-XXXXXXXX-X' - 'auto' DisqusMaterial for MkDocs is integrated with Disqus, so if you want to add acomments section to your documentation set the shortname of your Disqus projectin your mkdocs.yml: 12extra: disqus: 'your-shortname' The comments section is inserted on every page, except the index page.Additionally, a new entry at the bottom of the table of contents is generatedthat is linking to the comments section. The necessary JavaScript isautomatically included. !!! warning &quot;Requirements&quot; `site_url` value must be set in `mkdocs.yml` for the Disqus integration to load properly. Disqus can also be enabled or disabled for specific pages using Metadata. ExtensionsMkDocs supports several Markdown extensions. The following extensionsare not enabled by default (see the link for which are enabled by default)but highly recommended, so they should be switched on at all times: 123456markdown_extensions: - admonition - codehilite: guess_lang: false - toc: permalink: true For more information, see the following list of extensions supported by theMaterial theme including more information regarding installation and usage: Admonition Codehilite Footnotes Metadata Permalinks PyMdown Extensions PluginsMkDocs&#39;s plugin architecture makes it possible to add pre- or post-processingsteps that sit between the theme and your documentation. A great example of athird-party plugin is the mkdocs-minify-plugin which strips all whitespacefrom the generated documentation. Install it with pip: 1pip install mkdocs-minify-plugin Enable it with the following lines in your mkdocs.yml: 1234plugins: - search - minify: minify_html: true The MkDocs wiki contains a list of all available plugins. !!! warning &quot;Remember to re-add the search plugin&quot; If you have no `plugins` entry in your config file yet, you&apos;ll likely also want to add the `search` plugin. MkDocs enables it by default if there is no `plugins` entry set. Full exampleBelow is a full example configuration for a mkdocs.yml: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# Project informationsite_name: 'Material for MkDocs'site_description: 'A Material Design theme for MkDocs'site_author: 'Martin Donath'site_url: 'https://squidfunk.github.io/mkdocs-material/'# Repositoryrepo_name: 'squidfunk/mkdocs-material'repo_url: 'https://github.com/squidfunk/mkdocs-material'# Copyrightcopyright: 'Copyright &amp;copy; 2016 - 2017 Martin Donath'# Configurationtheme: name: 'material' language: 'en' palette: primary: 'indigo' accent: 'indigo' font: text: 'Roboto' code: 'Roboto Mono'# Customizationextra: manifest: 'manifest.webmanifest' social: - type: 'github' link: 'https://github.com/squidfunk' - type: 'twitter' link: 'https://twitter.com/squidfunk' - type: 'linkedin' link: 'https://linkedin.com/in/squidfunk'# Google Analyticsgoogle_analytics: - 'UA-XXXXXXXX-X' - 'auto'# Extensionsmarkdown_extensions: - admonition - codehilite: guess_lang: false - toc: permalink: true]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Tutorial</tag>
        <tag>MkDocs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1874：写给未来恋人的情书]]></title>
    <url>%2Fblog%2F2019%2F06%2F27%2Fpast%2F</url>
    <content type="text"><![CDATA[很早就看过的一本杂志《流年》上的一篇很喜欢的文章，特殊原因丢了这本杂志，在网上磕磕绊绊的找到了这篇文章。很开心的 1874：写给未来恋人的情书 郭敖写一封寄往1874的情书，我把它放在七月雨季里的大海之中。一封封情书穿越漫长的梦境，只为了百年前约定的相逢。 CHAFTER: INCEPTION 泥泞的小巷杂草丛生，又窄又深，不规则的青石板上生出青苔，倾斜的雨线勾勒出来的空巷里跑过一条瘸狗。后腿上的血块已经凝结成一块硬朗的疤痕，伤口周围沾满了泥痕，每走一步都会隐约地渗透出来血迹。 它在一棵繁茂的榆树下停留下来，沉郁而倔强的炮声像闷雷一样划过天空，在雨水中纷飞，四溢的弹片镶嵌入青石板上，留下一道一道短小的划痕。她叫娜兰，穿一身白色的粗布轻纱，头上戴着一株粉红色的花环，雨水浇熄了她最后一丝希望，她在婚礼上落跑的第二天，战火焚烧尽了原有的一切，血染红了雨中泥泞的土地，她的母亲倒在血泊之中，死死地攥住妹妹的手指，妹妹的手被粗织的麻绳捆绑在竖立的竹竿上，和姐姐同样的白色，白色的棉布衣裙包裹了一层泥浆，士兵拿着刺刀挑起她的脸，在她白皙的下颚划了一道细小的伤口。鲜血顺着嫩白的皮肤从伤口里沁出来，滑落成一粒黄豆般大小的血滴，从锋利的刀剑上流淌下来，在冷峻的刀刃上画了一个红色的线段，刀锋上显现出来她那张无助而绝美的脸。 拿着刺刀的士兵脱下手上的白色手套，把枪放在木屋靠近窗子的竹排旁边，三个士兵从军官的背后抢上去，撕破了妹妹的衣服，她躲在树丛中。参天繁茂的树枝把灰暗的天空掩盖地看不到一缕光线。 她看到了妹妹破碎的衣衫在雨幕中四溢横飞，很快被埋没在雨水之中，她不禁喊出了妹妹的名字，诺兰。妹妹今年十七岁，比她小两岁，她看着妹妹哭喊着在人群中挣扎，在她白皙的皮肤上，显赫地多出一道又一道的伤痕，几个日本士兵赤裸子身子。在她身体上尖叫着，狰狞的欢呼淹没了远方的雷声，她虽未成年，乳房却生得好看，白皙，在泥泞中沾满了污渍。 士兵们抓着她扭曲的酮体和四肢，按倒在泥水中，任凭她挣扎。 雨水从她的脸上滑落，她知道她在哭。她眼睛里布满了血丝。不是仇恨，是对于这个世界的无助，和这个世界一切人性的质疑。 她瞳孔里的血丝织成一张球状的网格，就像我天花板上的吊顶。 有一个人素未谋面，你却会常常想起她，她在过去，未来，或者现在正在发生的时间里等待着，我一直都以为每～次转角。每一次相遇，都是在为了和某个人靠近，只是为了和她相遇。 故事开始的时候。我在梦中，在梦中我第一次遇见那个叫诺兰的女子，很长一段时间里我都在重复着某一个梦境，每天都有着全新的故事，它们发展着，我渐渐地无法辨别出来哪里是梦境，哪里是现实。 我叫郭敖，专栏作家，多数时间里都宅在电脑前，亦没有朋友，也许这一切都归寂于我的生活太乏味。梦境反而来得更真实。 最近我总是梦到枪林弹雨，战火纷飞，看着千疮百孔的梦境在湿润的枕头中醒来，习惯地把枕头拿到阳光下晒干，用架子夹着一只角，放在靠近阳台外边的位置。我的枕头是粉红色，Mini款式小女生才用，在中间有一个凹槽，可以把脑袋放进去，睡上去特别的舒服。每次我把枕头拿到阳台上的时候，都会觉得不好意思，邻居用窃窃私语的眼神打量着我，因为那个枕头很像一只比基尼。 一个礼拜前WOLI把这支枕头拿给我，她并不是我的女友，每个礼拜都会来看望我，买来大包小包的干粮，足够我吃一个礼拜的分量。 她一直在劝我戒烟，每个礼拜都会带几包烟来，她知道我喜欢抽什么牌子的烟。我知道她最讨厌烟的味道，每当我抽烟的时候她都会选择一个最靠近我的位置坐下来，静静地看着我，因为只有我抽烟的时候才会闲下来跟她聊天，谈一些天气，世事。我们无所不谈，比如说今天她穿什么内裤，什么颜色。我又多久没有理发等等。 我多数在白天睡觉，她就坐在我的身边，帮我整理房间。以及换洗的衣物等等，很长一段时间她让我误认为自己还是孩子，那时候生活在老家里，母亲忙碌地打理着一切。 其实我很忌讳有个女人在我睡觉的时候走来走去，而且你不知道她什么时候来，也不知道她什么时候去的，我改了几回电子门的密码，她总是能很快地破解出来，并且毫无忌惮地走进来，和我说话，聊天，仿佛一切都没有发生过。 有一天我终于忍不住问她：你怎么知道的密码，我已经换过很多次了。 她无奈地说：那你能告诉我有什么方法可以让我不知道呢? 我说：我从来都没有告诉过你。 她说：以你的智商，除了设置110、112、911、123456、654321……你能不能想点有创意的密码? 第二天早上我换了一个她绝对想不到的密码，是一组怪异的数字，绝对想不到的是我换了太多次。我换过密码一刻钟以后，我再也记不起了那组怪异的数字。那天早上我在门口守候了四个小时五十二分，她准时地出现在门口，然后用不足四秒钟的时间打开了电子锁。那组密码是：1874。 一个让我都感觉到困惑的数字，闪现在脑海之中，稍瞬即逝。 我开始怀疑她是一个贼，一个职业而没有道德的贼。唯一的判断标准是：一个有道德的贼不会趁着别人睡着的时候穿着粉红色的三角裤满屋子跑着给人打扫卫生。并且房间里还多了一只很像比基尼的枕头，到现在为止我不知道她怎么在我不知不觉的情况下把那玩意儿放进我脑袋下的。以至于我睡醒以后，差点被自己给吓死。 我用崇敬而质疑的眼光看着她，我说这密码是我设置的，我自己都忘记了，你怎么会知道? 她说：秘密。 我一直怀疑她是中情局的红色特务。或者是FBI，而她仅仅只是一个设计师，绘图，阅读，看杜拉斯会哭，爱好穿着三角裤跑到我家里帮我洗衣服。 她说：我最近看一个叫郭敖的书，书名叫《北纬已北》，他说秘密是用来交换的，你告诉我一个你的秘密，我就告诉你怎么打开的那把锁。 我想了一会说：我今天是刻意去修改密码，就是不想你进来。 她说：这个不算，你每次都是刻意去修改的，你从来都没想过让我进来，再换一个。 我说：有，没干净衣服穿的时候。 她一脚把我从沙发上踹了出去，说：你从来都不肯说出来自己的想法， 我说即使你打开了天下所有的锁，能破解任何一组密码，有一种密码你一定打不开，就是每个人锁在内心深处的那个秘密。 她说别玩了，出过几本书，你还真当自己是作家。这样吧，讲个公平点的秘密，你告诉我你几天没换内裤了? 我说：咱们还是来谈谈我内心深处的那个秘密吧。我都不记得那个密码了，你先告诉我你怎么破解的密码? 她想了一会说：你设定密码的时候总是喜欢降序，或者升序来排列，还有你每次都吃着鸡腿去设置密码，恶心死了，猪都知道你那只油腻的手指摁过哪个按键。现在轮到你的秘密了。 她挑了一个最舒坦的姿态坐在沙发上，准备聆听我的秘密。 我说：我做了一个很奇怪的梦，每次都梦到大雨，梦到了战争，一队日本士兵攻占了一个港湾，还有一对漂亮的姐妹，被屠城以后的村子里，她亲眼看见了妹妹被一队日本士兵轮奸，我知道他们在求助。我不知道她们是什么人，但是我清 晰地看着他们每一张脸，每一个表情。都刻骨铭心，如果我生活在那个年代，一定陪着她慢慢地老去…… 她打断我说：那个漂亮女孩是不是和我很像? 我说：很像，不过不是像那两个女孩，而是那队日本士兵。 说完以后我想改口，因为我不知道WOLI她们家里是做什么的，这已经是第六次我的脑袋被她随身携带的IPHONE砸中。我一直怀疑她是一个狂热电子产品的女飞贼。 每个礼拜六她都会拉我出去新街口逛街，晒太阳，她的理由是担心我一个人躲在屋子里发霉，或者某一天死在了屋子里，从来都没有人知晓，那就成为了悲剧。 她每天都一副很开心的样子，为了一只手套，一件T恤，甚至听到一首老歌。都会让她很快乐，看着她幸福的样子，我觉得自己恍若隔世的老人，抑或一个襁褓中的孩子，对这一切开心的，不开心的事情，懵懂地围观着。 逛街的时候，我在人群中永远是她的跟屁虫，当她转身的时候在人群中，却一眼就能把我找到，而我从来都找不到她跑到了哪里。 我说：这里有这么多人，为什么你一眼就能找到我在哪里? 她说：就你这样子，眼睛只是关注着自己的脚尖，垂头丧气。一眼看上去就像瘪三，这里人虽然多，却没有比你更挫的。 她终于还是勾引起了我比较感兴趣的话题，我说：我真的很挫哦? 她没有说话，却很坚决地点了点头，眼睛里还透露着一丝歉意。看着我质疑的眼睛，她终于拿起手里的IPHONE拍了一张照片，然后拿给我看。说：你看，是不是很挫? 照片里的我一脸唏嘘的胡渣子，眼睛里充满了血丝，黑眼圈好像画上去的烟熏妆，我点了点头只好承认，为了挽回最后一丝希望，我说：其实艺术家也就是这范儿。 她转身收起来手机，质疑地问：你是艺术家吗? 我说：不是。 CHAPTER：兰屿 2010年9月16号无梦 我醒着的时间越来越长，我不敢去面对那个梦境，闭上眼睛就是泥泞的水波、挣扎、鲜血、呼喊和战争。 睡去的时候趴在书房里，一个月我都没有再梦到那对姐妹，睡梦中唯一的印象就是MSN不停上下线的提示声。和窗口的抖动。窗外下着雨，噼里啪啦地拍打在我的玻璃上，也许是天气太潮湿的缘故，窗子上的玻璃太薄，无梦的日子仿佛倾斜的水闸，淹没了我的梦境。 倾斜的雨线从空中迅速地拍打下来，飒飒地折断了几根桔死的竹子，绿色的竹林以一个倾斜的角度耸立在山腰上，山脚下的村庄里几处烧毁的房屋依然氤氲着一层白烟。她从树丛中走来，妹妹躺在泥泞之中，几处落红染色了她白色的衣衫，她的整个身体都在冰冷的泥水中抖动，痉挛的双手抓着几根枯死的稻草。 她走过去抱着妹妹，她为自己的懦弱和胆怯感到内疚，她感觉到妹妹在自己的怀里发抖，挣脱。看着灰飞烟灭的家园，她没有哭，拉着妹妹消失在竹林深处。 国境之南，兰屿。 这里荒草丛生，人烟稀少，集市亦很简朴，梯田的弧线规则的摆放在丘陵上，朝九晚五，暮鼓晨钟。她们在这里停留下来的时候，海平面上日军的战舰已经攻入他们的家园。 妹妹的身体一天一天的消瘦下去，她经常一个人坐在港湾的海边仰望着远方，威成的海风从海角以南的方向出来，面对着大海，呆滞的眼神，喃喃自语。 姐姐白天耕织，在傍晚的时候在港湾浅水里捕鱼，姐姐执着木浆在冲着岸边大喊着妹妹的名字：诺兰。 碧蓝色的大海像一块弧形的水晶球，粼粼的波光中映射出她那张忧郁的脸，海鸟在她的头顶盘旋飞过，消失在天际交接之处。 每天集市上的阿晨都会送一些新鲜的素菜来，他是本地的菜农，很小的时候便跟着父亲在兰屿种菜，诺兰在一个礼拜后病倒在竹塌上。每次在梦中惊醒，她的手指已经撕破被单，接下来的日子里，在她的下体总是流出血来，体温高烧不断。 她在挣扎中醒来，扑进姐姐的怀里，她说：娜，我忘不了，忘不了。 姐姐轻抚着她的头发说：又做恶梦? 诺兰：我梦到了一双眼睛在注视着我，我赤裸裸地躺在雨中，在雨线中我似乎看到了他那张脸。我看到他寂寞的一生。没有亲人，朋友，生活在一个浮夸的世界里，虽然没有战争，人与人之间早已经没有了信任，没有了爰，他仿供不属于我们这个世界，他说他会陪我老去，老到都不能动了，还要相互依偎着，拥抱着。 阿晨在门外叩响竹门，在门外大喊着娜兰的名字。娜兰抚摸着妹妹的身体，依然很烫，她让阿晨煮了药水，诺兰始终都不肯再睡去。 娜兰没有说话，诺兰转身看着她说：你不信? 娜兰说：你该休息了。 诺兰说：你有没有梦到过陌生人?他就站在那里，我能感觉到他的呼吸，他的身体，他的眼睛。他的……这么近，却又那么远。 阿晨端着药水从门口进来，他说：你该吃药了。 诺兰打翻了药水，摇着头说：你们都不信?我没病。 她起身踉跄地冲出竹屋，海面的冷风迎面袭来，湿润而成威的风卷动着她的身体，脚下踏着的青石板似乎在晃动。轻浮如棉。 她被海风舞动的身躯，突然失去重心，她感觉到天旋地转，在她重重摔倒在青石板上的一刹那，她看到了海边隐现地浮动着一条彩虹，然后归寂于一片黑暗之中，雨滴倾斜地从她的脸上扫过，她感觉不到疼痛。 我感觉到水滴慢慢地浸透我的衣衫，棉质的衣角从内至外黏贴在我身上，似乎我在从高空坠落。雨越下越大，仿佛用木盆倾流而下。 我睁开眼睛看见WOLI提着一只巨大的木盆。浇在我头上，我倒在书房里，正在重重地从椅子上摔下来。WOLI眨着眼睛看着我，我苏醒了意识，她手里另一桶冰水已经灌在我的头上。我说：我已经苏醒了。 她说：你已经睡了三天。 我说：你有没有梦到过一个很具体的陌生人?名字、身份、环境都是完全的独立的，并且那里我从来都没有去过。我甚至能感觉到她的痛苦，无助和孤寂。 她说有啊，每个人都会有这样的经历，有些人，有些地方，你总是觉得很熟悉，或者在哪里见过，在大脑会重组一些前生今世的信息，其实是你念念不忘的地方和故事，只是你在岁月中忘记了，所以那些你曾经去过的地方，就会出现在你的脑海之中。 我点了点头说：是啊，我也这么觉得。 她操起手里的水桶砸在我脑袋上，气愤地说神经病啊你。这你也信?我建议你去看心理医生，立即，马上，至少在精神病院来抓你以前。 我被她抓去看心理医生，心理医生是一个有着暴力倾向的老男人，他抬头看着我说：梦是一个很奇怪的东西，你可以在阡陌沟壑的城市里穿行，钢铁铸造的屋子和丛林里打猎，甚至梦到你殴打自己的小学老师，和你的高中的女老师做爱，他和我们现实的世界并无两样，只是在梦中你才感觉到前所未有的自由。 我说：从技术成面来讲，有没有可能长时间的梦见某一个陌生人呢? 他说：绝对可以，梦的潜能量是无穷无尽的。你先告诉我你高中的女老师长得漂亮吗?胸大不大?是不是前凸后翘?最主要的你要学会控制你的梦境，记住千万别让人给控制了，最近上映一部电影叫《盗梦空间》，我告诉你，那部电影完全在胡扯，真正的梦境你知道是什么吗?是超越时空 的梦境，用意识去控制另外一个人的梦境，通常这种人被称为特异功能人士，现在这种人大部分被关在监狱里，或者精神病院。 我说：这不是我想要的答案，我在问有没有可能长时间的梦到某一个陌生人。 我们跑题了?他质疑地看了我一眼说：好，现在开始说正题，你知道为什么他们会被关进精神病院吗?因为他们太伟大了，可以颠覆一个政府，甚至一个国家，比如说我就是这种人，自从拥有特异功能这种人被关进精神病院以后，你看这个世界乱成了什么样子?其实不把他们关进去，这个世界更乱，你不要小看我，我只要随手操起一个家伙…… 我实在听不下去了，也不想再浪费时间，随手操起一盏台灯向他脑袋上砸去，大骂道：操，操，操，操你妹啊。 WOLI抱歉地看着我说：我真不知道他是神经病。 我说：我也真不知道你是神经病。 她拉着我说：我让你知道一下什么是真实。 CHAPTER：给未来恋人的情书 南京。1912酒吧街。 霓虹灯下的一张张面孔就像一张揉皱的纸张，沉醉在嘈杂的音乐和干城一面的旋律之中，我们喝了几只WHISKY，一个玩朋克的女子，葡萄红的爆炸发型，在右边唇上打了一个环钉，举起我手里的杯子说：请我喝一杯? WOLI从旁边站起来，拿杯子泼了她一脸，说：Getaway，son of bitch! 我笑了笑说：这个世界就是这样，总有一个角度是喜剧。 她拿起另外一个杯子也泼了我一脸说：现在你感觉到真实了吗?那你知不知道人都有一个国度叫幸福? 我摇头，表示不懂。我说：有你在我身边，到哪我都觉得不真实。 她抬手在我脸上扇过，我有半边脸马上麻痹，她问我：疼吗? 我说：我知道了，现在很真实。 她拖着脸说：我就这样一天一天地陪着你，等你老了，会不会就是你的永远呢? 她说这句话的时候，我一直都假装没有听见，我从来都不会给任何人诺言，甚至每天我都在假装从来都没有遇见过她，或者她根本在我的生命之中没有出现过。但是她却活生生地每天在我身边活蹦乱跳。并且随时可能做出危险的事情来。 她看着我良久，表情严肃地问：诺兰是谁? 我不相信自己的耳朵。我相信没有人知道诺兰，我问：你说什么? 她说：你每天晚上在梦中都喊着她的名字。 我说这里太吵，我听不见。她尴尬地背过脸，整个晚上都没有再说话，在回去的路上。她一直都乖乖地跟在我的身后，她知道，有些话，有些事情，她永远都不会知晓，我们之间仿佛突然隔了一层薄薄的轻纱，却无法看清对方的样子。那天晚上她回去开着新买的Land rover揽胜5.0 V8 SC，只因为我说最喜欢的车是路虎。 开出长江大桥以后，她握着方向盘，踩尽了脚下的油门，然后闭上眼睛说：我和你在一起了六年，如果六十秒后我们都还活着，这辈子我都不会再来骚扰你。 五十九分四十八秒的时候，我们冲出了高速公路的栏杆，整个车子和我们飞跃在空中，我感觉到了身体失去了重力。唯一系靠在安全带上，她的脸没有表情，在黑暗中惨白得没有血色，我看到了她眼角里含着的泪水，在这一瞬间肆无忌惮地流下来。 我们没有死，整辆车钻进了高速路旁一家农房里，在床上睡熟的一对夫妻用不解而尴尬的眼神看着这辆路虎和车里正在喘气的两个人。 WOLI没有说话，推开车门径直地走出去，床上的夫妻刚要开始争论，她指着那辆路虎说：这辆车归你们了，明天可以去办过户。 我跟着她走了出去，她加快了步伐，我走过去抱住她，她说：你知道吗?你从来都不肯给任何人承诺，只是为了那个该死的梦?我一直都梦想着我们之间能有一个结局，这个世界上只有死亡是唯一不会落空的结局。你自由了。我们都已经死过了。 我不知道该怎么去面对她。我说：你有没有听说过一个叫兰屿的地方? 她停留了一下，转身破涕而笑，说：台湾兰屿? 我惊愕地问：台湾?那里有过和日本之间的战争? 她说：1874年台湾曾经被日本攻陷，占领。 七月，雨季。 我一个人去了台湾兰屿，在一个叫红头村的地方住下。这里的一切我都感觉到似曾相识，我记不清了这里的样子，以前的村子，现在已经变成了度假村。每天都会有很多人在海边划船。最近我频繁地梦到诺兰，我梦到她怀了日本士兵的孩子，却依然坚持把孩子生了下来，我能嗅到她的气味，这个她曾经生活过的地方。 我每天都会写一封信，一封寄往1874年的情书，我把它装在玻璃瓶内。放在七月潮湿的雨季里，看着它消失在天际的尽头。 我不知道诺兰有没有收到这些信，关于我和诺兰的最后一个梦境，我梦到了诺兰在一年后生下来一个女孩，看着那个女孩一天一天地长大，她知道是那些某个日本士兵的孩子，她爱着她，却把所有的仇恨都加载在她的身上。看着孩子一天一天地长大，我梦到诺兰在一天一天仓促地老去。村子里的人都认为她有精神病，姐姐娜兰和阿晨完婚的第二年，诺兰带着女儿搬到了山上住，她的女儿叫JASMINE，她看着镜子里自己苍老的容颜，而我醒着的时间也越来越长，只要不睡去，是不是就不会老去?在睡梦中我听到她说：我在你的梦中老去，你又在谁的梦中醒来? 之后我在兰屿的一年里，都没有再梦到过诺兰，我想这场梦也许真的到了该醒的时候，不会再梦到她了。 我离开兰屿的前一天晚上，在海边遇到了WOLI，她带了七封信给我，那些信纸上的字迹已经泛黄，这一封封情书穿越了漫长的时空和梦境。我抚摸着这一份迟到了百年的温柔。看着纸张上熟悉的文字，已经跨越了一个世纪回到我的手中，在信纸上却留着诺兰的泪痕。WOLI的母亲叫JASMINE，她父亲是著名的台商，他们家族有一个传说，祖母曾经是一个精神病人，她的一生都在等待着一个从未出现过的人，每日的思念让她急促地老去，直到最后她在一场地震中突然死去，那时母亲还小，在整理祖母遗物的时候，找到了她留下来的这七封信。已经封存了百年，WOLI一直都在找寻着这个人，直到在我的一本书里看到了情书中相同的句子。她便走进了我的生活之中。 那天晚上我最后一次梦到诺兰，我走进了那间竹屋。JASMINE已经在另外一个屋子里睡熟。 诺兰凝视着镜子里自己苍老的容颜，她在镜子里看到了我，我已是一个满头自发的老人，我抚摸着她的白发，拿起檀木的梳子帮她梳理着头发，她的嘴角终于泛起一丝微笑。她的笑容定格在铜镜之中。 突然之间，整个山谷都在晃动，整个屋顶塌陷下来，砸在我的腿上，我听见自己骨骼断裂的声音，血液顺着裤腿流淌下来。我不知道原来梦境可以这么逼真，我的整条腿都在颤抖，她转身用力支撑着从山坡上滚落下来的石块，我躺在石块之下无法动弹，七个小时以后，她依然用颤抖的手指支撑着，手指的皮肤一寸一寸地裂开，鲜血滴落到我的脸上，我从来都没有哭过，那一刻我泪流满面地乞求着她放手，在巨大的泥石流和崩塌到来之前，我乞求着，骂着她。在一切归寂于黑暗之前，我耳边传来崩裂的倒塌声。 我听见她说：来世，你来，我便来。 《流年》2011年1月转载于： https://www.xzbu.com/5/view-2117900.htm]]></content>
      <categories>
        <category>Novel</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>love</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 570 (Div. 3)]]></title>
    <url>%2Fblog%2F2019%2F06%2F27%2FCodeforces-570%2F</url>
    <content type="text"><![CDATA[Yesterday I participated in a competition with CodeForces difficulty div3.Link: Codeforces Round #570 (Div. 3) B. Equalize PricesDescription:There are n products in the shop. The price of the i-th product is ai. The owner of the shop wants to equalize the prices of all products. However, he wants to change prices smoothly. In fact, the owner of the shop can change the price of some product i in such a way that the difference between the old price of this product ai and the new price bi is at most k. In other words, the condition |ai−bi|≤k should be satisfied (|x| is the absolute value of x). He can change the price for each product not more than once. Note that he can leave the old prices for some products. The new price bi of each product i should be positive (i.e. bi&gt;0 should be satisfied for all i from 1 to n). Your task is to find out the maximum possible equal price B of all productts with the restriction that for all products the condiion |ai−B|≤k should be satisfied (where ai is the old price of the product and B is the same new price of all products) or report that it is impossible to find such price B. Note that the chosen price B should be integer. You should answer q independent queries. InputThe first line of the input contains one integer q (1≤q≤100) — the number of queries. Each query is presented by two lines. The first line of the query contains two integers n and k (1≤n≤100,1≤k≤108) — the number of products and the value k. The second line of the query contains n integers a1,a2,…,an (1≤ai≤108), where ai is the price of the i-th product. OutputPrint q integers, where the i-th integer is the answer B on the i-th query. If it is impossible to equalize prices of all given products with restriction that for all products the condition |ai−B|≤k should be satisfied (where ai is the old price of the product and B is the new equal price of all products), print -1. Otherwise print the maximum possible equal price of all products. Exampleinput 45 11 1 2 3 14 26 4 8 52 21 63 55 2 5 output 26-17 Note In the first example query you can choose the price B=2. It is easy to see that the difference between each old price and each new price B=2 is no more than 1.In the second example query you can choose the price B=6 and then all the differences between old and new price B=6 will be no more than 2.In the third example query you cannot choose any suitable price B. For any value B at least one condition out of two will be violated: |1−B|≤2, |6−B|≤2.In the fourth example query all values B between 1 and 7 are valid. But the maximum is 7, so it&#39;s the answer. Intentional analysis:An easy problem.First we should judge the difference between the maximum and minimum values in the series and the size relationship of 2*k.If the difference is greater than 2*k,we should output &quot;-1&quot;,else output the sum of the minimum in the series and k. Click to see Chinese Intentional analysis我们只需要判断数列中最大最小值的差跟2*k的大小关系，如果差大于2*k，就输出“-1”，否则就输出数列中的最小值与k的和。 Code:1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4 + 10;int a[maxn];int main()&#123; int q, n, k; cin &gt;&gt; q; while (q--) &#123; cin &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; sort(a, a + n); if ((a[n - 1] - a[0]) &gt; 2 * k) &#123; puts(&quot;-1&quot;); continue; &#125; else &#123; cout &lt;&lt; a[0] + k &lt;&lt; endl; &#125; &#125; return 0;&#125; C. Computer GameDescription:Vova is playing a computer game. There are in total n turns in the game and Vova really wants to play all of them. The initial charge of his laptop battery (i.e. the charge before the start of the game) is k. During each turn Vova can choose what to do: If the current charge of his laptop battery is strictly greater than a, Vova can just play, and then the charge of his laptop battery will decrease by a;if the current charge of his laptop battery is strictly greater than b (b&lt;a), Vova can play and charge his laptop, and then the charge of his laptop battery will decrease by b;if the current charge of his laptop battery is less than or equal to a and b at the same time then Vova cannot do anything and loses the game.Vova wants to complete the game (Vova can complete the game if after each of n turns the charge of the laptop battery is strictly greater than 0). Among all possible ways to complete the game, Vova wants to choose the one where the number of turns when he just plays is the maximum possible. It is possible that Vova cannot complete the game at all. Your task is to find out the maximum possible number of turns Vova can just play or report that Vova cannot complete the game. You have to answer q independent queries. InputThe first line of the input contains one integer q (1≤q≤105) — the number of queries. Each query is presented by a single line. The only line of the query contains four integers k,n,a and b (1≤k,n≤1e9,1≤b&lt;a≤1e9) — the initial charge of Vova&#39;s laptop battery, the number of turns in the game and values a and b, correspondingly. OutputFor each query print one integer: -1 if Vova cannot complete the game or the maximum number of turns Vova can just play otherwise. Exampleinput 615 5 3 215 5 4 315 5 2 115 5 5 116 7 5 220 5 7 3 output 4-15201 Note In the first example query Vova can just play 4 turns and spend 12 units of charge and then one turn play and charge and spend 2 more units. So the remaining charge of the battery will be 1.In the second example query Vova cannot complete the game because even if he will play and charge the battery during each turn then the charge of the notebook battery will be 0 after the last turn. Intentional analysis:When the laptop battery is greater than a(b)(equal is not allowed to reduce),it is going to reduce a(b).The number of reductions is greater than n to win.We should find the maximum number of times &quot;a&quot; if Vova can finish the game.This requires a two-point answer. Click to see Chinese Intentional analysis如果能获胜，就输出a能得到的最大值。说人话就是设减a的次数为x，求出可以满足ax+b(n-x)&gt;k的a的值。然后二分就行了。 Code:12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long longll k, n, a, b;bool cal(ll m)&#123; return (a * m + b * (n - m)) &lt; k;&#125;int main()&#123; ll q; cin &gt;&gt; q; while (q--) &#123; cin &gt;&gt; k &gt;&gt; n &gt;&gt; a &gt;&gt; b; ll l = 0, r = n; while (l &lt;= r) &#123; ll m = (l + r) / 2; if (cal(m)) l = m + 1; else r = m - 1; &#125; if (l &gt; 0) cout &lt;&lt; min(l - 1, n) &lt;&lt; endl; else cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl; &#125; return 0;&#125; Thanks for my master @boctorio D. Candy Box (easy version)Description:This problem is actually a subproblem of problem G from the same contest. There are n candies in a candy box. The type of the i-th candy is ai (1≤ai≤n). You have to prepare a gift using some of these candies with the following restriction: the numbers of candies of each type presented in a gift should be all distinct (i. e. for example, a gift having two candies of type 1 and two candies of type 2 is bad). It is possible that multiple types of candies are completely absent from the gift. It is also possible that not all candies of some types will be taken to a gift. Your task is to find out the maximum possible size of the single gift you can prepare using the candies you have. You have to answer q independent queries. If you are Python programmer, consider using PyPy instead of Python when you submit your code. InputThe first line of the input contains one integer q (1≤q≤2⋅105) — the number of queries. Each query is represented by two lines. The first line of each query contains one integer n (1≤n≤2⋅105) — the number of candies. The second line of each query contains n integers a1,a2,…,an (1≤ai≤n), where ai is the type of the i-th candy in the box. It is guaranteed that the sum of n over all queries does not exceed 2⋅105. OutputFor each query print one integer — the maximum possible size of the single gift you can compose using candies you got in this query with the restriction described in the problem statement. Exampleinput 381 4 8 4 5 6 3 8162 1 3 3 4 3 4 4 1 3 2 2 2 4 1 192 2 4 4 4 7 7 7 7 output 3109 Note In the first query, you can prepare a gift with two candies of type 8 and one candy of type 5, totalling to 3 candies.Note that this is not the only possible solution — taking two candies of type 4 and one candy of type 6 is also valid. Intentional analysis:Count the number of occurrences of each number and sort it out. Add from the biggest beginning, pay attention to if you can&#39;t continue to add the same, you should add one smaller than him. Click to see Chinese Intentional analysis统计出每个数字出现的次数，排一下序。从最大的开始往下加，注意如果出现相同的不能继续加，应该加上一个比它小一的（比如说4，4加出来应该是4+3，如果是4，2，加起来应该是4+2）。难点就是如何实现。 Code:123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e6 + 10;int num[maxn];int n, u, ans;int main()&#123; int q; cin &gt;&gt; q; while (q--) &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) num[i] = 0; ans = 0; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; u; num[u]++; &#125; sort(num + 1, num + 1 + n); int nw = n; for (int i = n; i &gt;= 1; i--) &#123; if (nw &gt; num[i]) &#123; nw = num[i]; &#125; ans += nw; nw--; if (nw &lt;= 0) break; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>Thinking</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Times 17]]></title>
    <url>%2Fblog%2F2019%2F06%2F23%2Fnowcoder-945-J%2F</url>
    <content type="text"><![CDATA[When all else is lost the future still remains. Times 17Link: nowcoder-945-JDescription:After realizing that there is much money to be made in software development, Farmer John has launched a small side business writing short programs for clients in the local farming industry.Farmer John&#39;s first programming task seems quite simple to him -- almost too simple: his client wants him to write a program that takes a number N as input, and prints 17 times N as output. Farmer John has just finished writing this simple program when the client calls him up in a panic and informs him that the input and output both must be expressed as binary numbers, and that these might be quite large.Please help Farmer John complete his programming task. Given an input number N, written in binary with at most 1000 digits, please write out the binary representation of 17 times N.输入描述: Line 1: The binary representation of N (at most 1000 digits). 输出描述: Line 1: The binary representation of N times 17. 示例1输入 10110111 输出 110000100111 说明 OUTPUT DETAILS:The binary number 10110111 is equal to 183 in decimal form.183 x 17 = 3111 is 110000100111 in binary format. Intentional analysis:When I first saw this problem,I think it&#39;s so easy if I use bitset.But then I find the string input is at most 1000 digits,obviously,even long long can&#39;t save.So we must choose another way.I search the Binary multiplication on the internet. How can we perform Binary multiplication? I think this following picture is a good way to explain. And in this problem,we need to multiply by 17.And the binary of 17 is 10001.So what we should do is add s+&#39;0000&#39; to s(s is the string we input).After this,a less easy problem has also appeared.How do we do binary addition?Just simulation.Just like the simulation we did before adding large numbers.You can see the sode to understand. Click to see Chinese Intentional analysis一开始想用bitset很简单，然后发现数据范围是2^1000,long long都存不下。然后去搜索了一下二进制相乘，上面那个图片就很好理解，这道题我们只需要跟17相乘。而17的二进制形式是10001.所以我们只需要将s后面接四个0与s（例如我们输入的是111，那我们只需要将‘1110000’与‘111’加起来）加起来就好（s是我们输入的字符串）。这个二进制相加只需要模拟就行了，就像我们之前模拟大数相加的时候一样模拟。Code:12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;char ans[1005];int main()&#123; string s, mid; int i = 0; cin &gt;&gt; s; mid = s + &quot;0000&quot;; int temp = 0; reverse(s.begin(), s.end());//binary addition reverse(mid.begin(), mid.end()); for (i = 0; i &lt; max(s.size(), mid.size()); i++) &#123; if (i &lt; s.size() &amp;&amp; i &lt; mid.size()) temp += s[i] + mid[i] - &apos;0&apos; - &apos;0&apos;; if (i &gt;= s.size() &amp;&amp; i &lt; mid.size()) temp += mid[i] - &apos;0&apos;; if (i &lt; s.size() &amp;&amp; i &gt;= mid.size()) temp += s[i] - &apos;0&apos;; ans[i] = temp % 2 + &apos;0&apos;; temp /= 2; &#125; if (temp == 1) &#123; ans[i] = &apos;1&apos;; i++; &#125; for (int j = i - 1; j &gt;= 0; j--) cout &lt;&lt; ans[j]; return 0;&#125; I have to say,python is easy and amazing this time.1print(bin(int(input(),2)*17)[2:]) Because you don&#39;t need to care how big the number is.Just calculate.]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>nowcoder</tag>
        <tag>python</tag>
        <tag>Thinking</tag>
        <tag>Binary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A solution]]></title>
    <url>%2Fblog%2F2019%2F06%2F22%2Fsolution%2F</url>
    <content type="text"><![CDATA[Summer is coming,relax!ralax!relax!What&#39;s the problem?Since I used hexo,this problem has been seen many times.When I first met this,I chose to wait.Fortunately,it&#39;s really good in a few days.Then next time,I waited about ten days or more,there&#39;s no changing.So I chose to delete all local files.Add re-&#39;hexo-g&#39;.Although the problem was solved this time, all the upload information before this was gone, and the upload date of the previous article became the same day.The last time,I searched a solution for this on the Internet. Delete &#39;.deploy_git&#39; in your Hexo root directory. Git clone your repositories of your blog in Github.And renama it to &#39;.deploy_git&#39;.There is a little and useful skill.As we all konw,the download speed is too slow in China.So we can use this code to improve your effectiveness. 1git clone your-repositorie&apos;s url --depth=1 Re-&#39;hexo-g&#39;,and &#39;hexo-d&#39;,then you can &#39;hexo-d&#39; successfully.]]></content>
      <categories>
        <category>Tutorial</category>
      </categories>
      <tags>
        <tag>Tutorial</tag>
        <tag>Useful</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Floyd]]></title>
    <url>%2Fblog%2F2019%2F06%2F21%2FFloyd%2F</url>
    <content type="text"><![CDATA[A man&#39;s best friends are his ten fingers. 最短路-FloydLink: HDU-2544 Description:在每年的校赛里，所有进入决赛的同学都会获得一件很漂亮的t-shirt。但是每当我们的工作人员把上百件的衣服从商店运回到赛场的时候，却是非常累的！所以现在他们想要寻找最短的从商店到赛场的路线，你可以帮助他们吗？ Input输入包括多组数据。每组数据第一行是两个整数N、M（N&lt;=100，M&lt;=10000），N表示成都的大街上有几个路口，标号为1的路口是商店所在地，标号为N的路口是赛场所在地，M则表示在成都有几条路。N=M=0表示输入结束。接下来M行，每行包括3个整数A，B，C（1&lt;=A,B&lt;=N,1&lt;=C&lt;=1000）,表示在路口A与路口B之间有一条路，我们的工作人员需要C分钟的时间走过这条路。输入保证至少存在1条商店到赛场的路线。 Output对于每组输入，输出一行，表示工作人员从商店走到赛场的最短时间 Sample Input 2 11 2 33 31 2 52 3 53 1 20 0 Sample Output 32 Code:123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4 + 5;const int INF = 0x3f3f3f3f;int a[maxn][maxn];int main()&#123; int n, m, u, v, p; while (cin &gt;&gt; n &gt;&gt; m) &#123; if (n == 0 &amp;&amp; m == 0) break; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) a[i][j] = INF; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; p; a[u][v] = p; a[v][u] = p; &#125; for (int k = 1; k &lt;= n; k++) for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) if (a[i][j] &gt; a[i][k] + a[k][j]) a[i][j] = a[i][k] + a[k][j]; cout &lt;&lt; a[1][n] &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>c/c++</tag>
        <tag>HDU</tag>
        <tag>Floyd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Put my curriculum on my blog]]></title>
    <url>%2Fblog%2F2019%2F06%2F20%2Fcurriculum%2F</url>
    <content type="text"><![CDATA[Html &amp;&amp; css is interesting.demo Create the curriculum locallyThis is easy to finish. Convert the table to a html formThere are many ways to finish.Such as: DocPe Add some useful featuresNow timeCode:12345678910111213141516171819202122232425262728293031323334353637383940&lt;body onload=&quot;getTime()&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;function getTime() &#123; var dateObj = new Date(); var year = dateObj.getFullYear();//年 var month = dateObj.getMonth()+1;//月 (注意：月份+1) var date = dateObj.getDate();//日 var day = dateObj.getDay(); var weeks = [&quot;星期日&quot;,&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;,&quot;星期四&quot;,&quot;星期五&quot;,&quot;星期六&quot;]; var week = weeks[day];//根据day值，获取星期数组中的星期数。 var hours = dateObj.getHours();//小时 var minutes = dateObj.getMinutes();//分钟 var seconds = dateObj.getSeconds();//秒 if(month&lt;10)&#123; month = &quot;0&quot;+month; &#125; if(date&lt;10)&#123; date = &quot;0&quot;+date; &#125; if(hours&lt;10)&#123; hours = &quot;0&quot;+hours; &#125; if(minutes&lt;10)&#123; minutes = &quot;0&quot;+minutes; &#125; if(seconds&lt;10)&#123; seconds = &quot;0&quot;+seconds; &#125; var newDate = year+&quot;年&quot;+month+&quot;月&quot;+date+&quot;日&quot;+hours+&quot;:&quot;+minutes+&quot;:&quot;+seconds+&quot;&amp;nbsp &amp;nbsp&quot;+week; document.getElementById(&quot;date1&quot;).innerHTML = newDate + &quot; 一言：&quot;;//在div中写入时间 setTimeout(&apos;getTime()&apos;, 500);//每隔500ms执行一次getTime()&#125;&lt;/script&gt;&lt;div id=&quot;date1&quot;&gt;&lt;/div&gt;&lt;/body&gt; 一言12&lt;div id=&quot;hitokoto&quot; &gt;&lt;script&gt;hitokoto()&lt;/script&gt;&lt;/div&gt;&lt;script src=&quot;https://v1.hitokoto.cn/?encode=js&amp;select=%23hitokoto&quot; defer&gt;&lt;/script&gt; Weather1&lt;iframe scrolling=&quot;no&quot; src=&quot;https://tianqiapi.com/api.php?style=tt&amp;skin=pitaya&quot; frameborder=&quot;0&quot; width=&quot;590&quot; height=&quot;98&quot; allowtransparency=&quot;true&quot;&gt;&lt;/iframe&gt;]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>html</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My story with she]]></title>
    <url>%2Fblog%2F2019%2F06%2F17%2Fromantic%2F</url>
    <content type="text"><![CDATA[You will konw the password if I want you know. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra]]></title>
    <url>%2Fblog%2F2019%2F06%2F17%2FDijkstra%2F</url>
    <content type="text"><![CDATA[I love you. 最短路-DijkstraLink: HDU-2544 Description:在每年的校赛里，所有进入决赛的同学都会获得一件很漂亮的t-shirt。但是每当我们的工作人员把上百件的衣服从商店运回到赛场的时候，却是非常累的！所以现在他们想要寻找最短的从商店到赛场的路线，你可以帮助他们吗？ Input输入包括多组数据。每组数据第一行是两个整数N、M（N&lt;=100，M&lt;=10000），N表示成都的大街上有几个路口，标号为1的路口是商店所在地，标号为N的路口是赛场所在地，M则表示在成都有几条路。N=M=0表示输入结束。接下来M行，每行包括3个整数A，B，C（1&lt;=A,B&lt;=N,1&lt;=C&lt;=1000）,表示在路口A与路口B之间有一条路，我们的工作人员需要C分钟的时间走过这条路。输入保证至少存在1条商店到赛场的路线。 Output对于每组输入，输出一行，表示工作人员从商店走到赛场的最短时间 Sample Input 2 11 2 33 31 2 52 3 53 1 20 0 Sample Output 32 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4 + 5;const int INF = 0x3f3f3f3f;int a[maxn][maxn];int dis[maxn];bool vis[maxn];int n, m, u, v, w;struct node&#123; int d, id;&#125;;bool operator &lt;(const node &amp;a, const node &amp;b)&#123; return a.d &gt; b.d;&#125;priority_queue&lt;node&gt; que;void Dijkstra()&#123; for (int i = 1; i &lt;= n; i++) dis[i] = INF; dis[1] = 0; que.push(node&#123; dis[1], 1 &#125;); while (!que.empty()) &#123; node p = que.top(); que.pop(); int mid = p.id; if (vis[mid] == 1) continue; vis[mid] = 1; for (int i = 1; i &lt;= n; i++) &#123; if (dis[i] &gt; dis[mid] + a[mid][i]) &#123; dis[i] = dis[mid] + a[mid][i]; que.push(node&#123; dis[i], i &#125;); &#125; &#125; &#125; cout &lt;&lt; dis[n] &lt;&lt; endl;&#125;int main()&#123; while (scanf(&quot;%d %d&quot;, &amp;n, &amp;m) &amp;&amp; (n &amp;&amp; m)) &#123; memset(vis, 0, sizeof(vis)); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) a[i][j] = INF; for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; a[u][v] = w; a[v][u] = w; &#125; Dijkstra(); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>c/c++</tag>
        <tag>Dijkstra</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Somewhere magical]]></title>
    <url>%2Fblog%2F2019%2F06%2F15%2Fsurprise%2F</url>
    <content type="text"><![CDATA[Let&#39;s do something special together. Generate virtual resume onlineLink: This resume does not exist Description:Entering the website will automatically generate a resume. If you are not satisfied, it will be allowed to generate again after 10 seconds!And everything inside is virtual. Avengers 3D Face Change EffectLink: Avengethem Description:You can replace the Avengers face with your own face and generate a GIF 毒鸡汤合集Link: 毒鸡汤 Description:You can go here and enjoy yorself. Tetris-PlusLink: Tetris Description:You can play kinds of mode Tetris here. A magical drawing boardLink: noard Description:Draw a picture you want to paint, and then it will become shy.Suggestion: Girls should think twice before entering. Perfect AI portrait generatorLink: This Person Does Not Exist Description:Very professional intelligent AI website, the website will randomly display portrait photos generated by AI intelligence, and generate realistic and non-existent people through the study of huge real portrait data. CSS代码渐变颜色生成工具Link: Grabient Description:Online visualization to set gradients and generate CSS code 在线扫雷Link: 扫雷 Description:Minesweeper,and there are many small games Canon Creative ParkLink: CREATIVE PARK Description:The website provides a large number of free production drawings of paper molds, cards and furniture accessories.The main thing is that the paper molds are always updated.]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Plus from Picture]]></title>
    <url>%2Fblog%2F2019%2F06%2F12%2FCodeForces-566-B%2F</url>
    <content type="text"><![CDATA[Are you ready for the cet4? Yes,I are. &lt;centerPlus from PictureLink: CodeForces-566-BDescription:You have a given picture with size w×h. Determine if the given picture has a single &quot;+&quot; shape or not. A &quot;+&quot; shape is described below: A &quot;+&quot; shape has one center nonempty cell.There should be some (at least one) consecutive non-empty cells in each direction (left, right, up, down) from the center. In other words, there should be a ray in each direction.All other cells are empty.Find out if the given picture has single &quot;+&quot; shape. InputThe first line contains two integers h and w (1≤h, w≤500) — the height and width of the picture. The i-th of the next h lines contains string si of length w consisting &quot;.&quot; and &quot;*&quot; where &quot;.&quot; denotes the empty space and &quot;*&quot; denotes the non-empty space. OutputIf the given picture satisfies all conditions, print &quot;YES&quot;. Otherwise, print &quot;NO&quot;. You can output each letter in any case (upper or lower). Examplesinput1234565 6........*....****...*.....*... outputYES input12343 5..*..****..*... outputNO input123456787 7..........*.....****....*......*...........*..... outputNO input1234565 6..**....**..******..**....**.. outputNO input12343 7.*...*.***.***.*...*. outputNO input1234565 10............*........*.******...*................. outputNO Note In the first example, the given picture contains one &quot;+&quot;.In the second example, two vertical branches are located in a different column.In the third example, there is a dot outside of the shape.In the fourth example, the width of the two vertical branches is 2.In the fifth example, there are two shapes.In the sixth example, there is an empty space inside of the shape. Intentional analysis:My way is find the center * of the &quot;+&quot;.And turn all of the &#39;*&#39; in &quot;+&quot; to &#39;.&#39;.And if there is still has &#39;*&#39; in the map.Should print &quot;NO&quot;,if not,print &quot;YES&quot;.But there is a special situation,there has no &#39;*&#39; in the map,we&#39;d better make a flag number to satisfy this. Click to see Chinese Intentional analysis我的方法就是找到“+”最中间的‘*’。然后把“+”中的&#39;*&#39;全部变成‘.’。然后再看图里面有没有‘*’，如果有就输出“NO”，没有就输出“YES”。但是还有一种情况就是图里面没有&#39;*&#39;，这个特殊处理一下就行。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;bits/stdc++.husing namespace std;const int maxn = 550;char m[maxn][maxn];int x[maxn];void find(int x, int y, int z)&#123; if (z == 0) &#123; while (m[x][y] == &apos;*&apos;) &#123; m[x][y] = &apos;.&apos;; y++; &#125; &#125; if (z == 1) &#123; while (m[x][y] == &apos;*&apos;) &#123; m[x][y] = &apos;.&apos;; x++; &#125; &#125; if (z == 2) &#123; while (m[x][y] == &apos;*&apos;) &#123; m[x][y] = &apos;.&apos;; y--; &#125; &#125; if (z == 3) &#123; while (m[x][y] == &apos;*&apos;) &#123; m[x][y] = &apos;.&apos;; x--; &#125; &#125;&#125;int main()&#123; int w, h; bool flag = 0; cin w h; for (int i = 0; i &lt; w; i++) for (int j = 0; j &lt; h; j++) cin m[i][j]; for (int i = 0; i &lt; w; i++) &#123; for (int j = 0; j &lt; h; j++) &#123; if (m[i][j] == &apos;*&apos;) &#123; int mid = 0; if (m[i - 1][j] == &apos;*&apos;) mid++; if (m[i][j - 1] == &apos;*&apos;) mid++; if (m[i + 1][j] == &apos;*&apos;) mid++; if (m[i][j + 1] == &apos;*&apos;) mid++; if (mid == 4) &#123; for (int k = 0; k &lt; 4; k++) &#123; m[i][j] = &apos;*&apos;; find(i, j, k); flag = 1; &#125; &#125; &#125; if (flag) break; &#125; if (flag) break; &#125; bool f = 0; for (int i = 0; i &lt; w; i++) for (int j = 0; j &lt; h; j++) &#123; if (m[i][j] == &apos;*&apos;) f = 1; &#125; if (!f &amp;&amp; flag) puts(&quot;YES&quot;); else puts(&quot;NO&quot;); return 0;&#125;]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>CodeForces</tag>
        <tag>Simulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Filling Shapes]]></title>
    <url>%2Fblog%2F2019%2F06%2F11%2FCodeForces-566-A%2F</url>
    <content type="text"><![CDATA[I will be a strong man,both body and soul. Filling ShapesLink: CodeForces-566-ADescription:You have a given integer n. Find the number of ways to fill all 3×n tiles with the shape described in the picture below. Upon filling, no empty spaces are allowed. Shapes cannot overlap. This picture describes when n=4. The left one is the shape and the right one is 3×n tiles.InputThe only line contains one integer n (1≤n≤60) — the length. OutputPrint the number of ways to fill. Examplesinput 4 output 4 input 1 output 0 Note In the first example, there are 4 possible cases of filling.In the second example, you cannot fill the shapes in 3×1 tiles. Code:12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; long long n; cin &gt;&gt; n; if (n % 2 != 0) cout &lt;&lt; 0 &lt;&lt; endl; else &#123; n /= 2; n = pow(2, n); printf(&quot;%lld\n&quot;, n); &#125; return 0;&#125; Nothing to say,just find the regular,and cout is something wrong happen and I don&#39;t know the reason now.Record it here!]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lose it!]]></title>
    <url>%2Fblog%2F2019%2F06%2F10%2FCodeForces-565-C%2F</url>
    <content type="text"><![CDATA[Live beautifully, dream passionately, love completely. Lose it!Link: CodeForces-565-CDescription:You are given an array a consisting of n integers. Each ai is one of the six following numbers: 4,8,15,16,23,42. Your task is to remove the minimum number of elements to make this array good. An array of length k is called good if k is divisible by 6 and it is possible to split it into k6 subsequences 4,8,15,16,23,42. Examples of good arrays: [4,8,15,16,23,42] (the whole array is a required sequence);[4,8,4,15,16,8,23,15,16,42,23,42] (the first sequence is formed from first, second, fourth, fifth, seventh and tenth elements and the second one is formed from remaining elements);[] (the empty array is good).Examples of bad arrays: [4,8,15,16,42,23] (the order of elements should be exactly 4,8,15,16,23,42);[4,8,15,16,23,42,4] (the length of the array is not divisible by 6);[4,8,15,16,23,42,4,8,15,16,23,23] (the first sequence can be formed from first six elements but the remaining array cannot form the required sequence).InputThe first line of the input contains one integer n (1≤n≤5⋅105) — the number of elements in a. The second line of the input contains n integers a1,a2,…,an (each ai is one of the following numbers: 4,8,15,16,23,42), where ai is the i-th element of a. OutputPrint one integer — the minimum number of elements you have to remove to obtain a good array. Examplesinput 54 8 15 16 23 output 5 input 124 8 4 15 16 8 23 15 16 42 23 42 output 0 input 154 8 4 8 15 16 8 16 23 15 16 4 42 23 42 output 3 Intentional analysis:The most difficult path of this problem is the order of the numbers is fixed.So you can not just find the minimum number of 4,8,15,16,23,42,and I had to say that is my first try,without doubt,wrong answer.But how to make sure that the order in which you find the number is fixed?My method is to use some numbers to mark the appearance of 4,8,15,16,23,42.Only 4 has appeared, the number of 8 can be increased by one, and the number of 4 should reduced by one.And so on.The final number of 42 is the answer.See the code. Click to see Chinese Intentional analysis要保证找出来的最长序列的顺序一定是4，8，15，16，23，42，这个一定要看清。我的办法就是用几个数标记他们的出现次数。只有当4出现的次数不为0的时候8出现，那么8出现的次数才能加一，而且此时4出现的次数就得减一。以此类推，最后得到的42出现的次数代表的就是能找到的最长序列的长度的1/6。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; ll n, a, mid = 0; cin &gt;&gt; n; ll f1 = 0, f2 = 0, f3 = 0, f4 = 0, f5 = 0, f6 = 0; for (ll i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a; if (a == 4) f1++; if (a == 8 &amp;&amp; f1) &#123; f2++; f1--; &#125; if (a == 15 &amp;&amp; f2) &#123; f3++; f2--; &#125; if (a == 16 &amp;&amp; f3) &#123; f4++; f3--; &#125; if (a == 23 &amp;&amp; f4) &#123; f5++; f4--; &#125; if (a == 42 &amp;&amp; f5) &#123; f6++; f5--; &#125; &#125; cout &lt;&lt; n - f6 * 6 &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How to change the avatar under valine]]></title>
    <url>%2Fblog%2F2019%2F06%2F08%2Fvaline%2F</url>
    <content type="text"><![CDATA[I can give you everything I haveComment system I chose valine,but many times I am not satisfied with the default avatar of valine.So I found something related on the Internet and successfully implemented this.This is easy to achieve.First: you shoule go to Gravatar to register an account.Attention:The email you use when registering is important and will be used next.After the registration is completed, change the personal information and change the avatar you want to use.Second: Fill in the email address when you comment, it will automatically match your avatarThen you can find your avatar replaced with your own custom. A common problem:You may not received verification email when you are registering.Reason: Some mailboxes have added gravatar to the blacklist.Solution: Add the following address to your email address whitelist in your mailbox settings123donotreply@gravatar.comdonotreply@wordpress.comsupport@gravatar.com Such as QQ-mailThen you should be able to find the verification email in the trash in the email.]]></content>
      <categories>
        <category>Tutorial</category>
      </categories>
      <tags>
        <tag>Tutorial</tag>
        <tag>valine</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Arithmetic Sequence]]></title>
    <url>%2Fblog%2F2019%2F06%2F08%2Fnowcoder921H%2F</url>
    <content type="text"><![CDATA[A very very very boring problem. Arithmetic SequenceLinks: nowcoder-921-HDescription:...然而，强如小r，是不屑于计算一些琐碎的计算的。现在小r给了你一个数X，要求你搞出一个等差数列a使得Sn=a1+a2+a3+⋯+an=∑i=0n−1(a1+id)=n(a1+an)2=X输入描述:输入一个数X，含义见题目描述。 输入保证X在int范围[−2e31∼2e31−1]内。输出描述:输出两行，第一行输出一个正整数n，代表你将要给出的数列长度。注意n不能太大，否则会导致输出超限、超时或运行时错误。 第二行输出符合题目要求的数列，每个数之间用空格隔开，含义见题目描述 要求输出的所有数范围在int内，否则视为答案错误。示例1输入6输出31 2 3示例2输入49输出71 3 5 7 9 11 13 code12345678#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int x; cin&gt;&gt;x; cout&lt;&lt;&quot;1&quot;&lt;&lt;endl&lt;&lt;x;&#125; 一个数也算是数列！！！Paste this problem just to remind myself, be brave when i should be brave.]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>nowcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Greedy-dating Ⅱ]]></title>
    <url>%2Fblog%2F2019%2F06%2F04%2Fdating%2F</url>
    <content type="text"><![CDATA[A basic greedy problem. 活动安排问题之二有若干个活动，第i个开始时间和结束时间是[Si,fi)，活动之间不能交叠，要把活动都安排完，至少需要几个教室？ 策略： 按照开始时间排序优先安排活动，如果冲突，则加一个教室。简单地理解一下，策略是这样，我们把活动按照开始时间有小到大的顺序排序。假设目前已经分配了k个教室（显然k初始等于0），对于当前这个活动，（1） 如果它能安排在k个教室里的某一个，则把它安排在其中的任何一个教室里，k不变。（2） 否则它和每个教室里的活动都冲突，则增加一个教室，安排这个活动。 这个策略是最优么？ 我们想像一下k增加1的过程： 因为我们是按照开始时间排序的，意味着当前考虑的这个活动开始的时候，k个教室里都有活动没结束（因为如果有一个教室的活动结束了，我们就可以安排这个活动进入那个教室而不冲突，从而不用增加k)。这就意味着在这个活动开始的时间点，算上目前考虑的这个活动，有(k + 1)个活动正在进行，同一时刻有(k + 1)个活动在进行，无论我们如何安排教室，都至少需要(k + 1)个教室。因为每个教室里不能同时进行两个活动。而我们的策略恰好需要(k + 1)个教室，所以是最优的。 这个策略也告诉我们，如果从时间轴上“宏观”考虑这个问题。考虑每个时间点同时进行的活动个数，作为这个时间点的厚度（把活动开始和结束时间想像成线段，那么每个时间点有多少条线段覆盖它，可以简单理解为“厚度”），我们至少需要最大厚度那么多个教室——因为那时恰好有最大厚度那么多个活动同时进行，而我们这个贪心策略恰好给了我们一个用最大厚度那么多个教室安排全部活动的一个方案。 如果只需要教室的个数，我们可以把所有开始时间和结束时间排序，遇到开始时间就把厚度加1，遇到结束时间就把厚度减1，显然最初始和最后结束时的厚度是0，在一系列厚度变化的过程中，峰值（最大值）就是最多同时进行的活动数，也是我们至少需要的教室数。 The above content comes from 51nod. Description:输入 第一行一个正整数n (n &lt;= 10000)代表活动的个数。第二行到第(n + 1)行包含n个开始时间和结束时间。开始时间严格小于结束时间，并且时间都是非负整数，小于1000000000 输出 一行包含一个整数表示最少教室的个数。 输入示例 31 23 42 9 输出示例 2 Code:1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;pair&lt;int, int&gt; &gt; v;int main()&#123; int n, a, b; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a &gt;&gt; b; v.push_back(make_pair(a, 1)); v.push_back(make_pair(b, 0)); &#125; sort(v.begin(), v.end()); int sum = 0, ans = 0; for (int i = 0; i &lt; 2 * n; i++) &#123; if (v[i].second == 1) sum++; else sum--; ans = max(ans, sum); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; Attention：A special case is that the start time and the end time are the same time, so it is very troublesome to use the array array directly.And the vector and pair is suitable here.]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Greedy</tag>
        <tag>51nod</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Uncle Drew's ACM Template]]></title>
    <url>%2Fblog%2F2019%2F06%2F03%2Ftemplate%2F</url>
    <content type="text"><![CDATA[I want to make a template for myself. 字符串处理最长回文子串Manacher(马拉车算法)12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1e5;char str[MAXN];char tmp[2*MAXN];int len[2*MAXN];int Manacher(char str[])&#123; tmp[0] = &apos;$&apos;; tmp[1] = &apos;#&apos;; int str_len = strlen(str); for(int i = 1;i &lt;= str_len;i++)&#123; tmp[2*i] = str[i-1]; tmp[2*i+1] = &apos;#&apos;; &#125; tmp[2*str_len+2] = &apos;\0&apos;; int mx = 0; int maxlen = -1; int mid; for(int i = 1; tmp[i]; i++)&#123; if(i &lt; mx) len[i] = min(len[2*mid-i],mx-i); else len[i] = 1; while(tmp[i-len[i]] == tmp[i+len[i]]) len[i]++; if(len[i]+i &gt; mx)&#123; mx = len[i]+i; mid = i; &#125; maxlen = max(maxlen,len[i]-1); &#125; return maxlen;//返回最长回文字串的长度&#125;int main()&#123; int n; cin&gt;&gt;n; scanf(&quot;%s&quot;,str); cout&lt;&lt;Manacher(str)； return 0;&#125; 数学素数Eratosthenes(埃拉托色尼筛法)123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;int a[1000000];int main()&#123; int sum=0,n; int i,j; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; sum=0; for(i=2;i&lt;=n;i++) a[i]=1; for(i=2;i&lt;=sqrt(n);i++)&#123; for(j=2*i;j&lt;=n;j+=i)&#123; a[j]=0; &#125; &#125; for(i=2;i&lt;=n;i++)&#123; if(a[i]) cout&lt;&lt;i&lt;&lt;endl;; &#125; &#125; return 0;&#125; 欧拉筛12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#define N 100int main(void)&#123; bool number[N+1]; int prime[N+1]; int i,j,count=0; memset(number,true,sizeof(number)); for(i=2;i&lt;=N;i++) &#123; if(number[i]) prime[count++]=i; for(j=0;j&lt;count&amp;&amp;prime[j]*i&lt;=N;j++) &#123; number[prime[j]*i]=false; if(i%prime[j]==0)//精华就在于此：它保证每个合数只会被它的最小质因数筛去，因此每个数只会被标记一次，所以时间复杂度是O(n) break; &#125; &#125; for(i=2;i&lt;N+1;i++) if(number[i]==true) printf(&quot;%d &quot;,i); return 0;&#125; 快速幂12345678910ll poww(ll x, ll y, ll z)&#123; ll ans = 1, base = x; while (y != 0) &#123; if (y &amp; 1 != 0) ans = ans * base % z; base = (base % z) * (base % z) % z; y &gt;&gt;= 1; &#125; return ans;&#125; 斐波那契(大数，根据第n项的值推出n)12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;const int maxx = 1e9 + 7;typedef long long ll;ll f[200050]; char s[100000];int main()&#123; ios::sync_with_stdio(false); map&lt;ll, ll&gt; ma; f[0] = 0; f[1] = 1; for (ll i = 2; i &lt; 200001; i++) &#123; f[i] = (f[i - 1] + f[i - 2]) % maxx; ma[f[i]] = i; &#125; ll n; cin &gt;&gt; n; while (n--) &#123; cin &gt;&gt; s; ll ans, num, l; l = strlen(s);//先把长度求出来，用的时候直接用 num = 0; for (ll i = 0; i &lt; l; i++) &#123; num = num * 10 + s[i] - &apos;0&apos;; num %= maxx; &#125; cout &lt;&lt; ma[num] &lt;&lt; endl; &#125; return 0;&#125; 大数(c++)大数相加(正整数)123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int n; cin &gt;&gt; n; int m = 0; int l = 0; for (int i = 1; i &lt;= n; i++) &#123; string s1, s2, s(10000, &apos;0&apos;); cin &gt;&gt; s1 &gt;&gt; s2; m++; cout &lt;&lt; (l++ ? &quot;\n&quot; : &quot;&quot;); reverse(s1.begin(), s1.end()); reverse(s2.begin(), s2.end()); for (int j = 0; j &lt; s1.length(); j++) s[j] = s1[j]; int temp = 0; for (int k = 0; k &lt; s2.length(); k++) &#123; temp += s[k] - 48 + s2[k] - 48; s[k] = temp % 10 + &apos;0&apos;; temp /= 10; &#125; s[s2.length()] = s[s2.length()] - 48 + temp + 48; reverse(s.begin(), s.end()); reverse(s1.begin(), s1.end()); reverse(s2.begin(), s2.end()); cout &lt;&lt; &quot;Case&quot; &lt;&lt; m &lt;&lt; &quot;:&quot; &lt;&lt; endl; cout &lt;&lt; s1 &lt;&lt; &quot;+&quot; &lt;&lt; s2 &lt;&lt; &quot;=&quot; &lt;&lt; s.substr(s.find_first_not_of(&apos;0&apos;)) &lt;&lt; endl; &#125; return 0;&#125; 大数相减(正整数)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int strComp(string &amp;s1, string &amp;s2)&#123; int len1 = s1.length(); int len2 = s2.length(); if (len1 &gt; len2) return 0; else if (len1 &lt; len2) return 1; else &#123; if (s1 &gt;= s2) return 0; else return 1; &#125;&#125;int main()&#123; string s1, s2; while (cin &gt;&gt; s1 &gt;&gt; s2) &#123; string s(10000, &apos;0&apos;); bool fgEx = true; if (strComp(s1, s2) == 1) &#123; string temp; temp = s1; s1 = s2; s2 = temp; fgEx = false; &#125; if (s1 == s2) &#123; cout &lt;&lt; s1 &lt;&lt; &quot; - &quot; &lt;&lt; s2 &lt;&lt; &quot; = &quot; &lt;&lt; &quot;0&quot; &lt;&lt; endl; continue; &#125; reverse(s1.begin(), s1.end()); reverse(s2.begin(), s2.end()); for (int i = 0; i &lt; s1.length(); i++) s[i] = s1[i]; for (int i = 0; i &lt; s2.length(); i++) &#123; if (s[i] &gt;= s2[i]) s[i] = s[i] - &apos;0&apos; - (s2[i] - &apos;0&apos;) + &apos;0&apos;; else &#123; s[i + 1] = s[i + 1] - &apos;0&apos; - 1 + &apos;0&apos;; s[i] = s[i] - &apos;0&apos; + 10 - (s2[i] - &apos;0&apos;) + &apos;0&apos;; &#125; &#125; if (fgEx == false) &#123; reverse(s2.begin(), s2.end()); cout &lt;&lt; s2 &lt;&lt; &quot; - &quot;; reverse(s1.begin(), s1.end()); cout &lt;&lt; s1 &lt;&lt; &quot; = &quot;; reverse(s.begin(), s.end()); cout &lt;&lt; &quot;-&quot; &lt;&lt; s.substr(s.find_first_not_of(&apos;0&apos;)) &lt;&lt; endl; &#125; else &#123; reverse(s1.begin(), s1.end()); cout &lt;&lt; s1 &lt;&lt; &quot; - &quot;; reverse(s2.begin(), s2.end()); cout &lt;&lt; s2 &lt;&lt; &quot; = &quot;; reverse(s.begin(), s.end()); cout &lt;&lt; s.substr(s.find_first_not_of(&apos;0&apos;)) &lt;&lt; endl; &#125; &#125; return 0;&#125; 大数相乘(正整数)1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; string s1, s2; while (cin &gt;&gt; s1 &gt;&gt; s2) &#123; string s(1000, &apos;0&apos;); reverse(s1.begin(), s1.end()); reverse(s2.begin(), s2.end()); for (int i = 0; i &lt; s1.length(); i++) for (int j = 0; j &lt; s2.length(); j++) &#123; int temp = (s1[i] - &apos;0&apos;) * (s2[j] - &apos;0&apos;); s[i + j + 1] = s[i + j + 1] - &apos;0&apos; + (s[i + j] - &apos;0&apos; + temp) / 10 + &apos;0&apos;; s[i + j] = (s[i + j] - &apos;0&apos; + temp) % 10 + &apos;0&apos;; &#125; reverse(s.begin(), s.end()); if (s.find_first_not_of(&apos;0&apos;) == string::npos) cout &lt;&lt; &quot;0&quot; &lt;&lt; endl; else cout &lt;&lt; s.substr(s.find_first_not_of(&apos;0&apos;)) &lt;&lt; endl; &#125; return 0;&#125; 大数相除(正整数)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int strComp(string &amp;s1, string &amp;s2)&#123; int len1 = s1.length(); int len2 = s2.length(); if (len1 &gt; len2) return 0; else if (len1 &lt; len2) return 1; else &#123; if (s1 &gt;= s2) return 0; else return 1; &#125;&#125;string Sub(string s1, string s2)&#123; if (strComp(s1, s2) == 1) return &quot;-1&quot;; reverse(s1.begin(), s1.end()); reverse(s2.begin(), s2.end()); string s(1000, &apos;0&apos;); for (int i = 0; i &lt; s1.length(); i++) s[i] = s1[i]; for (int i = 0; i &lt; s2.length(); i++) &#123; if (s[i] &gt;= s2[i]) s[i] = s[i] - &apos;0&apos; - (s2[i] - &apos;0&apos;) + &apos;0&apos;; else &#123; s[i + 1] = s[i + 1] - &apos;0&apos; - 1 + &apos;0&apos;; s[i] = s[i] - &apos;0&apos; + 10 - (s2[i] - &apos;0&apos;) + &apos;0&apos;; &#125; &#125; reverse(s.begin(), s.end()); if (s.find_first_not_of(&apos;0&apos;) == string::npos) return &quot;0&quot;; else return s.substr(s.find_first_not_of(&apos;0&apos;));&#125;int main()&#123; string s1, s2; while (cin &gt;&gt; s1 &gt;&gt; s2) &#123; string s(1000, &apos;0&apos;); if (strComp(s1, s2) == 1) &#123; cout &lt;&lt; &quot;0&quot; &lt;&lt; endl; continue; &#125; int len1 = s1.length(); int len2 = s2.length(); int dis = len1 - len2; for (int i = 0; i &lt; dis; i++) s2 += &apos;0&apos;; string ans(1000, &apos;0&apos;); while (dis &gt;= 0) &#123; int sum = 0; string temp; while ((temp = Sub(s1, s2)) != &quot;-1&quot;) &#123; sum++; s1 = temp; &#125; ans[ans.length() - dis - 1] = sum + &apos;0&apos;; dis--; s2 = s2.substr(0, len2 + dis); &#125; if (ans.find_first_not_of(&apos;0&apos;) == string::npos) cout &lt;&lt; &quot;0&quot; &lt;&lt; endl; else &#123; string res = ans.substr(ans.find_first_not_of(&apos;0&apos;)); cout &lt;&lt; res &lt;&lt; endl; &#125; &#125; return 0;&#125; 大数取模12345678910typedef long long ll;cin &gt;&gt; s;ll ans, num;ll l = strlen(s);num = 0;for (ll i = 0; i &lt; l; i++)&#123; num = num * 10 + s[i] - &apos;0&apos;; num %= maxx;&#125; 图论最小生成树kruskal12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;struct city&#123; int a; int b; int p;&#125; c[105];int p[105];int find(int x)&#123; return p[x] != x ? p[x] = find(p[x]) : x;&#125;void join(int x, int y)&#123; x = find(x); y = find(y); if (x != y) p[y] = x;&#125;bool cmp(city x, city y)&#123; return x.p &lt; y.p;&#125;int main()&#123; int n, m; while (cin &gt;&gt; n &gt;&gt; m) &#123; int sum = 0; if (n == 0) break; for (int i = 1; i &lt;= m; i++) p[i] = i; for (int i = 0; i &lt; n; i++) cin &gt;&gt; c[i].a &gt;&gt; c[i].b &gt;&gt; c[i].p; sort(c, c + n, cmp); for (int i = 0; i &lt; n; i++) &#123; if (find(c[i].a) != find(c[i].b)) &#123; join(c[i].a, c[i].b); sum += c[i].p; &#125; &#125; int flag = 0; for (int i = 1; i &lt;= m; i++) &#123; if (p[i] == i) flag++; &#125; if (flag == 1) cout &lt;&lt; sum &lt;&lt; endl; else puts(&quot;?&quot;); &#125; return 0;&#125; 最短路——Dijkstra123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4 + 5;const int INF = 0x3f3f3f3f;int a[maxn][maxn];int dis[maxn];bool vis[maxn];int n, m, u, v, w;struct node&#123; int d, id;&#125;;bool operator &lt;(const node &amp;a, const node &amp;b)&#123; return a.d &gt; b.d;&#125;priority_queue&lt;node&gt; que;void Dijkstra()&#123; for (int i = 1; i &lt;= n; i++) dis[i] = INF; dis[1] = 0; que.push(node&#123; dis[1], 1 &#125;); while (!que.empty()) &#123; node p = que.top(); que.pop(); int mid = p.id; if (vis[mid] == 1) continue; vis[mid] = 1; for (int i = 1; i &lt;= n; i++) &#123; if (dis[i] &gt; dis[mid] + a[mid][i]) &#123; dis[i] = dis[mid] + a[mid][i]; que.push(node&#123; dis[i], i &#125;); &#125; &#125; &#125; cout &lt;&lt; dis[n] &lt;&lt; endl;&#125;int main()&#123; while (scanf(&quot;%d %d&quot;, &amp;n, &amp;m) &amp;&amp; (n &amp;&amp; m)) &#123; memset(vis, 0, sizeof(vis)); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) a[i][j] = INF; for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; a[u][v] = w; a[v][u] = w; &#125; Dijkstra(); &#125;&#125; 搜索DFS1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int book[10], a[10], n;void dfs(int step)&#123; int i; if (step == n + 1)//当你在第n+1步的时候，说明前n部已经排好了。 &#123; for (i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, a[i]); printf(&quot;\n&quot;); return; //返回之前的一步； &#125; for (i = 1; i &lt;= n; i++) //按照1，2，3.。。的方式一一尝试。 &#123; if (book[i] == 0) //判断扑克牌i是不是还在手里 &#123; a[step] = i; //将i牌放在第step个盒子里。 book[i] = 1; //表示扑克牌不再第step个盒子里 dfs(step + 1); //继续下一步。 book[i] = 0; //将刚才尝试的扑克收回，才能进行下一步的尝试。 &#125; &#125; return; //结束搜索。&#125;int main()&#123; while (~scanf(&quot;%d&quot;, &amp;n)) dfs(1); return 0;&#125; BFS12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;#define pill pair&lt;int,int&gt;int sx,sy,ex,ey,n;char ma[1050][1050];int vis[1050][1050];int step[1050][1050];int d[4][2]=&#123;-1,0,0,1,1,0,0,-1&#125;;queue&lt;pair&lt;int,int&gt; &gt;que;void bfs(int x,int y)&#123; vis[x][y]=1; que.push(pill(x,y)); while(!que.empty()) &#123; x=que.front().first; y=que.front().second; que.pop(); for(int i=0;i&lt;4;i++) &#123; int xx=x+d[i][0]; int yy=y+d[i][1]; if(ma[xx][yy]==&apos;#&apos;||xx&lt;0||xx&gt;=n||yy&lt;0||yy&gt;=n||vis[xx][yy]==1) continue; que.push(pill(xx,yy)); vis[xx][yy]=1; step[xx][yy]=step[x][y]+1; &#125; &#125;&#125;int main()&#123; while(cin&gt;&gt;n) &#123; memset(vis,0,sizeof(vis)); for(int i=0;i&lt;n;i++) &#123; scanf(&quot;%s&quot;,ma[i]); &#125; &#125;&#125; 动态规划编辑距离12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 1050;int f[maxn][maxn];string a, b;bool same(char x, char y)&#123; if (x == y) return 0; return 1;&#125;int main()&#123; while (cin &gt;&gt; a &gt;&gt; b) &#123; memset(f, 0, sizeof(f)); for (int i = 0; i &lt;= a.size(); i++) &#123; for (int j = 0; j &lt;= b.size(); j++) &#123; if (i == 0) f[i][j] = j; else if (j == 0) f[i][j] = i; else f[i][j] = min(f[i - 1][j - 1] + same(a[i - 1], b[j - 1]), min(f[i - 1][j] + 1, f[i][j - 1] + 1)); &#125; &#125; cout &lt;&lt; f[a.size()][b.size()] &lt;&lt; endl; &#125; return 0;&#125; 最长公共子序列12345678910111213141516171819202122232425262728293031323334353637#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;stack&gt;using namespace std;const int maxn = 1050;int dp[maxn][maxn];char a[maxn], b[maxn];int main()&#123; scanf(&quot;%s %s&quot;, a + 1, b + 1); int n = strlen(a + 1), m = strlen(b + 1); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) &#123; if (a[i] == b[j]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); &#125; stack&lt;char&gt; ans; while (n &gt;= 1 &amp;&amp; m &gt;= 1) &#123; if (dp[n][m] == 0) break; if (dp[n][m] - dp[n - 1][m - 1] == 1 &amp;&amp; dp[n - 1][m - 1] == dp[n - 1][m] &amp;&amp; dp[n - 1][m - 1] == dp[n][m - 1]) &#123; ans.push(a[n]); n--; m--; &#125; else if (dp[n][m] == dp[n - 1][m] &amp;&amp; n &gt; 1) n--; else if (dp[n][m] == dp[n][m - 1] &amp;&amp; m &gt; 1) m--; &#125; while (!ans.empty()) &#123; printf(&quot;%c&quot;, ans.top()); ans.pop(); &#125; puts(&quot;&quot;); return 0;&#125; 最长递增子序列12345678910111213141516171819#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 50050;const int INF = 0x3f3f3f3f;int dp[maxn], a[maxn];int main()&#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; fill(dp, dp + n, INF); for (int i = 0; i &lt; n; i++) &#123; *lower_bound(dp, dp + n, a[i]) = a[i]; &#125; cout &lt;&lt; lower_bound(dp, dp + n, INF) - dp &lt;&lt; endl;&#125; 最大子段和1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;int main()&#123; int n, now; long long maxsum, sum; while (cin &gt;&gt; n) &#123; maxsum = sum = 0; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; now; sum = max(sum, 0LL) + now; maxsum = max(sum, maxsum); &#125; cout &lt;&lt; maxsum &lt;&lt; endl; &#125; return 0;&#125; 换零钱123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll solve(ll x)&#123; int coins[13] = &#123; 1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 2000, 5000, 10000 &#125;; ll dp[100005] = &#123; 0 &#125;; dp[0] = 1; for (int i = 0; i &lt; 13; i++) &#123; for (int j = coins[i]; j &lt;= x; j++) &#123; dp[j] = (dp[j] + dp[j - coins[i]]) % 1000000007; &#125; &#125; return dp[x];&#125;int main()&#123; ll t, a; cin &gt;&gt; t; while (t--) &#123; cin &gt;&gt; a; cout &lt;&lt; solve(a) &lt;&lt; endl; &#125;&#125; 计算几何求多边形面积123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;int main()&#123; int ncase; cin &gt;&gt; ncase; int x, y, x0, y0, sum = 0; cin &gt;&gt; x &gt;&gt; y; x0 = x; y0 = y; while (--ncase) &#123; int xtmp, ytmp; cin &gt;&gt; xtmp &gt;&gt; ytmp; sum += (x * ytmp - y * xtmp); x = xtmp; y = ytmp; &#125; sum += (x * y0 - y * x0); printf(&quot;%d\n&quot;, int(abs(sum) / 2)); return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kruskal]]></title>
    <url>%2Fblog%2F2019%2F06%2F02%2FKruskal%2F</url>
    <content type="text"><![CDATA[Who is confessing now, is confession not giving others the opportunity to refuse? If she is willing to go out with you, you will take her to the night and then hold her hand. If she is willing to hold hands with you, you will kiss her.Link: HDU-1863 畅通工程Description:省政府“畅通工程”的目标是使全省任何两个村庄间都可以实现公路交通（但不一定有直接的公路相连，只要能间接通过公路可达即可）。经过调查评估，得到的统计表中列出了有可能建设公路的若干条道路的成本。现请你编写程序，计算出全省畅通需要的最低成本。 Input测试输入包含若干测试用例。每个测试用例的第1行给出评估的道路条数 N、村庄数目M ( &lt; 100 )；随后的 N行对应村庄间道路的成本，每行给出一对正整数，分别是两个村庄的编号，以及此两村庄间道路的成本（也是正整数）。为简单起见，村庄从1到M编号。当N为0时，全部输入结束，相应的结果不要输出。 Output对每个测试用例，在1行里输出全省畅通需要的最低成本。若统计数据不足以保证畅通，则输出“?”。 Sample Input3 31 2 11 3 22 3 41 32 3 20 100 Sample Output3? The main thought of this problem is union-find.Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;struct city&#123; int a; int b; int p;&#125; c[105];int p[105];int find(int x)&#123; return p[x] != x ? p[x] = find(p[x]) : x;&#125;void join(int x, int y)&#123; x = find(x); y = find(y); if (x != y) p[y] = x;&#125;bool cmp(city x, city y)&#123; return x.p &lt; y.p;&#125;int main()&#123; // freopen(&quot;../in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;../out.txt&quot;, &quot;w&quot;, stdout); int n, m; while (cin &gt;&gt; n &gt;&gt; m) &#123; int sum = 0; if (n == 0) break; for (int i = 1; i &lt;= m; i++) p[i] = i; for (int i = 0; i &lt; n; i++) cin &gt;&gt; c[i].a &gt;&gt; c[i].b &gt;&gt; c[i].p; sort(c, c + n, cmp); for (int i = 0; i &lt; n; i++) &#123; if (find(c[i].a) != find(c[i].b)) &#123; join(c[i].a, c[i].b); sum += c[i].p; &#125; &#125; int flag = 0; for (int i = 1; i &lt;= m; i++) &#123; if (p[i] == i) flag++; &#125; if (flag == 1) cout &lt;&lt; sum &lt;&lt; endl; else puts(&quot;?&quot;); &#125; return 0;&#125; Recommend: 算法导论--最小生成树（Kruskal和Prim算法） Interjection: &quot;spirited away&quot; was released on June 21st. Do you want to go see it together?]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>c/c++</tag>
        <tag>Greedy</tag>
        <tag>HDU</tag>
        <tag>union-find</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ with Atom]]></title>
    <url>%2Fblog%2F2019%2F06%2F02%2Fuse_atom%2F</url>
    <content type="text"><![CDATA[Because the unknown bug in sublime and dev,I choose atom to satisfy my my needs for c++ programming and markdown.I think I can&#39;t teach you how to install atom clearly,so there has more links to what blog I saw when I install atom. InstallClick here to install Choose your suitable version.When the install begin,what you should do just is wait,atom will do everything itself for you. Attention: If you can&#39;t installed on the official website.Click here：https://pan.baidu.com/s/1xpP2G0qsaB_ciXvd9d9juQExtraction code：78aa If the above two conditions can not solve your installation problem.Just connect me through email or comment.I&#39;d like to help you.An important step-Configuration compilation environment Install MinGWClick here to installTo solve this there are many tutorial on the web.So I will not spend more time on this.recommend: MinGW.When you finish this step,You are not far from success.Install some useful packages(c++). linter-gcc2 linterrecommend: c++Install some useful packages(markdown) markdown-preview-plus markdown-scroll-sync language-markdown markdown-image-paste markdown-table-editor markdown-themeable-pdf、pdf-viewrecommend: markdown There are many useful and beautiful packages in atom,and you can manage them easier than sublime. If you still have some problems,just comment here or send a email to me.]]></content>
      <categories>
        <category>Tutorial</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>Tutorial</tag>
        <tag>Atom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大的湖]]></title>
    <url>%2Fblog%2F2019%2F05%2F26%2Fnowcoder-910-D%2F</url>
    <content type="text"><![CDATA[The first BFS problem I have solved by myself. 最大的湖Link&quot; nowcoder-910-DDescription:农场主约翰的农场在最近的一场风暴中被洪水淹没，这一事实只因他的奶牛极度害怕水的消息而恶化。 然而，他的保险公司只会根据他农场最大的“湖”的大小来偿还他一笔钱。 农场表示为一个矩形网格，有N（1≤N≤100）行和M（1≤M≤100）列。网格中的每个格子要么是干的， 要么是被淹没的，而恰好有K（1≤K≤N×M）个格子是被淹没的。正如人们所期望的，一个“湖”有一个 中心格子，其他格子通过共享一条边（只有四个方向，对角线不算的意思）与之相连。任何与中央格子共享一条边或与中央格 子相连的格子共享一条边的格子都将成为湖的一部分。 输入描述:第一行有三个整数N,M,K，分别表示这个矩形网格有N行，M列，K个被淹没的格子。 接下来K行，每一行有两个整数R,C。表示被淹没的格子在第R行，第C列。输出描述:输出最大的“湖”所包含的格子数目示例1输入3 4 53 22 23 12 31 1输出4 Intentional analysis:My solution to this problem is According to the input structure diagram and then proceed BFS. Click to see Chinese Intentional analysis通过输入构造图然后进行BFS。为了防止各种绕弯，我对下标进行了操作。 Code：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;char s[105][105];int d[4][2]=&#123;0,-1, -1,0, 0,1, 1,0&#125;;bool flag[105][105];int n,m,k,a,b,anss=0;queue&lt;pair&lt;int,int&gt; &gt; que;#define pil pair&lt;int,int&gt;int bfs(int x,int y)&#123; memset(flag,0,sizeof(flag)); flag[x][y]=1; int ans=1; que.push(pil(x,y)); while(!que.empty()) &#123; x=que.front().first; y=que.front().second; que.pop(); for(int i=0;i&lt;4;i++) &#123; int xx=x+d[i][0]; int yy=y+d[i][1]; if(xx&lt;0||yy&lt;0||xx&gt;=n||yy&gt;=m||s[xx][yy]==&apos;#&apos;||flag[xx][yy]==1) continue; else &#123; flag[xx][yy]=1; ans++; que.push(pil(xx,yy)); &#125; &#125; &#125; return ans;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) &#123; s[i][j]=&apos;#&apos;; &#125; while(k--) &#123; cin&gt;&gt;a&gt;&gt;b; s[a-1][b-1]=&apos;@&apos;; &#125; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;=m;j++) &#123; if(s[i][j]==&apos;@&apos;) anss=max(bfs(i,j),anss); &#125; &#125; cout&lt;&lt;anss&lt;&lt;endl;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>nowcoder</tag>
        <tag>Thinking</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[风雨无阻]]></title>
    <url>%2Fblog%2F2019%2F05%2F26%2Fnowcoder-900-A%2F</url>
    <content type="text"><![CDATA[Becouse all kinds of reasons,I haven&#39;t done a problem for a long time.But the main is I&#39;m tired.As the saying goes&quot;I also paid, but why are they so strong?&quot; 风雨无阻Links: 风雨无阻Description:许cosin的宝贝手表被他的仇人gen海偷走了。他决定秘密前往gen海家，去找回他的手表。许cosin历经千辛万苦，耗时3天，终于找到了gen海家。他通过观察发现gen海不在家，于是他决定偷偷潜入gen海家，然后找回手表。但他在gen海家的门前发现了一个密码锁，他必须解开这个锁才能进入gen海家。可是许cosin实在是太silly了，于是他就向你请教。请快速解决这个问题，gen海还有1秒就会回家了。锁上有两行，第一行一个数字N。第二行是一串字符串S（|S|≤6*105），字符串由许多子串构成，每个子串的格式均是XA其中X是一个运算符，A是一个数字。X可能是*，+，-，%，^（^表示次方）。现在需要把数字N代入字符串S，从左到右进行运算。密码就是运算结果的绝对值。 题目保证运算过程中N在int(-2147483648~2147483647)范围内，^后面的数字只能为2。运算过程从左至右，不满足运算的优先级（详见样例）输入描述:两行，第一行一个正整数N第二行是一个字符串S输出描述:一个数，表示运算结果的绝对值示例1输入5-7*3输出6说明5-7=-2 -2*3=-6 |-6|=6 Intentional analysis:When I first saw this problem,I think i can AC it easily through the &quot;eval&quot; in python.But,there is no need to consider the precedence of operators here.So I give it up and choose c/c++.I think the main thought is simulation.Process the string.But a other problem came is that a nubmer maybe many chars.So we must process the string with a special way instead of one by one which is wrong. Click to see Chinese Intentional analysis第一眼看到这个题，我直接想到了python中的eval函数，但是发现题目要求的是不考虑运算符的优先级，所以这个就不能用了。我有回归本行使用c/c++来写，就是一个简单的模拟，但是每次出现的数字它不一定只有一位，这就是这道题麻烦的地方，我选择了用字符串数组存起来每个数，因为题目保证每个运算符后面一定会有数字，所以只要按着顺序来就行，还有个麻烦的地方就是字符串跟整型之间的运算，即将字符串类型转换为整形。一开始我直接模拟了一下转换过程，也是过了这道题，后来我想到一个很方便的函数——stoi。基本作用就是直接将string类型转换为整型。关于这个函数我在这篇博文下面有详细的介绍，有兴趣的可以看一下。 My fisrt code:1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;string mid[100005];ll zh(string x)&#123; ll ans=0,m,j=1; for(int i=x.size()-1;i&gt;=0;i--) &#123; m=(x[i]-&apos;0&apos;)*j; j*=10; ans+=m; &#125; return ans;&#125;int main()&#123; ll a,j=0; string s; cin&gt;&gt;a&gt;&gt;s; for(int i=0;i&lt;s.size();i++) &#123; if(s[i]&gt;=&apos;0&apos;&amp;&amp;s[i]&lt;=&apos;9&apos;) &#123; mid[j]+=s[i]; &#125; else j++; &#125; j=1; for(int i=0;i&lt;s.size();i++) &#123; if(s[i]&gt;=&apos;0&apos;&amp;&amp;s[i]&lt;=&apos;9&apos;) &#123; continue; &#125; if(s[i]==&apos;+&apos;) a+=zh(mid[j]); if(s[i]==&apos;-&apos;) a-=zh(mid[j]); if(s[i]==&apos;%&apos;) a%=zh(mid[j]); if(s[i]==&apos;^&apos;) a*=a; if(s[i]==&apos;*&apos;) a*=zh(mid[j]); j++; &#125; cout&lt;&lt;abs(a)&lt;&lt;endl;&#125; A easy code and a easy thought.After sumbit this code,I thought of a function----&quot;stoi&quot;.It can convert string type directly to int type.So this is more easily!Code:123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;string mid[100005];int main()&#123; ll a,j=0; string s; cin&gt;&gt;a&gt;&gt;s; for(int i=0;i&lt;s.size();i++) &#123; if(s[i]&gt;=&apos;0&apos;&amp;&amp;s[i]&lt;=&apos;9&apos;) &#123; mid[j]+=s[i]; &#125; else j++; &#125; j=1; for(int i=0;i&lt;s.size();i++) &#123; if(s[i]&gt;=&apos;0&apos;&amp;&amp;s[i]&lt;=&apos;9&apos;) &#123; continue; &#125; if(s[i]==&apos;+&apos;) a+=stoi(mid[j]); if(s[i]==&apos;-&apos;) a-=stoi(mid[j]); if(s[i]==&apos;%&apos;) a%=stoi(mid[j]); if(s[i]==&apos;^&apos;) a*=a; if(s[i]==&apos;*&apos;) a*=stoi(mid[j]); j++; &#125; cout&lt;&lt;abs(a)&lt;&lt;endl;&#125; Something about convert type(from string to int/long long):reference: cppreference.comTo_intTo_longTo_long longstoi( const std::string&amp; str, std::size_t* pos = 0, int base = 10 ); (since C++11)stol( const std::string&amp; str, std::size_t* pos = 0, int base = 10 ); (since C++11)stoll( const std::string&amp; str, std::size_t* pos = 0, int base = 10 ); (since C++11)If you are converting string to unsiged long/long long,use stoul/stoull instead of stol/stoll.To_floatTo_doubleTo_long doublestof( const std::string&amp; str, std::size_t* pos = 0 ); (since C++11)stod( const std::string&amp; str, std::size_t* pos = 0 ); (since C++11)stold( const std::string&amp; str, std::size_t* pos = 0 ); (since C++11)These looks like similar. You may think these function are obscure,just use it. Like I solve this problem. Example:123456789101112131415161718192021222324252627Input:#include &lt;iostream&gt;#include &lt;string&gt;int main()&#123; std::string str1 = &quot;45&quot;; std::string str2 = &quot;3.14159&quot;; std::string str3 = &quot;31337 with words&quot;; std::string str4 = &quot;words and 2&quot;; int myint1 = std::stoi(str1); int myint2 = std::stoi(str2); int myint3 = std::stoi(str3); // error: &apos;std::invalid_argument&apos; // int myint4 = std::stoi(str4); std::cout &lt;&lt; &quot;std::stoi(\&quot;&quot; &lt;&lt; str1 &lt;&lt; &quot;\&quot;) is &quot; &lt;&lt; myint1 &lt;&lt; &apos;\n&apos;; std::cout &lt;&lt; &quot;std::stoi(\&quot;&quot; &lt;&lt; str2 &lt;&lt; &quot;\&quot;) is &quot; &lt;&lt; myint2 &lt;&lt; &apos;\n&apos;; std::cout &lt;&lt; &quot;std::stoi(\&quot;&quot; &lt;&lt; str3 &lt;&lt; &quot;\&quot;) is &quot; &lt;&lt; myint3 &lt;&lt; &apos;\n&apos;; //std::cout &lt;&lt; &quot;std::stoi(\&quot;&quot; &lt;&lt; str4 &lt;&lt; &quot;\&quot;) is &quot; &lt;&lt; myint4 &lt;&lt; &apos;\n&apos;;&#125;Output:std::stoi(&quot;45&quot;) is 45std::stoi(&quot;3.14159&quot;) is 3std::stoi(&quot;31337 with words&quot;) is 31337]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>nowcoder</tag>
        <tag>Thinking</tag>
        <tag>functions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[灰魔法师]]></title>
    <url>%2Fblog%2F2019%2F05%2F25%2Fnowcoder-215-A%2F</url>
    <content type="text"><![CDATA[A problem was met in a prgramming contest before.When I tried to solve this I find it&#39;s a meaningful problem. 灰魔法师Links: nowcoder-215-BHPUOJ-contest-3-BDescription:“White shores, and beyond. A far green country under a swift sunrise.”--灰魔法师 给出长度为n的序列a, 求有多少对数对 (i, j) (1 &lt;= i &lt; j &lt;= n) 满足 ai + aj 为完全平方数。输入描述:第一行一个整数 n (1 &lt;= n &lt;= 105)第二行 n 个整数 ai (1 &lt;= ai &lt;= 105)输出描述:输出一个整数，表示满足上述条件的数对个数。示例1输入31 3 6输出2说明满足条件的有 (1, 2), (2, 3) 两对。 Intentional analysis:We should use a tag array because the data range is too large and the violence will time out.For this way,this problem is easy too. Code:12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=200050;int a[maxn];int main()&#123; int n,x,ans=0; cin&gt;&gt;n; while(n--) &#123; cin&gt;&gt;x; for(int i=1;i*i&lt;=maxn;i++) if(i*i&gt;x) ans+=a[i*i-x]; a[x]++; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; The reason why I said this problem is meaningful is a thought,a &quot;flag&quot; thought,which can reduce the time the program runs to avoid TLE.]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>nowcoder</tag>
        <tag>HPUOJ</tag>
        <tag>Thinking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Little knowledge point(Reprint)]]></title>
    <url>%2Fblog%2F2019%2F05%2F20%2FLittle_knowledge_point%2F</url>
    <content type="text"><![CDATA[Something we&#39;d better know. Original link: Lesroad 能被2、3、4、5、6、7、8、9等数整除的数的特征性质1：如果数a、b都能被c整除，那么它们的和（a+b）或差(a－b)也能被c整除。 性质2：几个数相乘，如果其中有一个因数能被某一个数整除，那么它们的积也能被这个数整除。 能被2整除的数，个位上的数能被2整除（偶数都能被2整除），那么这个数能被2整除 能被3整除的数，各个数位上的数字和能被3整除，那么这个数能被3整除 能被4整除的数，个位和十位所组成的两位数能被4整除，那么这个数能被4整除 能被5整除的数，个位上为0或5的数都能被5整除，那么这个数能被5整除 能被6整除的数，各数位上的数字和能被3整除的偶数，如果一个数既能被2整除又能被3整除，那么这个数能被6整除 能被7整除的数，若一个整数的个位数字截去，再从余下的数中，减去个位数的2倍，如果差是7的倍数，则原数能被7整除。如果差太大或心算不易看出是否7的倍数，就需要继续上述「截尾、倍大、相减、验差」的过程，直到能清楚判断为止。例如，判断133是否7的倍数的过程如下：13－3×2＝7，所以133是7的倍数；又例如判断6139是否7的倍数的过程如下：613－9×2＝595 ， 59－5×2＝49，所以6139是7的倍数，余类推。 能被8整除的数，一个整数的末3位若能被8整除，则该数一定能被8整除。 能被9整除的数，各个数位上的数字和能被9整除，那么这个数能被9整除 能被10整除的数，如果一个数既能被2整除又能被5整除，那么这个数能被10整除（即个位数为零） 能被11整除的数，奇数位（从左往右数）上的数字和与偶数位上的数字和之差（大数减小数）能被11整除，则该数就能被11整除。 11的倍数检验法也可用上述检查7的「割尾法」处理！过程唯一不同的是：倍数不是2而是1！能被12整除的数，若一个整数能被3和4整除，则这个数能被12整除 能被13整除的数，若一个整数的个位数字截去，再从余下的数中，加上个位数的4倍，如果差是13的倍数，则原数能被13整除。如果差太大或心算不易看出是否13的倍数，就需要继续上述「截尾、倍大、相加、验差」的过程，直到能清楚判断为止。 能被17整除的数，若一个整数的个位数字截去，再从余下的数中，减去个位数的5倍，如果差是17的倍数，则原数能被17整除。如果差太大或心算不易看出是否17的倍数，就需要继续上述「截尾、倍大、相减、验差」的过程，直到能清楚判断为止。 另一种方法：若一个整数的末三位与3倍的前面的隔出数的差能被17整除，则这个数能被17整除 能被19整除的数，若一个整数的个位数字截去，再从余下的数中，加上个位数的2倍，如果差是19的倍数，则原数能被19整除。如果差太大或心算不易看出是否19的倍数，就需要继续上述「截尾、倍大、相加、验差」的过程，直到能清楚判断为止。 另一种方法：若一个整数的末三位与7倍的前面的隔出数的差能被19整除，则这个数能被19整除 能被23整除的数，若一个整数的末四位与前面5倍的隔出数的差能被23(或29)整除，则这个数能被23整除 能被25整除的数，十位和个位所组成的两位数能被25整除。 能被125整除的数，百位、十位和个位所组成的三位数能被125整除。]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Useful</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[棋盘问题]]></title>
    <url>%2Fblog%2F2019%2F05%2F20%2Fpoj-1321%2F</url>
    <content type="text"><![CDATA[I dont&#39;t want be a Iron man!!! poj-1321-棋盘问题Links: poj-1321Description:在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。Input 输入含有多组测试数据。每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n &lt;= 8 , k &lt;= n当为-1 -1时表示输入结束。随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。Output 对于每一组数据，给出一行输出，输出摆放的方案数目C数据保证C\&lt;2^31）。Sample Input 2 1 #..#4 4...#..#..#.. #...-1 -1Sample Output 21 To solve this problem,you should clear about the judge conditions——Each line and each column cannot have a piece at the same time. Click to see Chinese Intentional analysis这道题跟八皇后很像，就是判断条件不太一样，每一行和每一列不能同时有棋子，具体看代码注释。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;char s[10][10];//The mapint flag[10];//Record whether a column has been put on the chess pieceint n,k,ans,anss;//anss represents how many pieces have been placed now.ans is the final answer.void dfs(int now)&#123; if(k==anss)//All the pieces are finished. &#123; ans++; return ; &#125; if(now&gt;=n)//Boundary conditions return ; for(int j=0;j&lt;n;j++) &#123; if(flag[j]==0&amp;&amp;s[now][j]==&apos;#&apos;)//Judge whether you can put down the pieces here. &#123; flag[j]=1; anss++; dfs(now+1); flag[j]=0;//For the back anss--; &#125; &#125; dfs(now+1);&#125;int main()&#123; while(cin&gt;&gt;n&gt;&gt;k) &#123; memset(s,0,sizeof(s)); ans=0; if(n==-1&amp;&amp;k==-1) break; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) cin&gt;&gt;s[i][j]; dfs(0); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; Click to see Chinese code1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;char s[10][10];//存起来的图int flag[10];//标记这一列已经放过棋子int n,k,ans,anss;//anss是现在已经放上去的棋子，ans是最后的答案void dfs(int now)&#123; if(k==anss) &#123; ans++; return ; &#125; if(now&gt;=n) return ; for(int j=0;j&lt;n;j++) &#123; if(flag[j]==0&amp;&amp;s[now][j]==&apos;#&apos;)//判断这个位置是否可以放棋子 &#123; flag[j]=1; anss++; dfs(now+1); flag[j]=0;//为了回溯 anss--; &#125; &#125; dfs(now+1);&#125;int main()&#123; while(cin&gt;&gt;n&gt;&gt;k) &#123; memset(s,0,sizeof(s)); ans=0; if(n==-1&amp;&amp;k==-1) break; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) cin&gt;&gt;s[i][j]; dfs(0); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>DFS</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ICPC-Invitational in Xi'an]]></title>
    <url>%2Fblog%2F2019%2F05%2F20%2FIron-man%2F</url>
    <content type="text"><![CDATA[International Collegiate Programming Contest-Xi&#39;an 机缘巧合下，被选去参加了5.18-19的西安邀请赛。 等了好久，终于等到5.17的晚上。早早的到了火车站，我们需要从焦作先到郑州然后再转车去西安。去郑州还是很快的，但是我们也是第一次倒车，摸索着摸索着就会了呗。去西安的车是硬卧，还是第一次坐硬卧，空间也太狭小了。而且路上总会很颠簸，睡眠得质量还是不是很好的。到了西安，下来火车，映入眼帘得就是一个城墙，果然壮观。据老师跟我们说的，我们需要先坐公交去找他会和。找到他之后，我们去坐下一个公交。路上去吃了西安得“正宗”的胡辣汤，跟我们这里“正宗”得胡辣汤一点都不一样，那时我才反应过来，哦，原来这种“正宗”都是自己给自己加的！下一班公交要坐两个小时，这时已经略微有点倦意。路上还看到了秦岭，真的是连绵不绝。 到了学校下了车，进了学校，经过了一个耗资两亿的图书馆，看了看沿途学校的风景，挺美的。跟着老师一起去签到，领了参赛牌和衣服，衣服是橙色的，不是很喜欢，不过毕竟是白嫖的。等这些事都忙完已经十一点多了，下午两点多还得到这参加开幕式，我和两个队友就决定不去宾馆在这个学校转转。老师去宾馆处理事情，我们仨就在学校转悠起来。转完之后，坐在签到处等着开幕式，然后又一次机缘巧合下，没去开幕式。 三点多的时候，已经让进机房了(应该是因为是邀请赛，所以没有在体育馆进行，还是有点可惜的。里面的安排是两个位置坐三个人，而且地方特别小，幸亏我跟我的队友都比较瘦。电脑上也没有dev，有个clione还有codeblock什么的，还支持python。热身赛一共三道题，印象中开始没多久，旁边的那一队就AK了，那时候我们应该是才做出来一道题，而且下面的题毫无思路。一阵阵的伤心，不过最后随着队友的爆发和板子终于是过了两题了。最后一道题队友用python两行写了出来，可是发现题目中要求的是int32，而python中没有这个，导致样例都没过，然后两个队友就开始商量着模拟爆int32得处理，可是最后也莫得实现。距离五点半(比赛结束，只剩不到十分钟了，我说直接交一发吧，队友说肯定不会过毕竟样例都没过，我想的就是就算不过我们也要WA一发，证明我们来过啊。在我的怂恿下队友交了，还有一个队友说：这要是能过，我吃X，然后过了，过了。不知道是评测数据水了还是样例唬人，AK得感觉还是很好的。 做完题我们拿着饭票去食堂吃饭，但是我们一致决定不在学校吃了，就走着回宾馆，顺便在路上吃个饭，我们找到一家泡馍，就点了三碗，刚开始吃还是挺好吃的，但是吃了一会发现越来越油。可能没有找对地方吧。吃完饭回到宾馆就没事了，洗了个澡，玩会手机就睡了。 第二天早上起来，在宾馆吃了早餐，坐着大巴去学校，老师就回去了，我们三个到学校的时候还有点早，就站了一会，等到八点四十左右就进去机房了。总共13道题，第一道巨水，过了之后发现后面的题都不简单。然后一个队友开了L，发现可以找规律做，别的也没有思路，我们就开始一起找规律，找啊找啊，找了好久也没找到，这时候发现L和M过了好多，我们又看了M，一个队友说是什么图啊什么的，我就直接去看L了，最后还是队友强，找到规律过了L。周围的队都太强了，三四个气球，我们才两个。到了中午开始发吃的了，每个人发了一个那种“汉堡”还有一个面包一盒奶，本来以为这就结束了，最后又给每个人发了一袋零食，薯片啊，面包啊什么的。不过那个我和队友一点都没吃提了回来。过了一会我们有发现D好像可以写，然后队友写出来了D，一测样例发现第一个样例可以过，第二个样例过不去。我们一起手算了第二个样例，发现跟我们程序跑的一样跟样例也不一样，不敢交，可是我们也找不到更好的答案了，最后我们也知道了一定会打铁的事实，就直接破罐子破摔交了，然后又过了，过了。我枯了。 比赛结束之后我们坐着大巴到了一个地铁站，然后坐地铁到了钟楼，出来地铁去了回民街，刚进去就看到了一堆人，一堆，而且里面好多外国人，感觉自己就像村里人进城一样。说好给小伙伴带好吃的好玩的回去，结果转了好大一圈也没有发现什么好带的。最后我们每个人买了个肉夹馍，一个肉夹馍花了15块钱。还真是有点坑。这个时候我们已经准备回车站了，到了车站外面，发现不知道怎么去候车厅，问了下路，总算是进了候车厅。回去的车还是卧铺，到了郑州再转去焦作。 这就回来了，两天三夜的行程，真的很累，睡的也不安稳，还背着沉重的书包跑过来跑过去，不但身上累，心里面更累。还是打了个铁，有点失望的吧，不过我也不会气馁，下一年等我卷土重来！]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LIS]]></title>
    <url>%2Fblog%2F2019%2F05%2F14%2F51nod-dp-LIS%2F</url>
    <content type="text"><![CDATA[51nod is good! LISwikipediaDescription:输入 第1行：1个数N，N为序列的长度(2 &lt;= N &lt;= 50000)第2 - N + 1行：每行1个数，对应序列的元素(-10^9 &lt;= S[i] &lt;= 10^9) 输出 输出最长递增子序列的长度。 输入示例1234567898516824510 输出示例15 Code:12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;const int maxn=50050;const int INF=0x3f3f3f3f;int dp[maxn],a[maxn];int main()&#123; int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; &#125; fill(dp,dp+n,INF); for(int i=0;i&lt;n;i++) &#123; *lower_bound(dp,dp+n,a[i])=a[i]; &#125; cout&lt;&lt;lower_bound(dp,dp+n,INF)-dp&lt;&lt;endl;&#125; The main problem solving idea isSo we can use a convenient function,such aslower_bound.Click to know more about lower_boundHonestly, I don&#39;t know what this has to do with DP, but it doesn&#39;t matter, I will always know it later.]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>c/c++</tag>
        <tag>DP</tag>
        <tag>51nod</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大鱼海棠]]></title>
    <url>%2Fblog%2F2019%2F05%2F14%2Fmovie-1%2F</url>
    <content type="text"><![CDATA[You will konw the password if I want you know. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Edit distance]]></title>
    <url>%2Fblog%2F2019%2F05%2F14%2F51nod-dp-Edit-distance%2F</url>
    <content type="text"><![CDATA[I started to learn &quot;Edit distance&quot; though I still can&#39;t understand &quot;LCS&quot; enough.We will always encounter some trenches that cannot be crossed. At this time, we need to go around and wait until we are strong enough to solve this problem. This will never be the reason for us to stop. Edit distancewikipedia:Edit distanceDescription:编辑距离，又称Levenshtein距离（也叫做Edit Distance），是指两个字串之间，由一个转成另一个所需的最少编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。例如将kitten一字转成sitting：sitten （k-&gt;s）sittin （e-&gt;i）sitting （-&gt;g）所以kitten和sitting的编辑距离是3。俄罗斯科学家Vladimir Levenshtein在1965年提出这个概念。给出两个字符串a,b，求a和b的编辑距离。 The problem is easy if you know the state transition equation.1234567//From 51nodwe define the function same(i,j) to be 0 if S[i] == T[j], otherwise 1.Let us show the recursion:f(i,j) = min(f(i – 1, j – 1) + same(i,j), f(i – 1,j ) + 1, f(i, j – 1) + 1)initial value:f(0, j) = jf(i, 0) = i The tutorial above 51nod is really good.Nou just LCS or Edit distance,but every tutorial there.All the follwing are from 51nod.The difficulty of this problem is that it is difficult to have such operations as &quot;add&quot; and &quot;delete&quot;, which is very troublesome. Let&#39;s try to understand the problem from a different angle and see it as a string alignment problem. In fact, we can understand the problem from the perspective of bioinformatics comparison genes. Given the strings S and T, we can use a special character to facilitate the alignment of the two strings. The special character we added is &quot;-&quot;. We allow you to add this special character to S and T so that it is the same length, then &quot;align&quot; the two strings, and finally the two strings appear in the same position with different characters. With 1 point deduction, we want to make these two string alignment points as few as possible. For the example we actually took this alignment: 12345ABCF-DB-FG Note: If you want to align, the two &quot;-&quot; are relatively meaningless, so we ask that this does not happen.Then take a look:(1) S, T corresponding positions are ordinary characters, the same, then no points. For example, the position 2, 4(2) S, T is the normal character, and the difference is 1 point. For example, position 1(3) S is a special character at this position, and T is a normal character at this position, then 1 point is deducted, for example, position 5(4) S is a normal character at this position, and T is a special character at that position, then Deduct 1 point, for example, position 3, let&#39;s see what the deduction points correspond to? (1) No deduction, direct correspondence(2) Corresponding to the character modification of the corresponding positionin T (3) Corresponding to deleting the characterin T (4) Corresponding to adding the character in T , the target is clear, and it feels like Like LCS? Let us try:Let f(i,j) denote the minimum deduction after the alignment of the first i bit of S and the first j bit of T. Then let&#39;s take a look at the last one, the alignment (1) S[i] == T[j] must be used. At this time, the first i – 1 and j – 1 bits are already aligned. This part must be deducted at least. The minimum deduction in this case is f(i-1,j-1)(2) is similar to (1), S[i]≠T[j], in which case the least deduction is f(i) -1, j – 1) + 1(3) The front i position of S and the front (j – 1) bit of T are already aligned, and this part has the least points. In this case, the least deduction is f(i,j-1) + 1(4) The first (i-1) bit of S has been aligned with the first j position of T, which is the least. In this case, the minimum deduction is f(i,j-1) + 1 What is the value of f(i,j), obviously it depends on which case has the least deduction. An example on nowcoder:Link:Edit distanceDescription:UNIX系统下有一个行编辑器ed，它每次只对一行文本做删除一个字符、插入一个字符或替换一个字符三种操作。例如某一行的内容是“ABC”，经过把第二个字符替换成“D”、删除第一个字符、末尾插入一个字符“B”，这三步操作后，内容就变成了“DCB”。即“ABC”变成“DCB”需要经过3步操作，我们称它们的编辑距离为3。现在给你两个任意字符串（不包含空格），请帮忙计算它们的最短编辑距离。 输入描述:输入包含多组数据。 每组数据包含两个字符串m和n，它们仅包含字母，并且长度不超过1024。 输出描述:对应每组输入，输出最短编辑距离。示例1输入ABC CBCDABC DCB输出23 Intentional analysis:A basic Edit distance problem,just use the recursion above. Code:12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 1050;int f[maxn][maxn];string a,b;bool same(char x,char y)&#123; if(x==y) return 0; return 1;&#125;int main()&#123; while(cin&gt;&gt;a&gt;&gt;b) &#123; memset(f,0,sizeof(f)); for(int i=0;i&lt;=a.size();i++) &#123; for(int j=0;j&lt;=b.size();j++) &#123; if(i==0) f[i][j]=j; else if(j==0) f[i][j]=i; else f[i][j]=min(f[i-1][j-1]+same(a[i-1],b[j-1]),min(f[i-1][j]+1,f[i][j-1]+1)); &#125; &#125; cout&lt;&lt;f[a.size()][b.size()]&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>c/c++</tag>
        <tag>DP</tag>
        <tag>51nod</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Find the Tth Char]]></title>
    <url>%2Fblog%2F2019%2F05%2F13%2Famazing-thinking%2F</url>
    <content type="text"><![CDATA[There are all kinds of people in this world. It happens that we have become friends. This is not fate. It is just that we should be friends. ——Green BookWhen I first met a problem which name is Find the Nth Character in nowcoder,I find this problem is interesting for mind.After solving this,I find a similar problem like this in HDU which name is find the Nth digit.Link:Find the Nth Character in nowcoderfind the Nth digit in HDU Find the Nth CharacterDescription:Mr Cheng今天在给HLJU的同学们上程序算法课的时候出了一道找规律的题目，题目表述如下假设：现在要求上课的同学们把所有的串依次连接起来，于是得到:S=aababcabcdabcde...那么你能告诉Mr Cheng在S串中的第N个字母是多少吗？ 输入描述:输入首先是一个数字K，代表有K次询问(1&lt;=K&lt;=1000) 接下来的K行每行有一个整数N(1&lt;=N&lt;=10000) 输出描述:对于每次询问，输出串中第个位置对应的字母。 示例1输入61234510输出aababd Code:123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int t; int n; cin&gt;&gt;t; while (t--) &#123; cin&gt;&gt;n; int a = 1; char ans=&apos;a&apos;; while ( n &gt; a ) &#123; n -= a; a++; &#125; n%=26; if(n==0) n=26; ans+=n-1; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; find the nth digitDescription:假设：S1 = 1S2 = 12S3 = 123S4 = 1234.........S9 = 123456789S10 = 1234567891S11 = 12345678912............S18 = 123456789123456789..................现在我们把所有的串连接起来S = 1121231234.......123456789123456789112345678912.........那么你能告诉我在S串中的第N个数字是多少吗？ Input输入首先是一个数字K，代表有K次询问。接下来的K行每行有一个整数N(1 &lt;= N &lt; 2^31)。 Output对于每个N，输出S中第N个对应的数字. Sample Input61234510 Sample Output112124 Code:123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int t; int n; cin&gt;&gt;t; while (t--) &#123; cin&gt;&gt;n; int a = 1; char ans=&apos;1&apos;; while ( n &gt; a ) &#123; n -= a; a++; &#125; n%=9; if(n==0) n=9; ans+=n-1; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; Intentional analysis:We can easily find there is a few different between these two codes above.In fact,to solve this problem,the main thinking is find the Nth in the correct position.And the regular is121 2 3 4 5 6 7 8 9 10...1 12 123 1234 12345 123456 1234567 12345678 123456789 1234567891... Through this,you may understand this more.I know that what I said is not so clearly,so just think through these codes if you can&#39;t understand enough.]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>nowcoder</tag>
        <tag>Thinking</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Discrete mathematics-Chapter Six]]></title>
    <url>%2Fblog%2F2019%2F05%2F11%2FDiscrete-mathematics-Chapter-Six%2F</url>
    <content type="text"><![CDATA[The program work in Chapter 6 is about sets. In general, it is quite simple, because many functions are implemented in python with related encapsulated functions. Judge an element in a set or not123456789#Judge an element in a set or notprint("Enter the element to be judged:")a = input()print("Enter the set to be judged:")s = set(input().split())if a in s: print("The element %s is in the set %s" % (a,s))else: print("The element %s is not in the set %s" % (a,s)) Judge if a set is a subset of another set1234567891011#Judge if a set is a subset of another setprint("Input a set:")a=set(input().split())print("Input another set")b=set(input().split())if a.issubset(b): print("The set %s is the subset of the set %s" % (a,b))elif b.issubset(a): print("The set %s is the subset of the set %s" % (b,a))else: print("There is no subset relationship between the set %s and the set %s" % (a,b)) Judge if a set is a proper subset of another set1234567891011#Judge if a set is a proper subset of another setprint("Input a set:")a=set(input().split())print("Input another set")b=set(input().split())if len(a)!=len(b) and a.issubset(b): print("The set %s is the proper subset of the set %s" % (a,b))elif len(a)!=len(b) and b.issubset(a): print("The set %s is the proper subset of the set %s" % (b,a))else: print("There is no proper subset relationship between the set %s and the set %s" % (a,b)) Judge if two sets are equal123456789#Judge if two sets are equalprint("Input a set:")a=set(input().split())print("Input another set")b=set(input().split())if a==b: print("The set %s is equal to the set %s" % (a,b))else: print("The set %s is not equal to the set %s" % (a,b)) Judge a collection as an empty set1234567#Judge a collection as an empty setprint("Input a set to be judged:")a=set(input().split())if a: print("The set %s is not an empty set" % (a))else: print("The set is an empty set") Reference artical:https://blog.csdn.net/u013247765/article/details/79052257 Calculate the number of elements in a set1234#Calculate the number of elements in a setprint("Input the set to be calculated:")a=set(input().split())print("The number of elements in the set %s is %d" % (a,len(a))) List a set of power set elements and return the number of elements1234567891011121314151617#List a set of power set elements and return the number of elementsdef powerset(items): N = len(items) sall=[] for i in range(2**N): powers = [] for j in range(N): if(i &gt;&gt; j ) % 2 == 1: #For the i-th bit of the binary of x, if it is 1, this subset contains the ith element of s, otherwise it is not included. powers.append(items[j]) sall.append(powers) return sallprint("Input a set:")a=set(input().split())ans=powerset(list(a))print("The power set of the set %s are:" % (a))print(ans)print("The number of elements is %d" % (len(ans))) Reference artical:https://blog.csdn.net/beyondwdq/article/details/5540386https://blog.csdn.net/luoganttcc/article/details/80785149 Find the union of two sets123456#Find the union of two setsprint("Input a set:")a=set(input().split())print("Input another set:")b=set(input().split())print("the union of set %s and set %s is %s" % (a,b,a|b)) Judge if the intersection of two sets is an empty set12345678910#Judge if the intersection of two sets is an empty setprint("Input a set:")a=set(input().split())print("Input another set:")b=set(input().split())ans=a&amp;bif ans: print("The intersection of set %s and set %s is not an empty set" % (a,b))else: print("The intersection of set %s and set %s is an empty set" % (a,b)) Find the intersection of two sets123456#Find the intersection of two setsprint("Input a set:")a=set(input().split())print("Input another set:")b=set(input().split())print("The intersection of set %s and set %s is %s" % (a,b,a&amp;b)) Find the relative complement of two sets1234567#Find the relative complement of two setsprint("Input a set:")a=set(input().split())print("Input another set:")b=set(input().split())print("The relative complement of set %s and %s is %s" % (a,b,a-b))print("The relative complement of set %s and %s is %s" % (b,a,b-a)) Something about relative complement:baike.baiduWikipedia Find the symmetric difference set of two sets123456#Find the symmetric difference set of two setsprint("Input a set:")a=set(input().split())print("Input another set:")b=set(input().split())print("The symmetric difference set of set %s and set %s is %s" % (a,b,(a|b)-(a&amp;b))) Something about symmetric difference set:baike.baiduWikipedia]]></content>
      <categories>
        <category>Discrete mathematics</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Discrete mathematics</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LCS]]></title>
    <url>%2Fblog%2F2019%2F05%2F09%2F51nod-dp%2F</url>
    <content type="text"><![CDATA[DP is too difficult for me.I can&#39;t explain the code correctly so I just paste it here. LCS 给出两个字符串A B，求A与B的最长公共子序列（子序列不要求是连续的）。比如两个串为： abcicbaabdkscab ab是两个串的子序列，abc也是，abca也是，其中abca是这两个字符串最长的子序列。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//From the internet#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;string a,b;int dp[1050][1050],mark[1050][1050],la,lb;void lcs()&#123; int i,j; memset(dp,0,sizeof(dp)); for(int i=1;i&lt;=la;i++) mark[i][0]=1; for(int i=1;i&lt;=lb;i++) mark[0][i]=-1; for(int i=1;i&lt;=la;i++) &#123; for(int j=0;j&lt;=lb;j++) &#123; if(a[i-1]==b[j-1]) &#123; dp[i][j]=dp[i-1][j-1]+1; mark[i][j]=0; &#125; else if(dp[i-1][j]&gt;=dp[i][j-1]) &#123; dp[i][j]=dp[i-1][j]; mark[i][j]=1; &#125; else &#123; dp[i][j]=dp[i][j-1]; mark[i][j]=-1; &#125; &#125; &#125;&#125;void output(int x,int y)&#123; if(!x&amp;&amp;!y) return ; if(mark[x][y]==0) &#123; output(x-1,y-1); cout&lt;&lt;a[x-1]; &#125; else if(mark[x][y]==1) &#123; output(x-1,y); &#125; else &#123; output(x,y-1); &#125;&#125;int main()&#123; while(cin&gt;&gt;a&gt;&gt;b) &#123; la=a.size();lb=b.size(); lcs(); output(la,lb); cout&lt;&lt;endl; &#125; return 0;&#125; Code:12345678910111213141516171819202122232425262728293031323334353637383940//From boctorio#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;stack&gt;using namespace std;const int maxn = 1050 ;int dp[maxn][maxn];char a[maxn],b[maxn];int main()&#123; scanf(&quot;%s %s&quot;,a+1,b+1); int n=strlen(a+1),m=strlen(b+1); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) &#123; if(a[i]==b[j]) dp[i][j]=dp[i-1][j-1]+1; else dp[i][j]=max(dp[i-1][j],dp[i][j-1]); &#125; stack&lt;char&gt; ans; while(n&gt;=1&amp;&amp;m&gt;=1) &#123; if(dp[n][m]==0) break; if(dp[n][m]-dp[n-1][m-1]==1 &amp;&amp; dp[n-1][m-1]==dp[n-1][m] &amp;&amp; dp[n-1][m-1]==dp[n][m-1]) &#123; ans.push(a[n]); n--; m--; &#125; else if(dp[n][m]==dp[n-1][m] &amp;&amp; n&gt;1) n--; else if(dp[n][m]==dp[n][m-1] &amp;&amp; m&gt;1) m--; &#125; while(!ans.empty()) &#123; printf(&quot;%c&quot;,ans.top()); ans.pop(); &#125; puts(&quot;&quot;); return 0;&#125; You can take part in the tutorial of dp in the 51nod.It&#39;s so good!]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>c/c++</tag>
        <tag>DP</tag>
        <tag>51nod</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A Basic Greedy]]></title>
    <url>%2Fblog%2F2019%2F05%2F06%2FSDUT-2072%2F</url>
    <content type="text"><![CDATA[Greedy is a exacting method for programming,though it is not so good for us. 删数问题link: SDUT-2072 Description:键盘输入一个高精度的正整数n（≤100位），去掉其中任意s个数字后剩下的数字按照原来的左右次序组成一个新的正整数。编程对给定的n与s，寻找一种方案，使得剩下的数字组成的新数最小。Input输入有多组 每组包括原始数n，要去掉的数字数s；Output输出去掉s个数后最小的数Sample Input178543 4Sample Output13Intentional analysis:We&#39;d better use the string type to input.What we should do if find a number in the input which is bigger than it&#39;s next.Like a[i]&gt;a[i+1].And then delete the a[i].There is the greedy.There are many special situations we shoule consider. Can&#39;t find a a[i] which is satisfy a[i]&gt;a[i+1],just output the first n characters The answer string s has &#39;0&#39; at the first,the ordering output should be a number,nao a string.So the front &#39;0&#39; is not allowed. Click to see Chinese Intentional analysis我们输入的应该是字符串，方便操作并且保证数据范围。为了得到消去之后最大的值，我们只需要找到a[i]&gt;a[i+1]的i并将之删除即可。这就是体现贪心的地方。但是我们还需要考虑一些特殊情况1. 数本身就是递增的，此时我们只需要输出前n位即可。2. 得到的答案字符串的前面有0，判断一下并消去即可。 Code:1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;int main()&#123; string s; int n; while(cin&gt;&gt;s&gt;&gt;n) &#123; int l=s.size(); while(n--) &#123; for(int i=0;i&lt;l;i++) &#123; if(s[i]&gt;s[i+1]||i==l-1) &#123; s.erase(i,1); break; &#125; &#125; &#125; while(s[0]==&apos;0&apos;&amp;&amp;s[1]) s.erase(0,1); cout&lt;&lt;s&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>c/c++</tag>
        <tag>Greedy</tag>
        <tag>SDUTOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Basic Dynamic programming]]></title>
    <url>%2Fblog%2F2019%2F05%2F06%2FDP-basic%2F</url>
    <content type="text"><![CDATA[Yesterday a senior teach us about dynamic planning and i&#39;d like to recorded this basic question. 堆石子link: 堆石子Description:JQM开始玩堆石子的游戏。有 m 颗质量大小不同的石子，从最下面一层开始堆石子，最下面一层放置 n 颗石子，每层减少一颗石子，恰好到最上一层为 一颗 石子。现在从最下面一层开始每层石子中取出一颗石子（注意，为了方便取出，要求只能拿和已拿石子相邻的两颗石子中的一颗），求能取出的石子质量和最大为多少？ Input石子总数 m(1≤m≤400)接下来每行表示从最下面一层开始每层每个石子的质量 w(1≤w≤1e8) Output能取出的最大石子质量和 Examplesinput61 4 63 21output9Note 1 2 3 4 5 67 8 9 10如果你拿了8，那么你就只能拿4或者5而不能拿6 Intentional analysis:What we should is find the &quot;State transition equation&quot;.We know that the value of the optimal solution in the bottom row is his own, which is the critical condition.Another part of the state transition equation is that the value of the optimal solution is the maximum of the number above it and the number in the upper right corner, and then adds itself.Of course,we can solve this problem with DFS.Memory search is a perfect way to avoid TLE.So,we can get the &quot;State transition equation&quot;: 123456dp[i][j] = a[i][j] if(i==n)dp[i][j] = max(dp[i+1][j], dp[i+1][j+1]) + a[i][j]n represents the number of rows of triangles.a[i][j] represents the value of the i-th row and the j-th column in the triangle.dp[i][j] represents the value of the optimal solution for this position. Click to see Chinese Intentional analysis这是一道DP的裸题，我们需要的就是推出递推公式就行了。首先我们知道若想得到当前位置的最优解，就需要知道它上一个位置的最优解，一开始可能会想到dfs，看一下数据范围，dfs的话肯定会超时，但是dfs也是可以做的，但是需要用到记忆化搜索。继续说回我们用DP做的方法，我们知道最下面那一行的最优解的值就是他自己，这就是临界条件，状态转移方程的另一部分就是这个数最优解的值就是它的上面的那个数和右上角的那个数的最大值加上自己本身。所以我们可以得到123456dp[i][j] = a[i][j] if(i==n)dp[i][j] = max(dp[i+1][j], dp[i+1][j+1]) + a[i][j]n代表的是三角形的行数。a[i][j]代表的是三角形中的第i行第j列的值。dp[i][j]代表的就是这个位置的最优解的值。 Code-dp:1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=400;typedef long long ll;ll a[maxn][maxn];ll dp[maxn][maxn];int main()&#123; ll n,k=1; cin&gt;&gt;n; while(n) &#123; n-=k; k++; &#125; k-=1; for(ll i=k;i&gt;=1;i--) for(ll j=1;j&lt;=i;j++) cin&gt;&gt;a[i][j]; for(ll i=k;i&gt;=1;i--) &#123; for(ll j=1;j&lt;=i;j++) if(i==k) dp[i][j]=a[i][j]; else dp[i][j]=max(dp[i+1][j],dp[i+1][j+1])+a[i][j]; &#125; cout&lt;&lt;dp[1][1]&lt;&lt;endl; return 0;&#125; Code-dfs:123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1000;ll a[maxn][maxn];ll dp[maxn][maxn];ll n,k=1;ll dfs(ll x,ll y)&#123; if(dp[x][y]) return dp[x][y]; if(x==k) return dp[x][y]=a[x][y]; ll m = dfs(x+1,y); ll n = dfs(x+1,y+1); return dp[x][y]=max(m,n)+a[x][y];&#125;int main()&#123; cin&gt;&gt;n; while(n) &#123; n-=k; k++; &#125; k-=1; for(ll i=k;i&gt;=1;i--) for(ll j=1;j&lt;=i;j++) cin&gt;&gt;a[i][j]; cout&lt;&lt;dfs(1,1)&lt;&lt;endl; return 0;&#125; If you still confused with dp,just think about Fibonacci sequence.1234567F[0]=1F[1]=1F[2]=2F[3]=3F[4]=5......F[n]=F[n-1]+F[n-2] F[n]=F[n-1]+F[n-2] is Fibo&#39;s &quot;State transition equation&quot;.]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>DP</tag>
        <tag>DFS</tag>
        <tag>HPUOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Stone]]></title>
    <url>%2Fblog%2F2019%2F05%2F04%2Fnowcoder-893-D%2F</url>
    <content type="text"><![CDATA[Think in another way!!! nowcoder-893-D Stone link: Stone Description: 有n堆石子排成一排，第i堆石子有ai个石子。每次，你可以选择任意相邻的两堆石子进行合并，合并后的石子数量为两堆石子的和，消耗的体力等价于两堆石子中石子数少的那个。请问，将所有的石子合并成一堆，你所消耗的体力最小是多少？输入描述:第一行是一个整数T(1≤T≤20)，表示样例的个数。每个样例的第一行是一个整数(1≤n≤10000),表示石子堆的数量。第二行是n个整数(1≤ai≤1e9)输出描述:每行输出一个样例的结果。示例1输入221 211输出10说明巨大的输入，请使用C风格的输入。 Intentional analysis: Because the order of the series is not changeable,so we can use the sum of each item in the series to subtract the largest item.It&#39;s the answer. Click to see Chinese Intentional analysis一开始看到这道题，我以为是贪心裸题，结果仔细一看，数列的顺序是不能变的。。。然后就没了思路。。。等到比赛结束之后看了大佬思路，恍然大悟。因为每次能合起来两堆石子，消耗的疲劳度是最小的那个，并且顺序还不能变，所以若想使最后的疲劳度最小，只需要让最大的那堆石头当成最后一组合起来的一个就行。因为最大的那个不管加上其他哪个数之后都会大于那个数。在一次合成中消耗掉这个最大的数并且使它不计算入疲劳度，就可以得到最小的疲劳度。 Code:123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll a[10005];int main()&#123; ll n,t; scanf(&quot;%lld&quot;,&amp;n); while(n--) &#123; scanf(&quot;%lld&quot;,&amp;t); ll sum=0; for(ll i=0;i&lt;t;i++) &#123;scanf(&quot;%lld&quot;,&amp;a[i]);sum+=a[i];&#125; ll maxx=a[0]; for(ll i=1;i&lt;t;i++) maxx=max(maxx,a[i]); printf(&quot;%lld\n&quot;,sum-maxx); &#125; return 0;&#125;]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>nowcoder</tag>
        <tag>Thinking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QAQ]]></title>
    <url>%2Fblog%2F2019%2F05%2F04%2Fnowcoder-847-A%2F</url>
    <content type="text"><![CDATA[No Wrong Answer No Time Limit Exceeded No Memory Limit Exceeded No Segmentation Fault No Run Time Error No Presentation Error No Floating Point Error No Compilation Error No Output Limit Exceeded Just Accepted,Accepted,and Accepted Yesterday participated in a practice session of nowcoder,Then I met a question similar to the previous one. nowcoder-847-A QAQlink: QAQ Descrption: 给定一个只包含大写字母的长度为N的字符串S,求S中不含相邻字符且长度为3的&quot;QAQ&quot;子序列个数。即:设字符串S的第i个字符为Si,求满足下列条件的&lt;x,y,z&gt;三元组个数。1≤x,y,z≤Nx&lt;y−1y&lt;z−1Sx=&#39;Q&#39;,Sy=&#39;A&#39;,Sz=&#39;Q&#39; 输入描述:输入仅一行一个字符串S,字符串的长度N满足(1≤N≤5000)。N不会在输入中给出。保证S中只包含大写字母。输出描述:输出一行一个整数--满足条件的三元组个数。示例1输入QQAQQ输出1说明满足条件的三元组只有一个: &lt;1,3,5&gt;示例2输入QAQAQ输出0示例3输入QQHAHAQQAQ输出10 Intentional analysis: QAQ,let&#39;s look it carefully.Then we can find that the amount of &quot;QAQ&quot; is depends on the amount of &quot;A&quot;.So our task is find the position of &quot;A&quot;.Attention: You can&#39;t choose neighboring char from the original string. Click to see Chinese Intentional analysis观察一下可以发现，QAQ的数量取决于A的数量。所以我们只需要找到A的数量，然后进行判断计算就行。注意：这道题要求的QAQ不能是在原字符串中相邻的字符。 For example:12345678910QAQAQ12345We can find &quot;QAQ&quot; at:1 2 31 2 51 4 53 4 5but all of these have neighboring char,so the answer of this example is &quot;0&quot;,not &quot;4&quot;. Code:123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;string s;long long ans;int main()&#123; cin&gt;&gt;s; int l=s.size(); for(int i=0;i&lt;l;i++) &#123; if(s[i]==&apos;A&apos;) &#123; int a=0; int b=0; for(int j=i-2;j&gt;=0;j--) &#123; if(s[j]==&apos;Q&apos;) a++; &#125; for(int k=i+2;k&lt;l;k++) &#123; if(s[k]==&apos;Q&apos;) b++; &#125; ans+=a*b; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; One more thing you should better focus on:The answer is too big to be able to save a int type.I ffailed once because of this. A similar question:CodeForces-894-A QAQlink: QAQ Descripition:&quot;QAQ&quot; is a word to denote an expression of crying. Imagine &quot;Q&quot; as eyes with tears and &quot;A&quot; as a mouth. Now Diamond has given Bort a string consisting of only uppercase English letters of length n. There is a great number of &quot;QAQ&quot; in the string (Diamond is so cute!). Bort wants to know how many subsequences &quot;QAQ&quot; are in the string Diamond has given. Note that the letters &quot;QAQ&quot; don&#39;t have to be consecutive, but the order of letters should be exact. InputThe only line contains a string of length n (1 ≤ n ≤ 100). It&#39;s guaranteed that the string only contains uppercase English letters. OutputPrint a single integer — the number of subsequences &quot;QAQ&quot; in the string. ExamplesinputQAQAQYSYIOIWINoutput4inputQAQQQZZYNOIWINoutput3NoteIn the first example there are 4 subsequences &quot;QAQ&quot;: &quot;QAQAQYSYIOIWIN&quot;, &quot;QAQAQYSYIOIWIN&quot;, &quot;QAQAQYSYIOIWIN&quot;, &quot;QAQAQYSYIOIWIN&quot;. This is similar to the previois.The only thing different is choose a neighboring char is allowed here.So we just correct a number then we can solve this problem. Code:123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;string s;long long ans;int main()&#123; cin&gt;&gt;s; int l=s.size(); for(int i=0;i&lt;l;i++) &#123; if(s[i]==&apos;A&apos;) &#123; int a=0; int b=0; for(int j=i-2;j&gt;=0;j--) &#123; if(s[j]==&apos;Q&apos;) a++; &#125; for(int k=i+2;k&lt;l;k++) &#123; if(s[k]==&apos;Q&apos;) b++; &#125; ans+=a*b; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; You can find the difference between these two codes which is better for you to understand this series of questions. The most exciting thing I want to say is 我中奖啦 I got the prize Gané el premio. Ek het die prys gewen. Kam fituar çmimin. ሽልማቱን አሸንፌያለሁ. Ես հաղթել եմ մրցանակին: Mükafatı qazandım. Saria irabazi nuen. Я выйграў латарэю сяброў...... After nearly half a year of competition on the nowcoder.Participated in 18 games,I won the price at last.Congratulations! Show off]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>nowcoder</tag>
        <tag>Thinking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go back home]]></title>
    <url>%2Fblog%2F2019%2F05%2F01%2FWowwwww%2F</url>
    <content type="text"><![CDATA[You will konw the password if I want you know. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Prefix Sum Primes]]></title>
    <url>%2Fblog%2F2019%2F04%2F30%2FCodeForces-1149-A%2F</url>
    <content type="text"><![CDATA[A ac a day, keeps the doctor away! CodeForces-1149-A Prefix Sum PrimesTopic link:Prefix Sum PrimesDescription:We&#39;re giving away nice huge bags containing number tiles! A bag we want to present to you contains n tiles. Each of them has a single number written on it — either 1 or 2. However, there is one condition you must fulfill in order to receive the prize. You will need to put all the tiles from the bag in a sequence, in any order you wish. We will then compute the sums of all prefixes in the sequence, and then count how many of these sums are prime numbers. If you want to keep the prize, you will need to maximize the number of primes you get. Can you win the prize? Hurry up, the bags are waiting! InputThe first line of the input contains a single integer n (1≤n≤200000) — the number of number tiles in the bag. The following line contains n space-separated integers a1,a2,…,an (ai∈{1,2}) — the values written on the tiles. OutputOutput a permutation b1,b2,…,bn of the input sequence (a1,a2,…,an) maximizing the number of the prefix sums being prime numbers. If there are multiple optimal permutations, output any. Examplesinput51 2 1 2 1output1 1 1 2 2input91 1 2 1 1 1 2 1 1output1 1 1 2 1 1 1 2 1NoteThe first solution produces the prefix sums 1,2,3,5,7 (four primes constructed), while the prefix sums in the second solution are 1,2,3,5,6,7,8,10,11 (five primes). Primes are marked bold and blue. In each of these cases, the number of produced primes is maximum possible. Intentional analysis:To solve this problem,you&#39;d better know a rule——The difference between all adjacent prime numbers except 2, 3 is even.So what we should is just get the number of occurrences of 1 and 2,judge and print.There are three situations: 1.The number of occurrences of 1 is 0. 2.The number of occurrences of 2 is 0. 3.Both 1 and 2 have appeared. Where does it reflect greed?If the first two numbers are done,and you still have 2 ,just print it,and then print 1. Click to see Chinese Intentional analysis为了解决这个问题，有个规则你是必须要知道的——除了2，3之外的所有相邻的素数的差都是偶数。所以我们只需要知道给的数据中1，2出现几次就行了。这里总共有三种情况：一： 1没有出现过。二： 2没有出现过。三： 1，2都出现过。能体现出贪心的是哪里呢？就是当你处理完前两个质数2，3之后，如果你还有2，就把2先输出完，然后再输出剩下的1即可。 Code:123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int x,a=0,b=0,n; cin&gt;&gt;n; while(n--) &#123; cin&gt;&gt;x; if(x==1) a++; else b++; &#125; if(a==0) &#123; while(b--) cout&lt;&lt;&quot;2 &quot;; cout&lt;&lt;endl; return 0; &#125; if(b==0) &#123; while(a--) cout&lt;&lt;&quot;1 &quot;; cout&lt;&lt;endl; return 0; &#125; else &#123; cout&lt;&lt;&quot;2 1 &quot;; a-=1; b-=1; while(b--) cout&lt;&lt;&quot;2 &quot;; while(a--) cout&lt;&lt;&quot;1 &quot;; cout&lt;&lt;endl; return 0; &#125;&#125; There are many useful rules that I don’t know,still have to do more questions.]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>Greedy</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Getting Started]]></title>
    <url>%2Fblog%2F2019%2F04%2F28%2FCool%2F</url>
    <content type="text"><![CDATA[Hexo is a fast and powerful static blog generating framework, it&#39;s based on Node.js. By using Hexo you can write articles easily with Markdown, and besides the grammer of Markdown, you can also use tag plugins provided by Hexo to insert special formated content simply. In this page we assume you have installed Hexo and created a site with it. You can visit Hexo Docs to see how to install Hexo. Documentation Variables_config.ymlAvailable SettingsDefault SettingsThere are two main configuration files using by Hexo and both called _config.yml: The first one is under site root directory, which contains Hexo&#39;s config. The second one is under theme root directory, which is provided by NexT and contains theme&#39;s config. Let&#39;s call the first one – site config file, and the second one – theme config file.All available settings will be inside code blocks (with single backtick or &lt;code&gt; tags).And all default settings will be bold inside code blocks (with single backtick or &lt;code&gt; and ** or &lt;strong&gt; tags). Recommended SettingsDeprecated SettingsPossible ErrorsAll recommended settings will be highlighted under the success label.All deprecated settings will be highlighted under the warning label.And all possible errors will be highlighted under the danger label. NexT InstallationIt&#39;s easy to install Hexo theme: you can just download the NexT theme, copy the theme folder to the themes directory under site root directory and specify in site config file your theme root directory. The detailed steps are as follows: Downloading NexTNewest VersionStable VersionIf you know about Git, you can clone the whole repository and update it in any time with git pull command instead of downloading archive manually. Open your Terminal, change to Hexo site root directory and clone latest master branch of NexT theme: 12$ cd hexo$ git clone https://github.com/theme-next/hexo-theme-next themes/next Go to NexT version Release Page. Choose the version you need and download the Source Code (zip) in the Download section. For example v6.0.0. Extract the zip file to site&#39;s themes directory and rename the extracted folder (hexo-theme-next-6.0.0) to next. You also can read detailed installation instructions if you want any other installation variant. If you still use NexT version 5, you can read instructions for update from v5 to v6. Enabling NexTLike all Hexo themes, after you download it, open site config file, find theme section, and change its value to next (or another theme directory name). hexo/_config.yml1theme: next Now you have installed NexT theme, next we will verify whether it is enabled correctly. Between changing the theme and verifying it, we&#39;d better use hexo clean to clean Hexo&#39;s cache. Checking NexTFirst start Hexo local server, and enable debug parameter (by adding --debug), the whole command is hexo s --debug. You can see the output while running, and if you find problem, you can use the output to help others locate error better. When it prints: INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. Now you can open http://localhost:4000 in your browser, and check whether the site works correctly. If you find your site looks like this picture, you have installed it correctly. That’s default NexT scheme – Muse. Now you&#39;ve installed and enabled NexT. In next steps we will change some settings including personalization and third-party services integration. Adding PluginsThere are 2 variants to hook up NexT plugins: Local installation (plugins scripts will loaded from your site). CDN links (plugins scripts will loaded from remote hosts). If your site hosted on VPN (or any other) server with NGINX configuration, recommended to use local installation.And if your files deployed to any free hosting service (Github, Gitlab, etc.), recommended to use CDN links. LocalCDNIn NexT config now you can find dependencies on each module which was moved to external repositories which can be found by main organization link. For example, you want to use fancybox in your site. Go to theme config file and see: next/_config.yml12# Dependencies: https://github.com/theme-next/theme-next-fancyboxfancybox: false Then turn on fancybox and go to «Dependencies» link with installation instructions of this module.If you use cdn for any plugins, you need to replace your cdn link. For example, you want to use fancybox and you configured a cdn link. Go to theme config file and see: next/_config.yml123456vendors: # ... # Some contents... # ... fancybox: //cdn.jsdelivr.net/npm/fancybox@3.0.0/dist/js/jquery.fancybox.pack.js # Set or update fancybox cdn url. fancybox_css: //cdn.jsdelivr.net/npm/fancybox@3.0.0/dist/css/jquery.fancybox.min.css # Set or update fancybox cdn url. And jsDelivr CDN is recommended to deliver our third-party plugins because it is fast in everywhere and has the valid ICP license issued by the Chinese government. It does not only crawl the js files from npm packages, and it crawls from the GitHub Releases! We could use the following link to reference the js files, just as other CDNs. 1//cdn.jsdelivr.net/gh/user/repo@version/file And it could automatically minify the JS and CSS files, even if you don&#39;t have the minified version. Just use the filename.min.js or the filename.min.css to replace the file above. And we also provide other optional CDNs, including the famous CDNJS and the Bootcss which has the quite high access speed in China. NexT ConfigurationChoosing SchemeScheme is a feature supported by NexT, by using Scheme NexT gives you different views. And nearly all config can be used by those Schemes. Till now NexT supports 4 schemes, and they are: Muse → Default Scheme, this is the initial version of NexT. Uses black-white tone and mainly looks cleanly. Mist → A tighter version of Muse with a tidy single-column view. Pisces → Double-column Scheme, fresh like your neighbor&#39;s daughter. Gemini → Looks like Pisces, but have distinct column blocks with shadow to appear more sensitive to view. You can change Scheme by editing theme config file, searching scheme keyword. You&#39;ll see 4 lines of scheme settings and can enable one of them by removing it&#39;s # and added # to previous. next/_config.yml1234#scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini Choosing LanguageEdit site config file, set the value of language to the language you need. For example, English looks like this: hexo/config.yml1language: en NexT now supports following languages: Language Example Code 🇨🇳 Chinese (Simplified) 简体中文 zh-CN 🇹🇼 Chinese (Traditional) 繁體中文 zh-TW 🇭🇰 Chinese (Hong Kong) 繁體中文-香港 zh-HK 🇧🇶 Dutch Niederländisch nl 🇺🇸 English English en 🇹🇫 French Français fr 🇩🇪 German Deutsch de 🇮🇩 Indonesian Indonesia id 🇮🇹 Italian Italiano it 🇯🇵 Japanese 日本語 ja 🇰🇷 Korean 한국어 ko 🇮🇷 Persian فارسی fa 🇵🇹 Portuguese Português pt 🇧🇷 Portuguese (Brazilian) Português (Brazilian) pt-BR 🇷🇺 Russian Русский ru 🇪🇸 Spanish Español es 🇹🇷 Turkish Türk tr 🇺🇦 Ukrainian Український uk 🇻🇳 Vietnamese Tiếng Việt vi If you want to add or improve language for NexT theme, you can do it easily with crowdin service. Configuring Menu ItemsMenu settings items have format Key: /link/ || icon which contains 3 values: KeylinkiconKey → is the name of menu item (home, archives, etc.).If translate for this menu will be found in languages, this translate will be loaded; if not, Key name will be used. Key value is case sensitive (e.g. home is not same as Home). Value before || delimeter (/link/) → is the target link to relative url inside your site.Value after || delimeter (icon) → is the name of FontAwesome icon.If icon (with or without delimeter) is not specified, question icon will be loaded.Names of that icons can be found in Font Awesome site. By default NexT provides home and archives items. To customize menu items, edit the following content in theme config file: All custom pages which commented by default under menu section need to create manually. See «Custom Page Support» next/_config.yml123456789menu: home: / || home #about: /about/ || user #tags: /tags/ || tags #categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat Dynamic sub-menu within hierarchy structure is also supported. Add your sub-menu items in menu section in theme config file as following: next/_config.yml12345678menu: home: / || home archives: /archives/ || archive Docs: default: /docs/ || book Third Party Services: default: /third-party-services/ || plug Algolia Search: /algolia-search/ || adn If your site runs in a sub-directory, please remove the prefix / from the link. By default NexT shows the icons of menu items without badges. iconsbadgesYou can configure it by editing values in menu_settings.icons section in theme config file. next/_config.yml12menu_settings: icons: trueSet the value badges to true to display the count of Posts / Categories / Tags within menu items in menu_settings section in theme config file as following: next/_config.yml12menu_settings: badges: true Configuring FaviconBy default the Hexo site use NexT favicons in hexo-site/themes/next/source/images/ directory with different size for different device. You can replace them with your own favicons. For example, you can put your favicons in hexo-site/source/images/ directory. Then you need to rename them and change the settings in favicon section in theme config file, otherwise icons from Next will rewrite your custom icons in Hexo. You can also put custom favicons into hexo-site/source/ directory. In this way, you must remove /images prefix from paths. To generate custom favicons, you can visit Favicon Generator. hexo/_config.yml1234567favicon: small: /images/favicon-16x16-next.png medium: /images/favicon-32x32-next.png apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg android_manifest: /images/manifest.json ms_browserconfig: /images/browserconfig.xml Configuring AvatarBy default NexT doesn&#39;t show avatar in sidebar. You can configure it by editing values under avatar setting in theme config file. urlroundedrotatedopacityFor first test you can uncomment /images/avatar.gif value near the avatar.url setting to see default avatar: next/_config.yml12avatar: url: /images/avatar.gif Then you need to specify your own avatar. It can be done one of the ways below: Hexo directoryNexT directoryAbsolute URL from InternetPut your avatar under site directory source/uploads/ (create directory if it doesn&#39;t exists).And then change option to avatar: /uploads/avatar.png.Put your avatar under theme directory source/images/.And then change option to avatar: /images/avatar.png. Current site uses avatar under theme directory from file located in next/source/images/apple-touch-icon-next.png with following config:hexo/_config.yml123456theme_config: avatar: url: /images/apple-touch-icon-next.png rounded: true opacity: 1 rotated: false You also can specify any external URL with absolute path to image: http(s)://example.com/avatar.pngSet up rounded of avatar by changing the value of avatar.rounded: true → Avatar will be rounded. false → Avatar will be squared. next/_config.yml12avatar: rounded: trueSet up rotated of avatar by changing the value of avatar.rotated: true → Avatar will be rotate under the mouse hovering. false → Avatar will not rotate under the mouse hovering. next/_config.yml12avatar: rotated: trueThe value of opacity should be choose from 0 to 1 to set the opacity of the avatar: 1 → Avatar will be in default opacity style. 0 → Avatar will be transparent. next/_config.yml12avatar: opacity: 1 Configuring AuthorEdit site config file and set the value of author to your nickname. hexo/_config.yml12# Siteauthor: Configuring DescriptionEdit site config file and set the value of description to your description, which can be a sentence you like. hexo/_config.yml12# Sitedescription: Original_link:https://github.com/theme-next/theme-next.org/blob/source/source/docs/getting-started/index.md]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Tutorial</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Neko Performs Cat Furrier Transform]]></title>
    <url>%2Fblog%2F2019%2F04%2F28%2FCodeForces-1152-B%2F</url>
    <content type="text"><![CDATA[Someone asked me how good you are. I said how big the universe is, how good you are. CodeForces-1152-B Neko Performs Cat Furrier TransformTopic link:Neko Performs Cat Furrier TransformDescription:Cat Furrier Transform is a popular algorithm among cat programmers to create longcats. As one of the greatest cat programmers ever exist, Neko wants to utilize this algorithm to create the perfect longcat. Assume that we have a cat with a number x. A perfect longcat is a cat with a number equal 2m−1 for some non-negative integer m. For example, the numbers 0, 1, 3, 7, 15 and so on are suitable for the perfect longcats. In the Cat Furrier Transform, the following operations can be performed on x: (Operation A): you select any non-negative integer n and replace x with x⊕(2n−1), with ⊕ being a bitwise XOR operator.(Operation B): replace x with x+1.The first applied operation must be of type A, the second of type B, the third of type A again, and so on. Formally, if we number operations from one in the order they are executed, then odd-numbered operations must be of type A and the even-numbered operations must be of type B. Neko wants to produce perfect longcats at industrial scale, thus for each cat Neko only wants to perform at most 40 operations. Can you help Neko writing a transformation plan? Note that it is not required to minimize the number of operations. You just need to use no more than 40 operations. InputThe only line contains a single integer x (1≤x≤106). OutputThe first line should contain a single integer t (0≤t≤40) — the number of operations to apply. Then for each odd-numbered operation print the corresponding number ni in it. That is, print ⌈t2⌉ integers ni (0≤ni≤30), denoting the replacement x with x⊕(2ni−1) in the corresponding step. If there are multiple possible answers, you can print any of them. It is possible to show, that there is at least one answer in the constraints of this problem. Examplesinput39output45 3input1output0input7output0NoteIn the first test, one of the transforms might be as follows: 39→56→57→62→63. Or more precisely: Pick n=5. x is transformed into 39⊕31, or 56.Increase x by 1, changing its value to 57.Pick n=3. x is transformed into 57⊕7, or 62.Increase x by 1, changing its value to 63=26−1.In the second and third test, the number already satisfies the goal requirement. There are some differences between the description on my blog and the real,so I put a real piture here. Intentional analysis:The most important solution to this problem is to simulate.To solve this problem,you better use binary processing.If a number is equal to pow(2,n)-1,then its binary is 1 for each bit.So we only need to process the binary bits of the number to be processed.First, find the highest bit with a binary bit of 0.Then,Each of the next inversions.If the conditions are not met, add 1.This loops until the value that satisfies the condition appears. Click to see Chinese Intentional analysis这道题最重要的思想就是模拟，因为一个数如果是2的n次方减1，那么它的二进制位每一位都是1。因此这道题就可以对输入的数以二进制位的形式进行操作。首先找到最高位的0，然后对这一位以下的所有的二进制位与1进行异或，异或完判断是否满足条件，如果不满足就加一在进行判断，还不行的话就开始下一次循环，直到找到满足条件的数跳出循环即可。思想应该是很容易懂的，难得地方就是实现。一开始我想用bitset来做，但是没成功，还是老老实实的用数组做吧。Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; vector&lt;int&gt; v; int B[30],n,ans=0,t,now=0; cin&gt;&gt;n; t=n; while(t) &#123; B[now++]=t%2; t/=2; &#125; int i=now-1; for(;i&gt;=0;i--) &#123; if(B[i]==0) &#123; v.push_back(i+1); bool flag=0; for(int j=i;j&gt;=0;j--) &#123; B[j]^=1; if(B[j]==0&amp;&amp;j!=0) flag=1; &#125; ans++; if(flag==0) &#123; if(B[0]==0) &#123; B[0]++; ans++; &#125; i=-1; break; &#125; B[0]++; ans++; for(int k=0;k&lt;i;k++) &#123; if(B[k]&gt;1) &#123; B[k]=0; B[k+1]++; &#125; else break; &#125; &#125; if(i==-1) break; &#125; cout&lt;&lt;ans&lt;&lt;endl; for(int j=0;j&lt;v.size();j++) &#123; cout&lt;&lt;v[j]&lt;&lt;&quot; &quot;; if(j==v.size()-1) puts(&quot;&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>CodeForces</tag>
        <tag>Simulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Long Number]]></title>
    <url>%2Fblog%2F2019%2F04%2F27%2FCodeForces-1157-B%2F</url>
    <content type="text"><![CDATA[Oh,CF&#39;s charm is too strong,especially div3. CodeForces-1157-B Long NumberTopic link:Long NumberDescription:You are given a long decimal number a consisting of n digits from 1 to 9. You also have a function f that maps every digit from 1 to 9 to some (possibly the same) digit from 1 to 9. You can perform the following operation no more than once: choose a non-empty contiguous subsegment of digits in a, and replace each digit x from this segment with f(x). For example, if a=1337, f(1)=1, f(3)=5, f(7)=3, and you choose the segment consisting of three rightmost digits, you get 1553 as the result. What is the maximum possible number you can obtain applying this operation no more than once? InputThe first line contains one integer n (1≤n≤2e5) — the number of digits in a. The second line contains a string of n characters, denoting the number a. Each character is a decimal digit from 1 to 9. The third line contains exactly 9 integers f(1), f(2), ..., f(9) (1≤f(i)≤9). OutputPrint the maximum number you can get after applying the operation described in the statement no more than once. Examplesinput413371 2 5 4 6 6 3 1 9output1557input5111119 8 7 6 5 4 3 2 1output99999input2331 1 1 1 1 1 1 1 1output33Intentional analysis:Through reading this questions,we can see that this question is a greedy type of problem.Each number will correspond to another number,and if the corresponding number is greater than this number,we need to use it instead of this number,and as long as such a number appears continuously,we can always change it,but we can only change it once,and To find the maximum number after the change,you only need to find a series of consecutive changeable changes from the front and then output. Click to see Chinese Intentional analysis这道题就是每一个数都对应着一个数，题目要求更换之后取得最大值，可是只能更换一次，每次更换可以更换任一个数但是必须是连续的。这时就体现出贪心的思想了，要想这个数变得更大，在这个数的越高的位置数就得越大，所以只需要从前往后看，只要发现对应的数比本身大就开始更换直到对应的数小于本身，就停止更换。 Code:123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n;string s;char x; cin&gt;&gt;n&gt;&gt;s; map&lt;int,char&gt; ma; for(int i=1;i&lt;=9;i++) &#123; cin&gt;&gt;x; ma[i]=x; &#125; int flag; char mid; for(int i=0;i&lt;s.size();i++) &#123; if(s[i]&lt;ma[s[i]-&apos;0&apos;]) &#123; flag=i; break; &#125; &#125; for(int i=0;i&lt;flag;i++) &#123; cout&lt;&lt;s[i]; &#125; bool flag2=1; for(int i=flag;i&lt;s.size();i++) &#123; if(s[i]&gt;ma[s[i]-&apos;0&apos;]) flag2=0; if(flag2) cout&lt;&lt;ma[s[i]-&apos;0&apos;]; else cout&lt;&lt;s[i]; &#125; cout&lt;&lt;endl; return 0;&#125; I didn&#39;t understand the meaning of this question at first, which led to WA several times and wasted my time. Now the result of hack has not come out yet, if my code was hacked.I will find the bug and correct it as soon as possible!(2019.4.27 1:03) Accepted(2019.4.27 22:52)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>c/c++</tag>
        <tag>CodeForces</tag>
        <tag>STL</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL-bitset]]></title>
    <url>%2Fblog%2F2019%2F04%2F25%2Fbitset%2F</url>
    <content type="text"><![CDATA[These STL in c++ are so useful that you can sovle some problems easily through use them.I have known map,vector,queue,stack,set.And there is a STL named bitset. Introduction to bitset-personalI can&#39;t find a accurate explanation online.So there is my understanding of it.Bitset is a STL which is easy to treat a number as a binary. InstructionsIt is included by include&lt;bitset&gt;If you want to define a bitset,the code is as follows1bitset&lt;num&gt; n;//num must be defined as an integer literal constant or an integer type const object initialized with a constant value. If so initialized, each bit is 0.Of course you can also define it like this12int a;bitset&lt;num&gt; n(a); now,the bitset n is the binary form of a.And you even can use this like a array.Such as123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;bitset&gt;using namespace std;int main()&#123; int a; cin&gt;&gt;a; bitset&lt;4&gt; b(a); cout&lt;&lt;b&lt;&lt;endl; cout&lt;&lt;b[0]&lt;&lt;endl&lt;&lt;b[1]&lt;&lt;endl&lt;&lt;b[2]&lt;&lt;endl&lt;&lt;b[3]&lt;&lt;endl; return 0;&#125;Input:13 -5Ouput:1101101110111101 As can be seen from these examples, when the bit position in the bitset is operated, it is reversed.Such as:1234567int n = 16;bitset&lt;64&gt; b(n);b[0]=0b[1]=0b[2]=0b[3]=0b[4]=1 From the above example we can see that the negative number will directly become the complement form under the action of bitset.This has advantages and disadvantages.This has advantages and disadvantages, because some places just let you represent the binary form, no need to complement.If you meet a situtation like this,just take a judge,all numbers are processed as positive numbers, if they are negative, then add a negative sign.I&#39;d like to paste a example here. ExampleSource: 简单的二进制Description：计算机只能识别0和1,使用的是二进制，而在日常生活中人们使用的是十进制，”正如亚里士多德早就指出的那样，今天十进制的广泛采用，只不过是我们绝大多数人生来具有10个手指头这个解剖学事实的结果。 在计算机领域中，补码是一个重要的概念，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理。此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。 学习了计算机导论后，相信大家都明白了原码、反码和补码的区别，并能快速地将一个十进制整数的补码写出。今天我们将问题进行简化：给出一个十进制的整数N，请写出N在64位二进制补码表示下，一共有多少个1。 Input多组输入，每一行有一个整数N（保证N在int64范围内） Output输出N在二进制补码下1的个数，每组输出占一行 Examplesinput1015output24Note正整数的补码是其二进制表示，与原码相同 求负整数的补码，将其原码除符号位外的所有位取反后加一 Problem solving：We can see this problem need the complement when the number is negative.So the bitset is so comfortable for this. Code:123456789101112#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; long long n; while(scanf(&quot;%lld&quot;,&amp;n)!=EOF) &#123; bitset&lt;64&gt; b(n); cout&lt;&lt;b.count()&lt;&lt;endl; &#125; return 0;&#125; If you write this, the code will be very simple.The specific function functions will be discussed below. Many functionsAlmost all STL have lots of functions,bitset is no exception.I don&#39;t have the ability, and I don&#39;t have the energy to list them all, so I will list what I like and what I find useful. OverviewDefine a bitset first:bitset b; function Features b.any() Is there a binary bit with a value of 1 in b? b.none() Is there no binary bit with a value of 1 in b? b.count() The number of bits in b with a value of 1 b[pos] Access the binary bit at pos in b b.test(pos) Whether the binary bit in pos is 1 in b？ b.set() Set all binary bits in b to 1 b.set(pos) Put the binary position in b at pos as 1 b.reset() Set all binary bits in b to 0 b.reset(pos) Put the binary position in b at pos to 0 b.flip() All binary bits in b are inverted bit by bit b.flip(pos) Invert the binary bit at b in pos b.to_string() Convert the contents of the bitset to string b.to_ulong() Convert the contents of the bitset to unsigned long Next I will help you understand the usage of these functions with some examples. b.any() and b.none() and b.count()b.any(): Is there a binary bit with a value of 1 in b?123456789101112#include&lt;iostream&gt;#include&lt;bitset&gt;using namespace std;int main()&#123; int n=5,m=0;// n = 0101, m = 0 bitset&lt;8&gt; b1(n); bitset&lt;8&gt; b2(m); cout&lt;&lt;b1.none()&lt;&lt;&quot; &quot;&lt;&lt;b2.none();&#125;Operation result:1 0 So you can see that the return value of b.any() is the bool type. b.none()：Is there no binary bit with a value of 1 in b?123456789101112#include&lt;iostream&gt;#include&lt;bitset&gt;using namespace std;int main()&#123; int n=5,m=0;// n = 0101, m = 0 bitset&lt;8&gt; b1(n); bitset&lt;8&gt; b2(m); cout&lt;&lt;endl&lt;&lt;b1.none()&lt;&lt;&quot; &quot;&lt;&lt;b2.none();&#125;Operation result:0 1 So you can see that the return value of b.none() also is the bool type. b.count(): The number of bits in b with a value of 1123456789101112#include&lt;iostream&gt;#include&lt;bitset&gt;using namespace std;int main()&#123; int n=15,m=16;// n = 1111, m = 10000 bitset&lt;8&gt; b1(n); bitset&lt;8&gt; b2(m); cout&lt;&lt;b1.count()&lt;&lt;&quot; &quot;&lt;&lt;b2.count();&#125;Operation result:4 1 So the function of b.count() is to return the number of 1 in the binary.Just like the example above b[pos]b[pos]: Access the binary bit at pos in bI started the function&#39;s introduction at the beginning of this blog, you can look up. b.test(pos)b.test(pos): Whether the binary bit in pos is 1 in b？123456789101112#include&lt;iostream&gt;#include&lt;bitset&gt;using namespace std;int main()&#123; int n=15,m=16;// n = 1111, m = 10000 bitset&lt;8&gt; b1(n); bitset&lt;8&gt; b2(m); cout&lt;&lt;b1.test(1)&lt;&lt;&quot; &quot;&lt;&lt;b2.test(4)&lt;&lt;&quot; &quot;&lt;&lt;b2.test(1);&#125;Operation result:1 1 0 So you can see that the return value of b.test(pos) is the bool type,too. b.set() and b.set(pos)b.set(): Set all binary bits in b to 11234567891011121314#include&lt;iostream&gt;#include&lt;bitset&gt;using namespace std;int main()&#123; int n = 16; bitset&lt;8&gt; b(n); cout&lt;&lt;b&lt;&lt;endl; b.set(); cout&lt;&lt;b;&#125;Operation result:0001000011111111 b.set(pos): Put the binary position in b at pos as 11234567891011121314#include&lt;iostream&gt;#include&lt;bitset&gt;using namespace std;int main()&#123; int n = 16; bitset&lt;8&gt; b(n); cout&lt;&lt;b&lt;&lt;endl; b.set(0); cout&lt;&lt;b;&#125;Operation result:0001000000010001 b.reset() and b.reset(pos)b.reset(): Set all binary bits in b to 0b.reset(pos): Put the binary position in b at pos to 0These two functions are very similar to the two above, so I won’t go into details. b.flip() and b.flip(pos)b.flip(): All binary bits in b are inverted bit by bit1234567891011121314#include&lt;iostream&gt;#include&lt;bitset&gt;using namespace std;int main()&#123; int n = 16; bitset&lt;8&gt; b(n); cout&lt;&lt;b&lt;&lt;endl; b.flip(); cout&lt;&lt;b;&#125;Operation result:0001000011101111 b.flip(pos): Invert the binary bit at b in posBasically the same as above, no longer repeat b.to_string()b.to_string(): Convert the contents of the bitset to string12345678910111213#include&lt;iostream&gt;#include&lt;bitset&gt;using namespace std;int main()&#123; int n = 16; bitset&lt;8&gt; b(n); string s; s=b.to_string(); cout&lt;&lt;s&lt;&lt;endl;&#125;Operation result:00010000 b.to_ulong()12345678910111213141516#include&lt;iostream&gt;#include&lt;bitset&gt;using namespace std;int main()&#123; int n = 16; bitset&lt;5&gt; b(n); b.flip(); long a; cout&lt;&lt;b&lt;&lt;endl; a=b.to_ulong(); cout&lt;&lt;a&lt;&lt;endl;&#125;Operation result:0111115]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[White-book-example]]></title>
    <url>%2Fblog%2F2019%2F04%2F25%2FWhite-book-example%2F</url>
    <content type="text"><![CDATA[I&#39;m studing DFS these days,it&#39;s hard to understand.For this,i&#39;d like to paste a easy question here to understand it more. 部分和问题给定一组数，判断是否可以从中取出若干数，是他们的和恰好为一个数。Example:input4 132 3 4 7ouputYes 每个数都会有两个状态，加上或者不加上，这组样例中有四个数，每个数两个状态，也就是说最后的加起来的结果会有2的4次方(16)种。 Codes1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;int n,k,a[10000];bool dfs(int i,int sum)&#123; if(i==n) &#123;// puts(&quot;mmp&quot;); return sum==k; &#125; if(dfs(i+1,sum)) &#123;// puts(&quot;a&quot;); return 1; &#125; if(dfs(i+1,sum+a[i])) &#123; // puts(&quot;b&quot;); return 1; &#125; &#125;int main()&#123; cin&gt;&gt;n&gt;&gt;k; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; &#125; if(dfs(0,0)) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); return 0;&#125; 只看代码会很难理解，一重一重的递归，但这还只是最简单的一种。为了更好的让自己理解，我将这个样例的所有情况都列了出来。12345678910111213141516171819202122232425262728293031DFS(0,0) DFS(1,0) DFS(2,0) DFS(3,0) DFS(4,0) return 0 DFS(4,7) return 0 DFS(3,4) DFS(4,4) return 0 DFS(4,11) return 0 DFS(2,3) DFS(3,3) DFS(4,3) return 0 DFS(4,10) return 0 DFS(3,7) DFS(4,7) return 0 DFS(4,14) return 0 DFS(1,2) DFS(2,2) DFS(3,2) DFS(4,2) return 0 DFS(4,9) return 0 DFS(3,6) DFS(4,6) return 0 DFS(4,13) return 0 DFS(2,5) DFS(3,5) DFS(4,5) return 0 DFS(4,12) return 0 DFS(3,9) DFS(4,9) return 0 DFS(4,16) return 0 我又将这16种情况，用图的方式表示了出来12345 0 2 0 5 2 3 0 9 5 6 2 7 3 4 016 9 12 5 13 6 9 2 14 7 10 3 11 4 7 0 这时我发现程序跟画出来的是一模一样的。 可是还是不很理解，于是我运行起来程序，并且在每次递归中加入了可以看到的元素，输出a，b或者mmp啊什么的。一起来看看效果input:4 132 3 4 7mmp个数数出来是12个，a,b出现的顺序是b，b，a，b input:4 02 3 4 7mmp个数数出来是1个，a,b出现的顺序是a，a，a，a mmp代表的个数就是出现sum==k的时候前面进行的递归的次数，a代表的是第i位的数状态是不加，b代表的是第i位的数状态是加 也就这样了，DFS慢慢来，这样跑程序我觉得会加深理解啊哈🎈。]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复读机]]></title>
    <url>%2Fblog%2F2019%2F04%2F22%2Fnowcoder-NH-B%2F</url>
    <content type="text"><![CDATA[The game I played in the NOWCODER.COM a few days ago, the first time I met the “union-find” problem, it was solved with the help of the seniors. I have digested it in the past few days, or I wrote it on the blog first. 南华大学第十五届ACM程序设计竞赛(重现赛） B 复读机题目链接：复读机题目描述： 在某华大学里有一个无聊的群组，群内的所有成员都是复读机，他们疯狂复读着别人的消息。然而复读机们在群内也是有阵营的，一个阵营的复读机会根据心情选择是否复读同一个阵营的成员的消息，但绝对不会去复读其他阵营的消息。 群内有n个人（标号1-n号）。现在群内聊天记录中一共有m条消息。请根据这些消息，判断出如果群内第i号成员（1&lt;=i&lt;=n）发一条十分有趣的消息，在同一阵营的成员都会去复读这条消息情况下，那么这条消息会被复读几次？ 如果无法判断i号成员和j号成员是否为同一阵营，则视为不同阵营。 输入描述:输入包括m+1行。第一行包括两个整数n,m；其后的m行为当前的聊天记录，每行包括一个数字i和一个字符串s（表示i发了一条消息）。（保证1&lt;=i&lt;=n，m&lt;=100000，消息的字符串总长不超过100000）输出描述:输出一行，包括n个数字。第i个数字表示第i号成员的有趣消息会被复读几次（1&lt;=i&lt;=n）。数字与数字之间用一个空格分隔。示例1输入复制3 51 a2 a1 b2 c3 c输出复制2 2 2说明对于样例1： 由聊天记录的前两行可以得出2号和1号为同一阵营，由最后两行可得3号和2号为同一阵营，所以三者为同一阵营，他们三个发送的消息会被复读2次，故输出为2 2 2；示例2输入复制3 31 a2 b3 c输出复制0 0 0说明对于样例2：1，2，3号无法判断是否为同一阵营，视为不同阵营。备注:对于复读的概念： 若聊天记录为 1 a 2 a 3 a 属于2，3号复读了1号的消息。 若聊天记录为 1 a 2 b 3 a 不构成任何复读，1的‘a‘和3的‘a’均属于自己原创消息。 题意分析：具体并查集的思想我也解释不清，可以参考这篇博客：https://boctorio.com/2019/03/02/%E5%B9%B6%E6%9F%A5%E9%9B%86/这道题就是当你检测到相邻的两次输入的字符串是相等的就需要把这两个字符串的所对应的前面的数字看成是一组的。最后输出的时候，就输出和它同组的数目减一就行了（因为要除去它自己）。解题思路还是很简单的，实现起来的话用并查集就行了。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;using namespace std;const int maxn=100010;struct name&#123; int num; string sym;&#125;a[maxn];int pre[maxn];int sum[maxn];void init(int n)&#123; for(int i=1;i&lt;=n;i++) pre[i]=i;&#125;int find(int x)&#123; return pre[x]!=x?pre[x]=find(pre[x]):x;&#125;void Union(int x,int y)&#123; x=find(x); y=find(y); if(x&lt;y) pre[y]=x; else pre[x]=y;&#125;int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; init(n); cin&gt;&gt;a[0].num&gt;&gt;a[0].sym; for(int i=1;i&lt;m;i++) &#123; cin&gt;&gt;a[i].num&gt;&gt;a[i].sym; if(a[i].sym==a[i-1].sym) Union(a[i].num,a[i-1].num); &#125; for(int i=1;i&lt;=n;i++) &#123; find(i); sum[pre[i]]++; &#125; for(int i=1;i&lt;=n;i++) &#123; if(i!=1) cout&lt;&lt;&quot; &quot;; cout&lt;&lt;sum[pre[i]]-1; &#125; cout&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>nowcoder</tag>
        <tag>union-find</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A big change]]></title>
    <url>%2Fblog%2F2019%2F04%2F21%2FChange%2F</url>
    <content type="text"><![CDATA[To study English,and make my blog become large and luxurious,i have changed the main language of my blog from Chinese to English.Hope my English and programming&#39;s ablity can upgrade together. some changesI will correct the tags and categories tomorrow,though it will be too troublesome. I have already changed tags and categories. 2019.4.22 6:34 What next?“About” page! Carry out! in 2019.4.22. 7:29 The comment system Valine is Chinese now,i can&#39;t solve this,but i will finish this in the future. Carry out in 2019.4.22 10:20 How to put a post to the top?At first,i installed the plugin to achieve this,and something wrong happened.The top flag is there, but there is no function to achieve the top.So isearched this online.Finally,i still don&#39;t known why,but i solve this problem through other method. Implemented by modifying the filefile path:1Ur blog name/node_modules/hexo-generator-index/lib/generator.js Add the following codes in the file12345678910111213posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // Both articles have definitions on top if(a.top == b.top) return b.date - a.date; // If the top value is the same, it will be sorted according to the article date. else return b.top - a.top; // Otherwise,it willed be sorted according the value of top. &#125; else if(a.top &amp;&amp; !b.top) &#123; // The following is only one article top definition, then there will be top in front（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // Did not define the descending order according to the article date&#125;); At first,I didn&#39;t know much about js and didn&#39;t know where to insert it, so I failed several times.So if you are experiencing the same situation as me,you can directly copy these following codes and paste in your file.Note: just cover it all.12345678910111213141516171819202122232425262728&apos;use strict&apos;;var pagination = require(&apos;hexo-pagination&apos;);module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; if(a.top == b.top) return b.date - a.date; else return b.top - a.top; &#125; else if(a.top &amp;&amp; !b.top) &#123; return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; &#125;); var paginationDir = config.pagination_dir || &apos;page&apos;; return pagination(&apos;&apos;, posts, &#123; perPage: config.index_generator.per_page, layout: [&apos;index&apos;, &apos;archive&apos;], format: paginationDir + &apos;/%d/&apos;, data: &#123; __index: true &#125; &#125;);&#125;; How to display the flag of the topThis is easy.You still need to modify some files to achieve this features.file path:1Ur blog name/themes/next/layout/_macro/post.swig First,find the place of&lt;div class=&quot;post-meta&quot;&gt;.Second,insert these following codes12345&#123;% if post.top %&#125; &lt;i class=&quot;fa fa-thumb-tack&quot;&gt;&lt;/i&gt;//You can choose and replace the icon you want in http://www.fontawesome.com.cn/. &lt;font color=green&gt;Topping&lt;/font&gt;//You can change the color and specific content of the top logo in this. &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&#123;% endif %&#125; Of course,if you are not sure where to insert it,just compare with the code below.12345678910&lt;div class=&quot;post-meta&quot;&gt; &lt;span class=&quot;post-time&quot;&gt; &#123;% if post.top %&#125; &lt;i class=&quot;fa fa-thumb-tack&quot;&gt;&lt;/i&gt; &lt;font color=7D26CD&gt;Topping&lt;/font&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt; &#123;% endif %&#125; &#123;% set date_diff = date(post.date) != date(post.updated) %&#125; &#123;% set time_diff = time(post.date) != time(post.updated) %&#125; &#123;% set datetime_diff = date_diff or time_diff %&#125; RenderingReference article: https://blog.csdn.net/weixin_42556146/article/details/80836875 The introduction about the top is here. A really big changeGreat change, like changing the blog&#39;s bloodReference article: https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html Add article image summary The reason of why use this First of all, the abstract of the article refers to the part of the content that each article displays on the page, which is the content of the previous article. Since it will be displayed on the page, adding an image to the article summary for each article will make the page look beautiful. RenderingFirst,Edit this file1Urblog name/themes/next/_config.yml Change into1234excerpt_description: falseauto_excerpt: enable: false Second,add these fowlling codes into this file1Urblog Urblog name/themes/next/layout/_macro/post.swig codes12345&#123;% if post.image %&#125;&lt;div class=&quot;out-img-topic&quot;&gt; &lt;img src=&#123;&#123; post.image &#125;&#125; class=&quot;img-topic&quot; /&gt;&lt;/div&gt;&#123;% endif %&#125; If you change it correctly, this file will look like this.1234567891011121314151617181920212223242526 &#123;% if is_index %&#125; &#123;% if post.description and theme.excerpt_description %&#125; &#123;&#123; post.description &#125;&#125; &lt;!--noindex--&gt; &lt;div class=&quot;post-button text-center&quot;&gt; &lt;a class=&quot;btn&quot; href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot;&gt; &#123;&#123; __(&apos;post.read_more&apos;) &#125;&#125; &amp;raquo; &lt;/a&gt; &lt;/div&gt; &lt;!--/noindex--&gt; &#123;% elif post.excerpt %&#125; &#123;&#123; post.excerpt &#125;&#125;+ + &#123;% if post.image %&#125;+ &lt;div class=&quot;out-img-topic&quot;&gt;+ &lt;img src=&#123;&#123; post.image &#125;&#125; class=&quot;img-topic&quot; /&gt;+ &lt;/div&gt;+ &#123;% endif %&#125;+ &lt;!--noindex--&gt; &lt;div class=&quot;post-button text-center&quot;&gt; &lt;a class=&quot;btn&quot; href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&#123;% if theme.scroll_to_more %&#125;#&#123;&#123; __(&apos;post.more&apos;) &#125;&#125;&#123;% endif %&#125;&quot; rel=&quot;contents&quot;&gt; &#123;&#123; __(&apos;post.read_more&apos;) &#125;&#125; &amp;raquo; &lt;/a&gt; &lt;/div&gt; &lt;!--/noindex--&gt; Third,add these following codes into this file1Urblog name/themes/next/source/css/_custom/custom.styl codes12345678910111213141516//图片外部的容器方框.out-img-topic &#123; display: block; max-height:300px; margin-bottom: 24px; overflow: hidden;&#125;//图片img.img-topic &#123; display: block ; margin-left: .7em; margin-right: .7em; padding: 0; float: right; clear: right;&#125; Now,you have already finish this.Noteadd this image: url/the picture&#39;s path. The introduction about the image summary is here. A Little Summary Today is my birthday.And I successfully set my blog very beautiful.Everything is fine! 2019.4.23 Local searchSome unknown bug was happened on the local search,so I have to remove this. 2019.4.24 22:35 Local search is fine now. 2019.6.13 10:50 Replaced the new domain nameToday, I changed the domain name for my blog. Although it cost a lot of money, it seems that it is really high.But what&#39;s a little bad is that my visitor volume and pageviews are zero, and it&#39;s very uncomfortable. 2019.4.25 23:55 About the optimization of domestic access speedI put a copy of my blog on gitee again. Domestic visitors should see that this access speed should satisfy you.New home&#39;s name. ~2019.4.25 20:32~ Add Chinese Intentional analysisBecause the visitors to my blog are still domestic, some of the meanings written in English may not be clear, so I added a Chinese meaning analysis to some blogs. The specific operation is as follows.In fact, it is a syntax of markdown.1234&lt;details&gt;&lt;summary&gt;Description&lt;/summary&gt;//Hidden&lt;/details&gt; Rendering: A so cool syntax of markdown.1234567891011&#123;% tabs common-variables %&#125;&lt;!-- tab namea --&gt;txta&lt;!-- endtab --&gt;&lt;!-- tab nameb --&gt;txtb&lt;!-- endtab --&gt;&lt;!-- tab namec --&gt;txtc&lt;!-- endtab --&gt;&#123;% endtabs %&#125; Rendering: nameanamebnamectxtatxtbtxtc Summer is comming,come here and enjoy the cool snow.Reference article: https://blog.csdn.net/stormdony/article/details/86001618 Add a file name is snow.js into \themes\next\source\js\src Edit the contents of snow.js as Choose one:123456789101112131415161718192021222324252627282930313233343536373839404142/*样式一*/(function($)&#123; $.fn.snow = function(options)&#123; var $flake = $(&apos;&lt;div id=&quot;snowbox&quot; /&gt;&apos;).css(&#123;&apos;position&apos;: &apos;absolute&apos;,&apos;z-index&apos;:&apos;9999&apos;, &apos;top&apos;: &apos;-50px&apos;&#125;).html(&apos;&amp;#10052;&apos;), documentHeight = $(document).height(), documentWidth = $(document).width(), defaults = &#123; minSize : 10, maxSize : 20, newOn : 1000, flakeColor : &quot;#AFDAEF&quot; /* 此处可以定义雪花颜色，若要白色可以改为#FFFFFF */ &#125;, options = $.extend(&#123;&#125;, defaults, options); var interval= setInterval( function()&#123; var startPositionLeft = Math.random() * documentWidth - 100, startOpacity = 0.5 + Math.random(), sizeFlake = options.minSize + Math.random() * options.maxSize, endPositionTop = documentHeight - 200, endPositionLeft = startPositionLeft - 500 + Math.random() * 500, durationFall = documentHeight * 10 + Math.random() * 5000; $flake.clone().appendTo(&apos;body&apos;).css(&#123; left: startPositionLeft, opacity: startOpacity, &apos;font-size&apos;: sizeFlake, color: options.flakeColor &#125;).animate(&#123; top: endPositionTop, left: endPositionLeft, opacity: 0.2 &#125;,durationFall,&apos;linear&apos;,function()&#123; $(this).remove() &#125;); &#125;, options.newOn); &#125;;&#125;)(jQuery);$(function()&#123; $.fn.snow(&#123; minSize: 5, /* 定义雪花最小尺寸 */ maxSize: 50,/* 定义雪花最大尺寸 */ newOn: 300 /* 定义密集程度，数字越小越密集 */ &#125;);&#125;); Choose two:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/*样式二*//* 控制下雪 */function snowFall(snow) &#123; /* 可配置属性 */ snow = snow || &#123;&#125;; this.maxFlake = snow.maxFlake || 200; /* 最多片数 */ this.flakeSize = snow.flakeSize || 10; /* 雪花形状 */ this.fallSpeed = snow.fallSpeed || 1; /* 坠落速度 */&#125;/* 兼容写法 */requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || function(callback) &#123; setTimeout(callback, 1000 / 60); &#125;;cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame || window.oCancelAnimationFrame;/* 开始下雪 */snowFall.prototype.start = function()&#123; /* 创建画布 */ snowCanvas.apply(this); /* 创建雪花形状 */ createFlakes.apply(this); /* 画雪 */ drawSnow.apply(this)&#125;/* 创建画布 */function snowCanvas() &#123; /* 添加Dom结点 */ var snowcanvas = document.createElement(&quot;canvas&quot;); snowcanvas.id = &quot;snowfall&quot;; snowcanvas.width = window.innerWidth; snowcanvas.height = document.body.clientHeight; snowcanvas.setAttribute(&quot;style&quot;, &quot;position:absolute; top: 0; left: 0; z-index: 1; pointer-events: none;&quot;); document.getElementsByTagName(&quot;body&quot;)[0].appendChild(snowcanvas); this.canvas = snowcanvas; this.ctx = snowcanvas.getContext(&quot;2d&quot;); /* 窗口大小改变的处理 */ window.onresize = function() &#123; snowcanvas.width = window.innerWidth; /* snowcanvas.height = window.innerHeight */ &#125;&#125;/* 雪运动对象 */function flakeMove(canvasWidth, canvasHeight, flakeSize, fallSpeed) &#123; this.x = Math.floor(Math.random() * canvasWidth); /* x坐标 */ this.y = Math.floor(Math.random() * canvasHeight); /* y坐标 */ this.size = Math.random() * flakeSize + 2; /* 形状 */ this.maxSize = flakeSize; /* 最大形状 */ this.speed = Math.random() * 1 + fallSpeed; /* 坠落速度 */ this.fallSpeed = fallSpeed; /* 坠落速度 */ this.velY = this.speed; /* Y方向速度 */ this.velX = 0; /* X方向速度 */ this.stepSize = Math.random() / 30; /* 步长 */ this.step = 0 /* 步数 */&#125;flakeMove.prototype.update = function() &#123; var x = this.x, y = this.y; /* 左右摆动(余弦) */ this.velX *= 0.98; if (this.velY &lt;= this.speed) &#123; this.velY = this.speed &#125; this.velX += Math.cos(this.step += .05) * this.stepSize; this.y += this.velY; this.x += this.velX; /* 飞出边界的处理 */ if (this.x &gt;= canvas.width || this.x &lt;= 0 || this.y &gt;= canvas.height || this.y &lt;= 0) &#123; this.reset(canvas.width, canvas.height) &#125;&#125;;/* 飞出边界-放置最顶端继续坠落 */flakeMove.prototype.reset = function(width, height) &#123; this.x = Math.floor(Math.random() * width); this.y = 0; this.size = Math.random() * this.maxSize + 2; this.speed = Math.random() * 1 + this.fallSpeed; this.velY = this.speed; this.velX = 0;&#125;;// 渲染雪花-随机形状（此处可修改雪花颜色！！！）flakeMove.prototype.render = function(ctx) &#123; var snowFlake = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size); snowFlake.addColorStop(0, &quot;rgba(255, 255, 255, 0.9)&quot;); /* 此处是雪花颜色，默认是白色 */ snowFlake.addColorStop(.5, &quot;rgba(255, 255, 255, 0.5)&quot;); /* 若要改为其他颜色，请自行查 */ snowFlake.addColorStop(1, &quot;rgba(255, 255, 255, 0)&quot;); /* 找16进制的RGB 颜色代码。 */ ctx.save(); ctx.fillStyle = snowFlake; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); ctx.restore();&#125;;/* 创建雪花-定义形状 */function createFlakes() &#123; var maxFlake = this.maxFlake, flakes = this.flakes = [], canvas = this.canvas; for (var i = 0; i &lt; maxFlake; i++) &#123; flakes.push(new flakeMove(canvas.width, canvas.height, this.flakeSize, this.fallSpeed)) &#125;&#125;/* 画雪 */function drawSnow() &#123; var maxFlake = this.maxFlake, flakes = this.flakes; ctx = this.ctx, canvas = this.canvas, that = this; /* 清空雪花 */ ctx.clearRect(0, 0, canvas.width, canvas.height); for (var e = 0; e &lt; maxFlake; e++) &#123; flakes[e].update(); flakes[e].render(ctx); &#125; /* 一帧一帧的画 */ this.loop = requestAnimationFrame(function() &#123; drawSnow.apply(that); &#125;);&#125;/* 调用及控制方法 */var snow = new snowFall(&#123;maxFlake:60&#125;);snow.start(); Then add these follwing contents in \themes\next\layout\_layout.swig12&lt;!-- 雪花特效 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/snow.js&quot;&gt;&lt;/script&gt; To avoid the effects of mobile access, you can add the following instead of the one above.1234567&lt;!-- 雪花特效 --&gt;&lt;script type=&quot;text/javascript&quot;&gt; var windowWidth = $(window).width(); if (windowWidth &gt; 480) &#123; document.write(&apos;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/snow.js&quot;&gt;&lt;\/script&gt;&apos;); &#125;&lt;/script&gt; Rendering: Choose one: Choose two: Snowflakes only appear on the computer side is not the effect I want.But I still do not want to affect the reading of the mobile terminal.So I try to add a else on the basic of the contents above.Just like:123456789&lt;!-- 雪花特效 --&gt;&lt;script type=&quot;text/javascript&quot;&gt; var windowWidth = $(window).width(); if (windowWidth &gt; 480) &#123; document.write(&apos;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/snow.js&quot;&gt;&lt;\/script&gt;&apos;); &#125; else document.write(&apos;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/snow_point.js&quot;&gt;&lt;\/script&gt;&apos;);&lt;/script&gt; And make the Choose two become the file snow_point.js,and then reduce the number of snowflakes.The effect achieved now is enough to satisfy me. CalendarCloudI had add a calendarcloud into my blog successfully.But there is a bug:if some posts are in a same day,you can just come in one of them.How can I solve this problem,absolutly I can&#39;t.But you can click the month number so you can view a html which is full of post title which deploy in this month. The Album PageI have to admit that the access speed of this page is too slow, it has affected the experience of my blog, so I decided to temporarily remove this page, and then re-open this page after I find a perfect method. The Email alert serviceValine-AdminFollow this step by step, I have successfully configured it, are you sure not to comment here? How to solve the problem that the symbol——&#39; is too wideAdd these follwing codes int the config.yml in your hexo root directory.12345678marked: gfm: true pedantic: false sanitize: false tables: true breaks: true smartLists: true smartypants: false Add random quotesPreview: ' //这里分配十句随机出现的文本 quotes[2] = '' quotes[3] = '' quotes[4] = '' quotes[5] = '' quotes[6] = '' quotes[7] = '' quotes[8] = '' quotes[9] = '' quotes[0] = '' var quote = quotes[rand1] //由随机数选择一句话 //--> Main code:1234567891011121314151617181920212223&lt;script language=&quot;JavaScript&quot;&gt; &lt;!-- Hide var a = Math.random() + &quot;&quot; //Generate a random numbervar rand1 = a.charAt(5) //Get the fifth character of this number (actually from 0 to 9) quotes = new Array //Create an array of messagesquotes[1] = &apos;&lt;center&gt;&lt;--你不知道我有多想因为你而有底气说出舔狗舔到最后应有尽有--&gt;&lt;/center&gt;&apos; //Assign ten randomly appearing texts herequotes[2] = &apos;&lt;center&gt;&lt;--人生就像一杯茶，不会苦一辈子，但总会苦一阵子--&gt;&lt;/center&gt;&apos; quotes[3] = &apos;&lt;center&gt;&lt;--浮天水送无穷树，带雨云埋一半山--&gt;&lt;/center&gt;&apos; quotes[4] = &apos;&lt;center&gt;&lt;--有一个夜晚我烧毁了所有的记忆，从此我的梦就透明了；有一个早晨我扔掉了所有的昨天，从此我的脚步就轻盈了--&gt;&lt;/center&gt;&apos; quotes[5] = &apos;&lt;center&gt;&lt;--哭过喊过便会停止哭泣--&gt;&lt;/center&gt;&apos; quotes[6] = &apos;&lt;center&gt;&lt;--人非圣贤，孰能无过？过而能改，善莫大焉--&gt;&lt;/center&gt;&apos; quotes[7] = &apos;&lt;center&gt;&lt;--今日，吾爱，我们融为一体--&gt;&lt;/center&gt;&apos; quotes[8] = &apos;&lt;center&gt;&lt;--人类的智慧就如同孔雀的羽毛。极尽炫耀，只是为了吸引异性--&gt;&lt;/center&gt;&apos; quotes[9] = &apos;&lt;center&gt;&lt;--不管什么时候，能够改变世界的人都是一心追逐梦想的人。--&gt;&lt;/center&gt;&apos; quotes[0] = &apos;&lt;center&gt;&lt;--人类文明从仰望星空那一刻起，就已经距离揭示宇宙奥秘仅有一步之遥了。--&gt;&lt;/center&gt;&apos; var quote = quotes[rand1] //Choose a sentence from a random number//--&gt; &lt;/script&gt; &lt;script language=&quot;JavaScript&quot;&gt; &lt;!-- Hide document.write( quote ) //Write the words selected above into the page// --&gt; &lt;/script&gt; And there has some other way to achieve this effect.You can search it if you are interested in. 一言Code:123&lt;p id=&quot;hitokoto&quot;&gt;:D 获取中...&lt;/p&gt;&lt;script src=&quot;https://v1.hitokoto.cn/?encode=js&amp;select=%23hitokoto&quot; defer&gt;&lt;/script&gt; Add countdownCode:12345678910111213141516171819202122&lt;DIV id=&quot;CountMsg&quot; class=&quot;HotDate&quot;&gt;&lt;span id=&quot;td&quot;&gt;00天&lt;/span&gt;&lt;/DIV&gt;&lt;script type=&quot;text/javascript&quot;&gt;function getRTime()&#123;var EndTime= new Date(&apos;2020/10/23 10:00:00&apos;); //截止时间var NowTime = new Date();var t =EndTime.getTime() - NowTime.getTime();var d=Math.floor(t/1000/60/60/24);var h=Math.floor(t/1000/60/60%24);var m=Math.floor(t/1000/60%60);var s=Math.floor(t/1000%60);document.getElementById(&quot;td&quot;).innerHTML = &quot;距离一切结束还有&quot;+d+ &quot;天&quot;;document.getElementById(&quot;th&quot;).innerHTML = h+&quot;时&quot;;document.getElementById(&quot;tm&quot;).innerHTML = m+&quot;分&quot;;document.getElementById(&quot;ts&quot;).innerHTML = s+&quot;秒&quot;;&#125;setInterval(getRTime,1000);&lt;/script&gt; Add a guide page and a new about page.These days I spend all my free time on this,and now it&#39;s OK.Welcome to give me your advices. 说来惭愧，只记得一个女生的生日，却连家人的都记不住。爸 八月初四妈 十一月初九姐 二月初一]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小y的序列]]></title>
    <url>%2Fblog%2F2019%2F04%2F19%2Fnowcoder-practis44-A%2F</url>
    <content type="text"><![CDATA[又是一道不涉及算法，偏重于思维的水题诶。妥妥的签到，虽然我也没有自己成功的做出来。 牛客练习赛44 A 小y的序列题目链接：小y的序列题目描述：小y有一块长度为n的布匹。颜色全部为0。他要给这个布匹染色。他总共有m种染料。小y认为一种染料用多次是不和谐的。所以每种染料会被用刚好一次。也就是说小y要给这块布匹染m次色。第i次会把Li到Ri这个区间染成颜色i。现在给出最终布匹每段的颜色。请你输出一种染色方案。数据保证有解输入描述:输入共两行。第一行两个个正整数n,m，表示布匹的长度和染料的数量第二行n个用空格隔开的正整数，第i个数字ai表示第i个布匹的颜色。输出描述:输出m行。第i行包含两个正整数Li,Ri,表示第i次染色的区间。示例1输入3 31 2 3输出1 32 33 3 备注:1≤n,m≤1e50≤ai≤m1≤Li≤Ri≤n 题意分析:其实这道题就是让你找一个数第一次出现和最后一次出现的地方，然后输出就行。这里我用到了map，但是为什么会WA呢，因为题目中要求的是每种颜色都要用到，但是如果有一种颜色在最后的结果中没有出现并且不做处理的话，输出出来的结果就会有某几种颜色没有使用到，而题目又保证数据有解，所以我们只需要特判一下就行了。代码实现12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;const int maxn=1e5+7;int a[maxn];int main()&#123; map&lt;int,int&gt; ma; map&lt;int,int&gt; ma2; int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; if(!ma[a[i]]) ma[a[i]]=i; ma2[a[i]]=i; &#125; for(int i=1;i&lt;=m;i++) &#123; if(ma[i]==0) cout&lt;&lt;ma[m]&lt;&lt;&quot; &quot;&lt;&lt;ma2[m]&lt;&lt;endl; else cout&lt;&lt;ma[i]&lt;&lt;&quot; &quot;&lt;&lt;ma2[i]&lt;&lt;endl; &#125; return 0;&#125; 一开始WA了好几次，最后才意识到需要有一个特判。每天也就做做水题维持一下生活这样子了。😢]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>nowcoder</tag>
        <tag>Thinking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生活不止眼前的苟且，还有诗和远方的田野]]></title>
    <url>%2Fblog%2F2019%2F04%2F19%2Flife-summary%2F</url>
    <content type="text"><![CDATA[总结过去一段时间的生活。 首先说一下大学生活吧，确实没有高中时候期待的那样美好。一点都不舒服，每天忙的要死，又有很多听不懂还学不会的东西，确实没有幻想中的那么美好，毕竟还是要奋斗的，死于安乐啊。 然后说一下关于协会的事吧，早在刚来学校前就知道了这个协会，一开始也是被公费旅游给吸引的妥妥的。可是很现实的就是有实力才能出去比赛，出去公费旅游。运气也是不错，来来回回出去了好几次。可是五月份那个驻马店的省赛去不了了诶，贼难受，不过还是因为自己菜，如果我也很厉害还是可以去。可惜没如果。。。而且最近真的是不知道怎么提示，复杂一点的算法就看不懂了很难受，也就一直水水cf上面简单的思维题，给自己一个没有退步的假象，实际上真的是越来越菜。还是加油吧，争取多出去玩几次。 然后说一下sublime，这个玩意是真的好用，就是配置成c/c++的IDE的话好难。。。前前后后搞了好几次，就在昨天晚上终于是搞好了，还通过下载插件实现了sublime中编辑markdown并实时预览的功能(快捷键：ALT+m)，真好用。还很漂亮。这里提一下，用sublime下载插件如果会出错，建议用手机的4G网络开热点进行下载，具体是什么原因可以网上看，我也解释不清。还有就是google上的momomentum插件每次显示的壁纸都贼漂亮，一番查找终于是找到了图片的位置，有一种直接在网站上可以下载的方法可是我不会，但是可以在本地文件夹找到，文件路径为1C:\Users\11204\AppData\Local\Google\Chrome\User Data\Default\Extensions\laookkfknpbbblfpciffpaejjkokdgca\1.8.3_0(版本号)\backgrounds]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Expedition]]></title>
    <url>%2Fblog%2F2019%2F04%2F18%2Fpoj-2431%2F</url>
    <content type="text"><![CDATA[最近学长开的算法课中了解到了优先队列，又正好在白书上看到一道可以用优先队列实现的题，磕了小半天，终于是在白书的帮助下AC啦。🌞 poj 2431 Expedition题目链接：poj 2431 Expedition题目描述：A group of cows grabbed a truck and ventured on an expedition deep into the jungle. Being rather poor drivers, the cows unfortunately managed to run over a rock and puncture the truck&#39;s fuel tank. The truck now leaks one unit of fuel every unit of distance it travels. To repair the truck, the cows need to drive to the nearest town (no more than 1,000,000 units distant) down a long, winding road. On this road, between the town and the current location of the truck, there are N (1 &lt;= N &lt;= 10,000) fuel stops where the cows can stop to acquire additional fuel (1..100 units at each stop). The jungle is a dangerous place for humans and is especially dangerous for cows. Therefore, the cows want to make the minimum possible number of stops for fuel on the way to the town. Fortunately, the capacity of the fuel tank on their truck is so large that there is effectively no limit to the amount of fuel it can hold. The truck is currently L units away from the town and has P units of fuel (1 &lt;= P &lt;= 1,000,000). Determine the minimum number of stops needed to reach the town, or if the cows cannot reach the town at all.Input Line 1: A single integer, N Lines 2..N+1: Each line contains two space-separated integers describing a fuel stop: The first integer is the distance from the town to the stop; the second is the amount of fuel available at that stop. Line N+2: Two space-separated integers, L and POutput Line 1: A single integer giving the minimum number of fuel stops necessary to reach the town. If it is not possible to reach the town, output -1.Sample Input 44 45 211 515 1025 10Sample Output 2Hint INPUT DETAILS: The truck is 25 units away from the town; the truck has 10 units of fuel. Along the road, there are 4 fuel stops at distances 4, 5, 11, and 15 from the town (so these are initially at distances 21, 20, 14, and 10 from the truck). These fuel stops can supply up to 4, 2, 5, and 10 units of fuel, respectively. OUTPUT DETAILS: Drive 10 units, stop to acquire 10 more units of fuel, drive 4 more units, stop to acquire 5 more units of fuel, then drive to the town.题意分析：你需要驾驶一辆卡车行驶L单位距离。最开始时，卡车上有P单位的汽油。卡车每开1单位距离需要消耗1单位的汽油。如果在途中车上的汽油耗尽，卡车就无法继续前行，因而无法到达终点。在途中一共有N个加油站。给出每个加油站到终点的距离，以及这个加油站可以给卡车最多加多少汽油，并且卡车燃料箱的容量是没有限制的。如果卡车不能到达终点输出-1，否则输出最少停留，即需要加油的次数。 解题思路就是让卡车一直走下去，直至燃料箱中剩余为0的时候，看是不是经过了加油站，并且对那些加油站可以加的油的量进行判断，实现这一步，就可以用到优先队列。并且此时我们要给卡车加最多能加的油（体现贪心的地方）。我在这里用了结构体以及结构体的排序。代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;int l,p,pos=0,ans=0,re;//re代表油箱中剩的油，pos代表现在所在的位置priority_queue&lt;int&gt; q;struct oil&#123; int a,b;&#125;s[1000005];bool cmp(oil x,oil y)&#123; return x.a&lt;y.a;&#125;int main()&#123; int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;s[i].a&gt;&gt;s[i].b; cin&gt;&gt;l&gt;&gt;p; for(int i=0;i&lt;n;i++) s[i].a=l-s[i].a; sort(s,s+n,cmp); s[n].a=l; s[n].b=0; n++; re=p; for(int i=0;i&lt;n;i++) &#123; int d=s[i].a-pos; while(re-d&lt;0)//这个while代表的是此时油箱中剩的油的量够不够走到下一个位置。 &#123; if(q.empty())//队列为空代表已经没有可以加油的地方了，也就是到不了终点了。 &#123; cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl; return 0; &#125; re+=q.top(); q.pop(); ans++; &#125; re-=d; pos=s[i].a; q.push(s[i].b); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>Greedy</tag>
        <tag>poj</tag>
        <tag>Priority queue</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gourmet Cat]]></title>
    <url>%2Fblog%2F2019%2F04%2F17%2FCodeForces-1154C%2F</url>
    <content type="text"><![CDATA[昨晚cf的一道题，记录一下。 1154C Gourmet Catcf传送门：Gourmet Catvj传送门：Gourmet Cat题目描述Polycarp has a cat and his cat is a real gourmet! Dependent on a day of the week he eats certain type of food: on Mondays, Thursdays and Sundays he eats fish food;on Tuesdays and Saturdays he eats rabbit stew;on other days of week he eats chicken stake.Polycarp plans to go on a trip and already packed his backpack. His backpack contains: a daily rations of fish food;b daily rations of rabbit stew;c daily rations of chicken stakes.Polycarp has to choose such day of the week to start his trip that his cat can eat without additional food purchases as long as possible. Print the maximum number of days the cat can eat in a trip without additional food purchases, if Polycarp chooses the day of the week to start his trip optimally. InputThe first line of the input contains three positive integers a, b and c (1≤a,b,c≤7⋅1e8) — the number of daily rations of fish food, rabbit stew and chicken stakes in Polycarps backpack correspondingly. OutputPrint the maximum number of days the cat can eat in a trip without additional food purchases, if Polycarp chooses the day of the week to start his trip optimally. Examplesinput2 1 1output4input3 2 2output7input1 100 1output3input30 20 10output39NoteIn the first example the best day for start of the trip is Sunday. In this case, during Sunday and Monday the cat will eat fish food, during Tuesday — rabbit stew and during Wednesday — chicken stake. So, after four days of the trip all food will be eaten. In the second example Polycarp can start his trip in any day of the week. In any case there are food supplies only for one week in Polycarps backpack. In the third example Polycarp can start his trip in any day, excluding Wednesday, Saturday and Sunday. In this case, the cat will eat three different dishes in three days. Nevertheless that after three days of a trip there will be 99 portions of rabbit stew in a backpack, can cannot eat anything in fourth day of a trip.题意分析：这道题大概的意思就是给定一个序列abcacba abcacba......然后给定a，b，c的个数，求能得到的最大序列的长度。观察可以发现3个a2个b2个c可以当成一组看待，然后将a，b，c通过这个原则进行缩小。缩小之后在进行判断，从第一个a开始最长的序列是多长，从第二个b开始最长序列是多长，从第三个c开始最长序列是多长，从第四个a开始最长的序列是多长。。。。。。用代码实现这部分功能就是123456789101112131415int ans=0,s=0; for(int i=1;i&lt;8;i++) &#123; int j=i,s=0; int A=a,B=b,C=c; while(A&gt;=0&amp;&amp;B&gt;=0&amp;&amp;C&gt;=0) &#123; if(j%7==1||j%7==4||j%7==0) --A; else if(j%7==3||j%7==5) --C; else --B; j++; s++; &#125; ans=max(ans,s-1); &#125; 每次计算出的s都需要减1，因为当你退出while循环的时候，a，b，c中会有一个值为-1，相当于多计算了一个字符，所以需要减一。如果不懂的话，建议手动模拟一下while循环中的内容，会有助于理解的。 这道题的代码实现1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;using namespace std;int main()&#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; int x; x=min(a/3,min(b/2,c/2)); a-=x*3; b-=x*2; c-=x*2; int ans=0,s=0; for(int i=1;i&lt;8;i++) &#123; int j=i,s=0; int A=a,B=b,C=c; while(A&gt;=0&amp;&amp;B&gt;=0&amp;&amp;C&gt;=0) &#123; if(j%7==1||j%7==4||j%7==0) --A; else if(j%7==3||j%7==5) --C; else --B; j++; s++; &#125; ans=max(ans,s-1); &#125; cout&lt;&lt;ans+7*x&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[产生冠军]]></title>
    <url>%2Fblog%2F2019%2F04%2F16%2FHDU-water%2F</url>
    <content type="text"><![CDATA[蒟蒻的HDU刷（shui）题之旅 产生冠军题目描述：有一群人，打乒乓球比赛，两两捉对撕杀，每两个人之间最多打一场比赛。球赛的规则如下：如果A打败了B，B又打败了C，而A与C之间没有进行过比赛，那么就认定，A一定能打败C。如果A打败了B，B又打败了C，而且，C又打败了A，那么A、B、C三者都不可能成为冠军。根据这个规则，无需循环较量，或许就能确定冠军。你的任务就是面对一群比赛选手，在经过了若干场撕杀之后，确定是否已经实际上产生了冠军。 Input输入含有一些选手群，每群选手都以一个整数n(n&lt;1000)开头，后跟n对选手的比赛结果，比赛结果以一对选手名字（中间隔一空格）表示，前者战胜后者。如果n为0，则表示输入结束。 Output对于每个选手群，若你判断出产生了冠军，则在一行中输出“Yes”，否则在一行中输出“No”。 Sample Input3Alice BobSmith JohnAlice Smith5a cc dd eb ea d0 Sample OutputYesNo 题意分析：刚开似乎看到这道题以为是并查集（虽然我也不会。但是经过仔细的分析可以发现，如果冠军是确定存在的，那么这个冠军肯定是没有输过的，所以可以使用c++STL中的set。将所有人和输过的人分开存进set，在比较两个set的size，如果所有人比输过的人多1，则说明冠军是存在的。代码实现 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n,a; while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n) &#123; set&lt;string&gt; x; set&lt;string&gt; y; string p,q; while(n--) &#123; cin&gt;&gt;p&gt;&gt;q; x.insert(p); x.insert(q); y.insert(q); &#125; if(x.size()-y.size()==1) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>HDU</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[咕咕的计数题 II]]></title>
    <url>%2Fblog%2F2019%2F04%2F15%2FCCPC-F-2019%2F</url>
    <content type="text"><![CDATA[这是助我们拿银牌的一道题，自己都没有想到可以A了这道题，不过这道题还是思维更重要一些。 咕咕的计数题 II题目描述咕咕最近在学习初等数论，并且对下取整函数产生了极大的兴趣。下取整函数是指一个函数，自变量为 一个实数，因变量为一个整数，这个整数恰好是小于或等于自变量的最大的整数，通常记做 ⌊x⌋。例如， ⌊2.5⌋ = 2,⌊2⌋ = 2,⌊−2.5⌋ = −3。 咕咕发现，给定一个 a，并不是所有的自然数 n 都存在一个正整数 i 使得 ⌊n/i⌋ = a。那么，如果给定 l,r，咕咕好奇在区间 [l,r] 中有多少个正整数能使这个等式有正整数解 i 呢？ 那么，聪明的你，你能告诉咕咕吗？输入第一行有一个整数 T(1 ≤ T ≤ 1e6)，表示数据组数。接下来有 T 行，每行有三个数 a,l,r(1 ≤ a ≤ 1e18,1 ≤ l ≤ r ≤ 1e18)，表示一组询问。输出输出 T 行，对每组询问，输出一个整数表示答案。样例输入45 7 107 39 421000 1000 100027 100 1000样例输出121617提示数据范围当 n = 39,a = 7 时，能找到 i = 5 使得 ⌊39 /5 ⌋ = 7。题意分析这道题就是给你一个区间和一个数a，让你求区间内有几个数跟任意数整除之后可以得到a，通过看数据范围可以发现这道题的输入量巨大，所以应该是会可以找到一个规律。并且不能使用cin和cout。找到的规律AND式子假定a为7，l为1，r为70，区间内满足条件的值有一下几组123456789101112a = 7 ,l = 1 ,r = 70714 1521 22 2328 29 30 3135 36 37 38 3942 43 44 45 46 4749 50 51 52 53 54 5556 57 58 59 60 61 62 6364 65 66 67 68 69 70 7172 73 74 75 76 77 78 7980 仔细观察以及在写出来的过程中会发现满足整除出现a的数肯定是在(a*i,a*i+(i-1))内,i=1,2,3......并且一旦超过了a的平方之后，任意一个数都可以整除之后出现a。规律已经找到了，可是该怎么实现呢，我们会发现，在小于a的平方之前，每次出现的满足条件的数的个数是1,2,3,4,5,6......这样递增的，所以我们让这个数对a整除，对整除出来的数进行从1加到它本身的求和，然后减去有可能不满足的个数，表达不满足的个数，我们看上面的列出来的数，会发现，如果这个数对a取余小于这个数对a整除，就满足条件，所以就可以判断了。写成式子就是12Sum(l/a)-(l%a&lt;l/a?(l/a-l%a):0)Sum为自定义的从1加到本身的函数，可以直接用一个公式代替，这样方便理解 然后就可以求出左区间以内满足的个数x，右区间以内满足的个数y，y-x就可以求出[x,l)之间的满足条件的个数，但是这种方法并没有对r进行判断，所以我们要再对r进行一次判断，如果r也满足，直接答案加一就行了。分三种情况考虑 左区间l大于a的平方，此时所需要输出的答案就是r-l。 左区间l小于a的平方，但右区间r大于a的平方，此时需要把区间分成两段，一段是(a*a,r),一段是(l,a*a-1)。大于a的平方的那一段的区间长度，加上小于a的平方的那一段中满足上面总结的规律的数的个数即答案。 右区间小于a的平方，此时就可以直接在(l,r)内去找满足条件的数的个数输出就行。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cmath&gt;#include&lt;cstdio&gt;using namespace std;typedef long long ll;ll Sum(ll x)&#123; if(x%2==0) return x/2*(1+x); return x*(1+x)/2;&#125;int main()&#123; int t; ll a,l,r; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; ll ans=0,x,y; scanf(&quot;%lld %lld %lld&quot;,&amp;a,&amp;l,&amp;r); if(sqrt(l)&gt;=a) &#123; ans=r-l+1; &#125; else if(sqrt(r)&gt;=a) &#123; ans=r-a*a+1; r=a*a-1; x=Sum(l/a)-(l%a&lt;l/a?(l/a-l%a):0); y=Sum(r/a)-(r%a&lt;r/a?(r/a-r%a):0); if(r%a&lt;r/a) y++; ans+=y-x; &#125; else &#123; x=Sum(l/a)-(l%a&lt;l/a?(l/a-l%a):0); y=Sum(r/a)-(r%a&lt;r/a?(r/a-r%a):0); if(r%a&lt;r/a) y++; ans=y-x; &#125; printf(&quot;%lld\n&quot;,ans); &#125; return 0;&#125; 这里有一个坑，就是分情况讨论的时候l，r跟a的平方比较的时候要对l，r开平方之后跟a比较，第一次我们交的与a的平方比较，WA了，怎么都找不到bug，最后还是机灵的队友说了一下会不会平方之后爆long long，改了一下交了还真过了。。。这数据卡的东西真多。一定要注意！！！]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>Thinking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Childhood dream]]></title>
    <url>%2Fblog%2F2019%2F04%2F14%2FDream%2F</url>
    <content type="text"><![CDATA[昨天去郑轻打了CCPC的省赛(比赛链接)，所幸被队友带飞拿了个银（队友是真的强。这题当时想都不敢想，最后听学长一说发现还挺简单的，补一下。 Childhood dream题目链接:Childhood dream题目描述：你童年时期就有一个梦想，想要加入 ACM(Association of Calculation and Magic)，今天，这个机会终于 来了。但是 ACM 只想要哪些天赋异禀的人, 比如像 tourist，他们给了你一道题来检测你是否足够机智。猜一个长度为 m 数字串，总共有 n 个提示串，解释如下： 8640 0A2BA 前面的数字说明与答案相比，有多少个位置上的数字是相同的。 B 前面的数字说明与答案相比，有多 少个数字是相同的，但是位置不一样。 0 A 就表示给出的串没有任何位置和答案是相同的。 2 B 就表示给出的串中有两个数字和答案相同，但 是位置不一样。所以，对于上面那个提示串 6457 是一个合理的答案，但是 1234 并不是。现在给你 N(N&lt;=100) 个提示串（如上所示），你需要去找到一个数字串来符合每一个提示串的要求。提示串中的每个数字都是不同的，即一个串中不会存在相同的数字。你能解决这个问题并加入 ACM 吗？输入第一行两个数字，n(n&lt;=100) 和 m(m&lt;=9）, 提示串的数量以及目标字符串的长度。然后是 n 行，每行的格式如下：s x ys 是提示串，x 是 A 前的数字，y 是 B 前的数字，等同于：s xAyB输出一行，目标串。数据保证答案唯一。样例输入6 45164 3 05174 3 05194 3 05124 3 05134 3 05104 3 0样例输出5184题意分析这道题的意思就是猜一个数，数的位数是确定的，然后会进行猜数，会给出两个数，第一个数代表位置相等且大小相等的个数，第二个数代表的是数相等但位置不等的数，通过这几次猜测，让你输出对应的满足条件的答案。因为答案最大的长度才10所以可以直接全排，全排之后对每次猜测就行A跟B的计算，然后跟输入进行比较，最后根据比较的结果得出答案，题目保证答案唯一。这样想这道题还是很水的。。。代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;string s[105];int a[105],b[105];int A[10]=&#123;0,1,2,3,4,5,6,7,8,9&#125;;int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) cin&gt;&gt;s[i]&gt;&gt;a[i]&gt;&gt;b[i]; do &#123; bool flag=0; int x,y; for(int i=0;i&lt;n;i++) &#123; x=y=0; for(int j=0;j&lt;m;j++) &#123; if(A[j]==s[i][j]-&apos;0&apos;) &#123; x++; &#125; &#125; for(int j=0;j&lt;m;j++) for(int k=0;k&lt;m;k++) &#123; if(j!=k&amp;&amp;A[j]==s[i][k]-&apos;0&apos;) y++; &#125; if(x!=a[i]||y!=b[i]) &#123; flag=1; break; &#125; &#125; if(!flag) &#123; for(int i=0;i&lt;m;i++) &#123; cout&lt;&lt;A[i]; &#125; cout&lt;&lt;endl; break; &#125; &#125;while(next_permutation(A,A+10)); return 0;&#125; 全排之后取前m位进行判断就行。虽说题有点‘水’，但要是让我自己做出来显然还是不可以的，加油吧！ 附上学霸学长修改了的我的TLE的代码，我又学到了好多东西🎈1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;int a[10]=&#123;0,1,2,3,4,5,6,7,8,9&#125;;struct guess&#123; string S; int A,B;&#125;gue[100];int n,m,x,y;bool check()&#123; int k,l; for(int i=0;i&lt;n;i++) &#123; k=l=0; for(int j=0;j&lt;m;j++) &#123; if(a[j]==gue[i].S[j]-&apos;0&apos;) k++; &#125; for(int k=0;k&lt;m;k++) for(int j=0;j&lt;m;j++) &#123; if(k==j) continue; if(a[k]==gue[i].S[j]-&apos;0&apos;) l++; &#125; if(k!=gue[i].A||l!=gue[i].B) return 0; &#125; return 1;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) cin&gt;&gt;gue[i].S&gt;&gt;gue[i].A&gt;&gt;gue[i].B; do &#123; if(check()) &#123; for(int i=0;i&lt;m;i++) cout&lt;&lt;a[i]; cout&lt;&lt;endl; break; &#125; &#125;while(next_permutation(a,a+10)); return 0;&#125;]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>Thinking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现大数加法]]></title>
    <url>%2Fblog%2F2019%2F04%2F10%2FBignumber%2F</url>
    <content type="text"><![CDATA[c语言能存的最大的数（考虑精度的情况下）是unsigned long long,能存下的最大的数是2^64-1，虽然这个数已经够大了，但是某些情况下还是会有很大的数无法用整形处理的，此时我们就要用字符串。具体思想其实就是模拟，加法就是按位相加，再考虑一下低位过来的进位就可以了。说起来简单但是实现起来就不是那么回事了。之前刚开始了解的是用数组存，好像还很麻烦，这些天突然看到一个用了string类型以及string类型有关的函数来解决这个问题的，感觉不错。先上代码12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n,a,b; a=b=0; cin&gt;&gt;n; while(n--) &#123; string s1,s2,s(10000,&apos;0&apos;); cin&gt;&gt;s1&gt;&gt;s2; cout&lt;&lt;(b++?&quot;\n&quot;:&quot;&quot;); reverse(s1.begin(),s1.end()); reverse(s2.begin(),s2.end()); for(int i=0;i&lt;s1.size();i++) &#123; s[i]=s1[i]; &#125; int temp=0; for(int i=0;i&lt;s2.size();i++) &#123; temp+=s[i]+s2[i]-&apos;0&apos;-&apos;0&apos;; s[i]=temp%10+&apos;0&apos;; temp/=10; &#125; s[s2.size()]=s[s2.size()]+temp; reverse(s.begin(),s.end()); reverse(s1.begin(),s1.end()); reverse(s2.begin(),s2.end()); cout&lt;&lt;&quot;Case &quot;&lt;&lt;b&lt;&lt;&apos;:&apos;&lt;&lt;endl; cout&lt;&lt;s1&lt;&lt;&quot; + &quot;&lt;&lt;s2&lt;&lt;&quot; = &quot;&lt;&lt;s.substr(s.find_first_not_of(&apos;0&apos;))&lt;&lt;endl; &#125; return 0;&#125; 这是HDU1002的AC代码。其中有很多是格式控制符，跟大数相加无关，所需要理解的其实就是这一步123456for(int i=0;i&lt;s2.size();i++) &#123; temp+=s[i]+s2[i]-&apos;0&apos;-&apos;0&apos;; s[i]=temp%10+&apos;0&apos;; temp/=10; &#125; temp所表示的数就是进位。另外这里面还用到s.substr()，s.find_first_not_of()函数。因为在定义结果字符串s的时候定义成了全是0的一个字符串。s.substr()用来输出子串，s.find_first_not_of()用来找到第一个不是0的字符的位置来生成子串。这样写还是很简洁的，也比较好理解。]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>Simulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hangman Judge]]></title>
    <url>%2Fblog%2F2019%2F04%2F04%2FUVA-489%2F</url>
    <content type="text"><![CDATA[在学长的指点下，买了一本紫薯来啃，前两章食用感觉还不错。。。到了第三章例题虽然可以看懂，习题已经做不出来了。到了第四章，例题都有点看不懂了🤢！！！用了接近一下午的时间做出来一道例题，登到这里记录一下，顺便夸夸自己。 UVA 489 - Hangman Judge原题链接：Hangman Judge原题链接：Hangman Judge----vj ATTENTION ：我与书上的方法不一样。并且因为我很菜，用的方法会很笨，有什么想指点的请在评论区留言，勿喷👌。题目描述In “Hangman Judge,” you are to write a program that judges a series of Hangman games. For eachgame, the answer to the puzzle is given as well as the guesses. Rules are the same as the classic gameof hangman, and are given as follows:1.The contestant tries to solve to puzzle by guessing one letter at a time.2.Every time a guess is correct, all the characters in the word that match the guess will be “turnedover.” For example, if your guess is ‘o’ and the word is “book”, then both ‘o’s in the solution willbe counted as“solved”.3.Every time a wrong guess is made, a stroke will be added to the drawing of a hangman, whichneeds 7 strokes to complete. Each unique wrong guess only counts against the contestant once. 123456789______| || O| /|\| || / \ __|_| |______|_________| 4.If the drawing of the hangman is completed before the contestant has successfully guessed all thecharacters of the word, the contestant loses.5.If the contestant has guessed all the characters of the word before the drawing is complete, thecontestant wins the game.6.If the contestant does not guess enough letters to either win or lose, the contestant chickens out.Your task as the “Hangman Judge” is to determine, for each game, whether the contestant wins,loses, or fails to finish a game.InputYour program will be given a series of inputs regarding the status of a game. All input will be in lowercase. The first line of each section will contain a number to indicate which round of the game is beingplayed; the next line will be the solution to the puzzle; the last line is a sequence of the guesses made by the contestant. A round number of ‘-1’ would indicate the end of all games (and input).OutputThe output of your program is to indicate which round of the game the contestant is currently playing as well as the result of the game. There are three possible results:You win.You lose.You chickened out. Sample Input1cheesechese2cheeseabcdefg3cheeseabcdefgij-1Sample OutputRound 1You win.Round 2You chickened out.Round 3You lose. 题意分析：计算机想一个单词让你猜，你每次可以猜一个字母，如果单词里有那个字母，所有该字母会显示出来；如果没有那个字母，则计算机会在一副“侩子手”画上填上一笔。这幅画一共需要7笔就能完成，因此你最多只能错6次。注意，猜一个已经猜过的字母也算错。（以上内容来自——算法竞赛入门经典第二版 刘汝佳编）。题目中输入的第一个字符串就是计算机想的单词，第二个字符串就是你猜的所有字符，这道题书上和我在网上看的好多用的是用一个数组标记每个字母出现的次数，但是我不会用，于是用了map来实现。这题我WA了好几次，其实大致上的实现方式是差不多的，就是会有很多细节需要考虑。题目中的输出有三种情况You win. 即在错误7次一下成功猜出了所有第一个字符串中的字符。You chickened out. 即虽然错误次数没有超过7，但是并没有猜出来所有的第一个字符串中的字符。You lose. 即全部猜对之前错误次数大于等于7了。我的解题思路：首先将第一个字符串中的所有元素用map标记value为1，然后开始询问第二个字符串中的元素，如果这个元素（即字符）的map值为一，就说明它在第一个字符串中存在，反之就说明这是一次错误的猜测，此时需要对错误的次数加一方便以后的判断。需要注意的是因为在判断的过程中如果错误的次数已经到达了7次，后面的就不需要再进行判断了，因为此时已经Lose了。还有就是每一个错误的字符最多错一次，解释一下就是如果s不是第一个字符串中的元素，尽管你在第二个字符串中出现了几个s,都还只是猜错了一次。还有一些具体的细节我们在代码里进行解释。代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n; string x,y; while(cin&gt;&gt;n&amp;&amp;n!=-1)//题目要求n为-1时退出程序 &#123; map&lt;char,int&gt; ma;//用来标记第一个字符串中出现的字符 map&lt;char,int&gt; ma1;//用来判断是否需要对错误次数进行累加 getchar(); cin&gt;&gt;x&gt;&gt;y; int p=0; for(int i=0;i&lt;x.size();i++) &#123; ma[x[i]]=1;//把第一个字符串中出现的字符全部存进map并标记为1 &#125; for(int i=0;i&lt;y.size();i++) &#123; if(ma[y[i]])//如果ma[y[i]]不为0，即说明这个元素在第一个字符串中 &#123; ma[y[i]]=0;//对最后的判断第一个字符串有没有被猜完做准备 ma1[y[i]]=1;//因为这是一个正确的字符，所以标记为1，在接下来的判断中将其跳过 &#125; else if(!ma1[y[i]])//如果ma1[y[i]]为0，说明这个字符是错误且只出现了一次的，此时需要对错误次数加一 &#123; p++; ma1[y[i]]=1;//将y[i]标记为1，再遇见y[i]的时候，错误次数不变 &#125; if(p&gt;=7) break;//错误的次数已经到达了7次，直接跳出循环 &#125; int flag=1; map&lt;char,int&gt;::iterator it;//定义一个迭代器，用来遍历map中的每一个元素 for(it=ma.begin();it!=ma.end();it++) &#123; if(it-&gt;second)//如果存在一个it-&gt;second不为0，即说明没有猜完 &#123; flag=0; break; &#125; &#125; printf(&quot;Round %d\n&quot;,n);//这个很坑，一开始就没注意到，注意看题目的输出格式！！！ if(flag)//flag为1说明在7次错误以内已经猜对了所有字符，所以输出You win. puts(&quot;You win.&quot;); else//否则对错误次数进行判定，这个里面挺好懂的，就不做详细解释了 &#123; if(p&lt;7) puts(&quot;You chickened out.&quot;); else puts(&quot;You lose.&quot;); &#125; &#125; return 0;&#125; 至此这道题就告一段落了，再次说明一下，这种方法肯定是比较麻烦的那种，我知道😭但是这是我能想起来的可以解决的方法了，以后好好了解一下数组在这方面的应用。有什么想吐槽的就来吧，我听着 书上的方法1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define maxn 100int left,chance;char s[maxn],s2[maxn];int win,lose;void guess(char ch)&#123; int bad=1; for(int i=0;i&lt;strlen(s);i++) if(s[i]==ch) &#123; left--; s[i]=&apos; &apos;; bad=0; &#125; if(bad) --chance; if(!chance) lose=1; if(!left) win=1;&#125;int main()&#123; int rnd; while(scanf(&quot;%d%s%s&quot;,&amp;rnd,s,s2)==3&amp;&amp;rnd!=-1) &#123; printf(&quot;Round %d\n&quot;,rnd); win=lose=0; left=strlen(s); chance=7; for(int i=0;i&lt;strlen(s2);i++) &#123; guess(s2[i]); if(win||lose) break; &#125; if(win) printf(&quot;You win.\n&quot;); else if(lose) printf(&quot;You lose.\n&quot;); else printf(&quot;You chickened out.\n&quot;); &#125; return 0;&#125; 书上的方法还是很直接的，直接看就可以看懂了😘]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>Thinking</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Asia区域制]]></title>
    <url>%2Fblog%2F2019%2F04%2F02%2FAsia-B%2F</url>
    <content type="text"><![CDATA[校赛一道题，记录一下。 Asia区域制题目链接：Asia区域制题目描述二进制数据是用 0 和 1 两个数码来表示的数.它的基数为 2 ，进位规则是“逢二进一”，借位规则是“借一当二”，由18世纪德国数理哲学大师莱布尼兹发现.十六进制（简写为hex或下标 16 ）在数学中是一种逢 16 进 1 的进位制.一般用数字 0 到 9 和字母 A 到 F（或 a ~ f ）表示，其中: a ~ f 表示 10 ~ 15 ，这些称作十六进制数字.请将给定的二进制数转为十六进制数，英文字母使用小写形式. 输入第一行一个正整数 T， 代表有 T 组测试数据. (1≤T≤10).接下来 T 行，每行输入一串只包含 0 和 1 的字符串（无前导 0），字符串长度：1≤length≤106. 输出对于每组测试样例，输出转化后的十六进制数并单独占一行. 样例input2110output12题意分析就是将输入的一个二进制数转换成十六进制，但是需要注意的是这里给的二进制的数很大很大，就算用unsigned long long也存不下，所以只能使用字符串处理了。二进制转换成十六进制可以每四位转换成一个十进制数，最后全部转化完的结果就是十六进制的表现形式。具体看代码实现代码实现1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string s; int n; cin&gt;&gt;n; while(n--) &#123; cin&gt;&gt;s; stack&lt;char&gt; sta; stack&lt;int&gt; sta0; for(int i=0;i&lt;s.size();i++) &#123; sta.push(s[i]); &#125; while(!sta.empty()) &#123; int flag=0,k=1,s=0; while(flag&lt;4) &#123; int m=sta.top()-&apos;0&apos;; sta.pop(); s+=m*k; k*=2; flag++; if(sta.empty()) break; &#125; sta0.push(s); &#125; while(!sta0.empty()) &#123; printf(&quot;%0x&quot;,sta0.top()); sta0.pop(); &#125; cout&lt;&lt;endl; &#125; return 0;&#125; 这里用到一个小技巧，c语言的printf的格式控制符里面有控制八进制(%o)十六进制(%0x)的控制符（具体更多的用法可以自行百度）可以直接使用。说到控制符就很气，请接着往下看。我与这题的恩恩怨怨校赛前还专门复习了一下进制转换，一开始没仔细看以为是道水题，直接WA了两发。看到数据范围才醒悟过来。跟某大佬交流时听说python写这道题贼简单，正好我也在学习python，然后就试着用python写了这道题12for i in range(int(input())): print(hex(int(input(), 2))[2:]) 毫无人性啊有没有😭python的大数。。。用python就有一种作弊的既视感。好好学习！！！]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩形面积并]]></title>
    <url>%2Fblog%2F2019%2F04%2F01%2Fknowledge%2F</url>
    <content type="text"><![CDATA[这道题在我刚刚接触算法的时候就遇见过。。。当时暴力解了出来。第二次遇见没做出来，学长教了我一下，我又没仔细学。。昨天校赛的时候再次遇见。凉透了。把学长传下来的代码自己写一遍再贴在这里，时常告诫自己！校赛原题：Mo的面积学长博客：矩形面积并题目描述Mo的老师给了他两个矩形，让他求两个矩形的面积并。Mo很忙没时间解决这种小case，请你帮他解决。 输入输入两行，每行四个整数 x,y,x1,y1 。(x,y) 是矩形左下角，(x1,y1) 是矩形的右上角. (0≤x,y,x1,y1≤1000)。 输出输出一个整数表示二个矩形的面积并。 样例input0 1 2 31 0 3 2output7学长的代码(求两个矩形相交部分的面积)12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;double a[10];int main()&#123; double l,r,u,d; for(int i=1;i&lt;=8;i++)&#123; scanf(&quot;%lf&quot;,&amp;a[i]); &#125; l=max( min(a[1],a[3]) , min(a[5],a[7]) ); r=min( max(a[1],a[3]) , max(a[5],a[7]) ); d=max( min(a[2],a[4]) , min(a[6],a[8]) ); u=min( max(a[2],a[4]) , max(a[6],a[8]) ); if( r - l &lt;= 0 || u - d &lt;= 0 ) printf(&quot;0.00\n&quot;); else printf(&quot;%.2lf\n&quot;,(r-l)*(u-d)); return 0;&#125; 校赛原题代码(在学长的代码的基础上稍加改动就行)123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;int a[10];int main()&#123; int l,r,u,d,s,s1; for(int i=1;i&lt;=8;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; l=max( min(a[1],a[3]) , min(a[5],a[7]) ); r=min( max(a[1],a[3]) , max(a[5],a[7]) ); d=max( min(a[2],a[4]) , min(a[6],a[8]) ); u=min( max(a[2],a[4]) , max(a[6],a[8]) ); if( r - l &lt;= 0 || u - d &lt;= 0 ) s1=0; else s1=(r-l)*(u-d); s=(a[4]-a[2])*(a[3]-a[1])+(a[8]-a[6])*(a[7]-a[5]); cout&lt;&lt;s-s1&lt;&lt;endl; return 0;&#125; ！！！！！！！！！！一定要记住补题！！！！！！！！！！！！]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[彩虹瓶]]></title>
    <url>%2Fblog%2F2019%2F03%2F30%2FPTA-L2-032%2F</url>
    <content type="text"><![CDATA[今天跟着众多大佬学长去了郑轻参加天梯赛，显然我拖了大佬后腿，一拖九了解一下，吓得我快来补题先。 PTA L2-032 彩虹瓶 原题链接：PTA彩虹瓶题目描述彩虹瓶的制作过程（并不）是这样的：先把一大批空瓶铺放在装填场地上，然后按照一定的顺序将每种颜色的小球均匀撒到这批瓶子里。 假设彩虹瓶里要按顺序装 N 种颜色的小球（不妨将顺序就编号为 1 到 N）。现在工厂里有每种颜色的小球各一箱，工人需要一箱一箱地将小球从工厂里搬到装填场地。如果搬来的这箱小球正好是可以装填的颜色，就直接拆箱装填；如果不是，就把箱子先码放在一个临时货架上，码放的方法就是一箱一箱堆上去。当一种颜色装填完以后，先看看货架顶端的一箱是不是下一个要装填的颜色，如果是就取下来装填，否则去工厂里再搬一箱过来。 如果工厂里发货的顺序比较好，工人就可以顺利地完成装填。例如要按顺序装填 7 种颜色，工厂按照 7、6、1、3、2、5、4 这个顺序发货，则工人先拿到 7、6 两种不能装填的颜色，将其按照 7 在下、6 在上的顺序堆在货架上；拿到 1 时可以直接装填；拿到 3 时又得临时码放在 6 号颜色箱上；拿到 2 时可以直接装填；随后从货架顶取下 3 进行装填；然后拿到 5，临时码放到 6 上面；最后取了 4 号颜色直接装填；剩下的工作就是顺序从货架上取下 5、6、7 依次装填。 但如果工厂按照 3、1、5、4、2、6、7 这个顺序发货，工人就必须要愤怒地折腾货架了，因为装填完 2 号颜色以后，不把货架上的多个箱子搬下来就拿不到 3 号箱，就不可能顺利完成任务。 另外，货架的容量有限，如果要堆积的货物超过容量，工人也没办法顺利完成任务。例如工厂按照 7、6、5、4、3、2、1 这个顺序发货，如果货架够高，能码放 6 只箱子，那还是可以顺利完工的；但如果货架只能码放 5 只箱子，工人就又要愤怒了…… 本题就请你判断一下，工厂的发货顺序能否让工人顺利完成任务。 输入格式：输入首先在第一行给出 3 个正整数，分别是彩虹瓶的颜色数量 N（1&lt;N≤10​3​​ ）、临时货架的容量 M（&lt;N）、以及需要判断的发货顺序的数量 K。 随后 K 行，每行给出 N 个数字，是 1 到N 的一个排列，对应工厂的发货顺序。 一行中的数字都以空格分隔。 输出格式：对每个发货顺序，如果工人可以愉快完工，就在一行中输出 YES；否则输出 NO。 输入样例：7 5 37 6 1 3 2 5 43 1 5 4 2 6 77 6 5 4 3 2 1输出样例：YESNONO我与这道题的恩恩怨怨：第一次看到这道题的时候，是很懵的，描述太长感觉看不懂不想看。看了榜单发现好多人做出来了，回头仔细一看，发现这就是一道栈的题。用一个栈就可以解决，虽然发现了方法，可是由于菜还是没做出来，补题补题。补题时候发现我的思路又总是出问题，在学长的帮助下，还是成功的过了这道题。题意分析：这道题跟pta上之前一道题，几乎是原题，题目是出栈序列的合理性(想找的自己翻吧，我没找到🌚)。我们不管输入的是什么都先让它入栈然后对栈顶的元素进行判断，并且将符合条件的pop出栈。具体看代码代码实现1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n,m,k,a; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; while(k--) &#123; int k=1; bool flag=0; stack&lt;int&gt; sta; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a; sta.push(a); if(sta.size()&gt;m+1) flag=1; while(!sta.empty()) &#123; if(sta.top()==k) &#123; sta.pop(); k++;//k就是用来模拟此时应放的序号，如果有对应的就对k加1，模拟的就是这个放过了，准备放下一个。 &#125; else break; &#125; &#125; if(!flag&amp;&amp;k==n+1) puts(&quot;YES&quot;); else puts(&quot;NO&quot;); &#125; return 0;&#125; Ps：if(sta.size()&gt;m+1)是因为题目中要求的有货架最多存放的数量，即栈的最大容量。可为什么是m+1而不是m呢，这个我也纠结了好久。因为我们放进去之后接下来就要对它进行判断，所以在实际的过程中它是不用放在货架（入栈）上的，所以是m+1。还是不明白的话，建议手动模拟一下，这道题就会理解的更加透彻。Warning：栈空的时候千万不要用.top()。。。不要用，不要用，不要用。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归实现十进制与二进制的转换]]></title>
    <url>%2Fblog%2F2019%2F03%2F28%2FBinary%2F</url>
    <content type="text"><![CDATA[早在之前学dfs的时候，师父就教我说用递归写二进制的转换。当时也是碰巧写了出来，进来遇见这类问题时，发现这样转换的人确实少，我还是记录一下，免得以后再忘，有兴趣的也可以看一下啦。二进制：二进制是计算技术中广泛采用的一种数制。二进制数据是用0和1两个数码来表示的数。它的基数为2，进位规则是“逢二进一”，借位规则是“借一当二”，由18世纪德国数理哲学大师莱布尼兹发现。当前的计算机系统使用的基本上是二进制系统，数据在计算机中主要是以补码的形式存储的。计算机中的二进制则是一个非常微小的开关，用“开”来表示1，“关”来表示0。20世纪被称作第三次科技革命的重要标志之一的计算机的发明与应用，因为数字计算机只能识别和处理由‘0’.‘1’符号串组成的代码。其运算模式正是二进制。19世纪爱尔兰逻辑学家乔治布尔对逻辑命题的思考过程转化为对符号&quot;0&#39;&#39;.&#39;&#39;1&#39;&#39;的某种代数演算，二进制是逢2进位的进位制。0、1是基本算符。因为它只使用0、1两个数字符号，非常简单方便，易于用电子方式实现。转换二进制我们用的都是余数短除法，就是要转换的数对二取余，然后除以二，直到这个数为0，再将余数倒序排列即可。不懂的话请看图示：这里的倒序输出，我们想到的就是用数组或者栈来实现，这也是等很大众化的一种方式。我要介绍的这种方法采用的是递归，其实本质都是一样的，且不分优劣，这样写只单纯为了加深对递归的理解！12345678void Binary(int x)&#123; if(x==0) return ; Binary(x/2); cout&lt;&lt;x%2; return ;&#125; 这部分就是代码的核心。我们手动执行一下就知道这种使用递归实现的巧妙之处了。1234567891011121314当x=10时：此时x不为0，所以会执行Binary(x/2)x/2=5此时x不为0，所以会执行Binary(x/2)x/2=2此时x不为0，所以会执行Binary(x/2)x/2=1此时x不为0，所以会执行Binary(x/2)x/2=0此时x为0，所以会返回至上一次递归，而上一次递归中的x为1，所以输出x%2就是1，然后遇见return，返回上一次递归。上一次递归中x为2。所以输出x%2就是0，然后遇见return，返回上一次递归。上一次递归中x为5。所以输出x%2就是1，然后遇见return，返回上一次递归。上一次递归中x为10。所以输出x%2就是10，然后遇见return，返回上一次递归。上一次递归中x为1。此时这一次整体的递归就已经结束了，输出是1010，就是10的二进制形式。 这里比较难理解的就是每一次新的递归开始的时候，上一次的执行会“保留现场”。然后每一次递归结束后就返回上一层递归。注意：x==0时return这个判断条件必须存在，不然递归不会结束。完整代码12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;void Binary(int x)&#123; if(x==0) return ; Binary(x/2); cout&lt;&lt;x%2; return ;&#125;int main()&#123; int n; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; if(n==0) &#123; puts(&quot;0&quot;); continue; &#125; Binary(n); cout&lt;&lt;endl; &#125; return 0;&#125; 这样的话会发现如果输入的数是负数会出现错误，只需要小小的改正一下就行12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;void Binary(int x)&#123; if(x==0) return ; Binary(x/2); cout&lt;&lt;abs(x%2); return ;&#125;int main()&#123; int n; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; if(n==0) &#123; puts(&quot;0&quot;); continue; &#125; if(n&lt;0) cout&lt;&lt;&apos;-&apos;; Binary(n); cout&lt;&lt;endl; &#125; return 0;&#125; 这样就实现了任意整数转化成二进制的功能啦]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长对称子串]]></title>
    <url>%2Fblog%2F2019%2F03%2F26%2FPTA-L2-008%2F</url>
    <content type="text"><![CDATA[昨晚进行了天梯的训练赛，里面这一道题觉得很有意思。 PTA L2-008 最长对称子串题目描述对给定的字符串，本题要求你输出最长对称子串的长度。例如，给定Is PAT&amp;TAP symmetric?，最长对称子串为s PAT&amp;TAP s，于是你应该输出11。 输入格式：输入在一行中给出长度不超过1000的非空字符串。 输出格式：在一行中输出最长对称子串的长度。1234输入样例：Is PAT&amp;TAP symmetric?输出样例：11 题意分析第一眼看到这道题是没有什么思路的，但是回头发现很多人a了这题，我又仔细的思考了很久，想到一种方法，让字符串与翻转之后的它进行比较，如果出现相等的就继续比较，同时对ans加一直到下一个不相同的出现为止。再将ans与最大值比较存储后归零。但是TLE了。不过有好的pta也是给了我21分（总分25。回来之后又想了想，查了一下资料，发现一种更好用的方法。参考文章：CSDN——职业炮灰具体思路就是遍历字符串的每一个字符，每次循环中都对这个字符两边的字符进行判断，出现不一样的就退出内层循环。这里面分有两种情况，一种是最长回文串的长度是奇数，一种是偶数。其实大体上是一样的。具体可以看代码 代码实现12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string s; getline(cin,s); int l=s.size(),len=0; for(int i=0;i&lt;l;i++) &#123; for(int j=0;i-j&gt;=0&amp;&amp;i+j&lt;l;j++) &#123; if(s[i-j]!=s[i+j]) break; len=2*j+1&gt;len?2*j+1:len; &#125; for(int j=0;i-j&gt;=0&amp;&amp;i+j&lt;l;j++) &#123; if(s[i-j]!=s[i+j+1]) break; len=(2*j+2)&gt;len?(2*j+2):len; &#125; &#125; cout&lt;&lt;len&lt;&lt;endl; return 0;&#125; 总结以及向对自己说的话昨晚的天体训练赛垫底了。。。好多基础算法也都还不会，不能再沉迷于水题了，要学习。学习。学习！]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>Thinking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运算符的妙用]]></title>
    <url>%2Fblog%2F2019%2F03%2F26%2FUseful-c%2F</url>
    <content type="text"><![CDATA[运算符有很多，算数运算符，关系运算符，逻辑运算符，位运算符，赋值运算符，杂项运算符···在我做题的过程中，发现逻辑运算符用来处理某些问题时很是简单，今天总结一下我遇到过的。 位逻辑运算符——异或(^)异或指的是参与运算的两个值，如果两个相应位(二进制形式下，按位运算)相同，则结果为0，否则为1。我们先测试一下^的计算功能1234567891011121314151617181920#include&lt;stdio.h&gt;int main()&#123; int a,b; while(~scanf(&quot;%d %d&quot;,&amp;a,&amp;b)) &#123; printf(&quot;%d\n&quot;,a^b); &#125; return 0;&#125;input:0 00 11 01 1output:0110 实例分析HPUOJ 18级新生周赛第四场 A. 阴与阳题目描述阴与阳单测试点时限: 1.0 秒 内存限制: 256 MB “龟，象也；筮，数也。物生而后有象，象而后有滋，滋而后有数。” ——《左传·僖公十五年》 数，从诞生开始，就被赋予了特殊的意义。 从古希腊起，奇数就比偶数更招人喜爱。公元前6世纪的希腊哲学家毕达哥拉斯说，奇数阳刚（代表男性），偶数阴柔（代表女性）。他说，奇数拒绝被一分为二，说明它强大；偶数能被平分，说明它很脆弱。 在《周易》中，奇数代表阳爻，偶数代表阴爻。阳反而阴顺，故奇数刚而偶数柔。 而在当今素粒子领域的现象，似乎也认证了他们的见解：奇数的粒子的运动比偶数的粒子激烈。 现在定义阴数和阳数的概念：在一个无序序列中，出现次数为奇数次的数为阴数，出现次数为偶数次的数为阳数 输入第一行输入一个奇数N (1≤N≤107+1) 第二行输入N个整数x (0≤x≤109) 输入数据有多组，输入到文件结束 保证每组输入数据一定有且仅有一个阴数 输出输出每组数据中的唯一的阴数样例input123451 5 5 1 331 1 2 output1232 提示本题输入输出量比较大，请尽量使用快速的OI方法。题意分析题目描述很多，但是我们需要的就是读取里面有用的信息供自己使用。题目中说出现次数为奇数次的数为阴数，出现次数为偶数次的数为阳数，并且保证每组数据有且只有一个阴数，也就是说把两个相同的数两两消去，最后剩下的数就是阴数，不好理解的话可以想象一下扑克牌中的抽老鳖游戏，最后剩下的那个数没有与它配对的就是老鳖，也就是这里的阴数。并且看到题目中的数据范围，直接暴力显然是不行的，这里就要用到我们的^了。代码实现首先我们来看一下多个数依次异或之后的结果12345678910111213141516171819202122232425#include&lt;stdio.h&gt;int main()&#123; int t,a,b; scanf(&quot;%d %d&quot;,&amp;t,&amp;a); t-=1; while(t--) &#123; scanf(&quot;%d&quot;,&amp;b); a=a^b; &#125; printf(&quot;%d\n&quot;,a); return 0;&#125;input:51 1 2 2 351 1 2 2 231 3 1output:323 从这里你应该就可以看出异或的去重性，其实仔细想一下就很容易想到每两个相同的数异或之后为0，而0与任意一个数异或之后等于那个数，所以最后出现的数就是只出现过1+2n(奇数次)的数了。到了这里应该也可以发现，上面的代码加上多组输入就已经是本题的答案了，做简单的更改就可以了。12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; ios::sync_with_stdio(false);//使流的输入输出速度与C的输入输出持平 ll n,x,ans; while(cin&gt;&gt;n) &#123; ans=0; while(n--) &#123; cin&gt;&gt;x; ans^=x; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; 之前的ac代码蜜汁TLE了，但是用上ios::sync_with_stdio(false)与cin和cout可以过，scanf和printf却过不了。ios::sync_with_stdio(false)：iostream默认是与stdio关联在一起的，以使两者同步，因此消耗了iostream不少性能，设置为false后，不再同步了，iostream的性能提高了很多倍。而cin，cout之所以效率低，是因为先把要输出的东西存入缓冲区，再输出，导致效率降低，而这段语句可以来打消iostream的输入输出缓存，可以节省许多时间，使效率与scanf与printf相差无几。本段话摘选自(https://blog.csdn.net/deepseazbw/article/details/76672177) 位逻辑运算符————与(&amp;) 移位运算符————右移运算符(&gt;&gt;)实现快速幂&amp;运算通常用于二进制取位操作，例如一个数 &amp;1的结果就是取二进制的最末位。这可以用来判断一个整数的奇偶，二进制的最末位为0表示该数是偶数，最末位为1表示该数为奇数&gt;&gt;右移运算符，具体的用法书上和网站上总结的都有很多。快速幂也用到了这个运算符。具体实现请参考在下的学习笔记中的快速幂实现。 实例分析HDUOJ 1905 Pseudoprime numbers题目描述Time Limit: 1000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Problem DescriptionFermat&#39;s theorem states that for any prime number p and for any integer a &gt; 1, a^p == a (mod p). That is, if we raise a to the pth power and divide by p, the remainder is a. Some (but not very many) non-prime values of p, known as base-a pseudoprimes, have this property for some a. (And some, known as Carmichael Numbers, are base-a pseudoprimes for all a.)Given 2 &lt; p ≤ 1,000,000,000 and 1 &lt; a &lt; p, determine whether or not p is a base-a pseudoprime. InputInput contains several test cases followed by a line containing &quot;0 0&quot;. Each test case consists of a line containing p and a. OutputFor each test case, output &quot;yes&quot; if p is a base-a pseudoprime; otherwise output &quot;no&quot;. Sample Input3 210 3341 2341 31105 21105 30 0 Sample Outputnonoyesnoyesyes题意分析英文题面虽然不太好读懂，但是这道题的题意还是很清晰的。就是给出两个数p,a,如果p是素数输出no，否则判断a的p次方对p取模之后是不是等于a，如果不是a输出no。表面看是挺无脑的，但是看到数据范围会发现直接求n次方是不行的，绝对会超时，这时就要用到快速幂了。代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll isok(ll x)//判断是否为素数&#123; if(x&lt;2) return 0; for(ll i=2;i&lt;=sqrt(x);i++) &#123; if(x%i==0) &#123; return 0; &#125; &#125; return 1;&#125;ll poww(ll x,ll y,ll z)//快速幂&#123; ll ans=1,base=x; while(y!=0) &#123; if(y&amp;1!=0) ans=ans*base%z; base=(base%z)*(base%z)%z; y&gt;&gt;=1; &#125; return ans;&#125;int main()&#123; ll a,p; while(cin&gt;&gt;p&gt;&gt;a) &#123; if(p==0&amp;&amp;a==0) break; if(isok(p)) puts(&quot;no&quot;); else &#123; ll s=poww(a,p,p); if(s%p==a) puts(&quot;yes&quot;); else puts(&quot;no&quot;); &#125; &#125; return 0;&#125; 除去快速幂，基本上可以算是一道水题了，看代码应该都是可以看懂的。]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>Useful</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[终于搭好了]]></title>
    <url>%2Fblog%2F2019%2F03%2F26%2Fmy-blog%2F</url>
    <content type="text"><![CDATA[经过令我吐血的过程，终于是磕磕绊绊的搭好了一个白生生的博客。这是第一篇，就用来纪念这个伟大的时刻吧！还是决定简单的总结一下自己搭建的过程吧。从寒假知道可以自己搭建博客以来，就一直在百度谷歌相关的东西。刚开始看到域名注册，虚拟主机一类什么高深的东西，显然不适合我这个小白。然后就看到了github——很强大的一个网站，具体是什么作用我也不很清楚，但是用这个可以搭建一个自己的博客网站，并且是不收费的。一直搜索，又安装了各种各样的软件，结果当然是失败了。结果就是，启动：绝地求生。。。寒假开学之后，空余时间又看到了个人博客，很是羡慕别人，于是自己也想搭一个。于是我又开始了漫长的搜索，网上的好多教程大多数我都是看不懂的。。。毕竟电子竞技，菜是原罪。为此我还专门跑到学校图书馆找了一本书《GitHub入门到实践》，然后用自己的智商生生地把它读成了《Github从入门到放弃》。已经花费了这么多时间，自然是很不甘心的，我还是死磕着，鬼知道我经历了什么。“安装，卸载，安装，卸载。。。。。。”还有昨天晚上git下载模板用了四十分钟下载了2％，直到寝室熄灯下载还不到10％，气的我直接关掉了电脑。今天一上午的课都没好好听，一有时间就用手机搜索github搭博客的教程。中午回到寝室吃了饭就继续死磕，午休时间过去了，我下午没有课，室友有课，我一个人在寝室不停的找方法，找教程。“功夫不负有心人”，我成功了。但是我的博客的搭建却更多归功于我的一个学长学霸（手动@亦往沧劫:stuck_out_tongue_winking_eye:，就这样），我自己实在折腾不出来了，就去找学长求助。最终在学长和学长博客的帮助下，我才搭好了。万分感谢！最后还是总结一下我搭好博客的过程吧，防止今后再想搭却不会的情况，如果可能的话，也尽量帮一下想搭博客却不知道怎么做的小小白吧。我的系统是windows的。总结教程大部分的内容来自我的学霸学长他的搭建博客教程传送门:https://blog.todest.cn/post/hexo-next%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/ 下面我来用我的语言和我的想法以及我在搭建过程中出现的问题总结一下=1.首先当然是需要注册一个github的账号（传送门：github），这个注册我觉得不用详细的说，会用电脑的应改就会注册。注册好之后创建一个新的仓库，创建的时候repositort name必须保持格式&lt;username&gt;.github.io（username就是你的github账号的名字）。2 .创建成功之后，先不要管这里了。去下载git（传送门：git），Node.js（传送门：Node.js），安装的时候好多勾勾怎么选我也不是很清楚，咳咳咳，不过相信我，这不是很重要:sweat_smile::sweat_smile::sweat_smile:。3.该安装的东西都安装后，就该要配置SSH（传送门：SSH）了。打开git bash，在弹出来的框框里输入1ssh-keygen -t rsa -C &quot;邮件地址&quot; # 连续回车 邮件地址就是你注册github时候用到的邮箱。连续回车一定要有哦:grin:。然后将&quot;C:\Users\你的用户名\.ssh\id_rsa.pub&quot;的内容复制下来，打开GitHub设置-&gt;SSH and GPG keys-&gt;New SSH key（注意这里的设置是整个网站的设置，不是仓库里面的那个设置！！！），粘贴到此处确定。继续向框框内输入1ssh -T git@github.com 以测试SSH是否配置好，如果看到You&#39;ve successfully authenticated, but GitHub does not provide shell access.,就说明配置好了。4.接下来需要安装hexo，讲道理代码应该输入在git bash的框框里，可是我在安装的时候可能是因为有些勾勾没选所以在git bash中无法使用此命令,但是在cmd命令中可以正常使用。1npm install hexo-cli -g 这个命令是用来安装hexo的。安装好之后要初始化1hexo init Blog 这里的Blog是自己可以随意命名的，对应的会是在你的电脑中生成的文件夹的名称。初始化完成后，安装hexo扩展123cd Blog #进入Blog文件夹npm install hexo-deployer-git --savenpm install 把上面的代码输入命令行，等到下载完就可以下一步了。5.本地调试。123hexo cleanhexo g # 生成 此条和后一条可简写为 hexo s -g（g是generate的缩写）hexo s # 预览（s是start的缩写） hexo s是开启本地预览服务，打开浏览器访问 http://localhost:4000 即可看到内容。6.上传到GitHub pages。123hexo cleanhexo g # 此条和后一条可简写为 hexo d -ghexo d #（d是deploy的缩写） 等这些都完成得时候，你的博客也就基本上搭建完了，你可以自己去访问自己的博客了。当然我这里提到的只有最基础的搭建，具体还有更多的知识，我也在慢慢学习，并且愿意用博客记录这段历程。毕竟这是第一次博客，可能食用体验较差，望见谅。 用女神纪念-]]></content>
      <categories>
        <category>Tutorial</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十届蓝桥杯]]></title>
    <url>%2Fblog%2F2019%2F03%2F26%2FLanQiao%2F</url>
    <content type="text"><![CDATA[上一年的十二月份报了名的蓝桥杯，今天如期举行。原题：PDF版提取码：xc2kWORD版提取码：w4go早上要六点半在教学楼门口集合一起做大巴去赛点——河南科技学院。因为是周日，大早上的起来没几个人，校园里空荡荡的。准备好后就出发了，这个大巴的座非常舒服，去的路上风景也很好，心里既有害怕又有期待，第一次出去打比赛。 风景大好，去的路上我们也都聊得很开心。到了学校看到河南科技学院的大门还是比较震撼的，很高的门。并没有想象中的人山人海的感觉。机房里面气氛也很轻松。到了十一点多，负责人给我们发“午饭”。。。没人一根火腿，两个面包，一瓶水（水还没给我发，可能是因为我太菜，水都某的喝。这份300快的午餐还是很“丰盛”的嘛。比赛期间就一直听负责人说能提交的赶紧提交，有的电脑已经中了病毒。。。比赛完下午一点，本来好像是要直接走的，可是因为有些同学的电脑中了病毒，要进行延时，所以我们获得了差不多一个小时的活动时间。中间还叫上了一个本校的小姐姐给我们拍了合影嘻嘻。于是转了转学校周围吃了点饭，就出发回来了。挺充实的一天，再说一下题目吧。可能是连题都没看太懂，总觉得有点简单，基本上都能写出来，但是超时应该还是会有的。等以后真题可以看到了，就在这里补题就完事了。上面那三张照片是真好看，不过这肯定跟拍照的人没关系，肯定没有，没有（疯狂暗示。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不翻墙使用谷歌搜索的方法]]></title>
    <url>%2Fblog%2F2019%2F03%2F26%2FGoogle-search%2F</url>
    <content type="text"><![CDATA[好多朋友看见我用谷歌搜索就问我是怎么翻墙的，其实如果只是想使用Google搜索的是不需要翻墙的(单纯是为了翻墙的自己去了解一下各大VPN吧）。我把我能用谷歌搜索的过程跟大家分享一下。我用的软件 emm，神奇的是这个好像又可以直接添加插件了。。。一个小哥哥(@Faye)如是说:打开谷歌浏览器，点击右上角的三个点，进入菜单。找到更多工具选项，扩展程序就在那里面。点击进入页面后后，在右上角有一个开发者模式，点击打开。再把下载的CRX格式的插件文件用鼠标拉到扩展程序的页面，再在弹出的窗口中点击“添加扩展程序”，插件就安装上去了(๑•̀ㅂ•́)و✧(这颜文字用的，想撩他的联系我 不行的话就往下看吧。 Google Chrome(这个大家可以去直接搜索会有可以下载的) 插件伴侣 提取码：dmom 谷歌访问助手的插件 提取码：virl应该是每个浏览器都会有相应的插件，有需要的请自己去找，我在这里只提供chrome的相关软件。为什么需要插件伴侣：谷歌浏览器自Chrome67版本以后，我们从第三方下载站，自己下载插件文件，然后拖放到浏览器安装。这种方式，已经被谷歌官方禁止了！将上面两个软件下载之后并解压，文件夹里面的东西留好。找到点击打开之后，会出现以下的界面点击选择插件，找到自己下载的访问助手的插件开始安装注意下面会有一个isearch插件默认是安装的，不想要的话可以把勾点掉。安装的时候是需要退出浏览器的然后点击安装就成功了下面就是打开你的google浏览器，按照提示一步一步走下去就行，因为我之前已经安装过了，下面这些简单的步骤就不再赘述了。安装成功的效果如果安装步骤出现问题或者不知道该怎么做，我分享的压缩包里有一个pdf文件里面有比较详细的内容，可以参考一下。至此，你就可以愉快的使用谷歌搜索了，还有G-mail之类的都慢慢的探索吧，并且可以添加更多的插件来提高你的体验感。以上这种方法在pc端可以实现。 另外，http://www.hlhmf.com/谷歌镜像，可以直接使用谷歌搜索，手机电脑均可用。]]></content>
      <categories>
        <category>Tutorial</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础dfs之Lake Counting]]></title>
    <url>%2Fblog%2F2019%2F03%2F26%2FPOJ-2386%2F</url>
    <content type="text"><![CDATA[这道题是寒假时候做的，当时是看着书写的，所以印象不是很深，写进博客加深一下自己的印象，顺便尽可能的帮助一下与我一样的小小白。 POJ 2386 Lake Counting题目描述Lake CountingTime Limit: 1000MS Memory Limit: 65536K Due to recent rains, water has pooled in various places in Farmer John&#39;s field, which is represented by a rectangle of N x M (1 &lt;= N &lt;= 100; 1 &lt;= M &lt;= 100) squares. Each square contains either water (&#39;W&#39;) or dry land (&#39;.&#39;). Farmer John would like to figure out how many ponds have formed in his field. A pond is a connected set of squares with water in them, where a square is considered adjacent to all eight of its neighbors. Given a diagram of Farmer John&#39;s field, determine how many ponds he has.Input Line 1: Two space-separated integers: N and M Lines 2..N+1: M characters per line representing one row of Farmer John&#39;s field. Each character is either &#39;W&#39; or &#39;.&#39;. The characters do not have spaces between them.Output Line 1: The number of ponds in Farmer John&#39;s field.Sample Input 1234567891011121310 12W........WW..WWW.....WWW....WW...WW..........WW..........W....W......W...W.W.....WW.W.W.W.....W..W.W......W...W.......W.Sample Output3 Hint OUTPUT DETAILS: There are three ponds: one in the upper left, one in the lower left,and one along the right side. 大意分析，题目中让我们求“水洼”的个数，W表示有水，.表示无水，有水的周围八个方向内有水都算成是一个水洼。样例中的三个水洼可以加强对题意的理解。因为需要对每一个状态进行查询，所以这里我们需要用到dfs。代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;char p[105][105];int d[8][2]=&#123;0,1, 0,-1, 1,0, -1,0, 1,1, 1,-1, -1,1, -1,-1&#125;;//方向变量的定义，周围八个方向。int m,n,sum;void dfs(int x,int y)&#123; if(x&gt;=0&amp;&amp;y&gt;=0&amp;&amp;x&lt;n&amp;&amp;y&lt;m)//判断每次进行递归的时候x和y是否还在合理的范围内，否则直接退出当前循环。 &#123; if(p[x][y]==&apos;W&apos;) &#123; p[x][y]=&apos;.&apos;;//把查询到的W(有水)变成.(无水)。 for(int i=0;i&lt;8;i++) dfs(x+d[i][0],y+d[i][1]);//对每个有水地方的八个方向进行dfs，用来向下一步递归 &#125; &#125;&#125;int main()&#123; sum=0; cin&gt;&gt;n&gt;&gt;m; getchar(); for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;m;j++) &#123; cin&gt;&gt;p[i][j];//存图 &#125; getchar(); &#125; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;m;j++) &#123; if(p[i][j]==&apos;W&apos;)//从0，0开始，查询到W就开始dfs。 &#123; dfs(i,j); sum++;//每次dfs完回来之后，及说明与i，j相邻的水地没有了，所以水洼的数量加一 &#125; &#125; &#125; cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125; 参考白书之后，发现如果是八个方向的话，可以不用方向向量而是使用两层循环12345678for(int i=-1;i&lt;=1;i++) for(int j=1;j&lt;=1;j++) &#123; int nx=x+i; int ny=y+j; …… dfs(nx,ny); &#125; 这个就看个人喜好了。 我的个人喜好？]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[删除字符串中的子串]]></title>
    <url>%2Fblog%2F2019%2F03%2F26%2FPTA7-29%2F</url>
    <content type="text"><![CDATA[前段时间的一次选拔赛中遇到了这道题，没做出来。赛后搜索了一下相关的知识，发现有许多相应的函数可以直接用来做这道题。 PTA7-29 删除字符串中的子串题目链接：删除字符串中的子串 题目描述输入2个字符串S1和S2，要求删除字符串S1中出现的所有子串S2，即结果字符串中不能包含S2。 输入格式：输入在2行中分别给出不超过80个字符长度的、以回车结束的2个非空字符串，对应S1和S2。 输出格式：在一行中输出删除字符串S1中出现的所有子串S2后的结果字符串。 输入样例：Tomcat is a male ccatatcat输出样例：Tom is a male 题意分析这道题还是比较容易懂的，就是输入两个字符串S1，S2，将S1中出现的S2全部删掉即可，需要注意的是有可能删掉一个S2之后会出现一个新的S2（如样例），此时就需要再删除一次。因为输入是有空格的，所以不能直接cin。 代码实现12345678910111213141516#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; string a,b; getline(cin,a); getline(cin,b); while(a.find(b,0)!=-1) &#123; int p=a.find(b,0); a.erase(p,b.size()); &#125; cout&lt;&lt;a&lt;&lt;endl; return 0;&#125; 知识（补）不搜这道题都不知道string类型中也有这么多方便好用的函数，特此把这些常用的函数在我的博客总结一下，方便自己记忆。 原帖链接：十个你一定会用到的 C++ string 函数 赋值将字符串2赋值给字符串1： 字符串1 = 字符串2; 字符串1.assign(字符串2);1234567string s1=&quot;Drew&quot;,s2;s2=s1;cout&lt;&lt;s2&lt;&lt;&quot; &quot;;s2=&quot;is handsome&quot;;s1.assign(s2);cout&lt;&lt;s1;//运行结果：Drew is handsome 将字符串2从第m个字符开始的n个字符赋值给字符串1：字符串1.assign(字符串2, m, n);123456string s1=&quot;Uncle &quot;,s2=&quot;drew&quot;;s1.assign(s2,1,3);cout&lt;&lt;s1&lt;&lt;endl;cout&lt;&lt;s2;//运行结果：rew// drew 长度返回字符串长度： 字符串1.length(); 字符串1.size();123string s1=&quot;Uncle&quot;,s2=&quot;drew&quot;;cout&lt;&lt;s1.length()&lt;&lt;&quot; &quot;&lt;&lt;s2.size();//运行结果：5 4 比较&quot;&gt;&quot;, &quot;&lt;&quot;, &quot;==&quot;, &quot;&gt;=&quot;, &quot;&lt;=&quot;均可以用于字符串比较。这个不需要例子了。直接比较就可以 查找在字符串1中从第m个字符开始查找字符串2，返回第一次出现的首字母位置，失败时返回-1：字符串1.find(字符串2, m);123456789string s1=&quot;Uncle_drew!Uncle_drew!Uncle_drew!&quot;,s2=&quot;drew&quot;;int pos=-1;while(1)&#123; pos = s1.find(s2,pos+1); if(pos==-1) break; cout&lt;&lt;pos&lt;&lt;&quot; &quot;;&#125;//运行结果：6 17 28 在字符串1中从第m个字符开始从后向前查找字符串2，返回第一次出现的首字母位置，失败时返回-1：字符串1.rfind(字符串2, m);123456789string s1=&quot;Uncle_drew!Uncle_drew!Uncle_drew!&quot;,s2=&quot;drew&quot;;int pos=s1.size();while(pos)&#123; pos = s1.rfind(s2,pos-1); if(pos&lt;0) break; cout&lt;&lt;pos&lt;&lt;&quot; &quot;;&#125;//运行结果：28 17 6 连接将字符串2接到字符串1尾部： 字符串1.append(字符串2); //字符不可 字符串1 += 字符串2; //字符亦可1234567string s1=&quot;Uncle_&quot;,s2=&quot;drew is handsome&quot;;string s3=s1,s4=s2;s1.append(s2);cout&lt;&lt;s1&lt;&lt;&quot;\t&quot;;s3+=s4;cout&lt;&lt;s3;//运行结果：Uncle_drew is handsome Uncle_drew is handsome 将字符串2从第m个字符开始的n个字符接到字符串1尾部：字符串1.append(字符串2, m, n);1234string s1=&quot;Uncle&quot;,s2=&quot;drew is handsome&quot;;s1.append(s2,4,15);cout&lt;&lt;s1;//运行结果：Uncle is handsome 交换字符串1.swap(字符串2);1234string s2=&quot;Uncle &quot;,s1=&quot;drew is handsome&quot;;s1.swap(s2);cout&lt;&lt;s1&lt;&lt;&quot;\t&quot;&lt;&lt;s2;//运行结果：Uncle drew is handsome 子串返回字符串1从第m个字符开始的n个字符所组成的子串：字符串1.substr(m, n);123456string s1=&quot;Uncle &quot;,s2=&quot;drew is handsome&quot;;string s3,s4;s3=s1+s2;s4=s3.substr(6,20);cout&lt;&lt;s3&lt;&lt;&quot;的一个子串： &quot;&lt;&lt;s4;//运行结果：Uncle drew is handsome的一个子串： drew is handsome 替换在字符串1中删除从m开始的n个字符，然后在m处插入串s2字符串1.replace(m, n, s2);123456string s1=&quot;Uncle &quot;,s2=&quot;drew is not handsome&quot;;string s3=&quot;so&quot;,s4=&quot;not&quot;;int pos=s2.find(s4);s2.replace(pos,s4.size(),s3);cout&lt;&lt;s2;//运行结果：drew is so handsome 插入在字符串1的第m个字符处插入字符串2：字符串1.insert(m, 字符串2);12345string s1=&quot;Uncle &quot;,s2=&quot;drew is handsome&quot;;string s3=&quot;so &quot;;s2.insert(s2.find(&quot;handsome&quot;,0),s3);cout&lt;&lt;s2;//运行结果：drew is so handsome 删除从字符串1的第m个字符开始，删除n个字符：字符串1.erase(m, n);1234string s1=&quot;Uncle &quot;,s2=&quot;drew is not handsome&quot;;s2.erase(s2.find(&quot;not&quot;),4);cout&lt;&lt;s2;//运行结果：drew is handsome c语言中的string.h中也有许多对字符数组操作的函数，先记着吧。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记]]></title>
    <url>%2Fblog%2F2019%2F03%2F26%2FNotes%2F</url>
    <content type="text"><![CDATA[算法协会的学长们给我们每周一次的授课，在此总结一下。（之前就总结过，现在誊到博客上）。 第一次训练第一次训练主要讲了一下基础的东西。 时间复杂度 时间复杂度栈和队列 栈和队列 栈 First in last out(FILO) 1.栈的头文件 #include&lt;stack&gt; 2.栈的定义 stack&lt;变量类型(int,char...)&gt; s(栈的名字可以自定义) 3.常用函数 s.pop() 删掉栈顶的元素 s.top() 返回值为栈顶元素的值 s.push() 向栈中输入新的元素 队列 First in first out(FIFO) 1.队列的头文件#include&lt;queue&gt; 2.队列的定义 queue&lt;变量类型(int,char...)&gt; q(队列的名字可以自定义) 3常用函数 q.pop() 删掉队列最前面的元素 q.front() 返回值为栈顶元素的值 q.push() 在队尾压入新元素 q.back() 返回值为队列最后一个元素栈和队列的通用函数 栈和队列的通用函数 q/s.empty() 如果栈(队列)为空返回true，否则返回false q/s.size()返回栈(队列)中元素的个数 sort排序(默认为升序)1234567891011121314#include&lt;bits/stdc++.h&gt; //sort的头文件为algorithm,此处的头文件为万能头文件using namespace std;int main()&#123; int n,a[100]; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; sort(a,a+n); for(int i=0;i&lt;n;i++) cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; puts(&quot;&quot;); return 0;&#125; 若想更改成降序排列，需要添加一个自定义函数123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;bool cmp(int a,int b) //变成降序&#123; return a&gt;b;&#125;int main()&#123; int n,a[100]; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; sort(a,a+n,cmp); for(int i=0;i&lt;n;i++) cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; puts(&quot;&quot;); return 0;&#125; 2018-11-30 第二次训练第二次训练主要讲了二分查找，二分答案等。 二分法的使用条件 答案区间上下限确定，即最终答案在哪个范围是容易知道的。 检验某值是否可行是个简单活，即给你个值，你能很容易的判断是不是符合题目要求。 可行解满足区间单调性，即若x是可行解，则在答案区间内x+1（也可能是x-1）也可行。几个关于二分查找的函数因为二分查找的显著优越性，c++的库中封装了几个于二分查找有关的函数。1231.lower_bound(起始地址，结束地址，要查找的数值) 返回的是大于或等于val的第一个元素位置。2.upper_bound(起始地址，结束地址，要查找的数值) 返回的是大于val的第一个元素位置。3.binary_search(起始地址，结束地址，要查找的数值) 返回的是是否存在这么一个数，是一个bool值。 第三次训练第三次训练我们讲了一些特殊容器(STL)的用法.(stl内容太复杂了,我就先不总结了，以后补上） 快速幂(自学)代码实现12345678910 int poww(int a,int b)&#123; int ans=1,base=a; while(b!=0)&#123; if(b&amp;1!=0)//判断每次循环a的奇偶 ans*=base; base*=base; b&gt;&gt;=1;//去除b的二进制数中的最后一位 &#125; return ans;&#125; 快速幂的时间复杂度： O(log₂N)]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>c/c++</tag>
        <tag>Tutorial</tag>
        <tag>Useful</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[德鲁大叔学编程搭建基本完成]]></title>
    <url>%2Fblog%2F2019%2F03%2F26%2Fpoint%2F</url>
    <content type="text"><![CDATA[经过了将近十天时间的折腾，各种各样的查阅资料，各种骚扰麻烦学长，终于是差不多像样了。这期间花费了大量时间，作业都不写了，有点太丧心病狂。结果还是不错的，哈哈。 一些还没解决但是还在想解决办法(没什么大问题)的待办项 把离家出走的DaoVoice小图标找回来(昨天应该是DaoVoice哪里出了一些问题，今天它自己回来了) [] 添加收款码可以预览的功能 让谷歌收录我的网站！！！ 实现彩色标签主要遇到的问题基本上是由next主题的版本引起的，这个还是比较忧伤的，教程中的next版本跟我的不一样，好多东西要摸索着来。重点就是站点配置文件以及主题配置文件应该好好看看，很有帮助。 与刚搭建好的对应：]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[德鲁大叔观后感]]></title>
    <url>%2Fblog%2F2019%2F03%2F26%2Fmoive-feeling-Uncle_drew%2F</url>
    <content type="text"><![CDATA[德鲁大叔 第一次听说德鲁大叔这个词是某可乐的广告，刚刚沉迷于篮球的我，在网上把几部广告都看完了。讲的是我欧文和NBA的球星换上老人妆去街球场扮猪吃老虎的故事。广告毕竟是短的，但是还是能体现出欧文的骚气的哈哈。 然后经听说了欧文拍摄了这部电影，还是很期待的，但是网上各种消息说内地是不会上映的，两分钟的宣传片不知道看了多少遍。应该是上年的十月份左右吧，这部电影上映了，果然内地没有，在网上各种找资源啊，一开始还没有，过了一两个月，慢慢的找到了资源，刚找到的那天我第一次在学校熬夜了，熬夜看完了这部电影，怎么会有这么好看的电影，这是我的第一感觉，满满的都是震撼，我都不知道该怎么去描述。通过一场球赛映射出慢慢的人生道理，让我对欧文的崇拜愈发加深。那一晚我截下了好多精彩照片，但是由于特殊原因丢失了，但是德鲁大叔这部电影在我的手机和电脑上都有存着。用痴迷来形容我是很贴切的，一有时间就看那部电影，现在我还能回忆起来那部电影从开头到结尾的每一帧画面，每一句经典的台词。上学期英语老师组织电影配音，我毫不犹豫地选择了这部电影，哈哈毕竟喜欢。 最振奋人心的就是又过了一段时间，有消息说要在内地上映了，我没去看首映，不想自己一个人去看的。可是第二天我没忍住还是去看了，但我买了两张票，我幻想着她就在我身边跟我一起看。整个放映厅除了我没别人了，真的感觉的不值，真正有意义的电影没人看。 这部电影讲的就是一个因为年少时一次失误的篮球少年从打球到教练并且赌上自己的一切想要获得洛克公园的冠军的故事，但是他的死对头夺走了他的球队还有他的女友。他开始到处去寻找组建自己新的球队，却到处碰壁，接着他遇见了德鲁大叔，在整部电影里如神一般的存在，德鲁大叔带着他一起找回当年的队友，准备拿回当年因为特殊原因失去的冠军，中间历经很多磨练，最后由篮球少年的一次绝杀夺得了冠军正好与他年少时的失误有了一个对比。剧情虽然简单，甚至有点狗血，但我觉得只要是我们打球的人都会感动，眼酸。成长就行一场球赛，总会有许多的磕磕绊绊，但是我们能做的只有克服它，迎难而上。 其实关于这部电影感触这么深还是因为篮球吧，高二开始接触篮球，现在已经三年了，时间虽然不长，但是它的魅力早就深深的吸引住了我，甚至不再允许我有其他的爱好了，因为时间都想给它。晚上不吃饭去打球，中午不睡觉去打球，逃课打球，不开心时打球，高兴时打球，它能治愈你所有的负面状态，每次都仿佛打不完，打完球回到教室趴在座位上睡一觉，这种日子已经一去不复返了。 有句话很对：无篮球不兄弟，因为篮球我结识了我最好的兄弟，也认识了很多有趣的人。可能你们本不认识，但在球场上一起打一次球就会很熟了。我喜欢篮球，感谢它带给我的一切。我喜欢的台词 It&#39;s like a perfectly orchestrated symphony. 打篮球就像演奏一首精心编排的交响乐 And what&#39;s in it for you? Love,yongblood.Only love. 那你是为了什么打篮球？ 热爱，小伙子，只有热爱。 It&#39;s getting to be about that time,ain&#39;t it? 是时候展现真正的技术了 不是吗？ There&#39;s a fine line between confidence and arrogance. 自信与自大 界限分明 This game is all mental.All mental. 篮球运动关乎精神状态 精神状态 Hand down,man down 真是手起刀落 Once a shooter,always a shooter. 一朝为投手 终身是投手 You don&#39;t stop playing &#39;couse you get old.You get old &#39;cause you stop playing. 你不是因为老了才不打球，而是你决定不打球的那一刻，你才是真的老了。 Nothing a few Ws can&#39;t fix. 没有什么是赢点球解决不了的 Play the game the right way,it fixs everything. 用最恰当的方式打一场比赛 会修复一切 What&#39;s there not to love? 篮球有让人不爱上的理由吗 Basketball&#39;s the most reliable thing in the world.Don&#39;t complain,don&#39;t ask any questions.You bounce it,comes right back up. 篮球是世界上最可靠的东西 不要抱怨 也不要问任何问题 你运球 然后它弹回你手里 唯她，篮球与兄弟不可辜负。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[祝某凡生日快乐]]></title>
    <url>%2Fblog%2F2019%2F03%2F26%2FImportant%2F</url>
    <content type="text"><![CDATA[今天我姐某凡生日快乐，22了，永远18！(手动滑稽，祝她生日快乐。记住了今天！！！]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[离散数学程序作业]]></title>
    <url>%2Fblog%2F2019%2F03%2F26%2FDiscrete-mathematics%2F</url>
    <content type="text"><![CDATA[我们离散数学课的老师布置了相关的程序作业，我将在这里分享我的作业答案以及想法。 第一章作业能够输入五个连接词符号据说这些个符号也可以在各种输入法的表情符号里找到，那样时会很方便哈！下面我来总结一下我发现的方法123∧ 合取 unicode十六进制：2227∨ 析取 unicode十六进制：2228¬ 非 unicode十六进制：00AC(不区分大小写) Ascii十进制： 172 以上三种符号均可以在进入WPS后点击菜单栏的插入--符号--其他符号选项中进行添加，自己找这些符号也可以在弹出的框框里面选择编码以及对应的值直接搜索到。12↔ 等价→ 蕴涵 以上两种符号可以在插入--公式--插入新公式中找到。示例是在word里面进行的，经我测试ppt中操作是一样的，但是在excel中插入新公式我也不知道为什么不能点，可以直接从word/ppt复制粘贴。 判断是否为合式公式 这个问题有好多方法，递归，栈，数什么高深的东西，但显然我这种小小白是绝对做不出来的，当然只能用暴力的方法了，咳咳，那谁不是曾经说过吗，暴力出奇迹。python还不是很熟悉，我先用c++来实现。 我的方法是遍历字符串中的每一个字符，通过对不同情况的分析，进行分类处理。 我们来看看这个问题，要判断是否为合式公式，那我们首先应该了解一下何为合式公式。 合式公式：将命题变项用联结词和圆括号按照一定的逻辑关系联结起来的符号串称为合式公式。 由于这几个符号的输入比较麻烦，我们这里做一下简单的替换 &amp; 合取 | 析取 ! 非 - 蕴含 = 等价例如p&amp;q !p !(p&amp;q)&amp;s|r均为合式公式，而qwp q&amp;&amp;d等均不是合式公式。代码实现(具体分情况请参考注释)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;using namespace std;char s[100000];int main()&#123; bool flag; scanf(&quot;%s&quot;,s); flag=1;//定义一个布尔类型的变量，初始赋值为1，代表是合式公式，每种条件下的判断中若发现不是合式公式，就改变flag的值为0，代表不是合式公式。 if(s[0]==&apos;)&apos;||s[0]==&apos;&amp;&apos;||s[0]==&apos;-&apos;||s[0]==&apos;=&apos;||s[0]==&apos;|&apos;)//若第一个字符就是联结词或者右括号，显然不是合式公式。 &#123; puts(&quot;Not well formed!&quot;); return 0; &#125; for(int i=0;i&lt;strlen(s);i++)//这里的这种情况判断的是如果有两个字母（即原子命题）在一起，显然也不是合式公式。 &#123; if(s[i]&gt;=65&amp;&amp;s[i]&lt;=90||s[i]&gt;=97&amp;&amp;s[i]&lt;=122) &#123; if(s[i+1]&gt;=65&amp;&amp;s[i+1]&lt;=90||s[i+1]&gt;=97&amp;&amp;s[i+1]&lt;=122) &#123; puts(&quot;Not well formed!&quot;); return 0; &#125; &#125; &#125; for(int i=1;i&lt;strlen(s);i++)//这里的这种情况判断的是如果有两个联结词（不包括非）在一起，显然也不是合式公式。 &#123; if(s[i]==&apos;&amp;&apos;||s[i]==&apos;|&apos;||s[i]==&apos;-&apos;||s[i]==&apos;=&apos;) &#123; if(s[i+1]==&apos;&amp;&apos;||s[i+1]==&apos;|&apos;||s[i+1]==&apos;-&apos;||s[i+1]==&apos;=&apos;||s[i-1]==&apos;&amp;&apos;||s[i-1]==&apos;|&apos;||s[i-1]==&apos;-&apos;||s[i-1]==&apos;=&apos;) &#123; flag=0; break; &#125; &#125; else if(s[i]==&apos;!&apos;)//如果非后面加的是联结词，显然也不是合式公式。 &#123; if(s[i+1]==&apos;&amp;&apos;||s[i+1]==&apos;|&apos;||s[i+1]==&apos;-&apos;||s[i+1]==&apos;=&apos;) &#123; flag=0; break; &#125; if(s[i+1]==&apos;!&apos;||s[i-1]==&apos;!&apos;)//如果几个非连在一起可以看成是一个。 break; else if(s[i+1]&gt;122||s[i+1]&lt;65) &#123; flag=0; break; &#125; else if(s[i+1]&gt;90&amp;&amp;s[i+1]&lt;97)//此处判断的是非后面是否加的是原子命题。 &#123; flag=0; break; &#125; &#125; &#125; stack&lt;char&gt; sta;//设定一个栈用来检测左右括号的匹配性。 for(int i=0;i&lt;strlen(s);i++) &#123; if(s[i]==&apos;)&apos;&amp;&amp;sta.empty())//如果是右括号且此时栈空（说明此右括号的前面没有与之配的左括号，所以不是合式公式）。 &#123; flag=0; break; &#125; if(s[i]==&apos;(&apos;)//如果是左括号就入栈。 &#123; sta.push(s[i]); &#125; if(s[i]==&apos;)&apos;&amp;&amp;!sta.empty())//如果是右括号，且栈不空就将栈顶的左括号除去。 &#123; sta.pop(); &#125; &#125; if(!sta.empty())//如果字符串循环完毕且栈中还有元素，说明有左括号不存在与之对应的右括号，即不为合式公式。 flag=0; if(flag) puts(&quot;Well formed&quot;); else puts(&quot;Not well informed&quot;); return 0;&#125; 求合式公式的层次给出任意命题公式的成真赋值给出任意命题公式的成假赋值判断任一命题公式的公式类型]]></content>
      <categories>
        <category>Discrete mathematics</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>python</tag>
        <tag>Discrete mathematics</tag>
        <tag>WPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[河南理工大学18级算法协会招新赛(第二场)非官方题解]]></title>
    <url>%2Fblog%2F2019%2F03%2F26%2Fhpuoj%2F</url>
    <content type="text"><![CDATA[3月10日举办了协会的第二次招新赛，为了方(ceng)便(re)广(du)大同学学习，顺便提醒自己要补题，写一下我做题时候的思考以及会的题的思路跟大家分享一下顺便互相学习！毕竟我们小白之间交流还是轻松点（手动滑稽我校oj：HPUOJ本场招新赛：河南理工大学18级算法协会招新赛(第二场) A. wzy学长温暖的签到题题目描述单测试点时限: 1.0 秒 内存限制: 256 MB 每位ACMer（JBer）都是从a+b开始的！作为本场比赛的良心出题人，怎么能忘记出a+b这么经典的题目呢？请作为ACMer的你来尝试解决它吧！ 输入单组输入每行输入两个实数a，b（用空格隔开） 输出输出a+b的结果（结果保留两位小数） 样例input1 1output2.00input1.555 1.001output2.56提示0≤a,b≤100请使用double定义变量，并使用%lf输入和输出 题意分析这道题确实没有什么难得，简单的a+b，很多人也都a了，提示写的明明白白(wzy学长是真的可爱 代码实现12345678#include&lt;stdio.h&gt;int main()&#123; double a,b; scanf(&quot;%lf %lf&quot;,&amp;a,&amp;b); printf(&quot;%.2lf\n&quot;,a+b); return 0;&#125; B. 分糖果题目描述单测试点时限: 2.0 秒 内存限制: 512 MB Codancer 现在有n颗糖果，现在他要把这n颗糖果全部分给两个小朋友Dicer和thelittleboy,已知第i颗糖果能够使小朋友的开心值增加i,为了不让两个小朋友争吵，他必须使两个小朋友最终的开心值的差值最小化，现在Codancer很头疼，请你快来帮帮他吧QAQ。 输入单组输入输入一个数n,代表codancer的糖的数量。(1≤n≤1000000000) 输出输出两个小朋友的开心值的最小差值 样例input3output0input1output1 题意分析输入一个数n，题意就是把从1-n个数分成两组让他们的和的差最小。这道题我看到第一感觉就是找规律，其实规律无非也就哪几种。这道题我们可以列出来几个情况求出来答案来找规律1 2 3 4 5 6 7 8123456789糖果数量 分配方案 最小差值1 1 0 12 1 2 13 1，2 3 04 1，4 2.3 05 1，2，5 3，4 16 1，2，3，5 4，6 17 1，2，5，6 3，4，7 08 4,6,8 1,2,3,5,7 0 现在看起来规律就很明显了，1，1，0，0，1，1，0，0......在找规律的过程中我发现从1到n的和如果是偶数，最小差值就是0，如果是奇数，最小差值就是1.于是我直接定义了一个求和函数后判断奇偶，直接T了。。。其实可以发现1100是四个一组出现的，直接n对4求余判断余数就好了。 代码实现1234567891011#include&lt;stdio.h&gt;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); if(n%4==0||n%4==3) puts(&quot;0&quot;); else puts(&quot;1&quot;); return 0;&#125; 有些题掌握了规律实现起来就会很简单。(什么时候codancer能给我们发糖吃呢 C. 中位数题目描述单测试点时限: 2.0 秒 内存限制: 512 MB 给出一个1−n的排列，统计该排列有多少个长度为奇数的连续子序列的中位数是k。中位数是指把所有元素从小到大排列后，位于中间的数。接下来一行n个数代表这个排列。 输入单组输入一行两个数n,k代表排列的长度以及中位数。(1≤n≤100000,1≤k≤n) 输出输出满足条件的区间个数。 样例input7 45 7 2 4 3 1 6output4提示样例解释：满足条件的区间为{4}, {7,2,4}, {5,7,2,4,3}和{5,7,2,4,3,1,6}。 题意分析这道题刚看见以为是很简单的一道题，WA了几次之后才发现并不简单。最后好像也没几个人做出来这道题。学长讲的时候也没听懂。。咳咳，确实挺难。这两天为了更好的帮(ceng)助(re)大(du)家，这几天也是一直在搞这道题。不断地查阅资料，现在也差不多是搞懂了，快点来帮(ceng)助(re)大(du)家。参考于：洛谷P1627题解中位数说明这个区间内大于他的数的数量与小于他的数的数量相等。且这个题中符合题意的区间顺序是必须与输入一样的，不能更改。先找到中位数的位置标记一下，然后输入的同时对每一个数进行判断，大于中位数的标记为1，小于中位数的标记为-1。然后从中位数的左边开始第一次循环，对标记求和，如果有和为0的情况（即大于中位数的数的数量与小于中位数的数量相等），即说明这是一个符合题意的区间。接着对右边开始第二次循环，与第一次循环相等的步骤，但是要多一步，就是要考虑中位数位于区间中间（不是两端）的情况。具体可以在代码中解释。最后得到的答案还要加一，因为中位数自己一个区间也是可以的。 代码实现123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;int a[100050],flag[100050],f[200050];const int key=100000;int main()&#123; int n,k,bj,s,ans; cin&gt;&gt;n&gt;&gt;k; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; if(a[i]==k) bj=i; else if(a[i]&gt;k) flag[i]=1; else flag[i]=-1; &#125;//进行标记 s=ans=0; for(int i=bj-1;i&gt;=1;i--) &#123; s+=flag[i]; f[s+key]++;//用一个f数组来记录s为为-1，0，1时候的个数 if(s==0) ans++; &#125; s=0; for(int i=bj+1;i&lt;=n;i++) &#123; s+=flag[i]; if(s==0) ans++; ans+=f[-s+key];//中位数在区间中的情况。 &#125; ans+=1; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 咳咳，可以对着样例和代码自己跑一遍可以加深一下理解。 D. 打麻将题目描述单测试点时限: 2.0 秒 内存限制: 512 MB 打麻将实在是太有趣了，不知道大家过年的时候有没有打麻将呢？ 我是十分喜欢打麻将的，但是因为我不够聪明，所以我经常会诈胡(不具备胡牌的条件而胡牌)，因此我希望你能帮我判断一下我当前的手牌是否符合胡牌的条件。 为了简化这个问题，我们规定胡牌的条件如下： 你必须有且仅能有一个对子(即两张相同的牌)。除了那个对子之外，其他的都是刻子(3张相同的牌)。(刻子的数量可以为0)我们用两个字符表示一张麻将： B，T, W 分别表示牌的种类为 筒子，条子，万子 。(可能你不知道这是什么意思，不过没有关系，你只需要知道这三种类型的牌是互不相同的。)数字1~9表示牌上的数字。另外用HZ，FC，BB，EE，WW，SS，NN 来分别表示除了 筒子，条子，万子 以外的 红中，发财，白板，东风，西风，南风，北风 。对于两种牌来说，只要表示它们的两个字符中第一个字符或第二个字符任意一个不同，那么它们就是不同的牌，每种牌最多只有四张。(例如：B1 和 B2，B1 和 T1,HZ 和 FC 都是不同的。)输入第一行是一个数字T，表示你需要判断的次数。(1 \leq T \leq 10000)接下来2*T行，前一行是一个数字 n 是你的手牌数，2≤n≤14，接下来一行有 n 对字符，每一对字符代表你的一张手牌。保证不会有未知的牌型，不会有任何一种牌出现超过四次，但是你的手牌数因为某种原因可能会是正常出牌不能出现的个数。输出如果可以胡牌请输出 YES，否则输出 NO 。 样例input314B1 B1 B1 T1 T1 T1 W1 W1 W1 HZ HZ HZ WW WW2BB BB7BB BB B1 B1 B1 B2 B2outputYESYESNO 题意分析题面看起来很长，但是我们需要学会如何找到有用的信息。这道题我们需要知道的就是我们手中的牌只能有一种是出现了两次，别的牌出现的只能是三次。思路一清晰实现起来就会简单点了。这道题如果按我的方法的话希望大家补一下相关的知识：基础容器之map以及c++中的string(用char数组应该也是可以的，但是string会方便一些)类型。更详细的解释我会加在代码里。 代码实现123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string s[15]; int n,a; cin&gt;&gt;n; map&lt;string,int&gt; ma; while(n--) &#123; ma.clear();//因为是多组输入，所以每次开始时都需要将map清空，避免干扰到下一次的判断。 int flag=1; cin&gt;&gt;a; for(int i=0;i&lt;a;i++) &#123; cin&gt;&gt;s[i]; ma[s[i]]++; &#125; map&lt;string,int&gt;::iterator it; for(it=ma.begin();it!=ma.end();it++) &#123; if(it-&gt;second==1||it-&gt;second==4) &#123; flag=0; break; &#125;//如果有出现一次的或者出现四次的，肯定不能胡牌。 if(it-&gt;second==2) flag++;//判断出现两次的牌的数量。 &#125; if(flag==2)//因为flag定义时的赋值是1，所以如果现在的值是2则说明出项两次的牌（字符串）只有一个，符合条件，可以胡牌。否则就不能胡牌。 puts(&quot;YES&quot;); else puts(&quot;NO&quot;); &#125; return 0;&#125; (咳咳，我还是个麻将“高手”呢， E. 假票题目描述单测试点时限: 2.0 秒 内存限制: 512 MB 春天到了，万物复苏，乍暖还寒。H城为了庆祝春天的到来，将要举办一场盛大的舞会。 由于舞会非常的盛大，H城许多的居民都想参加舞会，但是舞厅大小有限，只能容纳n个人，为了防止到时候位置不够，人太拥挤，H城城主决定在舞会开始前进行售票。城主规定，每个人只能买一张票，每张票都会有其固定的编号（1~n）。但是有一个人，由于没抢到票，居然制造了一张与真票一模一样的假票！城主知道这个消息后，当然不能允许这种行为，因此就派出他最信任的大臣你去找出制造假票的人。 输入多组输入，处理到文件结束 第一行两个数n,m (1&lt;=n&lt;=10000,0&lt;=m&lt;=n+1)，表示总共售出n张票，编号为 1 ~ n，m表示舞会当天到场的人数（注意：由于有些人可能当天有事来不了，这种情况下你可能找不到制造假票的人）。 接下来一行m个数a1,a2,.....,am，表示检票口收到的所有票的编号。 输出如果能找到假票，则输出假票编号，否则输出-1。 样例input5 63 1 4 2 3 55 31 2 4output3-1 题意分析这个题还是比较容易读懂的，就是让你输出一组数中出现了两次的数。我一开始用的是先排序然后判断每一项与它后面那一项是否相等来判断是否有出现两次的，如果有，就将这个数输出，没有就输出-1，但是不知道为什么会WA，于是又改用了map，还好最后过了。 补题排序的那种方法也是可以的，只不过因为是多组输入，因为第一次的输入票的数量如果比第二次输入的多，此时就可能会存在数组中还依然存在着一些上一组的数据，导致结果错误。参考我之前的错误代码发现其中判断是否相等的时候多循环了一次——最后一次，这就会导致WA了。改一下就行了。代码请看下面。（感谢学长哈） 这题我跟小伙伴讨论之后发现用set也是可以的，比较前后的和的大小即可，有兴趣的可以自己实现一下。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;using namespace std;int a[10050];int main()&#123; map&lt;int,int&gt; ma; int n,m,b; while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;m)) &#123; bool flag=1; ma.clear(); while(m--) &#123; cin&gt;&gt;b; ma[b]++; &#125; map&lt;int,int&gt;::iterator it; for(it=ma.begin();it!=ma.end();it++) &#123; if(it-&gt;second==2) &#123; cout&lt;&lt;it-&gt;first&lt;&lt;endl; flag=0; break; &#125; &#125; if(flag) cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl; &#125; return 0;&#125;#include&lt;bits/stdc++.h&gt;using namespace std;int a[10050];int main()&#123; int n,m; while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;m)) &#123; int ans=-1; for(int i=0;i&lt;m;i++) &#123; cin&gt;&gt;a[i]; &#125; sort(a,a+m); for(int i=0;i&lt;m-1;i++) &#123; if(a[i]==a[i+1]) &#123; ans=a[i]; break; &#125; &#125; if(ans!=-1) cout&lt;&lt;ans&lt;&lt;endl; else puts(&quot;-1&quot;); &#125; return 0;&#125; F. 字符串博弈题目描述单测试点时限: 2.0 秒 内存限制: 512 MB 一天Codancer和Todest玩游戏。现在有一个由大写字母组成的字符串s，Codancer和Todest轮流进行一下操作：如果存在i使得s[i]=s[i+1],就可以把这两个字符从s中删除。比如原本s为ABBA,现在可以把BB删除，此时s就变为AA。如果一方不能再执行此操作时，该方即为败者。现在Codancer先手，判断Codancer能否获胜。 输入单组输入输入字符串s。1≤|s|≤10000 输出如果Codancer能够获胜输出”YES”,否则输出”NO”。(不加引号)。 样例inputABBAoutputNO 题意分析我对这道题的理解就是将字符串中相邻且相同的两个字母消掉，消到不能再消，统计消除的次数就是能进行的回合数，再对回合数的奇偶进行判断就可以了。但是消除的实现还是用栈（不会的可以补一下知识，这个我的博客中也有相关的文章不过是偏实用性（就是只讲了几种函数的用法）的）比较轻松。关于栈的传送门：Uncle_drew最帅 代码实现1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;char s[10005];int main()&#123; stack&lt;char&gt; sta; cin&gt;&gt;s; int a=0; for(int i=0;i&lt;strlen(s);i++) &#123; if(i&gt;0) &#123; if(sta.top()==s[i]) &#123; sta.pop(); a++; continue; &#125; &#125; sta.push(s[i]); &#125; if(a%2==0) puts(&quot;NO&quot;); else puts(&quot;YES&quot;);&#125; (Todest很帅的，小学妹们抓住机会，ε=ε=ε=┏(゜ロ゜;)┛ G. 小w的过路费(暂无)H. 超级简单的斐波那契数列题目描述单测试点时限: 1.0 秒 内存限制: 256 MB 众所周知，斐波那契数列又称黄金分割数列，由数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入 斐波那契的通项公式为：计算斐波那契的第n项是一件容易的事，但是如果给出第n项的斐波那契数num，你能反推出n吗？ 试一试吧！ 输入第一行一个整数T (0≤T≤100)，表示测试组数。之后的T行，每行一个斐波那契数num (num≠0,1) 输出对于每个测试数据，输出一行表示数num是斐波那契数列的第几项 样例input225output35提示保证num在斐波那契数列的前200000项中 题意分析一开始我看错题，以为是数列的最大值不超过200000.。。。直接交了3次，WA了3次。。。所以说看题还是很重要的。我们昨天也都听学长说了，斐波(肥波)那契数列第50项已经爆了unsigned long long了。所以我们直接存是不现实的，这时候就需要存储的时候对其取模然后存储，并且用map存储一下每个值对应的斐波(肥波)那契数列的项数。因为输入的数会很大，所以我们需要用到字符串输入，然后用到一个很XX的东西——对字符串表示的大数取模。 代码实现对用字符串输入的大数取模(感谢学长！123456789cin&gt;&gt;s;ll ans,num; ll l=strlen(s);num=0;for(ll i=0;i&lt;l;i++)&#123; num=num*10+s[i]-&apos;0&apos;; num%=maxx;&#125;//num就是这个大数取模之后的结果。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//这道题比赛的时候我是没写出来的，赛后补题。学会了大数取模屁颠屁颠的跑去交题#include&lt;bits/stdc++.h&gt;using namespace std;const int maxx=1e9+7;typedef long long ll;ll f[200050];char s[100000];int main()&#123; map&lt;ll,ll&gt; ma; f[0]=0; f[1]=1; for(ll i=2;i&lt;200001;i++) &#123; f[i]=(f[i-1]+f[i-2])%maxx; ma[f[i]]=i; &#125;//对斐波(肥波)那契数列进行取模存储 ll n; cin&gt;&gt;n; while(n--) &#123; cin&gt;&gt;s; ll ans,num; num=0; for(ll i=0;i&lt;strlen(s);i++) &#123; num=num*10+s[i]-&apos;0&apos;; num%=maxx; &#125; cout&lt;&lt;ma[num]&lt;&lt;endl; &#125; return 0;&#125;//然后TLE了。。。观察一下(hao jiu)代码会发现我在大数取模的for循环里面每次都对s的长度重新求一次，这样是很耗费时间的，自然会tle，改一下就好#include&lt;bits/stdc++.h&gt;using namespace std;const int maxx=1e9+7;typedef long long ll;ll f[200050];char s[100000];int main()&#123; ios::sync_with_stdio(false); map&lt;ll,ll&gt; ma; f[0]=0; f[1]=1; for(ll i=2;i&lt;200001;i++) &#123; f[i]=(f[i-1]+f[i-2])%maxx; ma[f[i]]=i; &#125; ll n; cin&gt;&gt;n; while(n--) &#123; cin&gt;&gt;s; ll ans,num,l; l=strlen(s);//先把长度求出来，用的时候直接用 num=0; for(ll i=0;i&lt;l;i++) &#123; num=num*10+s[i]-&apos;0&apos;; num%=maxx; &#125; cout&lt;&lt;ma[num]&lt;&lt;endl; &#125; return 0;&#125;取模的部分也可以这样写 for(ll i=0;i&lt;s.length();i++) &#123; num=num*10+s[i]-&apos;0&apos;; num%=maxx; &#125; I. 斐波那契（非递归）题目描述单测试点时限: 2.0 秒 内存限制: 512 MB 请输出斐波那契的第n项 输入多组输入处理到文件结束，每组输入一个数n。1≤n≤10000 输出输出第n个斐波那契数对109+7取模的结果 样例input34output23 题意分析简单的斐波(肥波)那契数列问题，与J题差不多，不过加了取模。直接代码就行了。 代码实现12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;typedef long long ll;const int maxn=1e9+7;ll f[10005];int main()&#123; f[0]=0; f[1]=1; for(int i=2;i&lt;10001;i++) &#123; f[i]=f[i-1]+f[i-2]; f[i]=f[i]%maxn; &#125;//打表 int a; while(~scanf(&quot;%d&quot;,&amp;a)) &#123; cout&lt;&lt;f[a]&lt;&lt;endl; &#125; return 0;&#125; J. 斐波那契数列题目描述单测试点时限: 2.0 秒 内存限制: 512 MB 请输出斐波那契的第n项 输入单组输入每组输入一个数n。0≤n≤10 输出输出斐波那契数列的第n项 样例input0output0input1output1 题意分析妥妥的签到 代码实现123456789101112131415#include&lt;stdio.h&gt;int a[15];int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); a[0]=0; a[1]=1; for(int i=2;i&lt;=10;i++) &#123; a[i]=a[i-1]+a[i-2]; &#125;//打表 printf(&quot;%d\n&quot;,a[n]); return 0;&#125; 咳咳，写这个“题解”，我是为了帮助同学，没有骗访问量没有没有。有不懂的可以直接qq我或者网页右下角有一个可以实时联系我的小框框你们可以直接跟我聊天，看见就会回复的，有什么不同的想法和思路可以在评论区发表一下意见，毕竟不是官方题解，考虑的可能不周全莫名其妙的a题，集思广益。]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>c/c++</tag>
        <tag>Useful</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Even Substrings]]></title>
    <url>%2Fblog%2F2019%2F03%2F26%2FCodeForces-1139A%2F</url>
    <content type="text"><![CDATA[cf果然上瘾，刚才补的一题赶紧记下来。😀 1139 A Even Substringscf传送门：Even Substringsvj传送门：Even Substrings 题目描述You are given a string s=s1s2…sn of length n, which only contains digits 1, 2, ..., 9. A substring s[l…r] of s is a string slsl+1sl+2…sr. A substring s[l…r] of s is called even if the number represented by it is even. Find the number of even substrings of s. Note, that even if some substrings are equal as strings, but have different l and r, they are counted as different substrings. InputThe first line contains an integer n (1≤n≤65000) — the length of the string s. The second line contains a string s of length n. The string s consists only of digits 1, 2, ..., 9. OutputPrint the number of even substrings of s. ExamplesInput41234Output6Input42244Output10NoteIn the first example, the [l,r] pairs corresponding to even substrings are: s[1…2]s[2…2]s[1…4]s[2…4]s[3…4]s[4…4]In the second example, all 10 substrings of s are even substrings. Note, that while substrings s[1…1] and s[2…2] both define the substring &quot;2&quot;, they are still counted as different substrings. 题意分析这道题说实话直接看我真的看不懂，然后我借助翻译，，，发现还是看不懂。经过一段时间的挣扎和猜题意终于是看懂了这道题。这道题就是输入一个字符串，让我们判断它的子串中偶数的个数，偶数指的就是把子串看成是整形的偶数。字符串的长度最大时65000，所以两重for是肯定不能用的，这时候就显现出了思维的重要性。如果这个字符串表示的数是偶数，那么它的最后一位一定是2或2的倍数。根据这一点就可以判断了。具体看代码 代码实现1234567891011121314151617#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; int n; string s,l; cin&gt;&gt;n&gt;&gt;s; int ans=0; for(int i=0;i&lt;n;i++) &#123; if((s[i]-&apos;0&apos;)%2==0) ans+=(i+1); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>Thinking</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Game 23]]></title>
    <url>%2Fblog%2F2019%2F03%2F26%2FCodeForces-1141A%2F</url>
    <content type="text"><![CDATA[萌新小白白看到昨晚cf上有一场div.3难度的比赛，于是我就勇敢的踏上了签到的路。 1141A Game 23cf传送门：Game 23vj传送门：Game 23 题目描述A. Game 23Polycarp plays &quot;Game 23&quot;. Initially he has a number n and his goal is to transform it to m. In one move, he can multiply n by 2 or multiply n by 3. He can perform any number of moves. Print the number of moves needed to transform n to m. Print -1 if it is impossible to do so. It is easy to prove that any way to transform n to m contains the same number of moves (i.e. number of moves doesn&#39;t depend on the way of transformation). InputThe only line of the input contains two integers n and m (1≤n≤m≤5⋅108). OutputPrint the number of moves to transform n to m, or -1 if there is no solution. ExamplesInput120 51840Output7Input42 42Output0Input48 72Output-1NoteIn the first example, the possible sequence of moves is: 120→240→720→1440→4320→12960→25920→51840. The are 7 steps in total. In the second example, no moves are needed. Thus, the answer is 0. In the third example, it is impossible to transform 48 to 72. 题意分析因为是全英文的题面，我选择了先看样例，又看到了提示，因为紧张加小激动我把题意理解错了。。。以为是个水题（对大佬是真水题吧）。题目要求就是输入两个数，问你从第一个数变成第二个数需要几步，变化的方法是乘以2或者乘以3，如果可以，输出步数，不可以的话就输出“-1”，听学长说是质因子分解，可是我不会（哈哈哈哈，以后会了再来试试。经过我跟小伙伴的一波探讨发现可以用第二个数对第一个数先求余，如果余数不为0，直接输出“-1”。余数如果为0，就对两数的商进行处理，除以三能除尽就一直除直到除不尽，再判断，如果除以二能除尽就一直除直到除不尽，每循环一次次数加一，最后都除不尽的时候需要在进行一次判断了看现在的商是不是1，如果不是则说明变化的过程中只有二和三是不够的，所以需要输出“-1”，反之输出次数即可。 代码实现123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; ll n,m,k,a,b; cin&gt;&gt;n&gt;&gt;m; if(m%n!=0) cout&lt;&lt;&quot;-1&quot;; ll s=0; if(m%n==0) &#123; k=m/n; while(k%3==0) &#123; k/=3; s++; &#125; while(k%2==0) &#123; k/=2; s++; &#125; if(k!=1) &#123; cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl; return 0; &#125; cout&lt;&lt;s; &#125; cout&lt;&lt;endl; return 0; &#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>Thinking</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCD和LCM]]></title>
    <url>%2Fblog%2F2019%2F03%2F26%2FGCD-LCM%2F</url>
    <content type="text"><![CDATA[GCD和LCM是很常用的，但是之前一直记不住，用一篇博客总结一下，希望自己能加强记忆！ GCD(最大公约数)定义 gcd,最大公因数（英语：highest common factor，hcf）也称最大公约数（英语：greatest common divisor，gcd）是数学词汇，指能够整除多个整数的最大正整数。而多个整数不能都为零。 c/c++语言实现求GCD 求两个整数最大公约数主要的方法有： 穷举法 素因数分解 短除法 辗转相除法 这里我们主要用辗转相除法(又称欧几里得算法)求最大公因数。辗转相除法：用较大数除以较小数，再用出现的余数（第一余数）去除除数，再用出现的余数（第二余数）去除第一余数，如此反复，直到最后余数是0为止。如果是求两个数的最大公约数，那么最后的除数就是这两个数的最大公约数。具体代码实现 1234567891011121314int gcd(int x,int y)&#123; if(y==0) return x; else return gcd(y,x%y);&#125;//这种方法可以用到三目运算符来简化代码int gcd(int x.int y)&#123; return y==0?x:gcd(y,x%y);&#125; 上面这种写法用到了递归，还有就是不用递归的写法 1234567891011int gcd(int x,int y)&#123; int z; while(y!=0) &#123; z=x%y; x=y; y=z; &#125; return x;&#125; 上面两种写法本质上是一样的，就是辗转相除法. 实例分析HDUOJ 2504题目描述又见GCDTime Limit: 1000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) 有三个正整数a,b,c(a,b,c是三个大于0小于1e6的数)，其中c不等于b。若a和c的最大公约数为b，现已知a和b，求满足条件的最小的c。 Input第一行输入一个n，表示有n组测试数据，接下来的n行，每行输入两个正整数a,b。 Output输出对应的c，每组测试数据占一行。 Sample Input26 212 4Sample Output48题目分析这是一道简单的考察最大公约数的问题。给定两个数a,b求满足gcd(a,c)=b的最小的c的值且c不等于b。数据范围在1e6以内，并且c是b的倍数，所以可以每次给b加c，每次判断是不是答案即可。即123c=2*b; //因为b是a,c的最大公约数，所以c肯定是大于等于b的。又因为题目中了b不等于c，所以给c定初值为2*b。while(gcd(a,c)!=b) b+=c; //c是b的倍数，所以可以每次给b加c 完整代码实现 1234567891011121314151617181920#include&lt;stdio.h&gt;int gcd(int x,int y)&#123; if(y==0) return x; return gcd(y,x%y);&#125;int main()&#123; int a,b,n; scanf(&quot;%d&quot;,&amp;n); while(n--) &#123; scanf(&quot;%d %d&quot;,&amp;a,&amp;b); int c=2*b; while(gcd(a,c)!=b) c+=b; printf(&quot;%d\n&quot;,c); &#125; return 0;&#125; 在vj上提交运行的结果 LCM(最小公倍数)定义LCM,两个或多个整数公有的倍数叫做它们的公倍数，其中除0以外最小的一个公倍数就叫做这几个整数的最小公倍数。 c/c++实现求LCMn个数的最小公倍数就等于这n个数乘积的绝对值除以这n个数的最大公约数。即lcm(a,b)=a*b/gcd(a,b)。换句话说就是，如果n个数以及这n个数的最大公约数已知，就能求出这n个数的最小公倍数。具体代码实现 12345678int gcd(int x,int y)&#123; return y==0?x:gcd(y,x%y);&#125;int lcm(int x,int y)&#123; return x*y/gcd(x,y);&#125; 实例分析蓝桥杯历届试题 核桃的数量题目描述历届试题 核桃的数量时间限制：1.0s 内存限制：256.0MB 问题描述小张是软件项目经理，他带领3个开发组。工期紧，今天都在加班呢。为鼓舞士气，小张打算给每个组发一袋核桃（据传言能补脑）。他的要求是： 各组的核桃数量必须相同 各组内必须能平分核桃（当然是不能打碎的） 尽量提供满足1,2条件的最小数量（节约闹革命嘛） 输入格式输入包含三个正整数a, b, c，表示每个组正在加班的人数，用空格分开（a,b,c是三个小于30的数）输出格式输出一个正整数，表示每袋核桃的数量。样例输入12 4 5样例输出120样例输入23 1 1样例输出23题目分析 经过看题的过程可以发现这只是一个让求三个数的最小公倍数的水题，直接写就行。具体代码实现 12345678910111213141516#include&lt;stdio.h&gt;int gcd(int x,int y)&#123; return y==0?x:gcd(y,x%y);&#125;int lcm(int x,int y)&#123; return x*y/gcd(x,y);&#125;int main()&#123; int a,b,c; scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c); printf(&quot;%d\n&quot;,lcm(lcm(a,b),c)); return 0;&#125; 在蓝桥评测系统上提交运行的结果 总结关于最大公约数以及最小公倍数的东西先总结到这里，以后再有拓展的话会继续添加。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo背景的更换]]></title>
    <url>%2Fblog%2F2019%2F03%2F26%2Fbackground-hexo%2F</url>
    <content type="text"><![CDATA[博客搭建好之后，只有空荡荡的一篇感悟，显得有点萧瑟。这明显不符合我的气质，所以必须装饰一下。首先我选择换一个背景，因为简单（手动滑稽）。我通过我经过换背景的愉快艰辛历程总结一下换背景的一些经验。找到自己喜欢的图片，把它放进文件myblog\themes\next\source\images(博客主题中的文件夹)然后去找到myblog\themes\next\source\css\_custom中的custom.styl在里面填入代码1234567body&#123; background:url(/images/(你选择要作为背景的图片).jpg); background-size:cover; background-repeat:no-repeat; background-attachment:fixed; background-position:center;&#125; 然后重新载入一次就可以看到自己的背景了。浅色背景还好，如果背景颜色较深，需要更改透明度什么的，我继续学习！！！]]></content>
      <categories>
        <category>Tutorial</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[map的应用之Summarize to the Power of Two]]></title>
    <url>%2Fblog%2F2019%2F03%2F26%2FCodeForces-1005C%2F</url>
    <content type="text"><![CDATA[萌新小白白渴望提升，学着大佬的样子去打cf，发现div3的题还是可以磕磕绊绊(WA多点)的做出来的。记录一下 CodeForces - 1005C Summarize to the Power of Twocf原题传送门:cf真好玩vjudge传送门:cf真好玩 题目描述A sequence a1,a2,…,an is called good if, for each element ai, there exists an element aj (i≠j) such that ai+aj is a power of two (that is, 2d for some non-negative integer d). For example, the following sequences are good: [5,3,11] (for example, for a1=5 we can choose a2=3. Note that their sum is a power of two. Similarly, such an element can be found for a2 and a3),[1,1,1,1023],[7,39,89,25,89],[].Note that, by definition, an empty sequence (with a length of 0) is good. For example, the following sequences are not good: [16] (for a1=16, it is impossible to find another element aj such that their sum is a power of two),[4,16] (for a1=4, it is impossible to find another element aj such that their sum is a power of two),[1,3,2,8,8,8] (for a3=2, it is impossible to find another element aj such that their sum is a power of two).You are given a sequence a1,a2,…,an. What is the minimum number of elements you need to remove to make it good? You can delete an arbitrary set of elements. InputThe first line contains the integer n (1≤n≤120000) — the length of the given sequence. The second line contains the sequence of integers a1,a2,…,an (1≤ai≤109). OutputPrint the minimum number of elements needed to be removed from the given sequence in order to make it good. It is possible that you need to delete all n elements, make it empty, and thus get a good sequence. ExamplesInput64 7 1 5 4 9Output1Input51 2 3 4 5Output2Input116Output1Input41 1 1 1023Output0NoteIn the first example, it is enough to delete one element a4=5. The remaining elements form the sequence [4,7,1,4,9], which is good. 题意分析啊，熟悉的全英文题面，虽然看起来有点吃力但还是要看的，不记得了之前在哪里听到过这样一句话，做程序员，不能排斥英语，你要学会去适应。也把这句话送给和我一样的小白白们。其实仔细看看还是可以懂个大概的，然后就可以看样例猜题意了。这道题的意思是给你一组数，每个数都可以和另外任意一个数（不包括他自己）进行求和，如果求和之后是2的N次方，这个数就可以存在在这个数列中。如果有一个数，和其他任意一个数相加都不是2的N次方，这个数就不符合要求，题目中要求输出的就是不符合条件的数字的个数（可以为0）。我一开始想着暴力判断再慢慢优化，然后发现我的优化能力不是很强（😭逃。然后想到了map。用2的N次方减去每一个数，判断差是否存在。具体看代码实现。 代码实现1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll a[200000];int main()&#123; map&lt;ll,ll&gt; ma; ll n,i,k,ans=0; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; ma[a[i]]++;//对a[i]出现的次数进行计数 &#125; for(int i=0;i&lt;n;i++) &#123; ll er=1,g=0,j=0; for(int j=0;j&lt;31;j++) &#123; if(ma[er-a[i]]!=0)//ma[er-a[i]]不为零说明差值在数列中存在 &#123; if(er-a[i]==a[i])//如果差值为它自己，就需要接着判断 &#123; if(ma[a[i]]&gt;1) g++; &#125; else g++; &#125; er*=2;//er就是2的N次方 &#125; if(g==0) ans++;//g为0则说明差值不存在或者差值与a[i]相等且a[i]只出现一次，即a[i]不是符合条件的数。 &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 小结随着慢慢的刷题，发现这些容器，函数什么的都贼好用，解决问题的时候应该多往这方面想一想。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>c/c++</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习笔记]]></title>
    <url>%2Fblog%2F2019%2F03%2F26%2Fpython_study%2F</url>
    <content type="text"><![CDATA[持续更新ing………………我们上学期学习了python，但是觉得学的很浅，因为python的实用性我决定剩下的python要自学起来，起码可以用python做一些题吧。我会把我难以理解或者积下来的知识点放进这篇文章中。推荐大家去https://www.liaoxuefeng.com/ 廖雪峰的官方网站学习，我是在本网站的基础上进行的学习以及自己的总结。 运算符python中的运算符有些跟c是不同的。python中有两种除法123456789101112/ 这个除法计算的结果是浮点数，即使两个整数恰好整除，结果也是浮点数；&gt;&gt;&gt; 10 / 33.3333333333333335&gt;&gt;&gt; 9 / 33.0// 这个是整除，不会四舍五入的&gt;&gt;&gt; 10 // 33&gt;&gt;&gt; 10 / 120.8333333333333334&gt;&gt;&gt; 10 // 120 各种函数ord()获取字符的整数表示chr()把编码转换为对应的字符123456789101112&gt;&gt;&gt; ord("崔")23828&gt;&gt;&gt; ord("美")32654&gt;&gt;&gt; ord("美")32654&gt;&gt;&gt; chr(23828)'崔'&gt;&gt;&gt; chr(32654)'美'&gt;&gt;&gt; chr(32654)'美' python的格式化python中的格式化方式跟c语言是一致的，用%实现。123456789%d 整数%f 浮点数%s 字符串%x 十六进制整数&gt;&gt;&gt; &apos;Hello, %s&apos; % &apos;world&apos;&apos;Hello, world&apos;&gt;&gt;&gt; &apos;Hi, %s, you have $%d.&apos; % (&apos;Michael&apos;, 1000000)&apos;Hi, Michael, you have $1000000.&apos;# 具体看来跟c还是有些出入的，注意一下 还有一种格式化输出的方式即format函数，这个我们上学期学过，我就不再总结了。 列表——listlist是一种有序的集合，可以随时添加和删除其中的元素。1234567891011&gt;&gt;&gt; girllist = ["崔美美","侍皮皮","顾六六"]&gt;&gt;&gt; girllist['崔美美', '侍皮皮', '顾六六']&gt;&gt;&gt; len(girllist)3&gt;&gt;&gt; girllist[0]'崔美美'&gt;&gt;&gt; girllist[-1]'顾六六'&gt;&gt;&gt; girllist[1]'侍皮皮' 可以用append函数向列表尾部增加新元素123&gt;&gt;&gt; girllist.append("jimila")&gt;&gt;&gt; girllist[3]'jimila' 还可以用insert函数把元素插入到指定的位置12345&gt;&gt;&gt; girllist['崔美美', '侍皮皮', '顾六六', 'jimila']&gt;&gt;&gt; girllist.insert(2,"drew")&gt;&gt;&gt; girllist['崔美美', '侍皮皮', 'drew', '顾六六', 'jimila'] pop函数可以直接删除列表末尾的元素123456&gt;&gt;&gt; girllist['崔美美', '侍皮皮', 'drew', '顾六六', 'jimila']&gt;&gt;&gt; girllist.pop()'jimila'&gt;&gt;&gt; girllist['崔美美', '侍皮皮', 'drew', '顾六六'] 也可以用pop(i)删除指定位置的元素123456&gt;&gt;&gt; girllist['崔美美', '侍皮皮', 'drew', '顾六六']&gt;&gt;&gt; girllist.pop(2)'drew'&gt;&gt;&gt; girllist['崔美美', '侍皮皮', '顾六六'] 要把某个元素替换成别的元素，可以直接赋值给对应的索引位置12345&gt;&gt;&gt; girllist['崔美美', '侍皮皮', '顾六六']&gt;&gt;&gt; girllist[0] = "悦美美"&gt;&gt;&gt; girllist['悦美美', '侍皮皮', '顾六六']]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
</search>
