<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Times 17]]></title>
    <url>%2F2019%2F06%2F23%2Fnowcoder-945-J%2F</url>
    <content type="text"><![CDATA[When all else is lost the future still remains. Times 17Link: nowcoder-945-JDescription:After realizing that there is much money to be made in software development, Farmer John has launched a small side business writing short programs for clients in the local farming industry.Farmer John&#39;s first programming task seems quite simple to him -- almost too simple: his client wants him to write a program that takes a number N as input, and prints 17 times N as output. Farmer John has just finished writing this simple program when the client calls him up in a panic and informs him that the input and output both must be expressed as binary numbers, and that these might be quite large.Please help Farmer John complete his programming task. Given an input number N, written in binary with at most 1000 digits, please write out the binary representation of 17 times N.输入描述: Line 1: The binary representation of N (at most 1000 digits). 输出描述: Line 1: The binary representation of N times 17. 示例1输入 10110111 输出 110000100111 说明 OUTPUT DETAILS:The binary number 10110111 is equal to 183 in decimal form.183 x 17 = 3111 is 110000100111 in binary format. Intentional analysis:When I first saw this problem,I think it&#39;s so easy if I use bitset.But then I find the string input is at most 1000 digits,obviously,even long long can&#39;t save.So we must choose another way.I search the Binary multiplication on the internet. How can we perform Binary multiplication? I think this following picture is a good way to explain. And in this problem,we need to multiply by 17.And the binary of 17 is 10001.So what we should do is add s+&#39;0000&#39; to s(s is the string we input).After this,a less easy problem has also appeared.How do we do binary addition?Just simulation.Just like the simulation we did before adding large numbers.You can see the sode to understand. Click to see Chinese Intentional analysis一开始想用bitset很简单，然后发现数据范围是2^1000,long long都存不下。然后去搜索了一下二进制相乘，上面那个图片就很好理解，这道题我们只需要跟17相乘。而17的二进制形式是10001.所以我们只需要将s后面接四个0与s（例如我们输入的是111，那我们只需要将‘1110000’与‘111’加起来）加起来就好（s是我们输入的字符串）。这个二进制相加只需要模拟就行了，就像我们之前模拟大数相加的时候一样模拟。Code:12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;char ans[1005];int main()&#123; string s, mid; int i = 0; cin &gt;&gt; s; mid = s + &quot;0000&quot;; int temp = 0; reverse(s.begin(), s.end());//binary addition reverse(mid.begin(), mid.end()); for (i = 0; i &lt; max(s.size(), mid.size()); i++) &#123; if (i &lt; s.size() &amp;&amp; i &lt; mid.size()) temp += s[i] + mid[i] - &apos;0&apos; - &apos;0&apos;; if (i &gt;= s.size() &amp;&amp; i &lt; mid.size()) temp += mid[i] - &apos;0&apos;; if (i &lt; s.size() &amp;&amp; i &gt;= mid.size()) temp += s[i] - &apos;0&apos;; ans[i] = temp % 2 + &apos;0&apos;; temp /= 2; &#125; if (temp == 1) &#123; ans[i] = &apos;1&apos;; i++; &#125; for (int j = i - 1; j &gt;= 0; j--) cout &lt;&lt; ans[j]; return 0;&#125;]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>Thinking</tag>
        <tag>nowcoder</tag>
        <tag>Binary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A solution]]></title>
    <url>%2F2019%2F06%2F22%2Fsolution%2F</url>
    <content type="text"><![CDATA[Summer is coming,relax!ralax!relax!What&#39;s the problem?Since I used hexo,this problem has been seen many times.When I first met this,I chose to wait.Fortunately,it&#39;s really good in a few days.Then next time,I waited about ten days or more,there&#39;s no changing.So I chose to delete all local files.Add re-&#39;hexo-g&#39;.Although the problem was solved this time, all the upload information before this was gone, and the upload date of the previous article became the same day.The last time,I searched a solution for this on the Internet. Delete &#39;.deploy_git&#39; in your Hexo root directory. Git clone your repositories of your blog in Github.And renama it to &#39;.deploy_git&#39;.There is a little and useful skill.As we all konw,the download speed is too slow in China.So we can use this code to improve your effectiveness. 1git clone your-repositorie&apos;s url --depth=1 Re-&#39;hexo-g&#39;,and &#39;hexo-d&#39;,then you can &#39;hexo-d&#39; successfully.]]></content>
      <categories>
        <category>Tutorial</category>
      </categories>
      <tags>
        <tag>Useful</tag>
        <tag>Tutorial</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Floyd]]></title>
    <url>%2F2019%2F06%2F21%2FFloyd%2F</url>
    <content type="text"><![CDATA[A man&#39;s best friends are his ten fingers. 最短路-FloydLink: HDU-2544 Description:在每年的校赛里，所有进入决赛的同学都会获得一件很漂亮的t-shirt。但是每当我们的工作人员把上百件的衣服从商店运回到赛场的时候，却是非常累的！所以现在他们想要寻找最短的从商店到赛场的路线，你可以帮助他们吗？ Input输入包括多组数据。每组数据第一行是两个整数N、M（N&lt;=100，M&lt;=10000），N表示成都的大街上有几个路口，标号为1的路口是商店所在地，标号为N的路口是赛场所在地，M则表示在成都有几条路。N=M=0表示输入结束。接下来M行，每行包括3个整数A，B，C（1&lt;=A,B&lt;=N,1&lt;=C&lt;=1000）,表示在路口A与路口B之间有一条路，我们的工作人员需要C分钟的时间走过这条路。输入保证至少存在1条商店到赛场的路线。 Output对于每组输入，输出一行，表示工作人员从商店走到赛场的最短时间 Sample Input 2 11 2 33 31 2 52 3 53 1 20 0 Sample Output 32 Code:123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4 + 5;const int INF = 0x3f3f3f3f;int a[maxn][maxn];int main()&#123; int n, m, u, v, p; while (cin &gt;&gt; n &gt;&gt; m) &#123; if (n == 0 &amp;&amp; m == 0) break; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) a[i][j] = INF; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; p; a[u][v] = p; a[v][u] = p; &#125; for (int k = 1; k &lt;= n; k++) for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) if (a[i][j] &gt; a[i][k] + a[k][j]) a[i][j] = a[i][k] + a[k][j]; cout &lt;&lt; a[1][n] &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>c/c++</tag>
        <tag>HDU</tag>
        <tag>Floyd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Put my curriculum on my blog]]></title>
    <url>%2F2019%2F06%2F20%2Fcurriculum%2F</url>
    <content type="text"><![CDATA[Html &amp;&amp; css is interesting.demo Create the curriculum locallyThis is easy to finish. Convert the table to a html formThere are many ways to finish.Such as: DocPe Add some useful featuresNow timeCode:12345678910111213141516171819202122232425262728293031323334353637383940&lt;body onload=&quot;getTime()&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;function getTime() &#123; var dateObj = new Date(); var year = dateObj.getFullYear();//年 var month = dateObj.getMonth()+1;//月 (注意：月份+1) var date = dateObj.getDate();//日 var day = dateObj.getDay(); var weeks = [&quot;星期日&quot;,&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;,&quot;星期四&quot;,&quot;星期五&quot;,&quot;星期六&quot;]; var week = weeks[day];//根据day值，获取星期数组中的星期数。 var hours = dateObj.getHours();//小时 var minutes = dateObj.getMinutes();//分钟 var seconds = dateObj.getSeconds();//秒 if(month&lt;10)&#123; month = &quot;0&quot;+month; &#125; if(date&lt;10)&#123; date = &quot;0&quot;+date; &#125; if(hours&lt;10)&#123; hours = &quot;0&quot;+hours; &#125; if(minutes&lt;10)&#123; minutes = &quot;0&quot;+minutes; &#125; if(seconds&lt;10)&#123; seconds = &quot;0&quot;+seconds; &#125; var newDate = year+&quot;年&quot;+month+&quot;月&quot;+date+&quot;日&quot;+hours+&quot;:&quot;+minutes+&quot;:&quot;+seconds+&quot;&amp;nbsp &amp;nbsp&quot;+week; document.getElementById(&quot;date1&quot;).innerHTML = newDate + &quot; 一言：&quot;;//在div中写入时间 setTimeout(&apos;getTime()&apos;, 500);//每隔500ms执行一次getTime()&#125;&lt;/script&gt;&lt;div id=&quot;date1&quot;&gt;&lt;/div&gt;&lt;/body&gt; 一言12&lt;div id=&quot;hitokoto&quot; &gt;&lt;script&gt;hitokoto()&lt;/script&gt;&lt;/div&gt;&lt;script src=&quot;https://v1.hitokoto.cn/?encode=js&amp;select=%23hitokoto&quot; defer&gt;&lt;/script&gt; Weather1&lt;iframe scrolling=&quot;no&quot; src=&quot;https://tianqiapi.com/api.php?style=tt&amp;skin=pitaya&quot; frameborder=&quot;0&quot; width=&quot;590&quot; height=&quot;98&quot; allowtransparency=&quot;true&quot;&gt;&lt;/iframe&gt;]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>Web</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My story with she]]></title>
    <url>%2F2019%2F06%2F17%2Fromantic%2F</url>
    <content type="text"><![CDATA[The password is my school name. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra]]></title>
    <url>%2F2019%2F06%2F17%2FDijkstra%2F</url>
    <content type="text"><![CDATA[I love you. 最短路-DijkstraLink: HDU-2544 Description:在每年的校赛里，所有进入决赛的同学都会获得一件很漂亮的t-shirt。但是每当我们的工作人员把上百件的衣服从商店运回到赛场的时候，却是非常累的！所以现在他们想要寻找最短的从商店到赛场的路线，你可以帮助他们吗？ Input输入包括多组数据。每组数据第一行是两个整数N、M（N&lt;=100，M&lt;=10000），N表示成都的大街上有几个路口，标号为1的路口是商店所在地，标号为N的路口是赛场所在地，M则表示在成都有几条路。N=M=0表示输入结束。接下来M行，每行包括3个整数A，B，C（1&lt;=A,B&lt;=N,1&lt;=C&lt;=1000）,表示在路口A与路口B之间有一条路，我们的工作人员需要C分钟的时间走过这条路。输入保证至少存在1条商店到赛场的路线。 Output对于每组输入，输出一行，表示工作人员从商店走到赛场的最短时间 Sample Input 2 11 2 33 31 2 52 3 53 1 20 0 Sample Output 32 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4 + 5;const int INF = 0x3f3f3f3f;int a[maxn][maxn];int dis[maxn];bool vis[maxn];int n, m, u, v, w;struct node&#123; int d, id;&#125;;bool operator &lt;(const node &amp;a, const node &amp;b)&#123; return a.d &gt; b.d;&#125;priority_queue&lt;node&gt; que;void Dijkstra()&#123; for (int i = 1; i &lt;= n; i++) dis[i] = INF; dis[1] = 0; que.push(node&#123; dis[1], 1 &#125;); while (!que.empty()) &#123; node p = que.top(); que.pop(); int mid = p.id; if (vis[mid] == 1) continue; vis[mid] = 1; for (int i = 1; i &lt;= n; i++) &#123; if (dis[i] &gt; dis[mid] + a[mid][i]) &#123; dis[i] = dis[mid] + a[mid][i]; que.push(node&#123; dis[i], i &#125;); &#125; &#125; &#125; cout &lt;&lt; dis[n] &lt;&lt; endl;&#125;int main()&#123; while (scanf(&quot;%d %d&quot;, &amp;n, &amp;m) &amp;&amp; (n &amp;&amp; m)) &#123; memset(vis, 0, sizeof(vis)); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) a[i][j] = INF; for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; a[u][v] = w; a[v][u] = w; &#125; Dijkstra(); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>c/c++</tag>
        <tag>Dijkstra</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Somewhere magical]]></title>
    <url>%2F2019%2F06%2F15%2Fsurprise%2F</url>
    <content type="text"><![CDATA[Let&#39;s do something special together. Generate virtual resume onlineLink: This resume does not exist Description:Entering the website will automatically generate a resume. If you are not satisfied, it will be allowed to generate again after 10 seconds!And everything inside is virtual. Avengers 3D Face Change EffectLink: Avengethem Description:You can replace the Avengers face with your own face and generate a GIF 毒鸡汤合集Link: 毒鸡汤 Description:You can go here and enjoy yorself. Tetris-PlusLink: Tetris Description:You can play kinds of mode Tetris here. A magical drawing boardLink: noard Description:Draw a picture you want to paint, and then it will become shy.Suggestion: Girls should think twice before entering. Perfect AI portrait generatorLink: This Person Does Not Exist Description:Very professional intelligent AI website, the website will randomly display portrait photos generated by AI intelligence, and generate realistic and non-existent people through the study of huge real portrait data. CSS代码渐变颜色生成工具Link: Grabient Description:Online visualization to set gradients and generate CSS code 在线扫雷Link: 扫雷 Description:Minesweeper,and there are many small games Canon Creative ParkLink: CREATIVE PARK Description:The website provides a large number of free production drawings of paper molds, cards and furniture accessories.The main thing is that the paper molds are always updated.]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Plus from Picture]]></title>
    <url>%2F2019%2F06%2F12%2FCodeForces-566-B%2F</url>
    <content type="text"><![CDATA[Are you ready for the cet4? Yes,I are. &lt;centerPlus from PictureLink: CodeForces-566-BDescription:You have a given picture with size w×h. Determine if the given picture has a single &quot;+&quot; shape or not. A &quot;+&quot; shape is described below: A &quot;+&quot; shape has one center nonempty cell.There should be some (at least one) consecutive non-empty cells in each direction (left, right, up, down) from the center. In other words, there should be a ray in each direction.All other cells are empty.Find out if the given picture has single &quot;+&quot; shape. InputThe first line contains two integers h and w (1≤h, w≤500) — the height and width of the picture. The i-th of the next h lines contains string si of length w consisting &quot;.&quot; and &quot;*&quot; where &quot;.&quot; denotes the empty space and &quot;*&quot; denotes the non-empty space. OutputIf the given picture satisfies all conditions, print &quot;YES&quot;. Otherwise, print &quot;NO&quot;. You can output each letter in any case (upper or lower). Examplesinput1234565 6........*....****...*.....*... outputYES input12343 5..*..****..*... outputNO input123456787 7..........*.....****....*......*...........*..... outputNO input1234565 6..**....**..******..**....**.. outputNO input12343 7.*...*.***.***.*...*. outputNO input1234565 10............*........*.******...*................. outputNO Note In the first example, the given picture contains one &quot;+&quot;.In the second example, two vertical branches are located in a different column.In the third example, there is a dot outside of the shape.In the fourth example, the width of the two vertical branches is 2.In the fifth example, there are two shapes.In the sixth example, there is an empty space inside of the shape. Intentional analysis:My way is find the center * of the &quot;+&quot;.And turn all of the &#39;*&#39; in &quot;+&quot; to &#39;.&#39;.And if there is still has &#39;*&#39; in the map.Should print &quot;NO&quot;,if not,print &quot;YES&quot;.But there is a special situation,there has no &#39;*&#39; in the map,we&#39;d better make a flag number to satisfy this. Click to see Chinese Intentional analysis我的方法就是找到“+”最中间的‘*’。然后把“+”中的&#39;*&#39;全部变成‘.’。然后再看图里面有没有‘*’，如果有就输出“NO”，没有就输出“YES”。但是还有一种情况就是图里面没有&#39;*&#39;，这个特殊处理一下就行。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;bits/stdc++.husing namespace std;const int maxn = 550;char m[maxn][maxn];int x[maxn];void find(int x, int y, int z)&#123; if (z == 0) &#123; while (m[x][y] == &apos;*&apos;) &#123; m[x][y] = &apos;.&apos;; y++; &#125; &#125; if (z == 1) &#123; while (m[x][y] == &apos;*&apos;) &#123; m[x][y] = &apos;.&apos;; x++; &#125; &#125; if (z == 2) &#123; while (m[x][y] == &apos;*&apos;) &#123; m[x][y] = &apos;.&apos;; y--; &#125; &#125; if (z == 3) &#123; while (m[x][y] == &apos;*&apos;) &#123; m[x][y] = &apos;.&apos;; x--; &#125; &#125;&#125;int main()&#123; int w, h; bool flag = 0; cin w h; for (int i = 0; i &lt; w; i++) for (int j = 0; j &lt; h; j++) cin m[i][j]; for (int i = 0; i &lt; w; i++) &#123; for (int j = 0; j &lt; h; j++) &#123; if (m[i][j] == &apos;*&apos;) &#123; int mid = 0; if (m[i - 1][j] == &apos;*&apos;) mid++; if (m[i][j - 1] == &apos;*&apos;) mid++; if (m[i + 1][j] == &apos;*&apos;) mid++; if (m[i][j + 1] == &apos;*&apos;) mid++; if (mid == 4) &#123; for (int k = 0; k &lt; 4; k++) &#123; m[i][j] = &apos;*&apos;; find(i, j, k); flag = 1; &#125; &#125; &#125; if (flag) break; &#125; if (flag) break; &#125; bool f = 0; for (int i = 0; i &lt; w; i++) for (int j = 0; j &lt; h; j++) &#123; if (m[i][j] == &apos;*&apos;) f = 1; &#125; if (!f &amp;&amp; flag) puts(&quot;YES&quot;); else puts(&quot;NO&quot;); return 0;&#125;]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>CodeForces</tag>
        <tag>Simulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Filling Shapes]]></title>
    <url>%2F2019%2F06%2F11%2FCodeForces-566-A%2F</url>
    <content type="text"><![CDATA[I will be a strong man,both body and soul. Filling ShapesLink: CodeForces-566-ADescription:You have a given integer n. Find the number of ways to fill all 3×n tiles with the shape described in the picture below. Upon filling, no empty spaces are allowed. Shapes cannot overlap. This picture describes when n=4. The left one is the shape and the right one is 3×n tiles.InputThe only line contains one integer n (1≤n≤60) — the length. OutputPrint the number of ways to fill. Examplesinput 4 output 4 input 1 output 0 Note In the first example, there are 4 possible cases of filling.In the second example, you cannot fill the shapes in 3×1 tiles. Code:12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; long long n; cin &gt;&gt; n; if (n % 2 != 0) cout &lt;&lt; 0 &lt;&lt; endl; else &#123; n /= 2; n = pow(2, n); printf(&quot;%lld\n&quot;, n); &#125; return 0;&#125; Nothing to say,just find the regular,and cout is something wrong happen and I don&#39;t know the reason now.Record it here!]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lose it!]]></title>
    <url>%2F2019%2F06%2F10%2FCodeForces-565-C%2F</url>
    <content type="text"><![CDATA[Live beautifully, dream passionately, love completely. Lose it!Link: CodeForces-565-CDescription:You are given an array a consisting of n integers. Each ai is one of the six following numbers: 4,8,15,16,23,42. Your task is to remove the minimum number of elements to make this array good. An array of length k is called good if k is divisible by 6 and it is possible to split it into k6 subsequences 4,8,15,16,23,42. Examples of good arrays: [4,8,15,16,23,42] (the whole array is a required sequence);[4,8,4,15,16,8,23,15,16,42,23,42] (the first sequence is formed from first, second, fourth, fifth, seventh and tenth elements and the second one is formed from remaining elements);[] (the empty array is good).Examples of bad arrays: [4,8,15,16,42,23] (the order of elements should be exactly 4,8,15,16,23,42);[4,8,15,16,23,42,4] (the length of the array is not divisible by 6);[4,8,15,16,23,42,4,8,15,16,23,23] (the first sequence can be formed from first six elements but the remaining array cannot form the required sequence).InputThe first line of the input contains one integer n (1≤n≤5⋅105) — the number of elements in a. The second line of the input contains n integers a1,a2,…,an (each ai is one of the following numbers: 4,8,15,16,23,42), where ai is the i-th element of a. OutputPrint one integer — the minimum number of elements you have to remove to obtain a good array. Examplesinput 54 8 15 16 23 output 5 input 124 8 4 15 16 8 23 15 16 42 23 42 output 0 input 154 8 4 8 15 16 8 16 23 15 16 4 42 23 42 output 3 Intentional analysis:The most difficult path of this problem is the order of the numbers is fixed.So you can not just find the minimum number of 4,8,15,16,23,42,and I had to say that is my first try,without doubt,wrong answer.But how to make sure that the order in which you find the number is fixed?My method is to use some numbers to mark the appearance of 4,8,15,16,23,42.Only 4 has appeared, the number of 8 can be increased by one, and the number of 4 should reduced by one.And so on.The final number of 42 is the answer.See the code. Click to see Chinese Intentional analysis要保证找出来的最长序列的顺序一定是4，8，15，16，23，42，这个一定要看清。我的办法就是用几个数标记他们的出现次数。只有当4出现的次数不为0的时候8出现，那么8出现的次数才能加一，而且此时4出现的次数就得减一。以此类推，最后得到的42出现的次数代表的就是能找到的最长序列的长度的1/6。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; ll n, a, mid = 0; cin &gt;&gt; n; ll f1 = 0, f2 = 0, f3 = 0, f4 = 0, f5 = 0, f6 = 0; for (ll i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a; if (a == 4) f1++; if (a == 8 &amp;&amp; f1) &#123; f2++; f1--; &#125; if (a == 15 &amp;&amp; f2) &#123; f3++; f2--; &#125; if (a == 16 &amp;&amp; f3) &#123; f4++; f3--; &#125; if (a == 23 &amp;&amp; f4) &#123; f5++; f4--; &#125; if (a == 42 &amp;&amp; f5) &#123; f6++; f5--; &#125; &#125; cout &lt;&lt; n - f6 * 6 &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How to change the avatar under valine]]></title>
    <url>%2F2019%2F06%2F08%2Fvaline%2F</url>
    <content type="text"><![CDATA[I can give you everything I haveComment system I chose valine,but many times I am not satisfied with the default avatar of valine.So I found something related on the Internet and successfully implemented this.This is easy to achieve.First: you shoule go to Gravatar to register an account.Attention:The email you use when registering is important and will be used next.After the registration is completed, change the personal information and change the avatar you want to use.Second: Fill in the email address when you comment, it will automatically match your avatarThen you can find your avatar replaced with your own custom. A common problem:You may not received verification email when you are registering.Reason: Some mailboxes have added gravatar to the blacklist.Solution: Add the following address to your email address whitelist in your mailbox settings123donotreply@gravatar.comdonotreply@wordpress.comsupport@gravatar.com Such as QQ-mailThen you should be able to find the verification email in the trash in the email.]]></content>
      <categories>
        <category>Tutorial</category>
      </categories>
      <tags>
        <tag>Tutorial</tag>
        <tag>valine</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Arithmetic Sequence]]></title>
    <url>%2F2019%2F06%2F08%2Fnowcoder921H%2F</url>
    <content type="text"><![CDATA[A very very very boring problem. Arithmetic SequenceLinks: nowcoder-921-HDescription:...然而，强如小r，是不屑于计算一些琐碎的计算的。现在小r给了你一个数X，要求你搞出一个等差数列a使得Sn=a1+a2+a3+⋯+an=∑i=0n−1(a1+id)=n(a1+an)2=X输入描述:输入一个数X，含义见题目描述。 输入保证X在int范围[−2e31∼2e31−1]内。输出描述:输出两行，第一行输出一个正整数n，代表你将要给出的数列长度。注意n不能太大，否则会导致输出超限、超时或运行时错误。 第二行输出符合题目要求的数列，每个数之间用空格隔开，含义见题目描述 要求输出的所有数范围在int内，否则视为答案错误。示例1输入6输出31 2 3示例2输入49输出71 3 5 7 9 11 13 code12345678#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int x; cin&gt;&gt;x; cout&lt;&lt;&quot;1&quot;&lt;&lt;endl&lt;&lt;x;&#125; 一个数也算是数列！！！Paste this problem just to remind myself, be brave when i should be brave.]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>nowcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Greedy-dating Ⅱ]]></title>
    <url>%2F2019%2F06%2F04%2Fdating%2F</url>
    <content type="text"><![CDATA[A basic greedy problem. 活动安排问题之二有若干个活动，第i个开始时间和结束时间是[Si,fi)，活动之间不能交叠，要把活动都安排完，至少需要几个教室？ 策略： 按照开始时间排序优先安排活动，如果冲突，则加一个教室。简单地理解一下，策略是这样，我们把活动按照开始时间有小到大的顺序排序。假设目前已经分配了k个教室（显然k初始等于0），对于当前这个活动，（1） 如果它能安排在k个教室里的某一个，则把它安排在其中的任何一个教室里，k不变。（2） 否则它和每个教室里的活动都冲突，则增加一个教室，安排这个活动。 这个策略是最优么？ 我们想像一下k增加1的过程： 因为我们是按照开始时间排序的，意味着当前考虑的这个活动开始的时候，k个教室里都有活动没结束（因为如果有一个教室的活动结束了，我们就可以安排这个活动进入那个教室而不冲突，从而不用增加k)。这就意味着在这个活动开始的时间点，算上目前考虑的这个活动，有(k + 1)个活动正在进行，同一时刻有(k + 1)个活动在进行，无论我们如何安排教室，都至少需要(k + 1)个教室。因为每个教室里不能同时进行两个活动。而我们的策略恰好需要(k + 1)个教室，所以是最优的。 这个策略也告诉我们，如果从时间轴上“宏观”考虑这个问题。考虑每个时间点同时进行的活动个数，作为这个时间点的厚度（把活动开始和结束时间想像成线段，那么每个时间点有多少条线段覆盖它，可以简单理解为“厚度”），我们至少需要最大厚度那么多个教室——因为那时恰好有最大厚度那么多个活动同时进行，而我们这个贪心策略恰好给了我们一个用最大厚度那么多个教室安排全部活动的一个方案。 如果只需要教室的个数，我们可以把所有开始时间和结束时间排序，遇到开始时间就把厚度加1，遇到结束时间就把厚度减1，显然最初始和最后结束时的厚度是0，在一系列厚度变化的过程中，峰值（最大值）就是最多同时进行的活动数，也是我们至少需要的教室数。 The above content comes from 51nod. Description:输入 第一行一个正整数n (n &lt;= 10000)代表活动的个数。第二行到第(n + 1)行包含n个开始时间和结束时间。开始时间严格小于结束时间，并且时间都是非负整数，小于1000000000 输出 一行包含一个整数表示最少教室的个数。 输入示例 31 23 42 9 输出示例 2 Code:1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;pair&lt;int, int&gt; &gt; v;int main()&#123; int n, a, b; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a &gt;&gt; b; v.push_back(make_pair(a, 1)); v.push_back(make_pair(b, 0)); &#125; sort(v.begin(), v.end()); int sum = 0, ans = 0; for (int i = 0; i &lt; 2 * n; i++) &#123; if (v[i].second == 1) sum++; else sum--; ans = max(ans, sum); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; Attention：A special case is that the start time and the end time are the same time, so it is very troublesome to use the array array directly.And the vector and pair is suitable here.]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Greedy</tag>
        <tag>51nod</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Uncle Drew's ACM Template]]></title>
    <url>%2F2019%2F06%2F03%2Ftemplate%2F</url>
    <content type="text"><![CDATA[I want to make a template for myself. 字符串处理最长回文子串Manacher(马拉车算法)12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1e5;char str[MAXN];char tmp[2*MAXN];int len[2*MAXN];int Manacher(char str[])&#123; tmp[0] = &apos;$&apos;; tmp[1] = &apos;#&apos;; int str_len = strlen(str); for(int i = 1;i &lt;= str_len;i++)&#123; tmp[2*i] = str[i-1]; tmp[2*i+1] = &apos;#&apos;; &#125; tmp[2*str_len+2] = &apos;\0&apos;; int mx = 0; int maxlen = -1; int mid; for(int i = 1; tmp[i]; i++)&#123; if(i &lt; mx) len[i] = min(len[2*mid-i],mx-i); else len[i] = 1; while(tmp[i-len[i]] == tmp[i+len[i]]) len[i]++; if(len[i]+i &gt; mx)&#123; mx = len[i]+i; mid = i; &#125; maxlen = max(maxlen,len[i]-1); &#125; return maxlen;//返回最长回文字串的长度&#125;int main()&#123; int n; cin&gt;&gt;n; scanf(&quot;%s&quot;,str); cout&lt;&lt;Manacher(str)； return 0;&#125; 数学素数Eratosthenes(埃拉托色尼筛法)123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;int a[1000000];int main()&#123; int sum=0,n; int i,j; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; sum=0; for(i=2;i&lt;=n;i++) a[i]=1; for(i=2;i&lt;=sqrt(n);i++)&#123; for(j=2*i;j&lt;=n;j+=i)&#123; a[j]=0; &#125; &#125; for(i=2;i&lt;=n;i++)&#123; if(a[i]) cout&lt;&lt;i&lt;&lt;endl;; &#125; &#125; return 0;&#125; 欧拉筛12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;#define N 100int main(void)&#123; bool number[N+1]; int prime[N+1]; int i,j,count=0; memset(number,true,sizeof(number)); for(i=2;i&lt;=N;i++) &#123; if(number[i]) prime[count++]=i; for(j=0;j&lt;count&amp;&amp;prime[j]*i&lt;=N;j++) &#123; number[prime[j]*i]=false; if(i%prime[j]==0)//精华就在于此：它保证每个合数只会被它的最小质因数筛去，因此每个数只会被标记一次，所以时间复杂度是O(n) break; &#125; &#125; for(i=2;i&lt;N+1;i++) if(number[i]==true) printf(&quot;%d &quot;,i); return 0;&#125; 快速幂12345678910ll poww(ll x, ll y, ll z)&#123; ll ans = 1, base = x; while (y != 0) &#123; if (y &amp; 1 != 0) ans = ans * base % z; base = (base % z) * (base % z) % z; y &gt;&gt;= 1; &#125; return ans;&#125; 斐波那契(大数，根据第n项的值推出n)12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;const int maxx = 1e9 + 7;typedef long long ll;ll f[200050]; char s[100000];int main()&#123; ios::sync_with_stdio(false); map&lt;ll, ll&gt; ma; f[0] = 0; f[1] = 1; for (ll i = 2; i &lt; 200001; i++) &#123; f[i] = (f[i - 1] + f[i - 2]) % maxx; ma[f[i]] = i; &#125; ll n; cin &gt;&gt; n; while (n--) &#123; cin &gt;&gt; s; ll ans, num, l; l = strlen(s);//先把长度求出来，用的时候直接用 num = 0; for (ll i = 0; i &lt; l; i++) &#123; num = num * 10 + s[i] - &apos;0&apos;; num %= maxx; &#125; cout &lt;&lt; ma[num] &lt;&lt; endl; &#125; return 0;&#125; 大数(c++)大数相加(正整数)123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int n; cin &gt;&gt; n; int m = 0; int l = 0; for (int i = 1; i &lt;= n; i++) &#123; string s1, s2, s(10000, &apos;0&apos;); cin &gt;&gt; s1 &gt;&gt; s2; m++; cout &lt;&lt; (l++ ? &quot;\n&quot; : &quot;&quot;); reverse(s1.begin(), s1.end()); reverse(s2.begin(), s2.end()); for (int j = 0; j &lt; s1.length(); j++) s[j] = s1[j]; int temp = 0; for (int k = 0; k &lt; s2.length(); k++) &#123; temp += s[k] - 48 + s2[k] - 48; s[k] = temp % 10 + &apos;0&apos;; temp /= 10; &#125; s[s2.length()] = s[s2.length()] - 48 + temp + 48; reverse(s.begin(), s.end()); reverse(s1.begin(), s1.end()); reverse(s2.begin(), s2.end()); cout &lt;&lt; &quot;Case&quot; &lt;&lt; m &lt;&lt; &quot;:&quot; &lt;&lt; endl; cout &lt;&lt; s1 &lt;&lt; &quot;+&quot; &lt;&lt; s2 &lt;&lt; &quot;=&quot; &lt;&lt; s.substr(s.find_first_not_of(&apos;0&apos;)) &lt;&lt; endl; &#125; return 0;&#125; 大数相减(正整数)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int strComp(string &amp;s1, string &amp;s2)&#123; int len1 = s1.length(); int len2 = s2.length(); if (len1 &gt; len2) return 0; else if (len1 &lt; len2) return 1; else &#123; if (s1 &gt;= s2) return 0; else return 1; &#125;&#125;int main()&#123; string s1, s2; while (cin &gt;&gt; s1 &gt;&gt; s2) &#123; string s(10000, &apos;0&apos;); bool fgEx = true; if (strComp(s1, s2) == 1) &#123; string temp; temp = s1; s1 = s2; s2 = temp; fgEx = false; &#125; if (s1 == s2) &#123; cout &lt;&lt; s1 &lt;&lt; &quot; - &quot; &lt;&lt; s2 &lt;&lt; &quot; = &quot; &lt;&lt; &quot;0&quot; &lt;&lt; endl; continue; &#125; reverse(s1.begin(), s1.end()); reverse(s2.begin(), s2.end()); for (int i = 0; i &lt; s1.length(); i++) s[i] = s1[i]; for (int i = 0; i &lt; s2.length(); i++) &#123; if (s[i] &gt;= s2[i]) s[i] = s[i] - &apos;0&apos; - (s2[i] - &apos;0&apos;) + &apos;0&apos;; else &#123; s[i + 1] = s[i + 1] - &apos;0&apos; - 1 + &apos;0&apos;; s[i] = s[i] - &apos;0&apos; + 10 - (s2[i] - &apos;0&apos;) + &apos;0&apos;; &#125; &#125; if (fgEx == false) &#123; reverse(s2.begin(), s2.end()); cout &lt;&lt; s2 &lt;&lt; &quot; - &quot;; reverse(s1.begin(), s1.end()); cout &lt;&lt; s1 &lt;&lt; &quot; = &quot;; reverse(s.begin(), s.end()); cout &lt;&lt; &quot;-&quot; &lt;&lt; s.substr(s.find_first_not_of(&apos;0&apos;)) &lt;&lt; endl; &#125; else &#123; reverse(s1.begin(), s1.end()); cout &lt;&lt; s1 &lt;&lt; &quot; - &quot;; reverse(s2.begin(), s2.end()); cout &lt;&lt; s2 &lt;&lt; &quot; = &quot;; reverse(s.begin(), s.end()); cout &lt;&lt; s.substr(s.find_first_not_of(&apos;0&apos;)) &lt;&lt; endl; &#125; &#125; return 0;&#125; 大数相乘(正整数)1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; string s1, s2; while (cin &gt;&gt; s1 &gt;&gt; s2) &#123; string s(1000, &apos;0&apos;); reverse(s1.begin(), s1.end()); reverse(s2.begin(), s2.end()); for (int i = 0; i &lt; s1.length(); i++) for (int j = 0; j &lt; s2.length(); j++) &#123; int temp = (s1[i] - &apos;0&apos;) * (s2[j] - &apos;0&apos;); s[i + j + 1] = s[i + j + 1] - &apos;0&apos; + (s[i + j] - &apos;0&apos; + temp) / 10 + &apos;0&apos;; s[i + j] = (s[i + j] - &apos;0&apos; + temp) % 10 + &apos;0&apos;; &#125; reverse(s.begin(), s.end()); if (s.find_first_not_of(&apos;0&apos;) == string::npos) cout &lt;&lt; &quot;0&quot; &lt;&lt; endl; else cout &lt;&lt; s.substr(s.find_first_not_of(&apos;0&apos;)) &lt;&lt; endl; &#125; return 0;&#125; 大数相除(正整数)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int strComp(string &amp;s1, string &amp;s2)&#123; int len1 = s1.length(); int len2 = s2.length(); if (len1 &gt; len2) return 0; else if (len1 &lt; len2) return 1; else &#123; if (s1 &gt;= s2) return 0; else return 1; &#125;&#125;string Sub(string s1, string s2)&#123; if (strComp(s1, s2) == 1) return &quot;-1&quot;; reverse(s1.begin(), s1.end()); reverse(s2.begin(), s2.end()); string s(1000, &apos;0&apos;); for (int i = 0; i &lt; s1.length(); i++) s[i] = s1[i]; for (int i = 0; i &lt; s2.length(); i++) &#123; if (s[i] &gt;= s2[i]) s[i] = s[i] - &apos;0&apos; - (s2[i] - &apos;0&apos;) + &apos;0&apos;; else &#123; s[i + 1] = s[i + 1] - &apos;0&apos; - 1 + &apos;0&apos;; s[i] = s[i] - &apos;0&apos; + 10 - (s2[i] - &apos;0&apos;) + &apos;0&apos;; &#125; &#125; reverse(s.begin(), s.end()); if (s.find_first_not_of(&apos;0&apos;) == string::npos) return &quot;0&quot;; else return s.substr(s.find_first_not_of(&apos;0&apos;));&#125;int main()&#123; string s1, s2; while (cin &gt;&gt; s1 &gt;&gt; s2) &#123; string s(1000, &apos;0&apos;); if (strComp(s1, s2) == 1) &#123; cout &lt;&lt; &quot;0&quot; &lt;&lt; endl; continue; &#125; int len1 = s1.length(); int len2 = s2.length(); int dis = len1 - len2; for (int i = 0; i &lt; dis; i++) s2 += &apos;0&apos;; string ans(1000, &apos;0&apos;); while (dis &gt;= 0) &#123; int sum = 0; string temp; while ((temp = Sub(s1, s2)) != &quot;-1&quot;) &#123; sum++; s1 = temp; &#125; ans[ans.length() - dis - 1] = sum + &apos;0&apos;; dis--; s2 = s2.substr(0, len2 + dis); &#125; if (ans.find_first_not_of(&apos;0&apos;) == string::npos) cout &lt;&lt; &quot;0&quot; &lt;&lt; endl; else &#123; string res = ans.substr(ans.find_first_not_of(&apos;0&apos;)); cout &lt;&lt; res &lt;&lt; endl; &#125; &#125; return 0;&#125; 大数取模12345678910typedef long long ll;cin &gt;&gt; s;ll ans, num;ll l = strlen(s);num = 0;for (ll i = 0; i &lt; l; i++)&#123; num = num * 10 + s[i] - &apos;0&apos;; num %= maxx;&#125; 图论最小生成树kruskal12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;struct city&#123; int a; int b; int p;&#125; c[105];int p[105];int find(int x)&#123; return p[x] != x ? p[x] = find(p[x]) : x;&#125;void join(int x, int y)&#123; x = find(x); y = find(y); if (x != y) p[y] = x;&#125;bool cmp(city x, city y)&#123; return x.p &lt; y.p;&#125;int main()&#123; int n, m; while (cin &gt;&gt; n &gt;&gt; m) &#123; int sum = 0; if (n == 0) break; for (int i = 1; i &lt;= m; i++) p[i] = i; for (int i = 0; i &lt; n; i++) cin &gt;&gt; c[i].a &gt;&gt; c[i].b &gt;&gt; c[i].p; sort(c, c + n, cmp); for (int i = 0; i &lt; n; i++) &#123; if (find(c[i].a) != find(c[i].b)) &#123; join(c[i].a, c[i].b); sum += c[i].p; &#125; &#125; int flag = 0; for (int i = 1; i &lt;= m; i++) &#123; if (p[i] == i) flag++; &#125; if (flag == 1) cout &lt;&lt; sum &lt;&lt; endl; else puts(&quot;?&quot;); &#125; return 0;&#125; 最短路——Dijkstra123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4 + 5;const int INF = 0x3f3f3f3f;int a[maxn][maxn];int dis[maxn];bool vis[maxn];int n, m, u, v, w;struct node&#123; int d, id;&#125;;bool operator &lt;(const node &amp;a, const node &amp;b)&#123; return a.d &gt; b.d;&#125;priority_queue&lt;node&gt; que;void Dijkstra()&#123; for (int i = 1; i &lt;= n; i++) dis[i] = INF; dis[1] = 0; que.push(node&#123; dis[1], 1 &#125;); while (!que.empty()) &#123; node p = que.top(); que.pop(); int mid = p.id; if (vis[mid] == 1) continue; vis[mid] = 1; for (int i = 1; i &lt;= n; i++) &#123; if (dis[i] &gt; dis[mid] + a[mid][i]) &#123; dis[i] = dis[mid] + a[mid][i]; que.push(node&#123; dis[i], i &#125;); &#125; &#125; &#125; cout &lt;&lt; dis[n] &lt;&lt; endl;&#125;int main()&#123; while (scanf(&quot;%d %d&quot;, &amp;n, &amp;m) &amp;&amp; (n &amp;&amp; m)) &#123; memset(vis, 0, sizeof(vis)); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) a[i][j] = INF; for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; a[u][v] = w; a[v][u] = w; &#125; Dijkstra(); &#125;&#125; 搜索DFS1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int book[10], a[10], n;void dfs(int step)&#123; int i; if (step == n + 1)//当你在第n+1步的时候，说明前n部已经排好了。 &#123; for (i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, a[i]); printf(&quot;\n&quot;); return; //返回之前的一步； &#125; for (i = 1; i &lt;= n; i++) //按照1，2，3.。。的方式一一尝试。 &#123; if (book[i] == 0) //判断扑克牌i是不是还在手里 &#123; a[step] = i; //将i牌放在第step个盒子里。 book[i] = 1; //表示扑克牌不再第step个盒子里 dfs(step + 1); //继续下一步。 book[i] = 0; //将刚才尝试的扑克收回，才能进行下一步的尝试。 &#125; &#125; return; //结束搜索。&#125;int main()&#123; while (~scanf(&quot;%d&quot;, &amp;n)) dfs(1); return 0;&#125; BFS12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;#define pill pair&lt;int,int&gt;int sx,sy,ex,ey,n;char ma[1050][1050];int vis[1050][1050];int step[1050][1050];int d[4][2]=&#123;-1,0,0,1,1,0,0,-1&#125;;queue&lt;pair&lt;int,int&gt; &gt;que;void bfs(int x,int y)&#123; vis[x][y]=1; que.push(pill(x,y)); while(!que.empty()) &#123; x=que.front().first; y=que.front().second; que.pop(); for(int i=0;i&lt;4;i++) &#123; int xx=x+d[i][0]; int yy=y+d[i][1]; if(ma[xx][yy]==&apos;#&apos;||xx&lt;0||xx&gt;=n||yy&lt;0||yy&gt;=n||vis[xx][yy]==1) continue; que.push(pill(xx,yy)); vis[xx][yy]=1; step[xx][yy]=step[x][y]+1; &#125; &#125;&#125;int main()&#123; while(cin&gt;&gt;n) &#123; memset(vis,0,sizeof(vis)); for(int i=0;i&lt;n;i++) &#123; scanf(&quot;%s&quot;,ma[i]); &#125; &#125;&#125; 动态规划编辑距离12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 1050;int f[maxn][maxn];string a, b;bool same(char x, char y)&#123; if (x == y) return 0; return 1;&#125;int main()&#123; while (cin &gt;&gt; a &gt;&gt; b) &#123; memset(f, 0, sizeof(f)); for (int i = 0; i &lt;= a.size(); i++) &#123; for (int j = 0; j &lt;= b.size(); j++) &#123; if (i == 0) f[i][j] = j; else if (j == 0) f[i][j] = i; else f[i][j] = min(f[i - 1][j - 1] + same(a[i - 1], b[j - 1]), min(f[i - 1][j] + 1, f[i][j - 1] + 1)); &#125; &#125; cout &lt;&lt; f[a.size()][b.size()] &lt;&lt; endl; &#125; return 0;&#125; 最长公共子序列12345678910111213141516171819202122232425262728293031323334353637#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;stack&gt;using namespace std;const int maxn = 1050;int dp[maxn][maxn];char a[maxn], b[maxn];int main()&#123; scanf(&quot;%s %s&quot;, a + 1, b + 1); int n = strlen(a + 1), m = strlen(b + 1); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) &#123; if (a[i] == b[j]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); &#125; stack&lt;char&gt; ans; while (n &gt;= 1 &amp;&amp; m &gt;= 1) &#123; if (dp[n][m] == 0) break; if (dp[n][m] - dp[n - 1][m - 1] == 1 &amp;&amp; dp[n - 1][m - 1] == dp[n - 1][m] &amp;&amp; dp[n - 1][m - 1] == dp[n][m - 1]) &#123; ans.push(a[n]); n--; m--; &#125; else if (dp[n][m] == dp[n - 1][m] &amp;&amp; n &gt; 1) n--; else if (dp[n][m] == dp[n][m - 1] &amp;&amp; m &gt; 1) m--; &#125; while (!ans.empty()) &#123; printf(&quot;%c&quot;, ans.top()); ans.pop(); &#125; puts(&quot;&quot;); return 0;&#125; 最长递增子序列12345678910111213141516171819#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 50050;const int INF = 0x3f3f3f3f;int dp[maxn], a[maxn];int main()&#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; fill(dp, dp + n, INF); for (int i = 0; i &lt; n; i++) &#123; *lower_bound(dp, dp + n, a[i]) = a[i]; &#125; cout &lt;&lt; lower_bound(dp, dp + n, INF) - dp &lt;&lt; endl;&#125; 最大子段和1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;int main()&#123; int n, now; long long maxsum, sum; while (cin &gt;&gt; n) &#123; maxsum = sum = 0; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; now; sum = max(sum, 0LL) + now; maxsum = max(sum, maxsum); &#125; cout &lt;&lt; maxsum &lt;&lt; endl; &#125; return 0;&#125; 换零钱123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll solve(ll x)&#123; int coins[13] = &#123; 1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 2000, 5000, 10000 &#125;; ll dp[100005] = &#123; 0 &#125;; dp[0] = 1; for (int i = 0; i &lt; 13; i++) &#123; for (int j = coins[i]; j &lt;= x; j++) &#123; dp[j] = (dp[j] + dp[j - coins[i]]) % 1000000007; &#125; &#125; return dp[x];&#125;int main()&#123; ll t, a; cin &gt;&gt; t; while (t--) &#123; cin &gt;&gt; a; cout &lt;&lt; solve(a) &lt;&lt; endl; &#125;&#125; 计算几何求多边形面积123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;int main()&#123; int ncase; cin &gt;&gt; ncase; int x, y, x0, y0, sum = 0; cin &gt;&gt; x &gt;&gt; y; x0 = x; y0 = y; while (--ncase) &#123; int xtmp, ytmp; cin &gt;&gt; xtmp &gt;&gt; ytmp; sum += (x * ytmp - y * xtmp); x = xtmp; y = ytmp; &#125; sum += (x * y0 - y * x0); printf(&quot;%d\n&quot;, int(abs(sum) / 2)); return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kruskal]]></title>
    <url>%2F2019%2F06%2F02%2FKruskal%2F</url>
    <content type="text"><![CDATA[Who is confessing now, is confession not giving others the opportunity to refuse? If she is willing to go out with you, you will take her to the night and then hold her hand. If she is willing to hold hands with you, you will kiss her.Link: HDU-1863 畅通工程Description:省政府“畅通工程”的目标是使全省任何两个村庄间都可以实现公路交通（但不一定有直接的公路相连，只要能间接通过公路可达即可）。经过调查评估，得到的统计表中列出了有可能建设公路的若干条道路的成本。现请你编写程序，计算出全省畅通需要的最低成本。 Input测试输入包含若干测试用例。每个测试用例的第1行给出评估的道路条数 N、村庄数目M ( &lt; 100 )；随后的 N行对应村庄间道路的成本，每行给出一对正整数，分别是两个村庄的编号，以及此两村庄间道路的成本（也是正整数）。为简单起见，村庄从1到M编号。当N为0时，全部输入结束，相应的结果不要输出。 Output对每个测试用例，在1行里输出全省畅通需要的最低成本。若统计数据不足以保证畅通，则输出“?”。 Sample Input3 31 2 11 3 22 3 41 32 3 20 100 Sample Output3? The main thought of this problem is union-find.Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;struct city&#123; int a; int b; int p;&#125; c[105];int p[105];int find(int x)&#123; return p[x] != x ? p[x] = find(p[x]) : x;&#125;void join(int x, int y)&#123; x = find(x); y = find(y); if (x != y) p[y] = x;&#125;bool cmp(city x, city y)&#123; return x.p &lt; y.p;&#125;int main()&#123; // freopen(&quot;../in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;../out.txt&quot;, &quot;w&quot;, stdout); int n, m; while (cin &gt;&gt; n &gt;&gt; m) &#123; int sum = 0; if (n == 0) break; for (int i = 1; i &lt;= m; i++) p[i] = i; for (int i = 0; i &lt; n; i++) cin &gt;&gt; c[i].a &gt;&gt; c[i].b &gt;&gt; c[i].p; sort(c, c + n, cmp); for (int i = 0; i &lt; n; i++) &#123; if (find(c[i].a) != find(c[i].b)) &#123; join(c[i].a, c[i].b); sum += c[i].p; &#125; &#125; int flag = 0; for (int i = 1; i &lt;= m; i++) &#123; if (p[i] == i) flag++; &#125; if (flag == 1) cout &lt;&lt; sum &lt;&lt; endl; else puts(&quot;?&quot;); &#125; return 0;&#125; Recommend: 算法导论--最小生成树（Kruskal和Prim算法） Interjection: &quot;spirited away&quot; was released on June 21st. Do you want to go see it together?]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Greedy</tag>
        <tag>c/c++</tag>
        <tag>HDU</tag>
        <tag>union-find</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ with Atom]]></title>
    <url>%2F2019%2F06%2F02%2Fuse_atom%2F</url>
    <content type="text"><![CDATA[Because the unknown bug in sublime and dev,I choose atom to satisfy my my needs for c++ programming and markdown.I think I can&#39;t teach you how to install atom clearly,so there has more links to what blog I saw when I install atom. InstallClick here to install Choose your suitable version.When the install begin,what you should do just is wait,atom will do everything itself for you. Attention: If you can&#39;t installed on the official website.Click here：https://pan.baidu.com/s/1xpP2G0qsaB_ciXvd9d9juQExtraction code：78aa If the above two conditions can not solve your installation problem.Just connect me through email or comment.I&#39;d like to help you.An important step-Configuration compilation environment Install MinGWClick here to installTo solve this there are many tutorial on the web.So I will not spend more time on this.recommend: MinGW.When you finish this step,You are not far from success.Install some useful packages(c++). linter-gcc2 linterrecommend: c++Install some useful packages(markdown) markdown-preview-plus markdown-scroll-sync language-markdown markdown-image-paste markdown-table-editor markdown-themeable-pdf、pdf-viewrecommend: markdown There are many useful and beautiful packages in atom,and you can manage them easier than sublime. If you still have some problems,just comment here or send a email to me.]]></content>
      <categories>
        <category>Tutorial</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>Tutorial</tag>
        <tag>Atom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大的湖]]></title>
    <url>%2F2019%2F05%2F26%2Fnowcoder-910-D%2F</url>
    <content type="text"><![CDATA[The first BFS problem I have solved by myself. 最大的湖Link&quot; nowcoder-910-DDescription:农场主约翰的农场在最近的一场风暴中被洪水淹没，这一事实只因他的奶牛极度害怕水的消息而恶化。 然而，他的保险公司只会根据他农场最大的“湖”的大小来偿还他一笔钱。 农场表示为一个矩形网格，有N（1≤N≤100）行和M（1≤M≤100）列。网格中的每个格子要么是干的， 要么是被淹没的，而恰好有K（1≤K≤N×M）个格子是被淹没的。正如人们所期望的，一个“湖”有一个 中心格子，其他格子通过共享一条边（只有四个方向，对角线不算的意思）与之相连。任何与中央格子共享一条边或与中央格 子相连的格子共享一条边的格子都将成为湖的一部分。 输入描述:第一行有三个整数N,M,K，分别表示这个矩形网格有N行，M列，K个被淹没的格子。 接下来K行，每一行有两个整数R,C。表示被淹没的格子在第R行，第C列。输出描述:输出最大的“湖”所包含的格子数目示例1输入3 4 53 22 23 12 31 1输出4 Intentional analysis:My solution to this problem is According to the input structure diagram and then proceed BFS. Click to see Chinese Intentional analysis通过输入构造图然后进行BFS。为了防止各种绕弯，我对下标进行了操作。 Code：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;char s[105][105];int d[4][2]=&#123;0,-1, -1,0, 0,1, 1,0&#125;;bool flag[105][105];int n,m,k,a,b,anss=0;queue&lt;pair&lt;int,int&gt; &gt; que;#define pil pair&lt;int,int&gt;int bfs(int x,int y)&#123; memset(flag,0,sizeof(flag)); flag[x][y]=1; int ans=1; que.push(pil(x,y)); while(!que.empty()) &#123; x=que.front().first; y=que.front().second; que.pop(); for(int i=0;i&lt;4;i++) &#123; int xx=x+d[i][0]; int yy=y+d[i][1]; if(xx&lt;0||yy&lt;0||xx&gt;=n||yy&gt;=m||s[xx][yy]==&apos;#&apos;||flag[xx][yy]==1) continue; else &#123; flag[xx][yy]=1; ans++; que.push(pil(xx,yy)); &#125; &#125; &#125; return ans;&#125; int main()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) &#123; s[i][j]=&apos;#&apos;; &#125; while(k--) &#123; cin&gt;&gt;a&gt;&gt;b; s[a-1][b-1]=&apos;@&apos;; &#125; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;=m;j++) &#123; if(s[i][j]==&apos;@&apos;) anss=max(bfs(i,j),anss); &#125; &#125; cout&lt;&lt;anss&lt;&lt;endl;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>nowcoder</tag>
        <tag>Thiking</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[风雨无阻]]></title>
    <url>%2F2019%2F05%2F26%2Fnowcoder-900-A%2F</url>
    <content type="text"><![CDATA[Becouse all kinds of reasons,I haven&#39;t done a problem for a long time.But the main is I&#39;m tired.As the saying goes&quot;I also paid, but why are they so strong?&quot; 风雨无阻Links: 风雨无阻Description:许cosin的宝贝手表被他的仇人gen海偷走了。他决定秘密前往gen海家，去找回他的手表。许cosin历经千辛万苦，耗时3天，终于找到了gen海家。他通过观察发现gen海不在家，于是他决定偷偷潜入gen海家，然后找回手表。但他在gen海家的门前发现了一个密码锁，他必须解开这个锁才能进入gen海家。可是许cosin实在是太silly了，于是他就向你请教。请快速解决这个问题，gen海还有1秒就会回家了。锁上有两行，第一行一个数字N。第二行是一串字符串S（|S|≤6*105），字符串由许多子串构成，每个子串的格式均是XA其中X是一个运算符，A是一个数字。X可能是*，+，-，%，^（^表示次方）。现在需要把数字N代入字符串S，从左到右进行运算。密码就是运算结果的绝对值。 题目保证运算过程中N在int(-2147483648~2147483647)范围内，^后面的数字只能为2。运算过程从左至右，不满足运算的优先级（详见样例）输入描述:两行，第一行一个正整数N第二行是一个字符串S输出描述:一个数，表示运算结果的绝对值示例1输入5-7*3输出6说明5-7=-2 -2*3=-6 |-6|=6 Intentional analysis:When I first saw this problem,I think i can AC it easily through the &quot;eval&quot; in python.But,there is no need to consider the precedence of operators here.So I give it up and choose c/c++.I think the main thought is simulation.Process the string.But a other problem came is that a nubmer maybe many chars.So we must process the string with a special way instead of one by one which is wrong. Click to see Chinese Intentional analysis第一眼看到这个题，我直接想到了python中的eval函数，但是发现题目要求的是不考虑运算符的优先级，所以这个就不能用了。我有回归本行使用c/c++来写，就是一个简单的模拟，但是每次出现的数字它不一定只有一位，这就是这道题麻烦的地方，我选择了用字符串数组存起来每个数，因为题目保证每个运算符后面一定会有数字，所以只要按着顺序来就行，还有个麻烦的地方就是字符串跟整型之间的运算，即将字符串类型转换为整形。一开始我直接模拟了一下转换过程，也是过了这道题，后来我想到一个很方便的函数——stoi。基本作用就是直接将string类型转换为整型。关于这个函数我在这篇博文下面有详细的介绍，有兴趣的可以看一下。 My fisrt code:1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;string mid[100005];ll zh(string x)&#123; ll ans=0,m,j=1; for(int i=x.size()-1;i&gt;=0;i--) &#123; m=(x[i]-&apos;0&apos;)*j; j*=10; ans+=m; &#125; return ans;&#125;int main()&#123; ll a,j=0; string s; cin&gt;&gt;a&gt;&gt;s; for(int i=0;i&lt;s.size();i++) &#123; if(s[i]&gt;=&apos;0&apos;&amp;&amp;s[i]&lt;=&apos;9&apos;) &#123; mid[j]+=s[i]; &#125; else j++; &#125; j=1; for(int i=0;i&lt;s.size();i++) &#123; if(s[i]&gt;=&apos;0&apos;&amp;&amp;s[i]&lt;=&apos;9&apos;) &#123; continue; &#125; if(s[i]==&apos;+&apos;) a+=zh(mid[j]); if(s[i]==&apos;-&apos;) a-=zh(mid[j]); if(s[i]==&apos;%&apos;) a%=zh(mid[j]); if(s[i]==&apos;^&apos;) a*=a; if(s[i]==&apos;*&apos;) a*=zh(mid[j]); j++; &#125; cout&lt;&lt;abs(a)&lt;&lt;endl;&#125; A easy code and a easy thought.After sumbit this code,I thought of a function----&quot;stoi&quot;.It can convert string type directly to int type.So this is more easily!Code:123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;string mid[100005];int main()&#123; ll a,j=0; string s; cin&gt;&gt;a&gt;&gt;s; for(int i=0;i&lt;s.size();i++) &#123; if(s[i]&gt;=&apos;0&apos;&amp;&amp;s[i]&lt;=&apos;9&apos;) &#123; mid[j]+=s[i]; &#125; else j++; &#125; j=1; for(int i=0;i&lt;s.size();i++) &#123; if(s[i]&gt;=&apos;0&apos;&amp;&amp;s[i]&lt;=&apos;9&apos;) &#123; continue; &#125; if(s[i]==&apos;+&apos;) a+=stoi(mid[j]); if(s[i]==&apos;-&apos;) a-=stoi(mid[j]); if(s[i]==&apos;%&apos;) a%=stoi(mid[j]); if(s[i]==&apos;^&apos;) a*=a; if(s[i]==&apos;*&apos;) a*=stoi(mid[j]); j++; &#125; cout&lt;&lt;abs(a)&lt;&lt;endl;&#125; Something about convert type(from string to int/long long):reference: cppreference.comTo_intTo_longTo_long longstoi( const std::string&amp; str, std::size_t* pos = 0, int base = 10 ); (since C++11)stol( const std::string&amp; str, std::size_t* pos = 0, int base = 10 ); (since C++11)stoll( const std::string&amp; str, std::size_t* pos = 0, int base = 10 ); (since C++11)If you are converting string to unsiged long/long long,use stoul/stoull instead of stol/stoll.To_floatTo_doubleTo_long doublestof( const std::string&amp; str, std::size_t* pos = 0 ); (since C++11)stod( const std::string&amp; str, std::size_t* pos = 0 ); (since C++11)stold( const std::string&amp; str, std::size_t* pos = 0 ); (since C++11)These looks like similar. You may think these function are obscure,just use it. Like I solve this problem. Example:123456789101112131415161718192021222324252627Input:#include &lt;iostream&gt;#include &lt;string&gt; int main()&#123; std::string str1 = &quot;45&quot;; std::string str2 = &quot;3.14159&quot;; std::string str3 = &quot;31337 with words&quot;; std::string str4 = &quot;words and 2&quot;; int myint1 = std::stoi(str1); int myint2 = std::stoi(str2); int myint3 = std::stoi(str3); // error: &apos;std::invalid_argument&apos; // int myint4 = std::stoi(str4); std::cout &lt;&lt; &quot;std::stoi(\&quot;&quot; &lt;&lt; str1 &lt;&lt; &quot;\&quot;) is &quot; &lt;&lt; myint1 &lt;&lt; &apos;\n&apos;; std::cout &lt;&lt; &quot;std::stoi(\&quot;&quot; &lt;&lt; str2 &lt;&lt; &quot;\&quot;) is &quot; &lt;&lt; myint2 &lt;&lt; &apos;\n&apos;; std::cout &lt;&lt; &quot;std::stoi(\&quot;&quot; &lt;&lt; str3 &lt;&lt; &quot;\&quot;) is &quot; &lt;&lt; myint3 &lt;&lt; &apos;\n&apos;; //std::cout &lt;&lt; &quot;std::stoi(\&quot;&quot; &lt;&lt; str4 &lt;&lt; &quot;\&quot;) is &quot; &lt;&lt; myint4 &lt;&lt; &apos;\n&apos;;&#125;Output:std::stoi(&quot;45&quot;) is 45std::stoi(&quot;3.14159&quot;) is 3std::stoi(&quot;31337 with words&quot;) is 31337]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>nowcoder</tag>
        <tag>Thiking</tag>
        <tag>functions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[灰魔法师]]></title>
    <url>%2F2019%2F05%2F25%2Fnowcoder-215-A%2F</url>
    <content type="text"><![CDATA[A problem was met in a prgramming contest before.When I tried to solve this I find it&#39;s a meaningful problem. 灰魔法师Links: nowcoder-215-BHPUOJ-contest-3-BDescription:“White shores, and beyond. A far green country under a swift sunrise.”--灰魔法师 给出长度为n的序列a, 求有多少对数对 (i, j) (1 &lt;= i &lt; j &lt;= n) 满足 ai + aj 为完全平方数。输入描述:第一行一个整数 n (1 &lt;= n &lt;= 105)第二行 n 个整数 ai (1 &lt;= ai &lt;= 105)输出描述:输出一个整数，表示满足上述条件的数对个数。示例1输入31 3 6输出2说明满足条件的有 (1, 2), (2, 3) 两对。 Intentional analysis:We should use a tag array because the data range is too large and the violence will time out.For this way,this problem is easy too. Code:12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=200050;int a[maxn];int main()&#123; int n,x,ans=0; cin&gt;&gt;n; while(n--) &#123; cin&gt;&gt;x; for(int i=1;i*i&lt;=maxn;i++) if(i*i&gt;x) ans+=a[i*i-x]; a[x]++; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; The reason why I said this problem is meaningful is a thought,a &quot;flag&quot; thought,which can reduce the time the program runs to avoid TLE.]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>HPUOJ</tag>
        <tag>nowcoder</tag>
        <tag>Thiking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Little knowledge point(Reprint)]]></title>
    <url>%2F2019%2F05%2F20%2FLittle_knowledge_point%2F</url>
    <content type="text"><![CDATA[Something we&#39;d better know. Original link: Lesroad 能被2、3、4、5、6、7、8、9等数整除的数的特征性质1：如果数a、b都能被c整除，那么它们的和（a+b）或差(a－b)也能被c整除。 性质2：几个数相乘，如果其中有一个因数能被某一个数整除，那么它们的积也能被这个数整除。 能被2整除的数，个位上的数能被2整除（偶数都能被2整除），那么这个数能被2整除 能被3整除的数，各个数位上的数字和能被3整除，那么这个数能被3整除 能被4整除的数，个位和十位所组成的两位数能被4整除，那么这个数能被4整除 能被5整除的数，个位上为0或5的数都能被5整除，那么这个数能被5整除 能被6整除的数，各数位上的数字和能被3整除的偶数，如果一个数既能被2整除又能被3整除，那么这个数能被6整除 能被7整除的数，若一个整数的个位数字截去，再从余下的数中，减去个位数的2倍，如果差是7的倍数，则原数能被7整除。如果差太大或心算不易看出是否7的倍数，就需要继续上述「截尾、倍大、相减、验差」的过程，直到能清楚判断为止。例如，判断133是否7的倍数的过程如下：13－3×2＝7，所以133是7的倍数；又例如判断6139是否7的倍数的过程如下：613－9×2＝595 ， 59－5×2＝49，所以6139是7的倍数，余类推。 能被8整除的数，一个整数的末3位若能被8整除，则该数一定能被8整除。 能被9整除的数，各个数位上的数字和能被9整除，那么这个数能被9整除 能被10整除的数，如果一个数既能被2整除又能被5整除，那么这个数能被10整除（即个位数为零） 能被11整除的数，奇数位（从左往右数）上的数字和与偶数位上的数字和之差（大数减小数）能被11整除，则该数就能被11整除。 11的倍数检验法也可用上述检查7的「割尾法」处理！过程唯一不同的是：倍数不是2而是1！能被12整除的数，若一个整数能被3和4整除，则这个数能被12整除 能被13整除的数，若一个整数的个位数字截去，再从余下的数中，加上个位数的4倍，如果差是13的倍数，则原数能被13整除。如果差太大或心算不易看出是否13的倍数，就需要继续上述「截尾、倍大、相加、验差」的过程，直到能清楚判断为止。 能被17整除的数，若一个整数的个位数字截去，再从余下的数中，减去个位数的5倍，如果差是17的倍数，则原数能被17整除。如果差太大或心算不易看出是否17的倍数，就需要继续上述「截尾、倍大、相减、验差」的过程，直到能清楚判断为止。 另一种方法：若一个整数的末三位与3倍的前面的隔出数的差能被17整除，则这个数能被17整除 能被19整除的数，若一个整数的个位数字截去，再从余下的数中，加上个位数的2倍，如果差是19的倍数，则原数能被19整除。如果差太大或心算不易看出是否19的倍数，就需要继续上述「截尾、倍大、相加、验差」的过程，直到能清楚判断为止。 另一种方法：若一个整数的末三位与7倍的前面的隔出数的差能被19整除，则这个数能被19整除 能被23整除的数，若一个整数的末四位与前面5倍的隔出数的差能被23(或29)整除，则这个数能被23整除 能被25整除的数，十位和个位所组成的两位数能被25整除。 能被125整除的数，百位、十位和个位所组成的三位数能被125整除。]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Useful</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[棋盘问题]]></title>
    <url>%2F2019%2F05%2F20%2Fpoj-1321%2F</url>
    <content type="text"><![CDATA[I dont&#39;t want be a Iron man!!! poj-1321-棋盘问题Links: poj-1321Description:在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。Input 输入含有多组测试数据。每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n &lt;= 8 , k &lt;= n当为-1 -1时表示输入结束。随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。Output 对于每一组数据，给出一行输出，输出摆放的方案数目C数据保证C\&lt;2^31）。Sample Input 2 1 #..#4 4...#..#..#.. #...-1 -1Sample Output 21 To solve this problem,you should clear about the judge conditions——Each line and each column cannot have a piece at the same time. Click to see Chinese Intentional analysis这道题跟八皇后很像，就是判断条件不太一样，每一行和每一列不能同时有棋子，具体看代码注释。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;char s[10][10];//The mapint flag[10];//Record whether a column has been put on the chess pieceint n,k,ans,anss;//anss represents how many pieces have been placed now.ans is the final answer.void dfs(int now)&#123; if(k==anss)//All the pieces are finished. &#123; ans++; return ; &#125; if(now&gt;=n)//Boundary conditions return ; for(int j=0;j&lt;n;j++) &#123; if(flag[j]==0&amp;&amp;s[now][j]==&apos;#&apos;)//Judge whether you can put down the pieces here. &#123; flag[j]=1; anss++; dfs(now+1); flag[j]=0;//For the back anss--; &#125; &#125; dfs(now+1);&#125;int main()&#123; while(cin&gt;&gt;n&gt;&gt;k) &#123; memset(s,0,sizeof(s)); ans=0; if(n==-1&amp;&amp;k==-1) break; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) cin&gt;&gt;s[i][j]; dfs(0); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; Click to see Chinese code1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;char s[10][10];//存起来的图int flag[10];//标记这一列已经放过棋子int n,k,ans,anss;//anss是现在已经放上去的棋子，ans是最后的答案void dfs(int now)&#123; if(k==anss) &#123; ans++; return ; &#125; if(now&gt;=n) return ; for(int j=0;j&lt;n;j++) &#123; if(flag[j]==0&amp;&amp;s[now][j]==&apos;#&apos;)//判断这个位置是否可以放棋子 &#123; flag[j]=1; anss++; dfs(now+1); flag[j]=0;//为了回溯 anss--; &#125; &#125; dfs(now+1);&#125;int main()&#123; while(cin&gt;&gt;n&gt;&gt;k) &#123; memset(s,0,sizeof(s)); ans=0; if(n==-1&amp;&amp;k==-1) break; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) cin&gt;&gt;s[i][j]; dfs(0); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>DFS</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ICPC-Invitational in Xi'an]]></title>
    <url>%2F2019%2F05%2F20%2FIron-man%2F</url>
    <content type="text"><![CDATA[International Collegiate Programming Contest-Xi&#39;an 机缘巧合下，被选去参加了5.18-19的西安邀请赛。 等了好久，终于等到5.17的晚上。早早的到了火车站，我们需要从焦作先到郑州然后再转车去西安。去郑州还是很快的，但是我们也是第一次倒车，摸索着摸索着就会了呗。去西安的车是硬卧，还是第一次坐硬卧，空间也太狭小了。而且路上总会很颠簸，睡眠得质量还是不是很好的。到了西安，下来火车，映入眼帘得就是一个城墙，果然壮观。据老师跟我们说的，我们需要先坐公交去找他会和。找到他之后，我们去坐下一个公交。路上去吃了西安得“正宗”的胡辣汤，跟我们这里“正宗”得胡辣汤一点都不一样，那时我才反应过来，哦，原来这种“正宗”都是自己给自己加的！下一班公交要坐两个小时，这时已经略微有点倦意。路上还看到了秦岭，真的是连绵不绝。 到了学校下了车，进了学校，经过了一个耗资两亿的图书馆，看了看沿途学校的风景，挺美的。跟着老师一起去签到，领了参赛牌和衣服，衣服是橙色的，不是很喜欢，不过毕竟是白嫖的。等这些事都忙完已经十一点多了，下午两点多还得到这参加开幕式，我和两个队友就决定不去宾馆在这个学校转转。老师去宾馆处理事情，我们仨就在学校转悠起来。转完之后，坐在签到处等着开幕式，然后又一次机缘巧合下，没去开幕式。 三点多的时候，已经让进机房了(应该是因为是邀请赛，所以没有在体育馆进行，还是有点可惜的。里面的安排是两个位置坐三个人，而且地方特别小，幸亏我跟我的队友都比较瘦。电脑上也没有dev，有个clione还有codeblock什么的，还支持python。热身赛一共三道题，印象中开始没多久，旁边的那一队就AK了，那时候我们应该是才做出来一道题，而且下面的题毫无思路。一阵阵的伤心，不过最后随着队友的爆发和板子终于是过了两题了。最后一道题队友用python两行写了出来，可是发现题目中要求的是int32，而python中没有这个，导致样例都没过，然后两个队友就开始商量着模拟爆int32得处理，可是最后也莫得实现。距离五点半(比赛结束，只剩不到十分钟了，我说直接交一发吧，队友说肯定不会过毕竟样例都没过，我想的就是就算不过我们也要WA一发，证明我们来过啊。在我的怂恿下队友交了，还有一个队友说：这要是能过，我吃X，然后过了，过了。不知道是评测数据水了还是样例唬人，AK得感觉还是很好的。 做完题我们拿着饭票去食堂吃饭，但是我们一致决定不在学校吃了，就走着回宾馆，顺便在路上吃个饭，我们找到一家泡馍，就点了三碗，刚开始吃还是挺好吃的，但是吃了一会发现越来越油。可能没有找对地方吧。吃完饭回到宾馆就没事了，洗了个澡，玩会手机就睡了。 第二天早上起来，在宾馆吃了早餐，坐着大巴去学校，老师就回去了，我们三个到学校的时候还有点早，就站了一会，等到八点四十左右就进去机房了。总共13道题，第一道巨水，过了之后发现后面的题都不简单。然后一个队友开了L，发现可以找规律做，别的也没有思路，我们就开始一起找规律，找啊找啊，找了好久也没找到，这时候发现L和M过了好多，我们又看了M，一个队友说是什么图啊什么的，我就直接去看L了，最后还是队友强，找到规律过了L。周围的队都太强了，三四个气球，我们才两个。到了中午开始发吃的了，每个人发了一个那种“汉堡”还有一个面包一盒奶，本来以为这就结束了，最后又给每个人发了一袋零食，薯片啊，面包啊什么的。不过那个我和队友一点都没吃提了回来。过了一会我们有发现D好像可以写，然后队友写出来了D，一测样例发现第一个样例可以过，第二个样例过不去。我们一起手算了第二个样例，发现跟我们程序跑的一样跟样例也不一样，不敢交，可是我们也找不到更好的答案了，最后我们也知道了一定会打铁的事实，就直接破罐子破摔交了，然后又过了，过了。我枯了。 比赛结束之后我们坐着大巴到了一个地铁站，然后坐地铁到了钟楼，出来地铁去了回民街，刚进去就看到了一堆人，一堆，而且里面好多外国人，感觉自己就像村里人进城一样。说好给小伙伴带好吃的好玩的回去，结果转了好大一圈也没有发现什么好带的。最后我们每个人买了个肉夹馍，一个肉夹馍花了15块钱。还真是有点坑。这个时候我们已经准备回车站了，到了车站外面，发现不知道怎么去候车厅，问了下路，总算是进了候车厅。回去的车还是卧铺，到了郑州再转去焦作。 这就回来了，两天三夜的行程，真的很累，睡的也不安稳，还背着沉重的书包跑过来跑过去，不但身上累，心里面更累。还是打了个铁，有点失望的吧，不过我也不会气馁，下一年等我卷土重来！]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LIS]]></title>
    <url>%2F2019%2F05%2F14%2F51nod-dp-LIS%2F</url>
    <content type="text"><![CDATA[51nod is good! LISwikipediaDescription:输入 第1行：1个数N，N为序列的长度(2 &lt;= N &lt;= 50000)第2 - N + 1行：每行1个数，对应序列的元素(-10^9 &lt;= S[i] &lt;= 10^9) 输出 输出最长递增子序列的长度。 输入示例1234567898516824510 输出示例15 Code:12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;const int maxn=50050;const int INF=0x3f3f3f3f;int dp[maxn],a[maxn];int main()&#123; int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; &#125; fill(dp,dp+n,INF); for(int i=0;i&lt;n;i++) &#123; *lower_bound(dp,dp+n,a[i])=a[i]; &#125; cout&lt;&lt;lower_bound(dp,dp+n,INF)-dp&lt;&lt;endl;&#125; The main problem solving idea isSo we can use a convenient function,such aslower_bound.Click to know more about lower_boundHonestly, I don&#39;t know what this has to do with DP, but it doesn&#39;t matter, I will always know it later.]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>c/c++</tag>
        <tag>DP</tag>
        <tag>51nod</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大鱼海棠]]></title>
    <url>%2F2019%2F05%2F14%2Fmovie-1%2F</url>
    <content type="text"><![CDATA[The password is my school name. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Edit distance]]></title>
    <url>%2F2019%2F05%2F14%2F51nod-dp-Edit-distance%2F</url>
    <content type="text"><![CDATA[I started to learn &quot;Edit distance&quot; though I still can&#39;t understand &quot;LCS&quot; enough.We will always encounter some trenches that cannot be crossed. At this time, we need to go around and wait until we are strong enough to solve this problem. This will never be the reason for us to stop. Edit distancewikipedia:Edit distanceDescription:编辑距离，又称Levenshtein距离（也叫做Edit Distance），是指两个字串之间，由一个转成另一个所需的最少编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。例如将kitten一字转成sitting：sitten （k-&gt;s）sittin （e-&gt;i）sitting （-&gt;g）所以kitten和sitting的编辑距离是3。俄罗斯科学家Vladimir Levenshtein在1965年提出这个概念。给出两个字符串a,b，求a和b的编辑距离。 The problem is easy if you know the state transition equation.1234567//From 51nodwe define the function same(i,j) to be 0 if S[i] == T[j], otherwise 1. Let us show the recursion: f(i,j) = min(f(i – 1, j – 1) + same(i,j), f(i – 1,j ) + 1, f(i, j – 1) + 1) initial value:f(0, j) = jf(i, 0) = i The tutorial above 51nod is really good.Nou just LCS or Edit distance,but every tutorial there.All the follwing are from 51nod.The difficulty of this problem is that it is difficult to have such operations as &quot;add&quot; and &quot;delete&quot;, which is very troublesome. Let&#39;s try to understand the problem from a different angle and see it as a string alignment problem. In fact, we can understand the problem from the perspective of bioinformatics comparison genes. Given the strings S and T, we can use a special character to facilitate the alignment of the two strings. The special character we added is &quot;-&quot;. We allow you to add this special character to S and T so that it is the same length, then &quot;align&quot; the two strings, and finally the two strings appear in the same position with different characters. With 1 point deduction, we want to make these two string alignment points as few as possible. For the example we actually took this alignment: 12345ABCF-DB-FG Note: If you want to align, the two &quot;-&quot; are relatively meaningless, so we ask that this does not happen.Then take a look:(1) S, T corresponding positions are ordinary characters, the same, then no points. For example, the position 2, 4(2) S, T is the normal character, and the difference is 1 point. For example, position 1(3) S is a special character at this position, and T is a normal character at this position, then 1 point is deducted, for example, position 5(4) S is a normal character at this position, and T is a special character at that position, then Deduct 1 point, for example, position 3, let&#39;s see what the deduction points correspond to? (1) No deduction, direct correspondence(2) Corresponding to the character modification of the corresponding positionin T (3) Corresponding to deleting the characterin T (4) Corresponding to adding the character in T , the target is clear, and it feels like Like LCS? Let us try:Let f(i,j) denote the minimum deduction after the alignment of the first i bit of S and the first j bit of T. Then let&#39;s take a look at the last one, the alignment (1) S[i] == T[j] must be used. At this time, the first i – 1 and j – 1 bits are already aligned. This part must be deducted at least. The minimum deduction in this case is f(i-1,j-1)(2) is similar to (1), S[i]≠T[j], in which case the least deduction is f(i) -1, j – 1) + 1(3) The front i position of S and the front (j – 1) bit of T are already aligned, and this part has the least points. In this case, the least deduction is f(i,j-1) + 1(4) The first (i-1) bit of S has been aligned with the first j position of T, which is the least. In this case, the minimum deduction is f(i,j-1) + 1 What is the value of f(i,j), obviously it depends on which case has the least deduction. An example on nowcoder:Link:Edit distanceDescription:UNIX系统下有一个行编辑器ed，它每次只对一行文本做删除一个字符、插入一个字符或替换一个字符三种操作。例如某一行的内容是“ABC”，经过把第二个字符替换成“D”、删除第一个字符、末尾插入一个字符“B”，这三步操作后，内容就变成了“DCB”。即“ABC”变成“DCB”需要经过3步操作，我们称它们的编辑距离为3。现在给你两个任意字符串（不包含空格），请帮忙计算它们的最短编辑距离。 输入描述:输入包含多组数据。 每组数据包含两个字符串m和n，它们仅包含字母，并且长度不超过1024。 输出描述:对应每组输入，输出最短编辑距离。示例1输入ABC CBCDABC DCB输出23 Intentional analysis:A basic Edit distance problem,just use the recursion above. Code:12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 1050;int f[maxn][maxn];string a,b;bool same(char x,char y)&#123; if(x==y) return 0; return 1;&#125;int main()&#123; while(cin&gt;&gt;a&gt;&gt;b) &#123; memset(f,0,sizeof(f)); for(int i=0;i&lt;=a.size();i++) &#123; for(int j=0;j&lt;=b.size();j++) &#123; if(i==0) f[i][j]=j; else if(j==0) f[i][j]=i; else f[i][j]=min(f[i-1][j-1]+same(a[i-1],b[j-1]),min(f[i-1][j]+1,f[i][j-1]+1)); &#125; &#125; cout&lt;&lt;f[a.size()][b.size()]&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>c/c++</tag>
        <tag>DP</tag>
        <tag>51nod</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Find the Tth Char]]></title>
    <url>%2F2019%2F05%2F13%2Famazing-thinking%2F</url>
    <content type="text"><![CDATA[There are all kinds of people in this world. It happens that we have become friends. This is not fate. It is just that we should be friends. ——Green BookWhen I first met a problem which name is Find the Nth Character in nowcoder,I find this problem is interesting for mind.After solving this,I find a similar problem like this in HDU which name is find the Nth digit.Link:Find the Nth Character in nowcoderfind the Nth digit in HDU Find the Nth CharacterDescription:Mr Cheng今天在给HLJU的同学们上程序算法课的时候出了一道找规律的题目，题目表述如下假设：现在要求上课的同学们把所有的串依次连接起来，于是得到:S=aababcabcdabcde...那么你能告诉Mr Cheng在S串中的第N个字母是多少吗？ 输入描述:输入首先是一个数字K，代表有K次询问(1&lt;=K&lt;=1000) 接下来的K行每行有一个整数N(1&lt;=N&lt;=10000) 输出描述:对于每次询问，输出串中第个位置对应的字母。 示例1输入61234510输出aababd Code:123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int t; int n; cin&gt;&gt;t; while (t--) &#123; cin&gt;&gt;n; int a = 1; char ans=&apos;a&apos;; while ( n &gt; a ) &#123; n -= a; a++; &#125; n%=26; if(n==0) n=26; ans+=n-1; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; find the nth digitDescription:假设：S1 = 1S2 = 12S3 = 123S4 = 1234.........S9 = 123456789S10 = 1234567891S11 = 12345678912............S18 = 123456789123456789..................现在我们把所有的串连接起来S = 1121231234.......123456789123456789112345678912.........那么你能告诉我在S串中的第N个数字是多少吗？ Input输入首先是一个数字K，代表有K次询问。接下来的K行每行有一个整数N(1 &lt;= N &lt; 2^31)。 Output对于每个N，输出S中第N个对应的数字. Sample Input61234510 Sample Output112124 Code:123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int t; int n; cin&gt;&gt;t; while (t--) &#123; cin&gt;&gt;n; int a = 1; char ans=&apos;1&apos;; while ( n &gt; a ) &#123; n -= a; a++; &#125; n%=9; if(n==0) n=9; ans+=n-1; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; Intentional analysis:We can easily find there is a few different between these two codes above.In fact,to solve this problem,the main thinking is find the Nth in the correct position.And the regular is121 2 3 4 5 6 7 8 9 10...1 12 123 1234 12345 123456 1234567 12345678 123456789 1234567891... Through this,you may understand this more.I know that what I said is not so clearly,so just think through these codes if you can&#39;t understand enough.]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>Thinking</tag>
        <tag>HDU</tag>
        <tag>nowcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Discrete mathematics-Chapter Six]]></title>
    <url>%2F2019%2F05%2F11%2FDiscrete-mathematics-Chapter-Six%2F</url>
    <content type="text"><![CDATA[The program work in Chapter 6 is about sets. In general, it is quite simple, because many functions are implemented in python with related encapsulated functions. Judge an element in a set or not123456789#Judge an element in a set or notprint("Enter the element to be judged:")a = input()print("Enter the set to be judged:")s = set(input().split())if a in s: print("The element %s is in the set %s" % (a,s))else: print("The element %s is not in the set %s" % (a,s)) Judge if a set is a subset of another set1234567891011#Judge if a set is a subset of another setprint("Input a set:")a=set(input().split())print("Input another set")b=set(input().split())if a.issubset(b): print("The set %s is the subset of the set %s" % (a,b))elif b.issubset(a): print("The set %s is the subset of the set %s" % (b,a))else: print("There is no subset relationship between the set %s and the set %s" % (a,b)) Judge if a set is a proper subset of another set1234567891011#Judge if a set is a proper subset of another setprint("Input a set:")a=set(input().split())print("Input another set")b=set(input().split())if len(a)!=len(b) and a.issubset(b): print("The set %s is the proper subset of the set %s" % (a,b))elif len(a)!=len(b) and b.issubset(a): print("The set %s is the proper subset of the set %s" % (b,a))else: print("There is no proper subset relationship between the set %s and the set %s" % (a,b)) Judge if two sets are equal123456789#Judge if two sets are equalprint("Input a set:")a=set(input().split())print("Input another set")b=set(input().split())if a==b: print("The set %s is equal to the set %s" % (a,b))else: print("The set %s is not equal to the set %s" % (a,b)) Judge a collection as an empty set1234567#Judge a collection as an empty setprint("Input a set to be judged:")a=set(input().split())if a: print("The set %s is not an empty set" % (a))else: print("The set is an empty set") Reference artical:https://blog.csdn.net/u013247765/article/details/79052257 Calculate the number of elements in a set1234#Calculate the number of elements in a setprint("Input the set to be calculated:")a=set(input().split())print("The number of elements in the set %s is %d" % (a,len(a))) List a set of power set elements and return the number of elements1234567891011121314151617#List a set of power set elements and return the number of elementsdef powerset(items): N = len(items) sall=[] for i in range(2**N): powers = [] for j in range(N): if(i &gt;&gt; j ) % 2 == 1: #For the i-th bit of the binary of x, if it is 1, this subset contains the ith element of s, otherwise it is not included. powers.append(items[j]) sall.append(powers) return sallprint("Input a set:")a=set(input().split())ans=powerset(list(a))print("The power set of the set %s are:" % (a))print(ans)print("The number of elements is %d" % (len(ans))) Reference artical:https://blog.csdn.net/beyondwdq/article/details/5540386https://blog.csdn.net/luoganttcc/article/details/80785149 Find the union of two sets123456#Find the union of two setsprint("Input a set:")a=set(input().split())print("Input another set:")b=set(input().split())print("the union of set %s and set %s is %s" % (a,b,a|b)) Judge if the intersection of two sets is an empty set12345678910#Judge if the intersection of two sets is an empty setprint("Input a set:")a=set(input().split())print("Input another set:")b=set(input().split())ans=a&amp;bif ans: print("The intersection of set %s and set %s is not an empty set" % (a,b))else: print("The intersection of set %s and set %s is an empty set" % (a,b)) Find the intersection of two sets123456#Find the intersection of two setsprint("Input a set:")a=set(input().split())print("Input another set:")b=set(input().split())print("The intersection of set %s and set %s is %s" % (a,b,a&amp;b)) Find the relative complement of two sets1234567#Find the relative complement of two setsprint("Input a set:")a=set(input().split())print("Input another set:")b=set(input().split())print("The relative complement of set %s and %s is %s" % (a,b,a-b))print("The relative complement of set %s and %s is %s" % (b,a,b-a)) Something about relative complement:baike.baiduWikipedia Find the symmetric difference set of two sets123456#Find the symmetric difference set of two setsprint("Input a set:")a=set(input().split())print("Input another set:")b=set(input().split())print("The symmetric difference set of set %s and set %s is %s" % (a,b,(a|b)-(a&amp;b))) Something about symmetric difference set:baike.baiduWikipedia]]></content>
      <categories>
        <category>Discrete mathematics</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Discrete mathematics</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LCS]]></title>
    <url>%2F2019%2F05%2F09%2F51nod-dp%2F</url>
    <content type="text"><![CDATA[DP is too difficult for me.I can&#39;t explain the code correctly so I just paste it here. LCS 给出两个字符串A B，求A与B的最长公共子序列（子序列不要求是连续的）。比如两个串为： abcicbaabdkscab ab是两个串的子序列，abc也是，abca也是，其中abca是这两个字符串最长的子序列。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//From the internet#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;string a,b;int dp[1050][1050],mark[1050][1050],la,lb;void lcs()&#123; int i,j; memset(dp,0,sizeof(dp)); for(int i=1;i&lt;=la;i++) mark[i][0]=1; for(int i=1;i&lt;=lb;i++) mark[0][i]=-1; for(int i=1;i&lt;=la;i++) &#123; for(int j=0;j&lt;=lb;j++) &#123; if(a[i-1]==b[j-1]) &#123; dp[i][j]=dp[i-1][j-1]+1; mark[i][j]=0; &#125; else if(dp[i-1][j]&gt;=dp[i][j-1]) &#123; dp[i][j]=dp[i-1][j]; mark[i][j]=1; &#125; else &#123; dp[i][j]=dp[i][j-1]; mark[i][j]=-1; &#125; &#125; &#125;&#125;void output(int x,int y)&#123; if(!x&amp;&amp;!y) return ; if(mark[x][y]==0) &#123; output(x-1,y-1); cout&lt;&lt;a[x-1]; &#125; else if(mark[x][y]==1) &#123; output(x-1,y); &#125; else &#123; output(x,y-1); &#125;&#125;int main()&#123; while(cin&gt;&gt;a&gt;&gt;b) &#123; la=a.size();lb=b.size(); lcs(); output(la,lb); cout&lt;&lt;endl; &#125; return 0;&#125; Code:12345678910111213141516171819202122232425262728293031323334353637383940//From boctorio#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;stack&gt;using namespace std;const int maxn = 1050 ;int dp[maxn][maxn];char a[maxn],b[maxn];int main()&#123; scanf(&quot;%s %s&quot;,a+1,b+1); int n=strlen(a+1),m=strlen(b+1); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) &#123; if(a[i]==b[j]) dp[i][j]=dp[i-1][j-1]+1; else dp[i][j]=max(dp[i-1][j],dp[i][j-1]); &#125; stack&lt;char&gt; ans; while(n&gt;=1&amp;&amp;m&gt;=1) &#123; if(dp[n][m]==0) break; if(dp[n][m]-dp[n-1][m-1]==1 &amp;&amp; dp[n-1][m-1]==dp[n-1][m] &amp;&amp; dp[n-1][m-1]==dp[n][m-1]) &#123; ans.push(a[n]); n--; m--; &#125; else if(dp[n][m]==dp[n-1][m] &amp;&amp; n&gt;1) n--; else if(dp[n][m]==dp[n][m-1] &amp;&amp; m&gt;1) m--; &#125; while(!ans.empty()) &#123; printf(&quot;%c&quot;,ans.top()); ans.pop(); &#125; puts(&quot;&quot;); return 0;&#125; You can take part in the tutorial of dp in the 51nod.It&#39;s so good!]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>c/c++</tag>
        <tag>DP</tag>
        <tag>51nod</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A Basic Greedy]]></title>
    <url>%2F2019%2F05%2F06%2FSDUT-2072%2F</url>
    <content type="text"><![CDATA[Greedy is a exacting method for programming,though it is not so good for us. 删数问题link: SDUT-2072 Description:键盘输入一个高精度的正整数n（≤100位），去掉其中任意s个数字后剩下的数字按照原来的左右次序组成一个新的正整数。编程对给定的n与s，寻找一种方案，使得剩下的数字组成的新数最小。Input输入有多组 每组包括原始数n，要去掉的数字数s；Output输出去掉s个数后最小的数Sample Input178543 4Sample Output13Intentional analysis:We&#39;d better use the string type to input.What we should do if find a number in the input which is bigger than it&#39;s next.Like a[i]&gt;a[i+1].And then delete the a[i].There is the greedy.There are many special situations we shoule consider. Can&#39;t find a a[i] which is satisfy a[i]&gt;a[i+1],just output the first n characters The answer string s has &#39;0&#39; at the first,the ordering output should be a number,nao a string.So the front &#39;0&#39; is not allowed. Click to see Chinese Intentional analysis我们输入的应该是字符串，方便操作并且保证数据范围。为了得到消去之后最大的值，我们只需要找到a[i]&gt;a[i+1]的i并将之删除即可。这就是体现贪心的地方。但是我们还需要考虑一些特殊情况1. 数本身就是递增的，此时我们只需要输出前n位即可。2. 得到的答案字符串的前面有0，判断一下并消去即可。 Code:1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;int main()&#123; string s; int n; while(cin&gt;&gt;s&gt;&gt;n) &#123; int l=s.size(); while(n--) &#123; for(int i=0;i&lt;l;i++) &#123; if(s[i]&gt;s[i+1]||i==l-1) &#123; s.erase(i,1); break; &#125; &#125; &#125; while(s[0]==&apos;0&apos;&amp;&amp;s[1]) s.erase(0,1); cout&lt;&lt;s&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Greedy</tag>
        <tag>SDUTOJ</tag>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Basic Dynamic programming]]></title>
    <url>%2F2019%2F05%2F06%2FDP-basic%2F</url>
    <content type="text"><![CDATA[Yesterday a senior teach us about dynamic planning and i&#39;d like to recorded this basic question. 堆石子link: 堆石子Description:JQM开始玩堆石子的游戏。有 m 颗质量大小不同的石子，从最下面一层开始堆石子，最下面一层放置 n 颗石子，每层减少一颗石子，恰好到最上一层为 一颗 石子。现在从最下面一层开始每层石子中取出一颗石子（注意，为了方便取出，要求只能拿和已拿石子相邻的两颗石子中的一颗），求能取出的石子质量和最大为多少？ Input石子总数 m(1≤m≤400)接下来每行表示从最下面一层开始每层每个石子的质量 w(1≤w≤1e8) Output能取出的最大石子质量和 Examplesinput61 4 63 21output9Note 1 2 3 4 5 67 8 9 10如果你拿了8，那么你就只能拿4或者5而不能拿6 Intentional analysis:What we should is find the &quot;State transition equation&quot;.We know that the value of the optimal solution in the bottom row is his own, which is the critical condition.Another part of the state transition equation is that the value of the optimal solution is the maximum of the number above it and the number in the upper right corner, and then adds itself.Of course,we can solve this problem with DFS.Memory search is a perfect way to avoid TLE.So,we can get the &quot;State transition equation&quot;: 123456dp[i][j] = a[i][j] if(i==n)dp[i][j] = max(dp[i+1][j], dp[i+1][j+1]) + a[i][j]n represents the number of rows of triangles.a[i][j] represents the value of the i-th row and the j-th column in the triangle.dp[i][j] represents the value of the optimal solution for this position. Click to see Chinese Intentional analysis这是一道DP的裸题，我们需要的就是推出递推公式就行了。首先我们知道若想得到当前位置的最优解，就需要知道它上一个位置的最优解，一开始可能会想到dfs，看一下数据范围，dfs的话肯定会超时，但是dfs也是可以做的，但是需要用到记忆化搜索。继续说回我们用DP做的方法，我们知道最下面那一行的最优解的值就是他自己，这就是临界条件，状态转移方程的另一部分就是这个数最优解的值就是它的上面的那个数和右上角的那个数的最大值加上自己本身。所以我们可以得到123456dp[i][j] = a[i][j] if(i==n)dp[i][j] = max(dp[i+1][j], dp[i+1][j+1]) + a[i][j]n代表的是三角形的行数。a[i][j]代表的是三角形中的第i行第j列的值。dp[i][j]代表的就是这个位置的最优解的值。 Code-dp:1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=400;typedef long long ll;ll a[maxn][maxn];ll dp[maxn][maxn];int main()&#123; ll n,k=1; cin&gt;&gt;n; while(n) &#123; n-=k; k++; &#125; k-=1; for(ll i=k;i&gt;=1;i--) for(ll j=1;j&lt;=i;j++) cin&gt;&gt;a[i][j]; for(ll i=k;i&gt;=1;i--) &#123; for(ll j=1;j&lt;=i;j++) if(i==k) dp[i][j]=a[i][j]; else dp[i][j]=max(dp[i+1][j],dp[i+1][j+1])+a[i][j]; &#125; cout&lt;&lt;dp[1][1]&lt;&lt;endl; return 0;&#125; Code-dfs:123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1000;ll a[maxn][maxn];ll dp[maxn][maxn];ll n,k=1;ll dfs(ll x,ll y)&#123; if(dp[x][y]) return dp[x][y]; if(x==k) return dp[x][y]=a[x][y]; ll m = dfs(x+1,y); ll n = dfs(x+1,y+1); return dp[x][y]=max(m,n)+a[x][y];&#125;int main()&#123; cin&gt;&gt;n; while(n) &#123; n-=k; k++; &#125; k-=1; for(ll i=k;i&gt;=1;i--) for(ll j=1;j&lt;=i;j++) cin&gt;&gt;a[i][j]; cout&lt;&lt;dfs(1,1)&lt;&lt;endl; return 0;&#125; If you still confused with dp,just think about Fibonacci sequence.1234567F[0]=1F[1]=1F[2]=2F[3]=3F[4]=5......F[n]=F[n-1]+F[n-2] F[n]=F[n-1]+F[n-2] is Fibo&#39;s &quot;State transition equation&quot;.]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>DP</tag>
        <tag>DFS</tag>
        <tag>HPUOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Stone]]></title>
    <url>%2F2019%2F05%2F04%2Fnowcoder-893-D%2F</url>
    <content type="text"><![CDATA[Think in another way!!! nowcoder-893-D Stone link: Stone Description: 有n堆石子排成一排，第i堆石子有ai个石子。每次，你可以选择任意相邻的两堆石子进行合并，合并后的石子数量为两堆石子的和，消耗的体力等价于两堆石子中石子数少的那个。请问，将所有的石子合并成一堆，你所消耗的体力最小是多少？输入描述:第一行是一个整数T(1≤T≤20)，表示样例的个数。每个样例的第一行是一个整数(1≤n≤10000),表示石子堆的数量。第二行是n个整数(1≤ai≤1e9)输出描述:每行输出一个样例的结果。示例1输入221 211输出10说明巨大的输入，请使用C风格的输入。 Intentional analysis: Because the order of the series is not changeable,so we can use the sum of each item in the series to subtract the largest item.It&#39;s the answer. Click to see Chinese Intentional analysis一开始看到这道题，我以为是贪心裸题，结果仔细一看，数列的顺序是不能变的。。。然后就没了思路。。。等到比赛结束之后看了大佬思路，恍然大悟。因为每次能合起来两堆石子，消耗的疲劳度是最小的那个，并且顺序还不能变，所以若想使最后的疲劳度最小，只需要让最大的那堆石头当成最后一组合起来的一个就行。因为最大的那个不管加上其他哪个数之后都会大于那个数。在一次合成中消耗掉这个最大的数并且使它不计算入疲劳度，就可以得到最小的疲劳度。 Code:123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll a[10005]; int main()&#123; ll n,t; scanf(&quot;%lld&quot;,&amp;n); while(n--) &#123; scanf(&quot;%lld&quot;,&amp;t); ll sum=0; for(ll i=0;i&lt;t;i++) &#123;scanf(&quot;%lld&quot;,&amp;a[i]);sum+=a[i];&#125; ll maxx=a[0]; for(ll i=1;i&lt;t;i++) maxx=max(maxx,a[i]); printf(&quot;%lld\n&quot;,sum-maxx); &#125; return 0;&#125;]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>nowcoder</tag>
        <tag>Thiking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QAQ]]></title>
    <url>%2F2019%2F05%2F04%2Fnowcoder-847-A%2F</url>
    <content type="text"><![CDATA[No Wrong Answer No Time Limit Exceeded No Memory Limit Exceeded No Segmentation Fault No Run Time Error No Presentation Error No Floating Point Error No Compilation Error No Output Limit Exceeded Just Accepted,Accepted,and Accepted Yesterday participated in a practice session of nowcoder,Then I met a question similar to the previous one. nowcoder-847-A QAQlink: QAQ Descrption: 给定一个只包含大写字母的长度为N的字符串S,求S中不含相邻字符且长度为3的&quot;QAQ&quot;子序列个数。即:设字符串S的第i个字符为Si,求满足下列条件的&lt;x,y,z&gt;三元组个数。1≤x,y,z≤Nx&lt;y−1y&lt;z−1Sx=&#39;Q&#39;,Sy=&#39;A&#39;,Sz=&#39;Q&#39; 输入描述:输入仅一行一个字符串S,字符串的长度N满足(1≤N≤5000)。N不会在输入中给出。保证S中只包含大写字母。输出描述:输出一行一个整数--满足条件的三元组个数。示例1输入QQAQQ输出1说明满足条件的三元组只有一个: &lt;1,3,5&gt;示例2输入QAQAQ输出0示例3输入QQHAHAQQAQ输出10 Intentional analysis: QAQ,let&#39;s look it carefully.Then we can find that the amount of &quot;QAQ&quot; is depends on the amount of &quot;A&quot;.So our task is find the position of &quot;A&quot;.Attention: You can&#39;t choose neighboring char from the original string. Click to see Chinese Intentional analysis观察一下可以发现，QAQ的数量取决于A的数量。所以我们只需要找到A的数量，然后进行判断计算就行。注意：这道题要求的QAQ不能是在原字符串中相邻的字符。 For example:12345678910QAQAQ12345We can find &quot;QAQ&quot; at: 1 2 31 2 51 4 53 4 5but all of these have neighboring char,so the answer of this example is &quot;0&quot;,not &quot;4&quot;. Code:123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;string s;long long ans;int main()&#123; cin&gt;&gt;s; int l=s.size(); for(int i=0;i&lt;l;i++) &#123; if(s[i]==&apos;A&apos;) &#123; int a=0; int b=0; for(int j=i-2;j&gt;=0;j--) &#123; if(s[j]==&apos;Q&apos;) a++; &#125; for(int k=i+2;k&lt;l;k++) &#123; if(s[k]==&apos;Q&apos;) b++; &#125; ans+=a*b; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; One more thing you should better focus on:The answer is too big to be able to save a int type.I ffailed once because of this. A similar question:CodeForces-894-A QAQlink: QAQ Descripition:&quot;QAQ&quot; is a word to denote an expression of crying. Imagine &quot;Q&quot; as eyes with tears and &quot;A&quot; as a mouth. Now Diamond has given Bort a string consisting of only uppercase English letters of length n. There is a great number of &quot;QAQ&quot; in the string (Diamond is so cute!). Bort wants to know how many subsequences &quot;QAQ&quot; are in the string Diamond has given. Note that the letters &quot;QAQ&quot; don&#39;t have to be consecutive, but the order of letters should be exact. InputThe only line contains a string of length n (1 ≤ n ≤ 100). It&#39;s guaranteed that the string only contains uppercase English letters. OutputPrint a single integer — the number of subsequences &quot;QAQ&quot; in the string. ExamplesinputQAQAQYSYIOIWINoutput4inputQAQQQZZYNOIWINoutput3NoteIn the first example there are 4 subsequences &quot;QAQ&quot;: &quot;QAQAQYSYIOIWIN&quot;, &quot;QAQAQYSYIOIWIN&quot;, &quot;QAQAQYSYIOIWIN&quot;, &quot;QAQAQYSYIOIWIN&quot;. This is similar to the previois.The only thing different is choose a neighboring char is allowed here.So we just correct a number then we can solve this problem. Code:123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;string s;long long ans;int main()&#123; cin&gt;&gt;s; int l=s.size(); for(int i=0;i&lt;l;i++) &#123; if(s[i]==&apos;A&apos;) &#123; int a=0; int b=0; for(int j=i-2;j&gt;=0;j--) &#123; if(s[j]==&apos;Q&apos;) a++; &#125; for(int k=i+2;k&lt;l;k++) &#123; if(s[k]==&apos;Q&apos;) b++; &#125; ans+=a*b; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; You can find the difference between these two codes which is better for you to understand this series of questions. The most exciting thing I want to say is 我中奖啦 I got the prize Gané el premio. Ek het die prys gewen. Kam fituar çmimin. ሽልማቱን አሸንፌያለሁ. Ես հաղթել եմ մրցանակին: Mükafatı qazandım. Saria irabazi nuen. Я выйграў латарэю сяброў...... After nearly half a year of competition on the nowcoder.Participated in 18 games,I won the price at last.Congratulations! Show off]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>nowcoder</tag>
        <tag>Thiking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go back home]]></title>
    <url>%2F2019%2F05%2F01%2FWowwwww%2F</url>
    <content type="text"><![CDATA[The password is my school name. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Prefix Sum Primes]]></title>
    <url>%2F2019%2F04%2F30%2FCodeForces-1149-A%2F</url>
    <content type="text"><![CDATA[A ac a day, keeps the doctor away! CodeForces-1149-A Prefix Sum PrimesTopic link:Prefix Sum PrimesDescription:We&#39;re giving away nice huge bags containing number tiles! A bag we want to present to you contains n tiles. Each of them has a single number written on it — either 1 or 2. However, there is one condition you must fulfill in order to receive the prize. You will need to put all the tiles from the bag in a sequence, in any order you wish. We will then compute the sums of all prefixes in the sequence, and then count how many of these sums are prime numbers. If you want to keep the prize, you will need to maximize the number of primes you get. Can you win the prize? Hurry up, the bags are waiting! InputThe first line of the input contains a single integer n (1≤n≤200000) — the number of number tiles in the bag. The following line contains n space-separated integers a1,a2,…,an (ai∈{1,2}) — the values written on the tiles. OutputOutput a permutation b1,b2,…,bn of the input sequence (a1,a2,…,an) maximizing the number of the prefix sums being prime numbers. If there are multiple optimal permutations, output any. Examplesinput51 2 1 2 1output1 1 1 2 2input91 1 2 1 1 1 2 1 1output1 1 1 2 1 1 1 2 1NoteThe first solution produces the prefix sums 1,2,3,5,7 (four primes constructed), while the prefix sums in the second solution are 1,2,3,5,6,7,8,10,11 (five primes). Primes are marked bold and blue. In each of these cases, the number of produced primes is maximum possible. Intentional analysis:To solve this problem,you&#39;d better know a rule——The difference between all adjacent prime numbers except 2, 3 is even.So what we should is just get the number of occurrences of 1 and 2,judge and print.There are three situations: 1.The number of occurrences of 1 is 0. 2.The number of occurrences of 2 is 0. 3.Both 1 and 2 have appeared. Where does it reflect greed?If the first two numbers are done,and you still have 2 ,just print it,and then print 1. Click to see Chinese Intentional analysis为了解决这个问题，有个规则你是必须要知道的——除了2，3之外的所有相邻的素数的差都是偶数。所以我们只需要知道给的数据中1，2出现几次就行了。这里总共有三种情况：一： 1没有出现过。二： 2没有出现过。三： 1，2都出现过。能体现出贪心的是哪里呢？就是当你处理完前两个质数2，3之后，如果你还有2，就把2先输出完，然后再输出剩下的1即可。 Code:123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int x,a=0,b=0,n; cin&gt;&gt;n; while(n--) &#123; cin&gt;&gt;x; if(x==1) a++; else b++; &#125; if(a==0) &#123; while(b--) cout&lt;&lt;&quot;2 &quot;; cout&lt;&lt;endl; return 0; &#125; if(b==0) &#123; while(a--) cout&lt;&lt;&quot;1 &quot;; cout&lt;&lt;endl; return 0; &#125; else &#123; cout&lt;&lt;&quot;2 1 &quot;; a-=1; b-=1; while(b--) cout&lt;&lt;&quot;2 &quot;; while(a--) cout&lt;&lt;&quot;1 &quot;; cout&lt;&lt;endl; return 0; &#125;&#125; There are many useful rules that I don’t know,still have to do more questions.]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>Greedy</tag>
        <tag>c/c++</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Getting Started]]></title>
    <url>%2F2019%2F04%2F28%2FCool%2F</url>
    <content type="text"><![CDATA[Hexo is a fast and powerful static blog generating framework, it&#39;s based on Node.js. By using Hexo you can write articles easily with Markdown, and besides the grammer of Markdown, you can also use tag plugins provided by Hexo to insert special formated content simply. In this page we assume you have installed Hexo and created a site with it. You can visit Hexo Docs to see how to install Hexo. Documentation Variables_config.ymlAvailable SettingsDefault SettingsThere are two main configuration files using by Hexo and both called _config.yml: The first one is under site root directory, which contains Hexo&#39;s config. The second one is under theme root directory, which is provided by NexT and contains theme&#39;s config. Let&#39;s call the first one – site config file, and the second one – theme config file.All available settings will be inside code blocks (with single backtick or &lt;code&gt; tags).And all default settings will be bold inside code blocks (with single backtick or &lt;code&gt; and ** or &lt;strong&gt; tags). Recommended SettingsDeprecated SettingsPossible ErrorsAll recommended settings will be highlighted under the success label.All deprecated settings will be highlighted under the warning label.And all possible errors will be highlighted under the danger label. NexT InstallationIt&#39;s easy to install Hexo theme: you can just download the NexT theme, copy the theme folder to the themes directory under site root directory and specify in site config file your theme root directory. The detailed steps are as follows: Downloading NexTNewest VersionStable VersionIf you know about Git, you can clone the whole repository and update it in any time with git pull command instead of downloading archive manually. Open your Terminal, change to Hexo site root directory and clone latest master branch of NexT theme: 12$ cd hexo$ git clone https://github.com/theme-next/hexo-theme-next themes/next Go to NexT version Release Page. Choose the version you need and download the Source Code (zip) in the Download section. For example v6.0.0. Extract the zip file to site&#39;s themes directory and rename the extracted folder (hexo-theme-next-6.0.0) to next. You also can read detailed installation instructions if you want any other installation variant. If you still use NexT version 5, you can read instructions for update from v5 to v6. Enabling NexTLike all Hexo themes, after you download it, open site config file, find theme section, and change its value to next (or another theme directory name). hexo/_config.yml1theme: next Now you have installed NexT theme, next we will verify whether it is enabled correctly. Between changing the theme and verifying it, we&#39;d better use hexo clean to clean Hexo&#39;s cache. Checking NexTFirst start Hexo local server, and enable debug parameter (by adding --debug), the whole command is hexo s --debug. You can see the output while running, and if you find problem, you can use the output to help others locate error better. When it prints: INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. Now you can open http://localhost:4000 in your browser, and check whether the site works correctly. If you find your site looks like this picture, you have installed it correctly. That’s default NexT scheme – Muse. Now you&#39;ve installed and enabled NexT. In next steps we will change some settings including personalization and third-party services integration. Adding PluginsThere are 2 variants to hook up NexT plugins: Local installation (plugins scripts will loaded from your site). CDN links (plugins scripts will loaded from remote hosts). If your site hosted on VPN (or any other) server with NGINX configuration, recommended to use local installation.And if your files deployed to any free hosting service (Github, Gitlab, etc.), recommended to use CDN links. LocalCDNIn NexT config now you can find dependencies on each module which was moved to external repositories which can be found by main organization link. For example, you want to use fancybox in your site. Go to theme config file and see: next/_config.yml12# Dependencies: https://github.com/theme-next/theme-next-fancyboxfancybox: false Then turn on fancybox and go to «Dependencies» link with installation instructions of this module.If you use cdn for any plugins, you need to replace your cdn link. For example, you want to use fancybox and you configured a cdn link. Go to theme config file and see: next/_config.yml123456vendors: # ... # Some contents... # ... fancybox: //cdn.jsdelivr.net/npm/fancybox@3.0.0/dist/js/jquery.fancybox.pack.js # Set or update fancybox cdn url. fancybox_css: //cdn.jsdelivr.net/npm/fancybox@3.0.0/dist/css/jquery.fancybox.min.css # Set or update fancybox cdn url. And jsDelivr CDN is recommended to deliver our third-party plugins because it is fast in everywhere and has the valid ICP license issued by the Chinese government. It does not only crawl the js files from npm packages, and it crawls from the GitHub Releases! We could use the following link to reference the js files, just as other CDNs. 1//cdn.jsdelivr.net/gh/user/repo@version/file And it could automatically minify the JS and CSS files, even if you don&#39;t have the minified version. Just use the filename.min.js or the filename.min.css to replace the file above. And we also provide other optional CDNs, including the famous CDNJS and the Bootcss which has the quite high access speed in China. NexT ConfigurationChoosing SchemeScheme is a feature supported by NexT, by using Scheme NexT gives you different views. And nearly all config can be used by those Schemes. Till now NexT supports 4 schemes, and they are: Muse → Default Scheme, this is the initial version of NexT. Uses black-white tone and mainly looks cleanly. Mist → A tighter version of Muse with a tidy single-column view. Pisces → Double-column Scheme, fresh like your neighbor&#39;s daughter. Gemini → Looks like Pisces, but have distinct column blocks with shadow to appear more sensitive to view. You can change Scheme by editing theme config file, searching scheme keyword. You&#39;ll see 4 lines of scheme settings and can enable one of them by removing it&#39;s # and added # to previous. next/_config.yml1234#scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini Choosing LanguageEdit site config file, set the value of language to the language you need. For example, English looks like this: hexo/config.yml1language: en NexT now supports following languages: Language Example Code 🇨🇳 Chinese (Simplified) 简体中文 zh-CN 🇹🇼 Chinese (Traditional) 繁體中文 zh-TW 🇭🇰 Chinese (Hong Kong) 繁體中文-香港 zh-HK 🇧🇶 Dutch Niederländisch nl 🇺🇸 English English en 🇹🇫 French Français fr 🇩🇪 German Deutsch de 🇮🇩 Indonesian Indonesia id 🇮🇹 Italian Italiano it 🇯🇵 Japanese 日本語 ja 🇰🇷 Korean 한국어 ko 🇮🇷 Persian فارسی fa 🇵🇹 Portuguese Português pt 🇧🇷 Portuguese (Brazilian) Português (Brazilian) pt-BR 🇷🇺 Russian Русский ru 🇪🇸 Spanish Español es 🇹🇷 Turkish Türk tr 🇺🇦 Ukrainian Український uk 🇻🇳 Vietnamese Tiếng Việt vi If you want to add or improve language for NexT theme, you can do it easily with crowdin service. Configuring Menu ItemsMenu settings items have format Key: /link/ || icon which contains 3 values: KeylinkiconKey → is the name of menu item (home, archives, etc.).If translate for this menu will be found in languages, this translate will be loaded; if not, Key name will be used. Key value is case sensitive (e.g. home is not same as Home). Value before || delimeter (/link/) → is the target link to relative url inside your site.Value after || delimeter (icon) → is the name of FontAwesome icon.If icon (with or without delimeter) is not specified, question icon will be loaded.Names of that icons can be found in Font Awesome site. By default NexT provides home and archives items. To customize menu items, edit the following content in theme config file: All custom pages which commented by default under menu section need to create manually. See «Custom Page Support» next/_config.yml123456789menu: home: / || home #about: /about/ || user #tags: /tags/ || tags #categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat Dynamic sub-menu within hierarchy structure is also supported. Add your sub-menu items in menu section in theme config file as following: next/_config.yml12345678menu: home: / || home archives: /archives/ || archive Docs: default: /docs/ || book Third Party Services: default: /third-party-services/ || plug Algolia Search: /algolia-search/ || adn If your site runs in a sub-directory, please remove the prefix / from the link. By default NexT shows the icons of menu items without badges. iconsbadgesYou can configure it by editing values in menu_settings.icons section in theme config file. next/_config.yml12menu_settings: icons: trueSet the value badges to true to display the count of Posts / Categories / Tags within menu items in menu_settings section in theme config file as following: next/_config.yml12menu_settings: badges: true Configuring FaviconBy default the Hexo site use NexT favicons in hexo-site/themes/next/source/images/ directory with different size for different device. You can replace them with your own favicons. For example, you can put your favicons in hexo-site/source/images/ directory. Then you need to rename them and change the settings in favicon section in theme config file, otherwise icons from Next will rewrite your custom icons in Hexo. You can also put custom favicons into hexo-site/source/ directory. In this way, you must remove /images prefix from paths. To generate custom favicons, you can visit Favicon Generator. hexo/_config.yml1234567favicon: small: /images/favicon-16x16-next.png medium: /images/favicon-32x32-next.png apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg android_manifest: /images/manifest.json ms_browserconfig: /images/browserconfig.xml Configuring AvatarBy default NexT doesn&#39;t show avatar in sidebar. You can configure it by editing values under avatar setting in theme config file. urlroundedrotatedopacityFor first test you can uncomment /images/avatar.gif value near the avatar.url setting to see default avatar: next/_config.yml12avatar: url: /images/avatar.gif Then you need to specify your own avatar. It can be done one of the ways below: Hexo directoryNexT directoryAbsolute URL from InternetPut your avatar under site directory source/uploads/ (create directory if it doesn&#39;t exists).And then change option to avatar: /uploads/avatar.png.Put your avatar under theme directory source/images/.And then change option to avatar: /images/avatar.png. Current site uses avatar under theme directory from file located in next/source/images/apple-touch-icon-next.png with following config:hexo/_config.yml123456theme_config: avatar: url: /images/apple-touch-icon-next.png rounded: true opacity: 1 rotated: false You also can specify any external URL with absolute path to image: http(s)://example.com/avatar.pngSet up rounded of avatar by changing the value of avatar.rounded: true → Avatar will be rounded. false → Avatar will be squared. next/_config.yml12avatar: rounded: trueSet up rotated of avatar by changing the value of avatar.rotated: true → Avatar will be rotate under the mouse hovering. false → Avatar will not rotate under the mouse hovering. next/_config.yml12avatar: rotated: trueThe value of opacity should be choose from 0 to 1 to set the opacity of the avatar: 1 → Avatar will be in default opacity style. 0 → Avatar will be transparent. next/_config.yml12avatar: opacity: 1 Configuring AuthorEdit site config file and set the value of author to your nickname. hexo/_config.yml12# Siteauthor: Configuring DescriptionEdit site config file and set the value of description to your description, which can be a sentence you like. hexo/_config.yml12# Sitedescription: Original_link:https://github.com/theme-next/theme-next.org/blob/source/source/docs/getting-started/index.md]]></content>
      <categories>
        <category>Notes</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Neko Performs Cat Furrier Transform]]></title>
    <url>%2F2019%2F04%2F28%2FCodeForces-1152-B%2F</url>
    <content type="text"><![CDATA[Someone asked me how good you are. I said how big the universe is, how good you are. CodeForces-1152-B Neko Performs Cat Furrier TransformTopic link:Neko Performs Cat Furrier TransformDescription:Cat Furrier Transform is a popular algorithm among cat programmers to create longcats. As one of the greatest cat programmers ever exist, Neko wants to utilize this algorithm to create the perfect longcat. Assume that we have a cat with a number x. A perfect longcat is a cat with a number equal 2m−1 for some non-negative integer m. For example, the numbers 0, 1, 3, 7, 15 and so on are suitable for the perfect longcats. In the Cat Furrier Transform, the following operations can be performed on x: (Operation A): you select any non-negative integer n and replace x with x⊕(2n−1), with ⊕ being a bitwise XOR operator.(Operation B): replace x with x+1.The first applied operation must be of type A, the second of type B, the third of type A again, and so on. Formally, if we number operations from one in the order they are executed, then odd-numbered operations must be of type A and the even-numbered operations must be of type B. Neko wants to produce perfect longcats at industrial scale, thus for each cat Neko only wants to perform at most 40 operations. Can you help Neko writing a transformation plan? Note that it is not required to minimize the number of operations. You just need to use no more than 40 operations. InputThe only line contains a single integer x (1≤x≤106). OutputThe first line should contain a single integer t (0≤t≤40) — the number of operations to apply. Then for each odd-numbered operation print the corresponding number ni in it. That is, print ⌈t2⌉ integers ni (0≤ni≤30), denoting the replacement x with x⊕(2ni−1) in the corresponding step. If there are multiple possible answers, you can print any of them. It is possible to show, that there is at least one answer in the constraints of this problem. Examplesinput39output45 3input1output0input7output0NoteIn the first test, one of the transforms might be as follows: 39→56→57→62→63. Or more precisely: Pick n=5. x is transformed into 39⊕31, or 56.Increase x by 1, changing its value to 57.Pick n=3. x is transformed into 57⊕7, or 62.Increase x by 1, changing its value to 63=26−1.In the second and third test, the number already satisfies the goal requirement. There are some differences between the description on my blog and the real,so I put a real piture here. Intentional analysis:The most important solution to this problem is to simulate.To solve this problem,you better use binary processing.If a number is equal to pow(2,n)-1,then its binary is 1 for each bit.So we only need to process the binary bits of the number to be processed.First, find the highest bit with a binary bit of 0.Then,Each of the next inversions.If the conditions are not met, add 1.This loops until the value that satisfies the condition appears. Click to see Chinese Intentional analysis这道题最重要的思想就是模拟，因为一个数如果是2的n次方减1，那么它的二进制位每一位都是1。因此这道题就可以对输入的数以二进制位的形式进行操作。首先找到最高位的0，然后对这一位以下的所有的二进制位与1进行异或，异或完判断是否满足条件，如果不满足就加一在进行判断，还不行的话就开始下一次循环，直到找到满足条件的数跳出循环即可。思想应该是很容易懂的，难得地方就是实现。一开始我想用bitset来做，但是没成功，还是老老实实的用数组做吧。Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; vector&lt;int&gt; v; int B[30],n,ans=0,t,now=0; cin&gt;&gt;n; t=n; while(t) &#123; B[now++]=t%2; t/=2; &#125; int i=now-1; for(;i&gt;=0;i--) &#123; if(B[i]==0) &#123; v.push_back(i+1); bool flag=0; for(int j=i;j&gt;=0;j--) &#123; B[j]^=1; if(B[j]==0&amp;&amp;j!=0) flag=1; &#125; ans++; if(flag==0) &#123; if(B[0]==0) &#123; B[0]++; ans++; &#125; i=-1; break; &#125; B[0]++; ans++; for(int k=0;k&lt;i;k++) &#123; if(B[k]&gt;1) &#123; B[k]=0; B[k+1]++; &#125; else break; &#125; &#125; if(i==-1) break; &#125; cout&lt;&lt;ans&lt;&lt;endl; for(int j=0;j&lt;v.size();j++) &#123; cout&lt;&lt;v[j]&lt;&lt;&quot; &quot;; if(j==v.size()-1) puts(&quot;&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>CodeForces</tag>
        <tag>Simulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Long Number]]></title>
    <url>%2F2019%2F04%2F27%2FCodeForces-1157-B%2F</url>
    <content type="text"><![CDATA[Oh,CF&#39;s charm is too strong,especially div3. CodeForces-1157-B Long NumberTopic link:Long NumberDescription:You are given a long decimal number a consisting of n digits from 1 to 9. You also have a function f that maps every digit from 1 to 9 to some (possibly the same) digit from 1 to 9. You can perform the following operation no more than once: choose a non-empty contiguous subsegment of digits in a, and replace each digit x from this segment with f(x). For example, if a=1337, f(1)=1, f(3)=5, f(7)=3, and you choose the segment consisting of three rightmost digits, you get 1553 as the result. What is the maximum possible number you can obtain applying this operation no more than once? InputThe first line contains one integer n (1≤n≤2e5) — the number of digits in a. The second line contains a string of n characters, denoting the number a. Each character is a decimal digit from 1 to 9. The third line contains exactly 9 integers f(1), f(2), ..., f(9) (1≤f(i)≤9). OutputPrint the maximum number you can get after applying the operation described in the statement no more than once. Examplesinput413371 2 5 4 6 6 3 1 9output1557input5111119 8 7 6 5 4 3 2 1output99999input2331 1 1 1 1 1 1 1 1output33Intentional analysis:Through reading this questions,we can see that this question is a greedy type of problem.Each number will correspond to another number,and if the corresponding number is greater than this number,we need to use it instead of this number,and as long as such a number appears continuously,we can always change it,but we can only change it once,and To find the maximum number after the change,you only need to find a series of consecutive changeable changes from the front and then output. Click to see Chinese Intentional analysis这道题就是每一个数都对应着一个数，题目要求更换之后取得最大值，可是只能更换一次，每次更换可以更换任一个数但是必须是连续的。这时就体现出贪心的思想了，要想这个数变得更大，在这个数的越高的位置数就得越大，所以只需要从前往后看，只要发现对应的数比本身大就开始更换直到对应的数小于本身，就停止更换。 Code:123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n;string s;char x; cin&gt;&gt;n&gt;&gt;s; map&lt;int,char&gt; ma; for(int i=1;i&lt;=9;i++) &#123; cin&gt;&gt;x; ma[i]=x; &#125; int flag; char mid; for(int i=0;i&lt;s.size();i++) &#123; if(s[i]&lt;ma[s[i]-&apos;0&apos;]) &#123; flag=i; break; &#125; &#125; for(int i=0;i&lt;flag;i++) &#123; cout&lt;&lt;s[i]; &#125; bool flag2=1; for(int i=flag;i&lt;s.size();i++) &#123; if(s[i]&gt;ma[s[i]-&apos;0&apos;]) flag2=0; if(flag2) cout&lt;&lt;ma[s[i]-&apos;0&apos;]; else cout&lt;&lt;s[i]; &#125; cout&lt;&lt;endl; return 0;&#125; I didn&#39;t understand the meaning of this question at first, which led to WA several times and wasted my time. Now the result of hack has not come out yet, if my code was hacked.I will find the bug and correct it as soon as possible!(2019.4.27 1:03) Accepted(2019.4.27 22:52)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>c/c++</tag>
        <tag>CodeForces</tag>
        <tag>STL</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL-bitset]]></title>
    <url>%2F2019%2F04%2F25%2Fbitset%2F</url>
    <content type="text"><![CDATA[These STL in c++ are so useful that you can sovle some problems easily through use them.I have known map,vector,queue,stack,set.And there is a STL named bitset. Introduction to bitset-personalI can&#39;t find a accurate explanation online.So there is my understanding of it.Bitset is a STL which is easy to treat a number as a binary. InstructionsIt is included by include&lt;bitset&gt;If you want to define a bitset,the code is as follows1bitset&lt;num&gt; n;//num must be defined as an integer literal constant or an integer type const object initialized with a constant value. If so initialized, each bit is 0.Of course you can also define it like this12int a;bitset&lt;num&gt; n(a); now,the bitset n is the binary form of a.And you even can use this like a array.Such as123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;bitset&gt;using namespace std;int main()&#123; int a; cin&gt;&gt;a; bitset&lt;4&gt; b(a); cout&lt;&lt;b&lt;&lt;endl; cout&lt;&lt;b[0]&lt;&lt;endl&lt;&lt;b[1]&lt;&lt;endl&lt;&lt;b[2]&lt;&lt;endl&lt;&lt;b[3]&lt;&lt;endl; return 0;&#125;Input:13 -5Ouput:1101101110111101 As can be seen from these examples, when the bit position in the bitset is operated, it is reversed.Such as:1234567int n = 16;bitset&lt;64&gt; b(n);b[0]=0b[1]=0b[2]=0b[3]=0b[4]=1 From the above example we can see that the negative number will directly become the complement form under the action of bitset.This has advantages and disadvantages.This has advantages and disadvantages, because some places just let you represent the binary form, no need to complement.If you meet a situtation like this,just take a judge,all numbers are processed as positive numbers, if they are negative, then add a negative sign.I&#39;d like to paste a example here. ExampleSource: 简单的二进制Description：计算机只能识别0和1,使用的是二进制，而在日常生活中人们使用的是十进制，”正如亚里士多德早就指出的那样，今天十进制的广泛采用，只不过是我们绝大多数人生来具有10个手指头这个解剖学事实的结果。 在计算机领域中，补码是一个重要的概念，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理。此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。 学习了计算机导论后，相信大家都明白了原码、反码和补码的区别，并能快速地将一个十进制整数的补码写出。今天我们将问题进行简化：给出一个十进制的整数N，请写出N在64位二进制补码表示下，一共有多少个1。 Input多组输入，每一行有一个整数N（保证N在int64范围内） Output输出N在二进制补码下1的个数，每组输出占一行 Examplesinput1015output24Note正整数的补码是其二进制表示，与原码相同 求负整数的补码，将其原码除符号位外的所有位取反后加一 Problem solving：We can see this problem need the complement when the number is negative.So the bitset is so comfortable for this. Code:123456789101112#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; long long n; while(scanf(&quot;%lld&quot;,&amp;n)!=EOF) &#123; bitset&lt;64&gt; b(n); cout&lt;&lt;b.count()&lt;&lt;endl; &#125; return 0;&#125; If you write this, the code will be very simple.The specific function functions will be discussed below. Many functionsAlmost all STL have lots of functions,bitset is no exception.I don&#39;t have the ability, and I don&#39;t have the energy to list them all, so I will list what I like and what I find useful. OverviewDefine a bitset first:bitset b; function Features b.any() Is there a binary bit with a value of 1 in b? b.none() Is there no binary bit with a value of 1 in b? b.count() The number of bits in b with a value of 1 b[pos] Access the binary bit at pos in b b.test(pos) Whether the binary bit in pos is 1 in b？ b.set() Set all binary bits in b to 1 b.set(pos) Put the binary position in b at pos as 1 b.reset() Set all binary bits in b to 0 b.reset(pos) Put the binary position in b at pos to 0 b.flip() All binary bits in b are inverted bit by bit b.flip(pos) Invert the binary bit at b in pos b.to_string() Convert the contents of the bitset to string b.to_ulong() Convert the contents of the bitset to unsigned long Next I will help you understand the usage of these functions with some examples. b.any() and b.none() and b.count()b.any(): Is there a binary bit with a value of 1 in b?123456789101112#include&lt;iostream&gt;#include&lt;bitset&gt;using namespace std;int main()&#123; int n=5,m=0;// n = 0101, m = 0 bitset&lt;8&gt; b1(n); bitset&lt;8&gt; b2(m); cout&lt;&lt;b1.none()&lt;&lt;&quot; &quot;&lt;&lt;b2.none();&#125;Operation result:1 0 So you can see that the return value of b.any() is the bool type. b.none()：Is there no binary bit with a value of 1 in b?123456789101112#include&lt;iostream&gt;#include&lt;bitset&gt;using namespace std;int main()&#123; int n=5,m=0;// n = 0101, m = 0 bitset&lt;8&gt; b1(n); bitset&lt;8&gt; b2(m); cout&lt;&lt;endl&lt;&lt;b1.none()&lt;&lt;&quot; &quot;&lt;&lt;b2.none();&#125;Operation result:0 1 So you can see that the return value of b.none() also is the bool type. b.count(): The number of bits in b with a value of 1123456789101112#include&lt;iostream&gt;#include&lt;bitset&gt;using namespace std;int main()&#123; int n=15,m=16;// n = 1111, m = 10000 bitset&lt;8&gt; b1(n); bitset&lt;8&gt; b2(m); cout&lt;&lt;b1.count()&lt;&lt;&quot; &quot;&lt;&lt;b2.count();&#125;Operation result:4 1 So the function of b.count() is to return the number of 1 in the binary.Just like the example above b[pos]b[pos]: Access the binary bit at pos in bI started the function&#39;s introduction at the beginning of this blog, you can look up. b.test(pos)b.test(pos): Whether the binary bit in pos is 1 in b？123456789101112#include&lt;iostream&gt;#include&lt;bitset&gt;using namespace std;int main()&#123; int n=15,m=16;// n = 1111, m = 10000 bitset&lt;8&gt; b1(n); bitset&lt;8&gt; b2(m); cout&lt;&lt;b1.test(1)&lt;&lt;&quot; &quot;&lt;&lt;b2.test(4)&lt;&lt;&quot; &quot;&lt;&lt;b2.test(1);&#125;Operation result:1 1 0 So you can see that the return value of b.test(pos) is the bool type,too. b.set() and b.set(pos)b.set(): Set all binary bits in b to 11234567891011121314#include&lt;iostream&gt;#include&lt;bitset&gt;using namespace std;int main()&#123; int n = 16; bitset&lt;8&gt; b(n); cout&lt;&lt;b&lt;&lt;endl; b.set(); cout&lt;&lt;b;&#125;Operation result:0001000011111111 b.set(pos): Put the binary position in b at pos as 11234567891011121314#include&lt;iostream&gt;#include&lt;bitset&gt;using namespace std;int main()&#123; int n = 16; bitset&lt;8&gt; b(n); cout&lt;&lt;b&lt;&lt;endl; b.set(0); cout&lt;&lt;b;&#125;Operation result:0001000000010001 b.reset() and b.reset(pos)b.reset(): Set all binary bits in b to 0b.reset(pos): Put the binary position in b at pos to 0These two functions are very similar to the two above, so I won’t go into details. b.flip() and b.flip(pos)b.flip(): All binary bits in b are inverted bit by bit1234567891011121314#include&lt;iostream&gt;#include&lt;bitset&gt;using namespace std;int main()&#123; int n = 16; bitset&lt;8&gt; b(n); cout&lt;&lt;b&lt;&lt;endl; b.flip(); cout&lt;&lt;b;&#125;Operation result:0001000011101111 b.flip(pos): Invert the binary bit at b in posBasically the same as above, no longer repeat b.to_string()b.to_string(): Convert the contents of the bitset to string12345678910111213#include&lt;iostream&gt;#include&lt;bitset&gt;using namespace std;int main()&#123; int n = 16; bitset&lt;8&gt; b(n); string s; s=b.to_string(); cout&lt;&lt;s&lt;&lt;endl;&#125;Operation result:00010000 b.to_ulong()12345678910111213141516#include&lt;iostream&gt;#include&lt;bitset&gt;using namespace std;int main()&#123; int n = 16; bitset&lt;5&gt; b(n); b.flip(); long a; cout&lt;&lt;b&lt;&lt;endl; a=b.to_ulong(); cout&lt;&lt;a&lt;&lt;endl;&#125;Operation result:0111115]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[White-book-example]]></title>
    <url>%2F2019%2F04%2F25%2FWhite-book-example%2F</url>
    <content type="text"><![CDATA[I&#39;m studing DFS these days,it&#39;s hard to understand.For this,i&#39;d like to paste a easy question here to understand it more. 部分和问题给定一组数，判断是否可以从中取出若干数，是他们的和恰好为一个数。Example:input4 132 3 4 7ouputYes 每个数都会有两个状态，加上或者不加上，这组样例中有四个数，每个数两个状态，也就是说最后的加起来的结果会有2的4次方(16)种。 Codes1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;int n,k,a[10000];bool dfs(int i,int sum)&#123; if(i==n) &#123;// puts(&quot;mmp&quot;); return sum==k; &#125; if(dfs(i+1,sum)) &#123;// puts(&quot;a&quot;); return 1; &#125; if(dfs(i+1,sum+a[i])) &#123; // puts(&quot;b&quot;); return 1; &#125; &#125;int main()&#123; cin&gt;&gt;n&gt;&gt;k; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; &#125; if(dfs(0,0)) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); return 0;&#125; 只看代码会很难理解，一重一重的递归，但这还只是最简单的一种。为了更好的让自己理解，我将这个样例的所有情况都列了出来。12345678910111213141516171819202122232425262728293031DFS(0,0) DFS(1,0) DFS(2,0) DFS(3,0) DFS(4,0) return 0 DFS(4,7) return 0 DFS(3,4) DFS(4,4) return 0 DFS(4,11) return 0 DFS(2,3) DFS(3,3) DFS(4,3) return 0 DFS(4,10) return 0 DFS(3,7) DFS(4,7) return 0 DFS(4,14) return 0 DFS(1,2) DFS(2,2) DFS(3,2) DFS(4,2) return 0 DFS(4,9) return 0 DFS(3,6) DFS(4,6) return 0 DFS(4,13) return 0 DFS(2,5) DFS(3,5) DFS(4,5) return 0 DFS(4,12) return 0 DFS(3,9) DFS(4,9) return 0 DFS(4,16) return 0 我又将这16种情况，用图的方式表示了出来12345 0 2 0 5 2 3 0 9 5 6 2 7 3 4 016 9 12 5 13 6 9 2 14 7 10 3 11 4 7 0 这时我发现程序跟画出来的是一模一样的。 可是还是不很理解，于是我运行起来程序，并且在每次递归中加入了可以看到的元素，输出a，b或者mmp啊什么的。一起来看看效果input:4 132 3 4 7mmp个数数出来是12个，a,b出现的顺序是b，b，a，b input:4 02 3 4 7mmp个数数出来是1个，a,b出现的顺序是a，a，a，a mmp代表的个数就是出现sum==k的时候前面进行的递归的次数，a代表的是第i位的数状态是不加，b代表的是第i位的数状态是加 也就这样了，DFS慢慢来，这样跑程序我觉得会加深理解啊哈🎈。]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复读机]]></title>
    <url>%2F2019%2F04%2F22%2Fnowcoder-NH-B%2F</url>
    <content type="text"><![CDATA[The game I played in the NOWCODER.COM a few days ago, the first time I met the “union-find” problem, it was solved with the help of the seniors. I have digested it in the past few days, or I wrote it on the blog first. 南华大学第十五届ACM程序设计竞赛(重现赛） B 复读机题目链接：复读机题目描述： 在某华大学里有一个无聊的群组，群内的所有成员都是复读机，他们疯狂复读着别人的消息。然而复读机们在群内也是有阵营的，一个阵营的复读机会根据心情选择是否复读同一个阵营的成员的消息，但绝对不会去复读其他阵营的消息。 群内有n个人（标号1-n号）。现在群内聊天记录中一共有m条消息。请根据这些消息，判断出如果群内第i号成员（1&lt;=i&lt;=n）发一条十分有趣的消息，在同一阵营的成员都会去复读这条消息情况下，那么这条消息会被复读几次？ 如果无法判断i号成员和j号成员是否为同一阵营，则视为不同阵营。 输入描述:输入包括m+1行。第一行包括两个整数n,m；其后的m行为当前的聊天记录，每行包括一个数字i和一个字符串s（表示i发了一条消息）。（保证1&lt;=i&lt;=n，m&lt;=100000，消息的字符串总长不超过100000）输出描述:输出一行，包括n个数字。第i个数字表示第i号成员的有趣消息会被复读几次（1&lt;=i&lt;=n）。数字与数字之间用一个空格分隔。示例1输入复制3 51 a2 a1 b2 c3 c输出复制2 2 2说明对于样例1： 由聊天记录的前两行可以得出2号和1号为同一阵营，由最后两行可得3号和2号为同一阵营，所以三者为同一阵营，他们三个发送的消息会被复读2次，故输出为2 2 2；示例2输入复制3 31 a2 b3 c输出复制0 0 0说明对于样例2：1，2，3号无法判断是否为同一阵营，视为不同阵营。备注:对于复读的概念： 若聊天记录为 1 a 2 a 3 a 属于2，3号复读了1号的消息。 若聊天记录为 1 a 2 b 3 a 不构成任何复读，1的‘a‘和3的‘a’均属于自己原创消息。 题意分析：具体并查集的思想我也解释不清，可以参考这篇博客：https://boctorio.com/2019/03/02/%E5%B9%B6%E6%9F%A5%E9%9B%86/这道题就是当你检测到相邻的两次输入的字符串是相等的就需要把这两个字符串的所对应的前面的数字看成是一组的。最后输出的时候，就输出和它同组的数目减一就行了（因为要除去它自己）。解题思路还是很简单的，实现起来的话用并查集就行了。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;using namespace std;const int maxn=100010;struct name&#123; int num; string sym;&#125;a[maxn];int pre[maxn];int sum[maxn];void init(int n)&#123; for(int i=1;i&lt;=n;i++) pre[i]=i;&#125;int find(int x)&#123; return pre[x]!=x?pre[x]=find(pre[x]):x;&#125;void Union(int x,int y)&#123; x=find(x); y=find(y); if(x&lt;y) pre[y]=x; else pre[x]=y;&#125;int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; init(n); cin&gt;&gt;a[0].num&gt;&gt;a[0].sym; for(int i=1;i&lt;m;i++) &#123; cin&gt;&gt;a[i].num&gt;&gt;a[i].sym; if(a[i].sym==a[i-1].sym) Union(a[i].num,a[i-1].num); &#125; for(int i=1;i&lt;=n;i++) &#123; find(i); sum[pre[i]]++; &#125; for(int i=1;i&lt;=n;i++) &#123; if(i!=1) cout&lt;&lt;&quot; &quot;; cout&lt;&lt;sum[pre[i]]-1; &#125; cout&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>nowcoder</tag>
        <tag>union-find</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A big change]]></title>
    <url>%2F2019%2F04%2F21%2FChange%2F</url>
    <content type="text"><![CDATA[Summer is comming,come here and enjoy the cool snow.To study English,and make my blog become large and luxurious,i have changed the main language of my blog from Chinese to English.Hope my English and programming&#39;s ablity can upgrade together. some changesI will correct the tags and categories tomorrow,though it will be too troublesome. I have already changed tags and categories. 2019.4.22 6:34 What next?“About” page! Carry out! in 2019.4.22. 7:29 The comment system Valine is Chinese now,i can&#39;t solve this,but i will finish this in the future. Carry out in 2019.4.22 10:20 How to put a post to the top?At first,i installed the plugin to achieve this,and something wrong happened.The top flag is there, but there is no function to achieve the top.So isearched this online.Finally,i still don&#39;t known why,but i solve this problem through other method. Implemented by modifying the filefile path:1Ur blog name/node_modules/hexo-generator-index/lib/generator.js Add the following codes in the file12345678910111213posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // Both articles have definitions on top if(a.top == b.top) return b.date - a.date; // If the top value is the same, it will be sorted according to the article date. else return b.top - a.top; // Otherwise,it willed be sorted according the value of top. &#125; else if(a.top &amp;&amp; !b.top) &#123; // The following is only one article top definition, then there will be top in front（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // Did not define the descending order according to the article date&#125;); At first,I didn&#39;t know much about js and didn&#39;t know where to insert it, so I failed several times.So if you are experiencing the same situation as me,you can directly copy these following codes and paste in your file.Note: just cover it all.12345678910111213141516171819202122232425262728&apos;use strict&apos;;var pagination = require(&apos;hexo-pagination&apos;);module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; if(a.top == b.top) return b.date - a.date; else return b.top - a.top; &#125; else if(a.top &amp;&amp; !b.top) &#123; return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; &#125;); var paginationDir = config.pagination_dir || &apos;page&apos;; return pagination(&apos;&apos;, posts, &#123; perPage: config.index_generator.per_page, layout: [&apos;index&apos;, &apos;archive&apos;], format: paginationDir + &apos;/%d/&apos;, data: &#123; __index: true &#125; &#125;);&#125;; How to display the flag of the topThis is easy.You still need to modify some files to achieve this features.file path:1Ur blog name/themes/next/layout/_macro/post.swig First,find the place of&lt;div class=&quot;post-meta&quot;&gt;.Second,insert these following codes12345&#123;% if post.top %&#125; &lt;i class=&quot;fa fa-thumb-tack&quot;&gt;&lt;/i&gt;//You can choose and replace the icon you want in http://www.fontawesome.com.cn/. &lt;font color=green&gt;Topping&lt;/font&gt;//You can change the color and specific content of the top logo in this. &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&#123;% endif %&#125; Of course,if you are not sure where to insert it,just compare with the code below.12345678910&lt;div class=&quot;post-meta&quot;&gt; &lt;span class=&quot;post-time&quot;&gt; &#123;% if post.top %&#125; &lt;i class=&quot;fa fa-thumb-tack&quot;&gt;&lt;/i&gt; &lt;font color=7D26CD&gt;Topping&lt;/font&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt; &#123;% endif %&#125; &#123;% set date_diff = date(post.date) != date(post.updated) %&#125; &#123;% set time_diff = time(post.date) != time(post.updated) %&#125; &#123;% set datetime_diff = date_diff or time_diff %&#125; RenderingReference article: https://blog.csdn.net/weixin_42556146/article/details/80836875 The introduction about the top is here. A really big changeGreat change, like changing the blog&#39;s bloodReference article: https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html Add article image summary The reason of why use this First of all, the abstract of the article refers to the part of the content that each article displays on the page, which is the content of the previous article. Since it will be displayed on the page, adding an image to the article summary for each article will make the page look beautiful. RenderingFirst,Edit this file1Urblog name/themes/next/_config.yml Change into1234excerpt_description: falseauto_excerpt: enable: false Second,add these fowlling codes into this file1Urblog Urblog name/themes/next/layout/_macro/post.swig codes12345&#123;% if post.image %&#125;&lt;div class=&quot;out-img-topic&quot;&gt; &lt;img src=&#123;&#123; post.image &#125;&#125; class=&quot;img-topic&quot; /&gt;&lt;/div&gt;&#123;% endif %&#125; If you change it correctly, this file will look like this.1234567891011121314151617181920212223242526 &#123;% if is_index %&#125; &#123;% if post.description and theme.excerpt_description %&#125; &#123;&#123; post.description &#125;&#125; &lt;!--noindex--&gt; &lt;div class=&quot;post-button text-center&quot;&gt; &lt;a class=&quot;btn&quot; href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot;&gt; &#123;&#123; __(&apos;post.read_more&apos;) &#125;&#125; &amp;raquo; &lt;/a&gt; &lt;/div&gt; &lt;!--/noindex--&gt; &#123;% elif post.excerpt %&#125; &#123;&#123; post.excerpt &#125;&#125;+ + &#123;% if post.image %&#125;+ &lt;div class=&quot;out-img-topic&quot;&gt;+ &lt;img src=&#123;&#123; post.image &#125;&#125; class=&quot;img-topic&quot; /&gt;+ &lt;/div&gt;+ &#123;% endif %&#125;+ &lt;!--noindex--&gt; &lt;div class=&quot;post-button text-center&quot;&gt; &lt;a class=&quot;btn&quot; href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&#123;% if theme.scroll_to_more %&#125;#&#123;&#123; __(&apos;post.more&apos;) &#125;&#125;&#123;% endif %&#125;&quot; rel=&quot;contents&quot;&gt; &#123;&#123; __(&apos;post.read_more&apos;) &#125;&#125; &amp;raquo; &lt;/a&gt; &lt;/div&gt; &lt;!--/noindex--&gt; Third,add these following codes into this file1Urblog name/themes/next/source/css/_custom/custom.styl codes12345678910111213141516//图片外部的容器方框.out-img-topic &#123; display: block; max-height:300px; margin-bottom: 24px; overflow: hidden;&#125;//图片img.img-topic &#123; display: block ; margin-left: .7em; margin-right: .7em; padding: 0; float: right; clear: right;&#125; Now,you have already finish this.Noteadd this image: url/the picture&#39;s path. The introduction about the image summary is here. A Little Summary Today is my birthday.And I successfully set my blog very beautiful.Everything is fine! 2019.4.23 Local searchSome unknown bug was happened on the local search,so I have to remove this. 2019.4.24 22:35 Local search is fine now. 2019.6.13 10:50 Replaced the new domain nameToday, I changed the domain name for my blog. Although it cost a lot of money, it seems that it is really high.But what&#39;s a little bad is that my visitor volume and pageviews are zero, and it&#39;s very uncomfortable. 2019.4.25 23:55 About the optimization of domestic access speedI put a copy of my blog on gitee again. Domestic visitors should see that this access speed should satisfy you.New home&#39;s name. 2019.4.25 20:32 Add Chinese Intentional analysisBecause the visitors to my blog are still domestic, some of the meanings written in English may not be clear, so I added a Chinese meaning analysis to some blogs. The specific operation is as follows.In fact, it is a syntax of markdown.1234&lt;details&gt;&lt;summary&gt;Description&lt;/summary&gt;//Hidden&lt;/details&gt; Rendering: A so cool syntax of markdown.1234567891011&#123;% tabs common-variables %&#125;&lt;!-- tab namea --&gt;txta&lt;!-- endtab --&gt;&lt;!-- tab nameb --&gt;txtb&lt;!-- endtab --&gt;&lt;!-- tab namec --&gt;txtc&lt;!-- endtab --&gt;&#123;% endtabs %&#125; Rendering: nameanamebnamectxtatxtbtxtc Summer is comming,come here and enjoy the cool snow.Reference article: https://blog.csdn.net/stormdony/article/details/86001618 Add a file name is snow.js into \themes\next\source\js\src Edit the contents of snow.js as Choose one:123456789101112131415161718192021222324252627282930313233343536373839404142/*样式一*/(function($)&#123; $.fn.snow = function(options)&#123; var $flake = $(&apos;&lt;div id=&quot;snowbox&quot; /&gt;&apos;).css(&#123;&apos;position&apos;: &apos;absolute&apos;,&apos;z-index&apos;:&apos;9999&apos;, &apos;top&apos;: &apos;-50px&apos;&#125;).html(&apos;&amp;#10052;&apos;), documentHeight = $(document).height(), documentWidth = $(document).width(), defaults = &#123; minSize : 10, maxSize : 20, newOn : 1000, flakeColor : &quot;#AFDAEF&quot; /* 此处可以定义雪花颜色，若要白色可以改为#FFFFFF */ &#125;, options = $.extend(&#123;&#125;, defaults, options); var interval= setInterval( function()&#123; var startPositionLeft = Math.random() * documentWidth - 100, startOpacity = 0.5 + Math.random(), sizeFlake = options.minSize + Math.random() * options.maxSize, endPositionTop = documentHeight - 200, endPositionLeft = startPositionLeft - 500 + Math.random() * 500, durationFall = documentHeight * 10 + Math.random() * 5000; $flake.clone().appendTo(&apos;body&apos;).css(&#123; left: startPositionLeft, opacity: startOpacity, &apos;font-size&apos;: sizeFlake, color: options.flakeColor &#125;).animate(&#123; top: endPositionTop, left: endPositionLeft, opacity: 0.2 &#125;,durationFall,&apos;linear&apos;,function()&#123; $(this).remove() &#125;); &#125;, options.newOn); &#125;;&#125;)(jQuery);$(function()&#123; $.fn.snow(&#123; minSize: 5, /* 定义雪花最小尺寸 */ maxSize: 50,/* 定义雪花最大尺寸 */ newOn: 300 /* 定义密集程度，数字越小越密集 */ &#125;);&#125;); Choose two:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/*样式二*//* 控制下雪 */function snowFall(snow) &#123; /* 可配置属性 */ snow = snow || &#123;&#125;; this.maxFlake = snow.maxFlake || 200; /* 最多片数 */ this.flakeSize = snow.flakeSize || 10; /* 雪花形状 */ this.fallSpeed = snow.fallSpeed || 1; /* 坠落速度 */&#125;/* 兼容写法 */requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || function(callback) &#123; setTimeout(callback, 1000 / 60); &#125;;cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame || window.oCancelAnimationFrame;/* 开始下雪 */snowFall.prototype.start = function()&#123; /* 创建画布 */ snowCanvas.apply(this); /* 创建雪花形状 */ createFlakes.apply(this); /* 画雪 */ drawSnow.apply(this)&#125;/* 创建画布 */function snowCanvas() &#123; /* 添加Dom结点 */ var snowcanvas = document.createElement(&quot;canvas&quot;); snowcanvas.id = &quot;snowfall&quot;; snowcanvas.width = window.innerWidth; snowcanvas.height = document.body.clientHeight; snowcanvas.setAttribute(&quot;style&quot;, &quot;position:absolute; top: 0; left: 0; z-index: 1; pointer-events: none;&quot;); document.getElementsByTagName(&quot;body&quot;)[0].appendChild(snowcanvas); this.canvas = snowcanvas; this.ctx = snowcanvas.getContext(&quot;2d&quot;); /* 窗口大小改变的处理 */ window.onresize = function() &#123; snowcanvas.width = window.innerWidth; /* snowcanvas.height = window.innerHeight */ &#125;&#125;/* 雪运动对象 */function flakeMove(canvasWidth, canvasHeight, flakeSize, fallSpeed) &#123; this.x = Math.floor(Math.random() * canvasWidth); /* x坐标 */ this.y = Math.floor(Math.random() * canvasHeight); /* y坐标 */ this.size = Math.random() * flakeSize + 2; /* 形状 */ this.maxSize = flakeSize; /* 最大形状 */ this.speed = Math.random() * 1 + fallSpeed; /* 坠落速度 */ this.fallSpeed = fallSpeed; /* 坠落速度 */ this.velY = this.speed; /* Y方向速度 */ this.velX = 0; /* X方向速度 */ this.stepSize = Math.random() / 30; /* 步长 */ this.step = 0 /* 步数 */&#125;flakeMove.prototype.update = function() &#123; var x = this.x, y = this.y; /* 左右摆动(余弦) */ this.velX *= 0.98; if (this.velY &lt;= this.speed) &#123; this.velY = this.speed &#125; this.velX += Math.cos(this.step += .05) * this.stepSize; this.y += this.velY; this.x += this.velX; /* 飞出边界的处理 */ if (this.x &gt;= canvas.width || this.x &lt;= 0 || this.y &gt;= canvas.height || this.y &lt;= 0) &#123; this.reset(canvas.width, canvas.height) &#125;&#125;;/* 飞出边界-放置最顶端继续坠落 */flakeMove.prototype.reset = function(width, height) &#123; this.x = Math.floor(Math.random() * width); this.y = 0; this.size = Math.random() * this.maxSize + 2; this.speed = Math.random() * 1 + this.fallSpeed; this.velY = this.speed; this.velX = 0;&#125;;// 渲染雪花-随机形状（此处可修改雪花颜色！！！）flakeMove.prototype.render = function(ctx) &#123; var snowFlake = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size); snowFlake.addColorStop(0, &quot;rgba(255, 255, 255, 0.9)&quot;); /* 此处是雪花颜色，默认是白色 */ snowFlake.addColorStop(.5, &quot;rgba(255, 255, 255, 0.5)&quot;); /* 若要改为其他颜色，请自行查 */ snowFlake.addColorStop(1, &quot;rgba(255, 255, 255, 0)&quot;); /* 找16进制的RGB 颜色代码。 */ ctx.save(); ctx.fillStyle = snowFlake; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); ctx.restore();&#125;;/* 创建雪花-定义形状 */function createFlakes() &#123; var maxFlake = this.maxFlake, flakes = this.flakes = [], canvas = this.canvas; for (var i = 0; i &lt; maxFlake; i++) &#123; flakes.push(new flakeMove(canvas.width, canvas.height, this.flakeSize, this.fallSpeed)) &#125;&#125;/* 画雪 */function drawSnow() &#123; var maxFlake = this.maxFlake, flakes = this.flakes; ctx = this.ctx, canvas = this.canvas, that = this; /* 清空雪花 */ ctx.clearRect(0, 0, canvas.width, canvas.height); for (var e = 0; e &lt; maxFlake; e++) &#123; flakes[e].update(); flakes[e].render(ctx); &#125; /* 一帧一帧的画 */ this.loop = requestAnimationFrame(function() &#123; drawSnow.apply(that); &#125;);&#125;/* 调用及控制方法 */var snow = new snowFall(&#123;maxFlake:60&#125;);snow.start(); Then add these follwing contents in \themes\next\layout\_layout.swig12&lt;!-- 雪花特效 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/snow.js&quot;&gt;&lt;/script&gt; To avoid the effects of mobile access, you can add the following instead of the one above.1234567&lt;!-- 雪花特效 --&gt;&lt;script type=&quot;text/javascript&quot;&gt; var windowWidth = $(window).width(); if (windowWidth &gt; 480) &#123; document.write(&apos;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/snow.js&quot;&gt;&lt;\/script&gt;&apos;); &#125;&lt;/script&gt; Rendering: Choose one: Choose two: Snowflakes only appear on the computer side is not the effect I want.But I still do not want to affect the reading of the mobile terminal.So I try to add a else on the basic of the contents above.Just like:123456789&lt;!-- 雪花特效 --&gt;&lt;script type=&quot;text/javascript&quot;&gt; var windowWidth = $(window).width(); if (windowWidth &gt; 480) &#123; document.write(&apos;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/snow.js&quot;&gt;&lt;\/script&gt;&apos;); &#125; else document.write(&apos;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/snow_point.js&quot;&gt;&lt;\/script&gt;&apos;);&lt;/script&gt; And make the Choose two become the file snow_point.js,and then reduce the number of snowflakes.The effect achieved now is enough to satisfy me. CalendarCloudI had add a calendarcloud into my blog successfully.But there is a bug:if some posts are in a same day,you can just come in one of them.How can I solve this problem,absolutly I can&#39;t.But you can click the month number so you can view a html which is full of post title which deploy in this month. The Album PageI have to admit that the access speed of this page is too slow, it has affected the experience of my blog, so I decided to temporarily remove this page, and then re-open this page after I find a perfect method. The Email alert serviceValine-AdminFollow this step by step, I have successfully configured it, are you sure not to comment here? How to solve the problem that the symbol——&#39; is too wideAdd these follwing codes int the config.yml in your hexo root directory.12345678marked: gfm: true pedantic: false sanitize: false tables: true breaks: true smartLists: true smartypants: false Add random quotesPreview: ' //这里分配十句随机出现的文本 quotes[2] = '' quotes[3] = '' quotes[4] = '' quotes[5] = '' quotes[6] = '' quotes[7] = '' quotes[8] = '' quotes[9] = '' quotes[0] = '' var quote = quotes[rand1] //由随机数选择一句话 //--> Main code:1234567891011121314151617181920212223&lt;script language=&quot;JavaScript&quot;&gt; &lt;!-- Hide var a = Math.random() + &quot;&quot; //Generate a random numbervar rand1 = a.charAt(5) //Get the fifth character of this number (actually from 0 to 9) quotes = new Array //Create an array of messagesquotes[1] = &apos;&lt;center&gt;&lt;--你不知道我有多想因为你而有底气说出舔狗舔到最后应有尽有--&gt;&lt;/center&gt;&apos; //Assign ten randomly appearing texts herequotes[2] = &apos;&lt;center&gt;&lt;--人生就像一杯茶，不会苦一辈子，但总会苦一阵子--&gt;&lt;/center&gt;&apos; quotes[3] = &apos;&lt;center&gt;&lt;--浮天水送无穷树，带雨云埋一半山--&gt;&lt;/center&gt;&apos; quotes[4] = &apos;&lt;center&gt;&lt;--有一个夜晚我烧毁了所有的记忆，从此我的梦就透明了；有一个早晨我扔掉了所有的昨天，从此我的脚步就轻盈了--&gt;&lt;/center&gt;&apos; quotes[5] = &apos;&lt;center&gt;&lt;--哭过喊过便会停止哭泣--&gt;&lt;/center&gt;&apos; quotes[6] = &apos;&lt;center&gt;&lt;--人非圣贤，孰能无过？过而能改，善莫大焉--&gt;&lt;/center&gt;&apos; quotes[7] = &apos;&lt;center&gt;&lt;--今日，吾爱，我们融为一体--&gt;&lt;/center&gt;&apos; quotes[8] = &apos;&lt;center&gt;&lt;--人类的智慧就如同孔雀的羽毛。极尽炫耀，只是为了吸引异性--&gt;&lt;/center&gt;&apos; quotes[9] = &apos;&lt;center&gt;&lt;--不管什么时候，能够改变世界的人都是一心追逐梦想的人。--&gt;&lt;/center&gt;&apos; quotes[0] = &apos;&lt;center&gt;&lt;--人类文明从仰望星空那一刻起，就已经距离揭示宇宙奥秘仅有一步之遥了。--&gt;&lt;/center&gt;&apos; var quote = quotes[rand1] //Choose a sentence from a random number//--&gt; &lt;/script&gt; &lt;script language=&quot;JavaScript&quot;&gt; &lt;!-- Hide document.write( quote ) //Write the words selected above into the page// --&gt; &lt;/script&gt; And there has some other way to achieve this effect.You can search it if you are interested in. 一言Code:123&lt;p id=&quot;hitokoto&quot;&gt;:D 获取中...&lt;/p&gt;&lt;script src=&quot;https://v1.hitokoto.cn/?encode=js&amp;select=%23hitokoto&quot; defer&gt;&lt;/script&gt; Add countdownCode:12345678910111213141516171819202122&lt;DIV id=&quot;CountMsg&quot; class=&quot;HotDate&quot;&gt;&lt;span id=&quot;td&quot;&gt;00天&lt;/span&gt;&lt;/DIV&gt;&lt;script type=&quot;text/javascript&quot;&gt;function getRTime()&#123;var EndTime= new Date(&apos;2020/10/23 10:00:00&apos;); //截止时间var NowTime = new Date();var t =EndTime.getTime() - NowTime.getTime();var d=Math.floor(t/1000/60/60/24);var h=Math.floor(t/1000/60/60%24);var m=Math.floor(t/1000/60%60);var s=Math.floor(t/1000%60);document.getElementById(&quot;td&quot;).innerHTML = &quot;距离一切结束还有&quot;+d+ &quot;天&quot;;document.getElementById(&quot;th&quot;).innerHTML = h+&quot;时&quot;;document.getElementById(&quot;tm&quot;).innerHTML = m+&quot;分&quot;;document.getElementById(&quot;ts&quot;).innerHTML = s+&quot;秒&quot;;&#125;setInterval(getRTime,1000);&lt;/script&gt;]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小y的序列]]></title>
    <url>%2F2019%2F04%2F19%2Fnowcoder-practis44-A%2F</url>
    <content type="text"><![CDATA[又是一道不涉及算法，偏重于思维的水题诶。妥妥的签到，虽然我也没有自己成功的做出来。 牛客练习赛44 A 小y的序列题目链接：小y的序列题目描述：小y有一块长度为n的布匹。颜色全部为0。他要给这个布匹染色。他总共有m种染料。小y认为一种染料用多次是不和谐的。所以每种染料会被用刚好一次。也就是说小y要给这块布匹染m次色。第i次会把Li到Ri这个区间染成颜色i。现在给出最终布匹每段的颜色。请你输出一种染色方案。数据保证有解输入描述:输入共两行。第一行两个个正整数n,m，表示布匹的长度和染料的数量第二行n个用空格隔开的正整数，第i个数字ai表示第i个布匹的颜色。输出描述:输出m行。第i行包含两个正整数Li,Ri,表示第i次染色的区间。示例1输入3 31 2 3输出1 32 33 3 备注:1≤n,m≤1e50≤ai≤m1≤Li≤Ri≤n 题意分析:其实这道题就是让你找一个数第一次出现和最后一次出现的地方，然后输出就行。这里我用到了map，但是为什么会WA呢，因为题目中要求的是每种颜色都要用到，但是如果有一种颜色在最后的结果中没有出现并且不做处理的话，输出出来的结果就会有某几种颜色没有使用到，而题目又保证数据有解，所以我们只需要特判一下就行了。代码实现12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;const int maxn=1e5+7;int a[maxn];int main()&#123; map&lt;int,int&gt; ma; map&lt;int,int&gt; ma2; int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; if(!ma[a[i]]) ma[a[i]]=i; ma2[a[i]]=i; &#125; for(int i=1;i&lt;=m;i++) &#123; if(ma[i]==0) cout&lt;&lt;ma[m]&lt;&lt;&quot; &quot;&lt;&lt;ma2[m]&lt;&lt;endl; else cout&lt;&lt;ma[i]&lt;&lt;&quot; &quot;&lt;&lt;ma2[i]&lt;&lt;endl; &#125; return 0;&#125; 一开始WA了好几次，最后才意识到需要有一个特判。每天也就做做水题维持一下生活这样子了。😢]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>Thinking</tag>
        <tag>nowcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生活不止眼前的苟且，还有诗和远方的田野]]></title>
    <url>%2F2019%2F04%2F19%2Flife-summary%2F</url>
    <content type="text"><![CDATA[总结过去一段时间的生活。 首先说一下大学生活吧，确实没有高中时候期待的那样美好。一点都不舒服，每天忙的要死，又有很多听不懂还学不会的东西，确实没有幻想中的那么美好，毕竟还是要奋斗的，死于安乐啊。 然后说一下关于协会的事吧，早在刚来学校前就知道了这个协会，一开始也是被公费旅游给吸引的妥妥的。可是很现实的就是有实力才能出去比赛，出去公费旅游。运气也是不错，来来回回出去了好几次。可是五月份那个驻马店的省赛去不了了诶，贼难受，不过还是因为自己菜，如果我也很厉害还是可以去。可惜没如果。。。而且最近真的是不知道怎么提示，复杂一点的算法就看不懂了很难受，也就一直水水cf上面简单的思维题，给自己一个没有退步的假象，实际上真的是越来越菜。还是加油吧，争取多出去玩几次。 然后说一下sublime，这个玩意是真的好用，就是配置成c/c++的IDE的话好难。。。前前后后搞了好几次，就在昨天晚上终于是搞好了，还通过下载插件实现了sublime中编辑markdown并实时预览的功能(快捷键：ALT+m)，真好用。还很漂亮。这里提一下，用sublime下载插件如果会出错，建议用手机的4G网络开热点进行下载，具体是什么原因可以网上看，我也解释不清。还有就是google上的momomentum插件每次显示的壁纸都贼漂亮，一番查找终于是找到了图片的位置，有一种直接在网站上可以下载的方法可是我不会，但是可以在本地文件夹找到，文件路径为1C:\Users\11204\AppData\Local\Google\Chrome\User Data\Default\Extensions\laookkfknpbbblfpciffpaejjkokdgca\1.8.3_0(版本号)\backgrounds]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Expedition]]></title>
    <url>%2F2019%2F04%2F18%2Fpoj-2431%2F</url>
    <content type="text"><![CDATA[最近学长开的算法课中了解到了优先队列，又正好在白书上看到一道可以用优先队列实现的题，磕了小半天，终于是在白书的帮助下AC啦。🌞 poj 2431 Expedition题目链接：poj 2431 Expedition题目描述：A group of cows grabbed a truck and ventured on an expedition deep into the jungle. Being rather poor drivers, the cows unfortunately managed to run over a rock and puncture the truck&#39;s fuel tank. The truck now leaks one unit of fuel every unit of distance it travels. To repair the truck, the cows need to drive to the nearest town (no more than 1,000,000 units distant) down a long, winding road. On this road, between the town and the current location of the truck, there are N (1 &lt;= N &lt;= 10,000) fuel stops where the cows can stop to acquire additional fuel (1..100 units at each stop). The jungle is a dangerous place for humans and is especially dangerous for cows. Therefore, the cows want to make the minimum possible number of stops for fuel on the way to the town. Fortunately, the capacity of the fuel tank on their truck is so large that there is effectively no limit to the amount of fuel it can hold. The truck is currently L units away from the town and has P units of fuel (1 &lt;= P &lt;= 1,000,000). Determine the minimum number of stops needed to reach the town, or if the cows cannot reach the town at all.Input Line 1: A single integer, N Lines 2..N+1: Each line contains two space-separated integers describing a fuel stop: The first integer is the distance from the town to the stop; the second is the amount of fuel available at that stop. Line N+2: Two space-separated integers, L and POutput Line 1: A single integer giving the minimum number of fuel stops necessary to reach the town. If it is not possible to reach the town, output -1.Sample Input 44 45 211 515 1025 10Sample Output 2Hint INPUT DETAILS: The truck is 25 units away from the town; the truck has 10 units of fuel. Along the road, there are 4 fuel stops at distances 4, 5, 11, and 15 from the town (so these are initially at distances 21, 20, 14, and 10 from the truck). These fuel stops can supply up to 4, 2, 5, and 10 units of fuel, respectively. OUTPUT DETAILS: Drive 10 units, stop to acquire 10 more units of fuel, drive 4 more units, stop to acquire 5 more units of fuel, then drive to the town.题意分析：你需要驾驶一辆卡车行驶L单位距离。最开始时，卡车上有P单位的汽油。卡车每开1单位距离需要消耗1单位的汽油。如果在途中车上的汽油耗尽，卡车就无法继续前行，因而无法到达终点。在途中一共有N个加油站。给出每个加油站到终点的距离，以及这个加油站可以给卡车最多加多少汽油，并且卡车燃料箱的容量是没有限制的。如果卡车不能到达终点输出-1，否则输出最少停留，即需要加油的次数。 解题思路就是让卡车一直走下去，直至燃料箱中剩余为0的时候，看是不是经过了加油站，并且对那些加油站可以加的油的量进行判断，实现这一步，就可以用到优先队列。并且此时我们要给卡车加最多能加的油（体现贪心的地方）。我在这里用了结构体以及结构体的排序。代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;int l,p,pos=0,ans=0,re;//re代表油箱中剩的油，pos代表现在所在的位置priority_queue&lt;int&gt; q;struct oil&#123; int a,b;&#125;s[1000005];bool cmp(oil x,oil y)&#123; return x.a&lt;y.a;&#125;int main()&#123; int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;s[i].a&gt;&gt;s[i].b; cin&gt;&gt;l&gt;&gt;p; for(int i=0;i&lt;n;i++) s[i].a=l-s[i].a; sort(s,s+n,cmp); s[n].a=l; s[n].b=0; n++; re=p; for(int i=0;i&lt;n;i++) &#123; int d=s[i].a-pos; while(re-d&lt;0)//这个while代表的是此时油箱中剩的油的量够不够走到下一个位置。 &#123; if(q.empty())//队列为空代表已经没有可以加油的地方了，也就是到不了终点了。 &#123; cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl; return 0; &#125; re+=q.top(); q.pop(); ans++; &#125; re-=d; pos=s[i].a; q.push(s[i].b); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>Greedy</tag>
        <tag>c/c++</tag>
        <tag>poj</tag>
        <tag>Priority queue</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gourmet Cat]]></title>
    <url>%2F2019%2F04%2F17%2FCodeForces-1154C%2F</url>
    <content type="text"><![CDATA[昨晚cf的一道题，记录一下。 1154C Gourmet Catcf传送门：Gourmet Catvj传送门：Gourmet Cat题目描述Polycarp has a cat and his cat is a real gourmet! Dependent on a day of the week he eats certain type of food: on Mondays, Thursdays and Sundays he eats fish food;on Tuesdays and Saturdays he eats rabbit stew;on other days of week he eats chicken stake.Polycarp plans to go on a trip and already packed his backpack. His backpack contains: a daily rations of fish food;b daily rations of rabbit stew;c daily rations of chicken stakes.Polycarp has to choose such day of the week to start his trip that his cat can eat without additional food purchases as long as possible. Print the maximum number of days the cat can eat in a trip without additional food purchases, if Polycarp chooses the day of the week to start his trip optimally. InputThe first line of the input contains three positive integers a, b and c (1≤a,b,c≤7⋅1e8) — the number of daily rations of fish food, rabbit stew and chicken stakes in Polycarps backpack correspondingly. OutputPrint the maximum number of days the cat can eat in a trip without additional food purchases, if Polycarp chooses the day of the week to start his trip optimally. Examplesinput2 1 1output4input3 2 2output7input1 100 1output3input30 20 10output39NoteIn the first example the best day for start of the trip is Sunday. In this case, during Sunday and Monday the cat will eat fish food, during Tuesday — rabbit stew and during Wednesday — chicken stake. So, after four days of the trip all food will be eaten. In the second example Polycarp can start his trip in any day of the week. In any case there are food supplies only for one week in Polycarps backpack. In the third example Polycarp can start his trip in any day, excluding Wednesday, Saturday and Sunday. In this case, the cat will eat three different dishes in three days. Nevertheless that after three days of a trip there will be 99 portions of rabbit stew in a backpack, can cannot eat anything in fourth day of a trip.题意分析：这道题大概的意思就是给定一个序列abcacba abcacba......然后给定a，b，c的个数，求能得到的最大序列的长度。观察可以发现3个a2个b2个c可以当成一组看待，然后将a，b，c通过这个原则进行缩小。缩小之后在进行判断，从第一个a开始最长的序列是多长，从第二个b开始最长序列是多长，从第三个c开始最长序列是多长，从第四个a开始最长的序列是多长。。。。。。用代码实现这部分功能就是123456789101112131415int ans=0,s=0; for(int i=1;i&lt;8;i++) &#123; int j=i,s=0; int A=a,B=b,C=c; while(A&gt;=0&amp;&amp;B&gt;=0&amp;&amp;C&gt;=0) &#123; if(j%7==1||j%7==4||j%7==0) --A; else if(j%7==3||j%7==5) --C; else --B; j++; s++; &#125; ans=max(ans,s-1); &#125; 每次计算出的s都需要减1，因为当你退出while循环的时候，a，b，c中会有一个值为-1，相当于多计算了一个字符，所以需要减一。如果不懂的话，建议手动模拟一下while循环中的内容，会有助于理解的。 这道题的代码实现1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;using namespace std;int main()&#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; int x; x=min(a/3,min(b/2,c/2)); a-=x*3; b-=x*2; c-=x*2; int ans=0,s=0; for(int i=1;i&lt;8;i++) &#123; int j=i,s=0; int A=a,B=b,C=c; while(A&gt;=0&amp;&amp;B&gt;=0&amp;&amp;C&gt;=0) &#123; if(j%7==1||j%7==4||j%7==0) --A; else if(j%7==3||j%7==5) --C; else --B; j++; s++; &#125; ans=max(ans,s-1); &#125; cout&lt;&lt;ans+7*x&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[产生冠军]]></title>
    <url>%2F2019%2F04%2F16%2FHDU-water%2F</url>
    <content type="text"><![CDATA[蒟蒻的HDU刷（shui）题之旅 产生冠军题目描述：有一群人，打乒乓球比赛，两两捉对撕杀，每两个人之间最多打一场比赛。球赛的规则如下：如果A打败了B，B又打败了C，而A与C之间没有进行过比赛，那么就认定，A一定能打败C。如果A打败了B，B又打败了C，而且，C又打败了A，那么A、B、C三者都不可能成为冠军。根据这个规则，无需循环较量，或许就能确定冠军。你的任务就是面对一群比赛选手，在经过了若干场撕杀之后，确定是否已经实际上产生了冠军。 Input输入含有一些选手群，每群选手都以一个整数n(n&lt;1000)开头，后跟n对选手的比赛结果，比赛结果以一对选手名字（中间隔一空格）表示，前者战胜后者。如果n为0，则表示输入结束。 Output对于每个选手群，若你判断出产生了冠军，则在一行中输出“Yes”，否则在一行中输出“No”。 Sample Input3Alice BobSmith JohnAlice Smith5a cc dd eb ea d0 Sample OutputYesNo 题意分析：刚开似乎看到这道题以为是并查集（虽然我也不会。但是经过仔细的分析可以发现，如果冠军是确定存在的，那么这个冠军肯定是没有输过的，所以可以使用c++STL中的set。将所有人和输过的人分开存进set，在比较两个set的size，如果所有人比输过的人多1，则说明冠军是存在的。代码实现 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n,a; while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n) &#123; set&lt;string&gt; x; set&lt;string&gt; y; string p,q; while(n--) &#123; cin&gt;&gt;p&gt;&gt;q; x.insert(p); x.insert(q); y.insert(q); &#125; if(x.size()-y.size()==1) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>HDU</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[咕咕的计数题 II]]></title>
    <url>%2F2019%2F04%2F15%2FCCPC-F-2019%2F</url>
    <content type="text"><![CDATA[这是助我们拿银牌的一道题，自己都没有想到可以A了这道题，不过这道题还是思维更重要一些。 咕咕的计数题 II题目描述咕咕最近在学习初等数论，并且对下取整函数产生了极大的兴趣。下取整函数是指一个函数，自变量为 一个实数，因变量为一个整数，这个整数恰好是小于或等于自变量的最大的整数，通常记做 ⌊x⌋。例如， ⌊2.5⌋ = 2,⌊2⌋ = 2,⌊−2.5⌋ = −3。 咕咕发现，给定一个 a，并不是所有的自然数 n 都存在一个正整数 i 使得 ⌊n/i⌋ = a。那么，如果给定 l,r，咕咕好奇在区间 [l,r] 中有多少个正整数能使这个等式有正整数解 i 呢？ 那么，聪明的你，你能告诉咕咕吗？输入第一行有一个整数 T(1 ≤ T ≤ 1e6)，表示数据组数。接下来有 T 行，每行有三个数 a,l,r(1 ≤ a ≤ 1e18,1 ≤ l ≤ r ≤ 1e18)，表示一组询问。输出输出 T 行，对每组询问，输出一个整数表示答案。样例输入45 7 107 39 421000 1000 100027 100 1000样例输出121617提示数据范围当 n = 39,a = 7 时，能找到 i = 5 使得 ⌊39 /5 ⌋ = 7。题意分析这道题就是给你一个区间和一个数a，让你求区间内有几个数跟任意数整除之后可以得到a，通过看数据范围可以发现这道题的输入量巨大，所以应该是会可以找到一个规律。并且不能使用cin和cout。找到的规律AND式子假定a为7，l为1，r为70，区间内满足条件的值有一下几组123456789101112a = 7 ,l = 1 ,r = 70714 1521 22 2328 29 30 3135 36 37 38 3942 43 44 45 46 4749 50 51 52 53 54 5556 57 58 59 60 61 62 6364 65 66 67 68 69 70 7172 73 74 75 76 77 78 7980 仔细观察以及在写出来的过程中会发现满足整除出现a的数肯定是在(a*i,a*i+(i-1))内,i=1,2,3......并且一旦超过了a的平方之后，任意一个数都可以整除之后出现a。规律已经找到了，可是该怎么实现呢，我们会发现，在小于a的平方之前，每次出现的满足条件的数的个数是1,2,3,4,5,6......这样递增的，所以我们让这个数对a整除，对整除出来的数进行从1加到它本身的求和，然后减去有可能不满足的个数，表达不满足的个数，我们看上面的列出来的数，会发现，如果这个数对a取余小于这个数对a整除，就满足条件，所以就可以判断了。写成式子就是12Sum(l/a)-(l%a&lt;l/a?(l/a-l%a):0)Sum为自定义的从1加到本身的函数，可以直接用一个公式代替，这样方便理解 然后就可以求出左区间以内满足的个数x，右区间以内满足的个数y，y-x就可以求出[x,l)之间的满足条件的个数，但是这种方法并没有对r进行判断，所以我们要再对r进行一次判断，如果r也满足，直接答案加一就行了。分三种情况考虑 左区间l大于a的平方，此时所需要输出的答案就是r-l。 左区间l小于a的平方，但右区间r大于a的平方，此时需要把区间分成两段，一段是(a*a,r),一段是(l,a*a-1)。大于a的平方的那一段的区间长度，加上小于a的平方的那一段中满足上面总结的规律的数的个数即答案。 右区间小于a的平方，此时就可以直接在(l,r)内去找满足条件的数的个数输出就行。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cmath&gt;#include&lt;cstdio&gt;using namespace std;typedef long long ll;ll Sum(ll x)&#123; if(x%2==0) return x/2*(1+x); return x*(1+x)/2;&#125;int main()&#123; int t; ll a,l,r; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; ll ans=0,x,y; scanf(&quot;%lld %lld %lld&quot;,&amp;a,&amp;l,&amp;r); if(sqrt(l)&gt;=a) &#123; ans=r-l+1; &#125; else if(sqrt(r)&gt;=a) &#123; ans=r-a*a+1; r=a*a-1; x=Sum(l/a)-(l%a&lt;l/a?(l/a-l%a):0); y=Sum(r/a)-(r%a&lt;r/a?(r/a-r%a):0); if(r%a&lt;r/a) y++; ans+=y-x; &#125; else &#123; x=Sum(l/a)-(l%a&lt;l/a?(l/a-l%a):0); y=Sum(r/a)-(r%a&lt;r/a?(r/a-r%a):0); if(r%a&lt;r/a) y++; ans=y-x; &#125; printf(&quot;%lld\n&quot;,ans); &#125; return 0;&#125; 这里有一个坑，就是分情况讨论的时候l，r跟a的平方比较的时候要对l，r开平方之后跟a比较，第一次我们交的与a的平方比较，WA了，怎么都找不到bug，最后还是机灵的队友说了一下会不会平方之后爆long long，改了一下交了还真过了。。。这数据卡的东西真多。一定要注意！！！]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>Thinking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Childhood dream]]></title>
    <url>%2F2019%2F04%2F14%2FDream%2F</url>
    <content type="text"><![CDATA[昨天去郑轻打了CCPC的省赛(比赛链接)，所幸被队友带飞拿了个银（队友是真的强。这题当时想都不敢想，最后听学长一说发现还挺简单的，补一下。 Childhood dream题目链接:Childhood dream题目描述：你童年时期就有一个梦想，想要加入 ACM(Association of Calculation and Magic)，今天，这个机会终于 来了。但是 ACM 只想要哪些天赋异禀的人, 比如像 tourist，他们给了你一道题来检测你是否足够机智。猜一个长度为 m 数字串，总共有 n 个提示串，解释如下： 8640 0A2BA 前面的数字说明与答案相比，有多少个位置上的数字是相同的。 B 前面的数字说明与答案相比，有多 少个数字是相同的，但是位置不一样。 0 A 就表示给出的串没有任何位置和答案是相同的。 2 B 就表示给出的串中有两个数字和答案相同，但 是位置不一样。所以，对于上面那个提示串 6457 是一个合理的答案，但是 1234 并不是。现在给你 N(N&lt;=100) 个提示串（如上所示），你需要去找到一个数字串来符合每一个提示串的要求。提示串中的每个数字都是不同的，即一个串中不会存在相同的数字。你能解决这个问题并加入 ACM 吗？输入第一行两个数字，n(n&lt;=100) 和 m(m&lt;=9）, 提示串的数量以及目标字符串的长度。然后是 n 行，每行的格式如下：s x ys 是提示串，x 是 A 前的数字，y 是 B 前的数字，等同于：s xAyB输出一行，目标串。数据保证答案唯一。样例输入6 45164 3 05174 3 05194 3 05124 3 05134 3 05104 3 0样例输出5184题意分析这道题的意思就是猜一个数，数的位数是确定的，然后会进行猜数，会给出两个数，第一个数代表位置相等且大小相等的个数，第二个数代表的是数相等但位置不等的数，通过这几次猜测，让你输出对应的满足条件的答案。因为答案最大的长度才10所以可以直接全排，全排之后对每次猜测就行A跟B的计算，然后跟输入进行比较，最后根据比较的结果得出答案，题目保证答案唯一。这样想这道题还是很水的。。。代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;string s[105];int a[105],b[105];int A[10]=&#123;0,1,2,3,4,5,6,7,8,9&#125;;int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) cin&gt;&gt;s[i]&gt;&gt;a[i]&gt;&gt;b[i]; do &#123; bool flag=0; int x,y; for(int i=0;i&lt;n;i++) &#123; x=y=0; for(int j=0;j&lt;m;j++) &#123; if(A[j]==s[i][j]-&apos;0&apos;) &#123; x++; &#125; &#125; for(int j=0;j&lt;m;j++) for(int k=0;k&lt;m;k++) &#123; if(j!=k&amp;&amp;A[j]==s[i][k]-&apos;0&apos;) y++; &#125; if(x!=a[i]||y!=b[i]) &#123; flag=1; break; &#125; &#125; if(!flag) &#123; for(int i=0;i&lt;m;i++) &#123; cout&lt;&lt;A[i]; &#125; cout&lt;&lt;endl; break; &#125; &#125;while(next_permutation(A,A+10)); return 0;&#125; 全排之后取前m位进行判断就行。虽说题有点‘水’，但要是让我自己做出来显然还是不可以的，加油吧！ 附上学霸学长修改了的我的TLE的代码，我又学到了好多东西🎈1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;int a[10]=&#123;0,1,2,3,4,5,6,7,8,9&#125;;struct guess&#123; string S; int A,B;&#125;gue[100];int n,m,x,y;bool check()&#123; int k,l; for(int i=0;i&lt;n;i++) &#123; k=l=0; for(int j=0;j&lt;m;j++) &#123; if(a[j]==gue[i].S[j]-&apos;0&apos;) k++; &#125; for(int k=0;k&lt;m;k++) for(int j=0;j&lt;m;j++) &#123; if(k==j) continue; if(a[k]==gue[i].S[j]-&apos;0&apos;) l++; &#125; if(k!=gue[i].A||l!=gue[i].B) return 0; &#125; return 1;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) cin&gt;&gt;gue[i].S&gt;&gt;gue[i].A&gt;&gt;gue[i].B; do &#123; if(check()) &#123; for(int i=0;i&lt;m;i++) cout&lt;&lt;a[i]; cout&lt;&lt;endl; break; &#125; &#125;while(next_permutation(a,a+10)); return 0;&#125;]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>Thinking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现大数加法]]></title>
    <url>%2F2019%2F04%2F10%2FBignumber%2F</url>
    <content type="text"><![CDATA[c语言能存的最大的数（考虑精度的情况下）是unsigned long long,能存下的最大的数是2^64-1，虽然这个数已经够大了，但是某些情况下还是会有很大的数无法用整形处理的，此时我们就要用字符串。具体思想其实就是模拟，加法就是按位相加，再考虑一下低位过来的进位就可以了。说起来简单但是实现起来就不是那么回事了。之前刚开始了解的是用数组存，好像还很麻烦，这些天突然看到一个用了string类型以及string类型有关的函数来解决这个问题的，感觉不错。先上代码12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n,a,b; a=b=0; cin&gt;&gt;n; while(n--) &#123; string s1,s2,s(10000,&apos;0&apos;); cin&gt;&gt;s1&gt;&gt;s2; cout&lt;&lt;(b++?&quot;\n&quot;:&quot;&quot;); reverse(s1.begin(),s1.end()); reverse(s2.begin(),s2.end()); for(int i=0;i&lt;s1.size();i++) &#123; s[i]=s1[i]; &#125; int temp=0; for(int i=0;i&lt;s2.size();i++) &#123; temp+=s[i]+s2[i]-&apos;0&apos;-&apos;0&apos;; s[i]=temp%10+&apos;0&apos;; temp/=10; &#125; s[s2.size()]=s[s2.size()]+temp; reverse(s.begin(),s.end()); reverse(s1.begin(),s1.end()); reverse(s2.begin(),s2.end()); cout&lt;&lt;&quot;Case &quot;&lt;&lt;b&lt;&lt;&apos;:&apos;&lt;&lt;endl; cout&lt;&lt;s1&lt;&lt;&quot; + &quot;&lt;&lt;s2&lt;&lt;&quot; = &quot;&lt;&lt;s.substr(s.find_first_not_of(&apos;0&apos;))&lt;&lt;endl; &#125; return 0;&#125; 这是HDU1002的AC代码。其中有很多是格式控制符，跟大数相加无关，所需要理解的其实就是这一步123456for(int i=0;i&lt;s2.size();i++) &#123; temp+=s[i]+s2[i]-&apos;0&apos;-&apos;0&apos;; s[i]=temp%10+&apos;0&apos;; temp/=10; &#125; temp所表示的数就是进位。另外这里面还用到s.substr()，s.find_first_not_of()函数。因为在定义结果字符串s的时候定义成了全是0的一个字符串。s.substr()用来输出子串，s.find_first_not_of()用来找到第一个不是0的字符的位置来生成子串。这样写还是很简洁的，也比较好理解。]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>Simulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hangman Judge]]></title>
    <url>%2F2019%2F04%2F04%2FUVA-489%2F</url>
    <content type="text"><![CDATA[在学长的指点下，买了一本紫薯来啃，前两章食用感觉还不错。。。到了第三章例题虽然可以看懂，习题已经做不出来了。到了第四章，例题都有点看不懂了🤢！！！用了接近一下午的时间做出来一道例题，登到这里记录一下，顺便夸夸自己。 UVA 489 - Hangman Judge原题链接：Hangman Judge原题链接：Hangman Judge----vj ATTENTION ：我与书上的方法不一样。并且因为我很菜，用的方法会很笨，有什么想指点的请在评论区留言，勿喷👌。题目描述In “Hangman Judge,” you are to write a program that judges a series of Hangman games. For eachgame, the answer to the puzzle is given as well as the guesses. Rules are the same as the classic gameof hangman, and are given as follows:1.The contestant tries to solve to puzzle by guessing one letter at a time.2.Every time a guess is correct, all the characters in the word that match the guess will be “turnedover.” For example, if your guess is ‘o’ and the word is “book”, then both ‘o’s in the solution willbe counted as“solved”.3.Every time a wrong guess is made, a stroke will be added to the drawing of a hangman, whichneeds 7 strokes to complete. Each unique wrong guess only counts against the contestant once. 123456789______| || O| /|\| || / \ __|_| |______|_________| 4.If the drawing of the hangman is completed before the contestant has successfully guessed all thecharacters of the word, the contestant loses.5.If the contestant has guessed all the characters of the word before the drawing is complete, thecontestant wins the game.6.If the contestant does not guess enough letters to either win or lose, the contestant chickens out.Your task as the “Hangman Judge” is to determine, for each game, whether the contestant wins,loses, or fails to finish a game.InputYour program will be given a series of inputs regarding the status of a game. All input will be in lowercase. The first line of each section will contain a number to indicate which round of the game is beingplayed; the next line will be the solution to the puzzle; the last line is a sequence of the guesses made by the contestant. A round number of ‘-1’ would indicate the end of all games (and input).OutputThe output of your program is to indicate which round of the game the contestant is currently playing as well as the result of the game. There are three possible results:You win.You lose.You chickened out. Sample Input1cheesechese2cheeseabcdefg3cheeseabcdefgij-1Sample OutputRound 1You win.Round 2You chickened out.Round 3You lose. 题意分析：计算机想一个单词让你猜，你每次可以猜一个字母，如果单词里有那个字母，所有该字母会显示出来；如果没有那个字母，则计算机会在一副“侩子手”画上填上一笔。这幅画一共需要7笔就能完成，因此你最多只能错6次。注意，猜一个已经猜过的字母也算错。（以上内容来自——算法竞赛入门经典第二版 刘汝佳编）。题目中输入的第一个字符串就是计算机想的单词，第二个字符串就是你猜的所有字符，这道题书上和我在网上看的好多用的是用一个数组标记每个字母出现的次数，但是我不会用，于是用了map来实现。这题我WA了好几次，其实大致上的实现方式是差不多的，就是会有很多细节需要考虑。题目中的输出有三种情况You win. 即在错误7次一下成功猜出了所有第一个字符串中的字符。You chickened out. 即虽然错误次数没有超过7，但是并没有猜出来所有的第一个字符串中的字符。You lose. 即全部猜对之前错误次数大于等于7了。我的解题思路：首先将第一个字符串中的所有元素用map标记value为1，然后开始询问第二个字符串中的元素，如果这个元素（即字符）的map值为一，就说明它在第一个字符串中存在，反之就说明这是一次错误的猜测，此时需要对错误的次数加一方便以后的判断。需要注意的是因为在判断的过程中如果错误的次数已经到达了7次，后面的就不需要再进行判断了，因为此时已经Lose了。还有就是每一个错误的字符最多错一次，解释一下就是如果s不是第一个字符串中的元素，尽管你在第二个字符串中出现了几个s,都还只是猜错了一次。还有一些具体的细节我们在代码里进行解释。代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n; string x,y; while(cin&gt;&gt;n&amp;&amp;n!=-1)//题目要求n为-1时退出程序 &#123; map&lt;char,int&gt; ma;//用来标记第一个字符串中出现的字符 map&lt;char,int&gt; ma1;//用来判断是否需要对错误次数进行累加 getchar(); cin&gt;&gt;x&gt;&gt;y; int p=0; for(int i=0;i&lt;x.size();i++) &#123; ma[x[i]]=1;//把第一个字符串中出现的字符全部存进map并标记为1 &#125; for(int i=0;i&lt;y.size();i++) &#123; if(ma[y[i]])//如果ma[y[i]]不为0，即说明这个元素在第一个字符串中 &#123; ma[y[i]]=0;//对最后的判断第一个字符串有没有被猜完做准备 ma1[y[i]]=1;//因为这是一个正确的字符，所以标记为1，在接下来的判断中将其跳过 &#125; else if(!ma1[y[i]])//如果ma1[y[i]]为0，说明这个字符是错误且只出现了一次的，此时需要对错误次数加一 &#123; p++; ma1[y[i]]=1;//将y[i]标记为1，再遇见y[i]的时候，错误次数不变 &#125; if(p&gt;=7) break;//错误的次数已经到达了7次，直接跳出循环 &#125; int flag=1; map&lt;char,int&gt;::iterator it;//定义一个迭代器，用来遍历map中的每一个元素 for(it=ma.begin();it!=ma.end();it++) &#123; if(it-&gt;second)//如果存在一个it-&gt;second不为0，即说明没有猜完 &#123; flag=0; break; &#125; &#125; printf(&quot;Round %d\n&quot;,n);//这个很坑，一开始就没注意到，注意看题目的输出格式！！！ if(flag)//flag为1说明在7次错误以内已经猜对了所有字符，所以输出You win. puts(&quot;You win.&quot;); else//否则对错误次数进行判定，这个里面挺好懂的，就不做详细解释了 &#123; if(p&lt;7) puts(&quot;You chickened out.&quot;); else puts(&quot;You lose.&quot;); &#125; &#125; return 0;&#125; 至此这道题就告一段落了，再次说明一下，这种方法肯定是比较麻烦的那种，我知道😭但是这是我能想起来的可以解决的方法了，以后好好了解一下数组在这方面的应用。有什么想吐槽的就来吧，我听着 书上的方法1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define maxn 100int left,chance;char s[maxn],s2[maxn];int win,lose;void guess(char ch)&#123; int bad=1; for(int i=0;i&lt;strlen(s);i++) if(s[i]==ch) &#123; left--; s[i]=&apos; &apos;; bad=0; &#125; if(bad) --chance; if(!chance) lose=1; if(!left) win=1;&#125;int main()&#123; int rnd; while(scanf(&quot;%d%s%s&quot;,&amp;rnd,s,s2)==3&amp;&amp;rnd!=-1) &#123; printf(&quot;Round %d\n&quot;,rnd); win=lose=0; left=strlen(s); chance=7; for(int i=0;i&lt;strlen(s2);i++) &#123; guess(s2[i]); if(win||lose) break; &#125; if(win) printf(&quot;You win.\n&quot;); else if(lose) printf(&quot;You lose.\n&quot;); else printf(&quot;You chickened out.\n&quot;); &#125; return 0;&#125; 书上的方法还是很直接的，直接看就可以看懂了😘]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>Thinking</tag>
        <tag>UVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Asia区域制]]></title>
    <url>%2F2019%2F04%2F02%2FAsia-B%2F</url>
    <content type="text"><![CDATA[校赛一道题，记录一下。 Asia区域制题目链接：Asia区域制题目描述二进制数据是用 0 和 1 两个数码来表示的数.它的基数为 2 ，进位规则是“逢二进一”，借位规则是“借一当二”，由18世纪德国数理哲学大师莱布尼兹发现.十六进制（简写为hex或下标 16 ）在数学中是一种逢 16 进 1 的进位制.一般用数字 0 到 9 和字母 A 到 F（或 a ~ f ）表示，其中: a ~ f 表示 10 ~ 15 ，这些称作十六进制数字.请将给定的二进制数转为十六进制数，英文字母使用小写形式. 输入第一行一个正整数 T， 代表有 T 组测试数据. (1≤T≤10).接下来 T 行，每行输入一串只包含 0 和 1 的字符串（无前导 0），字符串长度：1≤length≤106. 输出对于每组测试样例，输出转化后的十六进制数并单独占一行. 样例input2110output12题意分析就是将输入的一个二进制数转换成十六进制，但是需要注意的是这里给的二进制的数很大很大，就算用unsigned long long也存不下，所以只能使用字符串处理了。二进制转换成十六进制可以每四位转换成一个十进制数，最后全部转化完的结果就是十六进制的表现形式。具体看代码实现代码实现1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string s; int n; cin&gt;&gt;n; while(n--) &#123; cin&gt;&gt;s; stack&lt;char&gt; sta; stack&lt;int&gt; sta0; for(int i=0;i&lt;s.size();i++) &#123; sta.push(s[i]); &#125; while(!sta.empty()) &#123; int flag=0,k=1,s=0; while(flag&lt;4) &#123; int m=sta.top()-&apos;0&apos;; sta.pop(); s+=m*k; k*=2; flag++; if(sta.empty()) break; &#125; sta0.push(s); &#125; while(!sta0.empty()) &#123; printf(&quot;%0x&quot;,sta0.top()); sta0.pop(); &#125; cout&lt;&lt;endl; &#125; return 0; &#125; 这里用到一个小技巧，c语言的printf的格式控制符里面有控制八进制(%o)十六进制(%0x)的控制符（具体更多的用法可以自行百度）可以直接使用。说到控制符就很气，请接着往下看。我与这题的恩恩怨怨校赛前还专门复习了一下进制转换，一开始没仔细看以为是道水题，直接WA了两发。看到数据范围才醒悟过来。跟某大佬交流时听说python写这道题贼简单，正好我也在学习python，然后就试着用python写了这道题12for i in range(int(input())): print(hex(int(input(), 2))[2:]) 毫无人性啊有没有😭python的大数。。。用python就有一种作弊的既视感。好好学习！！！]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩形面积并]]></title>
    <url>%2F2019%2F04%2F01%2Fknowledge%2F</url>
    <content type="text"><![CDATA[这道题在我刚刚接触算法的时候就遇见过。。。当时暴力解了出来。第二次遇见没做出来，学长教了我一下，我又没仔细学。。昨天校赛的时候再次遇见。凉透了。把学长传下来的代码自己写一遍再贴在这里，时常告诫自己！校赛原题：Mo的面积学长博客：矩形面积并题目描述Mo的老师给了他两个矩形，让他求两个矩形的面积并。Mo很忙没时间解决这种小case，请你帮他解决。 输入输入两行，每行四个整数 x,y,x1,y1 。(x,y) 是矩形左下角，(x1,y1) 是矩形的右上角. (0≤x,y,x1,y1≤1000)。 输出输出一个整数表示二个矩形的面积并。 样例input0 1 2 31 0 3 2output7学长的代码(求两个矩形相交部分的面积)12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;double a[10];int main()&#123; double l,r,u,d; for(int i=1;i&lt;=8;i++)&#123; scanf(&quot;%lf&quot;,&amp;a[i]); &#125; l=max( min(a[1],a[3]) , min(a[5],a[7]) ); r=min( max(a[1],a[3]) , max(a[5],a[7]) ); d=max( min(a[2],a[4]) , min(a[6],a[8]) ); u=min( max(a[2],a[4]) , max(a[6],a[8]) ); if( r - l &lt;= 0 || u - d &lt;= 0 ) printf(&quot;0.00\n&quot;); else printf(&quot;%.2lf\n&quot;,(r-l)*(u-d)); return 0;&#125; 校赛原题代码(在学长的代码的基础上稍加改动就行)123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;int a[10];int main()&#123; int l,r,u,d,s,s1; for(int i=1;i&lt;=8;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; l=max( min(a[1],a[3]) , min(a[5],a[7]) ); r=min( max(a[1],a[3]) , max(a[5],a[7]) ); d=max( min(a[2],a[4]) , min(a[6],a[8]) ); u=min( max(a[2],a[4]) , max(a[6],a[8]) ); if( r - l &lt;= 0 || u - d &lt;= 0 ) s1=0; else s1=(r-l)*(u-d); s=(a[4]-a[2])*(a[3]-a[1])+(a[8]-a[6])*(a[7]-a[5]); cout&lt;&lt;s-s1&lt;&lt;endl; return 0;&#125; ！！！！！！！！！！一定要记住补题！！！！！！！！！！！！]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[彩虹瓶]]></title>
    <url>%2F2019%2F03%2F30%2FPTA-L2-032%2F</url>
    <content type="text"><![CDATA[今天跟着众多大佬学长去了郑轻参加天梯赛，显然我拖了大佬后腿，一拖九了解一下，吓得我快来补题先。 PTA L2-032 彩虹瓶 原题链接：PTA彩虹瓶题目描述彩虹瓶的制作过程（并不）是这样的：先把一大批空瓶铺放在装填场地上，然后按照一定的顺序将每种颜色的小球均匀撒到这批瓶子里。 假设彩虹瓶里要按顺序装 N 种颜色的小球（不妨将顺序就编号为 1 到 N）。现在工厂里有每种颜色的小球各一箱，工人需要一箱一箱地将小球从工厂里搬到装填场地。如果搬来的这箱小球正好是可以装填的颜色，就直接拆箱装填；如果不是，就把箱子先码放在一个临时货架上，码放的方法就是一箱一箱堆上去。当一种颜色装填完以后，先看看货架顶端的一箱是不是下一个要装填的颜色，如果是就取下来装填，否则去工厂里再搬一箱过来。 如果工厂里发货的顺序比较好，工人就可以顺利地完成装填。例如要按顺序装填 7 种颜色，工厂按照 7、6、1、3、2、5、4 这个顺序发货，则工人先拿到 7、6 两种不能装填的颜色，将其按照 7 在下、6 在上的顺序堆在货架上；拿到 1 时可以直接装填；拿到 3 时又得临时码放在 6 号颜色箱上；拿到 2 时可以直接装填；随后从货架顶取下 3 进行装填；然后拿到 5，临时码放到 6 上面；最后取了 4 号颜色直接装填；剩下的工作就是顺序从货架上取下 5、6、7 依次装填。 但如果工厂按照 3、1、5、4、2、6、7 这个顺序发货，工人就必须要愤怒地折腾货架了，因为装填完 2 号颜色以后，不把货架上的多个箱子搬下来就拿不到 3 号箱，就不可能顺利完成任务。 另外，货架的容量有限，如果要堆积的货物超过容量，工人也没办法顺利完成任务。例如工厂按照 7、6、5、4、3、2、1 这个顺序发货，如果货架够高，能码放 6 只箱子，那还是可以顺利完工的；但如果货架只能码放 5 只箱子，工人就又要愤怒了…… 本题就请你判断一下，工厂的发货顺序能否让工人顺利完成任务。 输入格式：输入首先在第一行给出 3 个正整数，分别是彩虹瓶的颜色数量 N（1&lt;N≤10​3​​ ）、临时货架的容量 M（&lt;N）、以及需要判断的发货顺序的数量 K。 随后 K 行，每行给出 N 个数字，是 1 到N 的一个排列，对应工厂的发货顺序。 一行中的数字都以空格分隔。 输出格式：对每个发货顺序，如果工人可以愉快完工，就在一行中输出 YES；否则输出 NO。 输入样例：7 5 37 6 1 3 2 5 43 1 5 4 2 6 77 6 5 4 3 2 1输出样例：YESNONO我与这道题的恩恩怨怨：第一次看到这道题的时候，是很懵的，描述太长感觉看不懂不想看。看了榜单发现好多人做出来了，回头仔细一看，发现这就是一道栈的题。用一个栈就可以解决，虽然发现了方法，可是由于菜还是没做出来，补题补题。补题时候发现我的思路又总是出问题，在学长的帮助下，还是成功的过了这道题。题意分析：这道题跟pta上之前一道题，几乎是原题，题目是出栈序列的合理性(想找的自己翻吧，我没找到🌚)。我们不管输入的是什么都先让它入栈然后对栈顶的元素进行判断，并且将符合条件的pop出栈。具体看代码代码实现1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n,m,k,a; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; while(k--) &#123; int k=1; bool flag=0; stack&lt;int&gt; sta; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a; sta.push(a); if(sta.size()&gt;m+1) flag=1; while(!sta.empty()) &#123; if(sta.top()==k) &#123; sta.pop(); k++;//k就是用来模拟此时应放的序号，如果有对应的就对k加1，模拟的就是这个放过了，准备放下一个。 &#125; else break; &#125; &#125; if(!flag&amp;&amp;k==n+1) puts(&quot;YES&quot;); else puts(&quot;NO&quot;); &#125; return 0;&#125; Ps：if(sta.size()&gt;m+1)是因为题目中要求的有货架最多存放的数量，即栈的最大容量。可为什么是m+1而不是m呢，这个我也纠结了好久。因为我们放进去之后接下来就要对它进行判断，所以在实际的过程中它是不用放在货架（入栈）上的，所以是m+1。还是不明白的话，建议手动模拟一下，这道题就会理解的更加透彻。Warning：栈空的时候千万不要用.top()。。。不要用，不要用，不要用。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归实现十进制与二进制的转换]]></title>
    <url>%2F2019%2F03%2F28%2FBinary%2F</url>
    <content type="text"><![CDATA[早在之前学dfs的时候，师父就教我说用递归写二进制的转换。当时也是碰巧写了出来，进来遇见这类问题时，发现这样转换的人确实少，我还是记录一下，免得以后再忘，有兴趣的也可以看一下啦。二进制：二进制是计算技术中广泛采用的一种数制。二进制数据是用0和1两个数码来表示的数。它的基数为2，进位规则是“逢二进一”，借位规则是“借一当二”，由18世纪德国数理哲学大师莱布尼兹发现。当前的计算机系统使用的基本上是二进制系统，数据在计算机中主要是以补码的形式存储的。计算机中的二进制则是一个非常微小的开关，用“开”来表示1，“关”来表示0。20世纪被称作第三次科技革命的重要标志之一的计算机的发明与应用，因为数字计算机只能识别和处理由‘0’.‘1’符号串组成的代码。其运算模式正是二进制。19世纪爱尔兰逻辑学家乔治布尔对逻辑命题的思考过程转化为对符号&quot;0&#39;&#39;.&#39;&#39;1&#39;&#39;的某种代数演算，二进制是逢2进位的进位制。0、1是基本算符。因为它只使用0、1两个数字符号，非常简单方便，易于用电子方式实现。转换二进制我们用的都是余数短除法，就是要转换的数对二取余，然后除以二，直到这个数为0，再将余数倒序排列即可。不懂的话请看图示：这里的倒序输出，我们想到的就是用数组或者栈来实现，这也是等很大众化的一种方式。我要介绍的这种方法采用的是递归，其实本质都是一样的，且不分优劣，这样写只单纯为了加深对递归的理解！12345678void Binary(int x)&#123; if(x==0) return ; Binary(x/2); cout&lt;&lt;x%2; return ;&#125; 这部分就是代码的核心。我们手动执行一下就知道这种使用递归实现的巧妙之处了。1234567891011121314当x=10时：此时x不为0，所以会执行Binary(x/2)x/2=5此时x不为0，所以会执行Binary(x/2)x/2=2此时x不为0，所以会执行Binary(x/2)x/2=1此时x不为0，所以会执行Binary(x/2)x/2=0此时x为0，所以会返回至上一次递归，而上一次递归中的x为1，所以输出x%2就是1，然后遇见return，返回上一次递归。上一次递归中x为2。所以输出x%2就是0，然后遇见return，返回上一次递归。上一次递归中x为5。所以输出x%2就是1，然后遇见return，返回上一次递归。上一次递归中x为10。所以输出x%2就是10，然后遇见return，返回上一次递归。上一次递归中x为1。此时这一次整体的递归就已经结束了，输出是1010，就是10的二进制形式。 这里比较难理解的就是每一次新的递归开始的时候，上一次的执行会“保留现场”。然后每一次递归结束后就返回上一层递归。注意：x==0时return这个判断条件必须存在，不然递归不会结束。完整代码12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;void Binary(int x)&#123; if(x==0) return ; Binary(x/2); cout&lt;&lt;x%2; return ;&#125;int main()&#123; int n; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; if(n==0) &#123; puts(&quot;0&quot;); continue; &#125; Binary(n); cout&lt;&lt;endl; &#125; return 0;&#125; 这样的话会发现如果输入的数是负数会出现错误，只需要小小的改正一下就行12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;void Binary(int x)&#123; if(x==0) return ; Binary(x/2); cout&lt;&lt;abs(x%2); return ;&#125;int main()&#123; int n; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; if(n==0) &#123; puts(&quot;0&quot;); continue; &#125; if(n&lt;0) cout&lt;&lt;&apos;-&apos;; Binary(n); cout&lt;&lt;endl; &#125; return 0;&#125; 这样就实现了任意整数转化成二进制的功能啦]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长对称子串]]></title>
    <url>%2F2019%2F03%2F26%2FPTA-L2-008%2F</url>
    <content type="text"><![CDATA[昨晚进行了天梯的训练赛，里面这一道题觉得很有意思。 PTA L2-008 最长对称子串题目描述对给定的字符串，本题要求你输出最长对称子串的长度。例如，给定Is PAT&amp;TAP symmetric?，最长对称子串为s PAT&amp;TAP s，于是你应该输出11。 输入格式：输入在一行中给出长度不超过1000的非空字符串。 输出格式：在一行中输出最长对称子串的长度。1234输入样例：Is PAT&amp;TAP symmetric?输出样例：11 题意分析第一眼看到这道题是没有什么思路的，但是回头发现很多人a了这题，我又仔细的思考了很久，想到一种方法，让字符串与翻转之后的它进行比较，如果出现相等的就继续比较，同时对ans加一直到下一个不相同的出现为止。再将ans与最大值比较存储后归零。但是TLE了。不过有好的pta也是给了我21分（总分25。回来之后又想了想，查了一下资料，发现一种更好用的方法。参考文章：CSDN——职业炮灰具体思路就是遍历字符串的每一个字符，每次循环中都对这个字符两边的字符进行判断，出现不一样的就退出内层循环。这里面分有两种情况，一种是最长回文串的长度是奇数，一种是偶数。其实大体上是一样的。具体可以看代码 代码实现12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string s; getline(cin,s); int l=s.size(),len=0; for(int i=0;i&lt;l;i++) &#123; for(int j=0;i-j&gt;=0&amp;&amp;i+j&lt;l;j++) &#123; if(s[i-j]!=s[i+j]) break; len=2*j+1&gt;len?2*j+1:len; &#125; for(int j=0;i-j&gt;=0&amp;&amp;i+j&lt;l;j++) &#123; if(s[i-j]!=s[i+j+1]) break; len=(2*j+2)&gt;len?(2*j+2):len; &#125; &#125; cout&lt;&lt;len&lt;&lt;endl; return 0;&#125; 总结以及向对自己说的话昨晚的天体训练赛垫底了。。。好多基础算法也都还不会，不能再沉迷于水题了，要学习。学习。学习！]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>Thinking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运算符的妙用]]></title>
    <url>%2F2019%2F03%2F26%2FUseful-c%2F</url>
    <content type="text"><![CDATA[运算符有很多，算数运算符，关系运算符，逻辑运算符，位运算符，赋值运算符，杂项运算符···在我做题的过程中，发现逻辑运算符用来处理某些问题时很是简单，今天总结一下我遇到过的。 位逻辑运算符——异或(^)异或指的是参与运算的两个值，如果两个相应位(二进制形式下，按位运算)相同，则结果为0，否则为1。我们先测试一下^的计算功能1234567891011121314151617181920#include&lt;stdio.h&gt;int main()&#123; int a,b; while(~scanf(&quot;%d %d&quot;,&amp;a,&amp;b)) &#123; printf(&quot;%d\n&quot;,a^b); &#125; return 0;&#125;input:0 00 11 01 1output:0110 实例分析HPUOJ 18级新生周赛第四场 A. 阴与阳题目描述阴与阳单测试点时限: 1.0 秒 内存限制: 256 MB “龟，象也；筮，数也。物生而后有象，象而后有滋，滋而后有数。” ——《左传·僖公十五年》 数，从诞生开始，就被赋予了特殊的意义。 从古希腊起，奇数就比偶数更招人喜爱。公元前6世纪的希腊哲学家毕达哥拉斯说，奇数阳刚（代表男性），偶数阴柔（代表女性）。他说，奇数拒绝被一分为二，说明它强大；偶数能被平分，说明它很脆弱。 在《周易》中，奇数代表阳爻，偶数代表阴爻。阳反而阴顺，故奇数刚而偶数柔。 而在当今素粒子领域的现象，似乎也认证了他们的见解：奇数的粒子的运动比偶数的粒子激烈。 现在定义阴数和阳数的概念：在一个无序序列中，出现次数为奇数次的数为阴数，出现次数为偶数次的数为阳数 输入第一行输入一个奇数N (1≤N≤107+1) 第二行输入N个整数x (0≤x≤109) 输入数据有多组，输入到文件结束 保证每组输入数据一定有且仅有一个阴数 输出输出每组数据中的唯一的阴数样例input123451 5 5 1 331 1 2 output1232 提示本题输入输出量比较大，请尽量使用快速的OI方法。题意分析题目描述很多，但是我们需要的就是读取里面有用的信息供自己使用。题目中说出现次数为奇数次的数为阴数，出现次数为偶数次的数为阳数，并且保证每组数据有且只有一个阴数，也就是说把两个相同的数两两消去，最后剩下的数就是阴数，不好理解的话可以想象一下扑克牌中的抽老鳖游戏，最后剩下的那个数没有与它配对的就是老鳖，也就是这里的阴数。并且看到题目中的数据范围，直接暴力显然是不行的，这里就要用到我们的^了。代码实现首先我们来看一下多个数依次异或之后的结果12345678910111213141516171819202122232425#include&lt;stdio.h&gt;int main()&#123; int t,a,b; scanf(&quot;%d %d&quot;,&amp;t,&amp;a); t-=1; while(t--) &#123; scanf(&quot;%d&quot;,&amp;b); a=a^b; &#125; printf(&quot;%d\n&quot;,a); return 0;&#125;input:51 1 2 2 351 1 2 2 231 3 1output:323 从这里你应该就可以看出异或的去重性，其实仔细想一下就很容易想到每两个相同的数异或之后为0，而0与任意一个数异或之后等于那个数，所以最后出现的数就是只出现过1+2n(奇数次)的数了。到了这里应该也可以发现，上面的代码加上多组输入就已经是本题的答案了，做简单的更改就可以了。12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; ios::sync_with_stdio(false);//使流的输入输出速度与C的输入输出持平 ll n,x,ans; while(cin&gt;&gt;n) &#123; ans=0; while(n--) &#123; cin&gt;&gt;x; ans^=x; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; 之前的ac代码蜜汁TLE了，但是用上ios::sync_with_stdio(false)与cin和cout可以过，scanf和printf却过不了。ios::sync_with_stdio(false)：iostream默认是与stdio关联在一起的，以使两者同步，因此消耗了iostream不少性能，设置为false后，不再同步了，iostream的性能提高了很多倍。而cin，cout之所以效率低，是因为先把要输出的东西存入缓冲区，再输出，导致效率降低，而这段语句可以来打消iostream的输入输出缓存，可以节省许多时间，使效率与scanf与printf相差无几。本段话摘选自(https://blog.csdn.net/deepseazbw/article/details/76672177) 位逻辑运算符————与(&amp;) 移位运算符————右移运算符(&gt;&gt;)实现快速幂&amp;运算通常用于二进制取位操作，例如一个数 &amp;1的结果就是取二进制的最末位。这可以用来判断一个整数的奇偶，二进制的最末位为0表示该数是偶数，最末位为1表示该数为奇数&gt;&gt;右移运算符，具体的用法书上和网站上总结的都有很多。快速幂也用到了这个运算符。具体实现请参考在下的学习笔记中的快速幂实现。 实例分析HDUOJ 1905 Pseudoprime numbers题目描述Time Limit: 1000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Problem DescriptionFermat&#39;s theorem states that for any prime number p and for any integer a &gt; 1, a^p == a (mod p). That is, if we raise a to the pth power and divide by p, the remainder is a. Some (but not very many) non-prime values of p, known as base-a pseudoprimes, have this property for some a. (And some, known as Carmichael Numbers, are base-a pseudoprimes for all a.)Given 2 &lt; p ≤ 1,000,000,000 and 1 &lt; a &lt; p, determine whether or not p is a base-a pseudoprime. InputInput contains several test cases followed by a line containing &quot;0 0&quot;. Each test case consists of a line containing p and a. OutputFor each test case, output &quot;yes&quot; if p is a base-a pseudoprime; otherwise output &quot;no&quot;. Sample Input3 210 3341 2341 31105 21105 30 0 Sample Outputnonoyesnoyesyes题意分析英文题面虽然不太好读懂，但是这道题的题意还是很清晰的。就是给出两个数p,a,如果p是素数输出no，否则判断a的p次方对p取模之后是不是等于a，如果不是a输出no。表面看是挺无脑的，但是看到数据范围会发现直接求n次方是不行的，绝对会超时，这时就要用到快速幂了。代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll isok(ll x)//判断是否为素数&#123; if(x&lt;2) return 0; for(ll i=2;i&lt;=sqrt(x);i++) &#123; if(x%i==0) &#123; return 0; &#125; &#125; return 1;&#125;ll poww(ll x,ll y,ll z)//快速幂&#123; ll ans=1,base=x; while(y!=0) &#123; if(y&amp;1!=0) ans=ans*base%z; base=(base%z)*(base%z)%z; y&gt;&gt;=1; &#125; return ans;&#125;int main()&#123; ll a,p; while(cin&gt;&gt;p&gt;&gt;a) &#123; if(p==0&amp;&amp;a==0) break; if(isok(p)) puts(&quot;no&quot;); else &#123; ll s=poww(a,p,p); if(s%p==a) puts(&quot;yes&quot;); else puts(&quot;no&quot;); &#125; &#125; return 0;&#125; 除去快速幂，基本上可以算是一道水题了，看代码应该都是可以看懂的。]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>Useful</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[终于搭好了]]></title>
    <url>%2F2019%2F03%2F26%2Fmy-blog%2F</url>
    <content type="text"><![CDATA[经过令我吐血的过程，终于是磕磕绊绊的搭好了一个白生生的博客。这是第一篇，就用来纪念这个伟大的时刻吧！还是决定简单的总结一下自己搭建的过程吧。从寒假知道可以自己搭建博客以来，就一直在百度谷歌相关的东西。刚开始看到域名注册，虚拟主机一类什么高深的东西，显然不适合我这个小白。然后就看到了github——很强大的一个网站，具体是什么作用我也不很清楚，但是用这个可以搭建一个自己的博客网站，并且是不收费的。一直搜索，又安装了各种各样的软件，结果当然是失败了。结果就是，启动：绝地求生。。。寒假开学之后，空余时间又看到了个人博客，很是羡慕别人，于是自己也想搭一个。于是我又开始了漫长的搜索，网上的好多教程大多数我都是看不懂的。。。毕竟电子竞技，菜是原罪。为此我还专门跑到学校图书馆找了一本书《GitHub入门到实践》，然后用自己的智商生生地把它读成了《Github从入门到放弃》。已经花费了这么多时间，自然是很不甘心的，我还是死磕着，鬼知道我经历了什么。“安装，卸载，安装，卸载。。。。。。”还有昨天晚上git下载模板用了四十分钟下载了2％，直到寝室熄灯下载还不到10％，气的我直接关掉了电脑。今天一上午的课都没好好听，一有时间就用手机搜索github搭博客的教程。中午回到寝室吃了饭就继续死磕，午休时间过去了，我下午没有课，室友有课，我一个人在寝室不停的找方法，找教程。“功夫不负有心人”，我成功了。但是我的博客的搭建却更多归功于我的一个学长学霸（手动@亦往沧劫:stuck_out_tongue_winking_eye:，就这样），我自己实在折腾不出来了，就去找学长求助。最终在学长和学长博客的帮助下，我才搭好了。万分感谢！最后还是总结一下我搭好博客的过程吧，防止今后再想搭却不会的情况，如果可能的话，也尽量帮一下想搭博客却不知道怎么做的小小白吧。我的系统是windows的。总结教程大部分的内容来自我的学霸学长他的搭建博客教程传送门:https://blog.todest.cn/post/hexo-next%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/ 下面我来用我的语言和我的想法以及我在搭建过程中出现的问题总结一下=1.首先当然是需要注册一个github的账号（传送门：github），这个注册我觉得不用详细的说，会用电脑的应改就会注册。注册好之后创建一个新的仓库，创建的时候repositort name必须保持格式&lt;username&gt;.github.io（username就是你的github账号的名字）。2 .创建成功之后，先不要管这里了。去下载git（传送门：git），Node.js（传送门：Node.js），安装的时候好多勾勾怎么选我也不是很清楚，咳咳咳，不过相信我，这不是很重要:sweat_smile::sweat_smile::sweat_smile:。3.该安装的东西都安装后，就该要配置SSH（传送门：SSH）了。打开git bash，在弹出来的框框里输入1ssh-keygen -t rsa -C &quot;邮件地址&quot; # 连续回车 邮件地址就是你注册github时候用到的邮箱。连续回车一定要有哦:grin:。然后将&quot;C:\Users\你的用户名\.ssh\id_rsa.pub&quot;的内容复制下来，打开GitHub设置-&gt;SSH and GPG keys-&gt;New SSH key（注意这里的设置是整个网站的设置，不是仓库里面的那个设置！！！），粘贴到此处确定。继续向框框内输入1ssh -T git@github.com 以测试SSH是否配置好，如果看到You&#39;ve successfully authenticated, but GitHub does not provide shell access.,就说明配置好了。4.接下来需要安装hexo，讲道理代码应该输入在git bash的框框里，可是我在安装的时候可能是因为有些勾勾没选所以在git bash中无法使用此命令,但是在cmd命令中可以正常使用。1npm install hexo-cli -g 这个命令是用来安装hexo的。安装好之后要初始化1hexo init Blog 这里的Blog是自己可以随意命名的，对应的会是在你的电脑中生成的文件夹的名称。初始化完成后，安装hexo扩展123cd Blog #进入Blog文件夹npm install hexo-deployer-git --savenpm install 把上面的代码输入命令行，等到下载完就可以下一步了。5.本地调试。123hexo cleanhexo g # 生成 此条和后一条可简写为 hexo s -g（g是generate的缩写）hexo s # 预览（s是start的缩写） hexo s是开启本地预览服务，打开浏览器访问 http://localhost:4000 即可看到内容。6.上传到GitHub pages。123hexo cleanhexo g # 此条和后一条可简写为 hexo d -ghexo d #（d是deploy的缩写） 等这些都完成得时候，你的博客也就基本上搭建完了，你可以自己去访问自己的博客了。当然我这里提到的只有最基础的搭建，具体还有更多的知识，我也在慢慢学习，并且愿意用博客记录这段历程。毕竟这是第一次博客，可能食用体验较差，望见谅。 用女神纪念-]]></content>
      <categories>
        <category>Tutorial</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十届蓝桥杯]]></title>
    <url>%2F2019%2F03%2F26%2FLanQiao%2F</url>
    <content type="text"><![CDATA[上一年的十二月份报了名的蓝桥杯，今天如期举行。原题：PDF版提取码：xc2kWORD版提取码：w4go早上要六点半在教学楼门口集合一起做大巴去赛点——河南科技学院。因为是周日，大早上的起来没几个人，校园里空荡荡的。准备好后就出发了，这个大巴的座非常舒服，去的路上风景也很好，心里既有害怕又有期待，第一次出去打比赛。 风景大好，去的路上我们也都聊得很开心。到了学校看到河南科技学院的大门还是比较震撼的，很高的门。并没有想象中的人山人海的感觉。机房里面气氛也很轻松。到了十一点多，负责人给我们发“午饭”。。。没人一根火腿，两个面包，一瓶水（水还没给我发，可能是因为我太菜，水都某的喝。这份300快的午餐还是很“丰盛”的嘛。比赛期间就一直听负责人说能提交的赶紧提交，有的电脑已经中了病毒。。。比赛完下午一点，本来好像是要直接走的，可是因为有些同学的电脑中了病毒，要进行延时，所以我们获得了差不多一个小时的活动时间。中间还叫上了一个本校的小姐姐给我们拍了合影嘻嘻。于是转了转学校周围吃了点饭，就出发回来了。挺充实的一天，再说一下题目吧。可能是连题都没看太懂，总觉得有点简单，基本上都能写出来，但是超时应该还是会有的。等以后真题可以看到了，就在这里补题就完事了。上面那三张照片是真好看，不过这肯定跟拍照的人没关系，肯定没有，没有（疯狂暗示。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不翻墙使用谷歌搜索的方法]]></title>
    <url>%2F2019%2F03%2F26%2FGoogle-search%2F</url>
    <content type="text"><![CDATA[好多朋友看见我用谷歌搜索就问我是怎么翻墙的，其实如果只是想使用Google搜索的是不需要翻墙的(单纯是为了翻墙的自己去了解一下各大VPN吧）。我把我能用谷歌搜索的过程跟大家分享一下。我用的软件 emm，神奇的是这个好像又可以直接添加插件了。。。一个小哥哥(@Faye)如是说:打开谷歌浏览器，点击右上角的三个点，进入菜单。找到更多工具选项，扩展程序就在那里面。点击进入页面后后，在右上角有一个开发者模式，点击打开。再把下载的CRX格式的插件文件用鼠标拉到扩展程序的页面，再在弹出的窗口中点击“添加扩展程序”，插件就安装上去了(๑•̀ㅂ•́)و✧(这颜文字用的，想撩他的联系我 不行的话就往下看吧。 Google Chrome(这个大家可以去直接搜索会有可以下载的) 插件伴侣 提取码：dmom 谷歌访问助手的插件 提取码：virl应该是每个浏览器都会有相应的插件，有需要的请自己去找，我在这里只提供chrome的相关软件。为什么需要插件伴侣：谷歌浏览器自Chrome67版本以后，我们从第三方下载站，自己下载插件文件，然后拖放到浏览器安装。这种方式，已经被谷歌官方禁止了！将上面两个软件下载之后并解压，文件夹里面的东西留好。找到点击打开之后，会出现以下的界面点击选择插件，找到自己下载的访问助手的插件开始安装注意下面会有一个isearch插件默认是安装的，不想要的话可以把勾点掉。安装的时候是需要退出浏览器的然后点击安装就成功了下面就是打开你的google浏览器，按照提示一步一步走下去就行，因为我之前已经安装过了，下面这些简单的步骤就不再赘述了。安装成功的效果如果安装步骤出现问题或者不知道该怎么做，我分享的压缩包里有一个pdf文件里面有比较详细的内容，可以参考一下。至此，你就可以愉快的使用谷歌搜索了，还有G-mail之类的都慢慢的探索吧，并且可以添加更多的插件来提高你的体验感。以上这种方法在pc端可以实现。 另外，http://www.hlhmf.com/谷歌镜像，可以直接使用谷歌搜索，手机电脑均可用。]]></content>
      <categories>
        <category>Tutorial</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[删除字符串中的子串]]></title>
    <url>%2F2019%2F03%2F26%2FPTA7-29%2F</url>
    <content type="text"><![CDATA[前段时间的一次选拔赛中遇到了这道题，没做出来。赛后搜索了一下相关的知识，发现有许多相应的函数可以直接用来做这道题。 PTA7-29 删除字符串中的子串题目链接：删除字符串中的子串 题目描述输入2个字符串S1和S2，要求删除字符串S1中出现的所有子串S2，即结果字符串中不能包含S2。 输入格式：输入在2行中分别给出不超过80个字符长度的、以回车结束的2个非空字符串，对应S1和S2。 输出格式：在一行中输出删除字符串S1中出现的所有子串S2后的结果字符串。 输入样例：Tomcat is a male ccatatcat输出样例：Tom is a male 题意分析这道题还是比较容易懂的，就是输入两个字符串S1，S2，将S1中出现的S2全部删掉即可，需要注意的是有可能删掉一个S2之后会出现一个新的S2（如样例），此时就需要再删除一次。因为输入是有空格的，所以不能直接cin。 代码实现12345678910111213141516#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; string a,b; getline(cin,a); getline(cin,b); while(a.find(b,0)!=-1) &#123; int p=a.find(b,0); a.erase(p,b.size()); &#125; cout&lt;&lt;a&lt;&lt;endl; return 0;&#125; 知识（补）不搜这道题都不知道string类型中也有这么多方便好用的函数，特此把这些常用的函数在我的博客总结一下，方便自己记忆。 原帖链接：十个你一定会用到的 C++ string 函数 赋值将字符串2赋值给字符串1： 字符串1 = 字符串2; 字符串1.assign(字符串2);1234567string s1=&quot;Drew&quot;,s2;s2=s1;cout&lt;&lt;s2&lt;&lt;&quot; &quot;;s2=&quot;is handsome&quot;;s1.assign(s2);cout&lt;&lt;s1;//运行结果：Drew is handsome 将字符串2从第m个字符开始的n个字符赋值给字符串1：字符串1.assign(字符串2, m, n);123456string s1=&quot;Uncle &quot;,s2=&quot;drew&quot;;s1.assign(s2,1,3);cout&lt;&lt;s1&lt;&lt;endl;cout&lt;&lt;s2;//运行结果：rew// drew 长度返回字符串长度： 字符串1.length(); 字符串1.size();123string s1=&quot;Uncle&quot;,s2=&quot;drew&quot;;cout&lt;&lt;s1.length()&lt;&lt;&quot; &quot;&lt;&lt;s2.size();//运行结果：5 4 比较&quot;&gt;&quot;, &quot;&lt;&quot;, &quot;==&quot;, &quot;&gt;=&quot;, &quot;&lt;=&quot;均可以用于字符串比较。这个不需要例子了。直接比较就可以 查找在字符串1中从第m个字符开始查找字符串2，返回第一次出现的首字母位置，失败时返回-1：字符串1.find(字符串2, m);123456789string s1=&quot;Uncle_drew!Uncle_drew!Uncle_drew!&quot;,s2=&quot;drew&quot;;int pos=-1;while(1)&#123; pos = s1.find(s2,pos+1); if(pos==-1) break; cout&lt;&lt;pos&lt;&lt;&quot; &quot;;&#125;//运行结果：6 17 28 在字符串1中从第m个字符开始从后向前查找字符串2，返回第一次出现的首字母位置，失败时返回-1：字符串1.rfind(字符串2, m);123456789string s1=&quot;Uncle_drew!Uncle_drew!Uncle_drew!&quot;,s2=&quot;drew&quot;;int pos=s1.size();while(pos)&#123; pos = s1.rfind(s2,pos-1); if(pos&lt;0) break; cout&lt;&lt;pos&lt;&lt;&quot; &quot;;&#125;//运行结果：28 17 6 连接将字符串2接到字符串1尾部： 字符串1.append(字符串2); //字符不可 字符串1 += 字符串2; //字符亦可1234567string s1=&quot;Uncle_&quot;,s2=&quot;drew is handsome&quot;;string s3=s1,s4=s2;s1.append(s2);cout&lt;&lt;s1&lt;&lt;&quot;\t&quot;;s3+=s4;cout&lt;&lt;s3;//运行结果：Uncle_drew is handsome Uncle_drew is handsome 将字符串2从第m个字符开始的n个字符接到字符串1尾部：字符串1.append(字符串2, m, n);1234string s1=&quot;Uncle&quot;,s2=&quot;drew is handsome&quot;;s1.append(s2,4,15);cout&lt;&lt;s1;//运行结果：Uncle is handsome 交换字符串1.swap(字符串2);1234string s2=&quot;Uncle &quot;,s1=&quot;drew is handsome&quot;;s1.swap(s2);cout&lt;&lt;s1&lt;&lt;&quot;\t&quot;&lt;&lt;s2;//运行结果：Uncle drew is handsome 子串返回字符串1从第m个字符开始的n个字符所组成的子串：字符串1.substr(m, n);123456string s1=&quot;Uncle &quot;,s2=&quot;drew is handsome&quot;;string s3,s4;s3=s1+s2;s4=s3.substr(6,20);cout&lt;&lt;s3&lt;&lt;&quot;的一个子串： &quot;&lt;&lt;s4;//运行结果：Uncle drew is handsome的一个子串： drew is handsome 替换在字符串1中删除从m开始的n个字符，然后在m处插入串s2字符串1.replace(m, n, s2);123456string s1=&quot;Uncle &quot;,s2=&quot;drew is not handsome&quot;;string s3=&quot;so&quot;,s4=&quot;not&quot;;int pos=s2.find(s4);s2.replace(pos,s4.size(),s3);cout&lt;&lt;s2;//运行结果：drew is so handsome 插入在字符串1的第m个字符处插入字符串2：字符串1.insert(m, 字符串2);12345string s1=&quot;Uncle &quot;,s2=&quot;drew is handsome&quot;;string s3=&quot;so &quot;;s2.insert(s2.find(&quot;handsome&quot;,0),s3);cout&lt;&lt;s2;//运行结果：drew is so handsome 删除从字符串1的第m个字符开始，删除n个字符：字符串1.erase(m, n);1234string s1=&quot;Uncle &quot;,s2=&quot;drew is not handsome&quot;;s2.erase(s2.find(&quot;not&quot;),4);cout&lt;&lt;s2;//运行结果：drew is handsome c语言中的string.h中也有许多对字符数组操作的函数，先记着吧。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础dfs之Lake Counting]]></title>
    <url>%2F2019%2F03%2F26%2FPOJ-2386%2F</url>
    <content type="text"><![CDATA[这道题是寒假时候做的，当时是看着书写的，所以印象不是很深，写进博客加深一下自己的印象，顺便尽可能的帮助一下与我一样的小小白。 POJ 2386 Lake Counting题目描述Lake CountingTime Limit: 1000MS Memory Limit: 65536K Due to recent rains, water has pooled in various places in Farmer John&#39;s field, which is represented by a rectangle of N x M (1 &lt;= N &lt;= 100; 1 &lt;= M &lt;= 100) squares. Each square contains either water (&#39;W&#39;) or dry land (&#39;.&#39;). Farmer John would like to figure out how many ponds have formed in his field. A pond is a connected set of squares with water in them, where a square is considered adjacent to all eight of its neighbors. Given a diagram of Farmer John&#39;s field, determine how many ponds he has.Input Line 1: Two space-separated integers: N and M Lines 2..N+1: M characters per line representing one row of Farmer John&#39;s field. Each character is either &#39;W&#39; or &#39;.&#39;. The characters do not have spaces between them.Output Line 1: The number of ponds in Farmer John&#39;s field.Sample Input 1234567891011121310 12W........WW..WWW.....WWW....WW...WW..........WW..........W....W......W...W.W.....WW.W.W.W.....W..W.W......W...W.......W.Sample Output3 Hint OUTPUT DETAILS: There are three ponds: one in the upper left, one in the lower left,and one along the right side. 大意分析，题目中让我们求“水洼”的个数，W表示有水，.表示无水，有水的周围八个方向内有水都算成是一个水洼。样例中的三个水洼可以加强对题意的理解。因为需要对每一个状态进行查询，所以这里我们需要用到dfs。代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;char p[105][105];int d[8][2]=&#123;0,1, 0,-1, 1,0, -1,0, 1,1, 1,-1, -1,1, -1,-1&#125;;//方向变量的定义，周围八个方向。int m,n,sum;void dfs(int x,int y)&#123; if(x&gt;=0&amp;&amp;y&gt;=0&amp;&amp;x&lt;n&amp;&amp;y&lt;m)//判断每次进行递归的时候x和y是否还在合理的范围内，否则直接退出当前循环。 &#123; if(p[x][y]==&apos;W&apos;) &#123; p[x][y]=&apos;.&apos;;//把查询到的W(有水)变成.(无水)。 for(int i=0;i&lt;8;i++) dfs(x+d[i][0],y+d[i][1]);//对每个有水地方的八个方向进行dfs，用来向下一步递归 &#125; &#125;&#125;int main()&#123; sum=0; cin&gt;&gt;n&gt;&gt;m; getchar(); for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;m;j++) &#123; cin&gt;&gt;p[i][j];//存图 &#125; getchar(); &#125; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;m;j++) &#123; if(p[i][j]==&apos;W&apos;)//从0，0开始，查询到W就开始dfs。 &#123; dfs(i,j); sum++;//每次dfs完回来之后，及说明与i，j相邻的水地没有了，所以水洼的数量加一 &#125; &#125; &#125; cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125; 参考白书之后，发现如果是八个方向的话，可以不用方向向量而是使用两层循环12345678for(int i=-1;i&lt;=1;i++) for(int j=1;j&lt;=1;j++) &#123; int nx=x+i; int ny=y+j; …… dfs(nx,ny); &#125; 这个就看个人喜好了。 我的个人喜好？]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[德鲁大叔学编程搭建基本完成]]></title>
    <url>%2F2019%2F03%2F26%2Fpoint%2F</url>
    <content type="text"><![CDATA[经过了将近十天时间的折腾，各种各样的查阅资料，各种骚扰麻烦学长，终于是差不多像样了。这期间花费了大量时间，作业都不写了，有点太丧心病狂。结果还是不错的，哈哈。 一些还没解决但是还在想解决办法(没什么大问题)的待办项 把离家出走的DaoVoice小图标找回来(昨天应该是DaoVoice哪里出了一些问题，今天它自己回来了) [] 添加收款码可以预览的功能 让谷歌收录我的网站！！！ 实现彩色标签主要遇到的问题基本上是由next主题的版本引起的，这个还是比较忧伤的，教程中的next版本跟我的不一样，好多东西要摸索着来。重点就是站点配置文件以及主题配置文件应该好好看看，很有帮助。 与刚搭建好的对应：]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记]]></title>
    <url>%2F2019%2F03%2F26%2FNotes%2F</url>
    <content type="text"><![CDATA[算法协会的学长们给我们每周一次的授课，在此总结一下。（之前就总结过，现在誊到博客上）。 第一次训练第一次训练主要讲了一下基础的东西。 时间复杂度 时间复杂度栈和队列 栈和队列 栈 First in last out(FILO) 1.栈的头文件 #include&lt;stack&gt; 2.栈的定义 stack&lt;变量类型(int,char...)&gt; s(栈的名字可以自定义) 3.常用函数 s.pop() 删掉栈顶的元素 s.top() 返回值为栈顶元素的值 s.push() 向栈中输入新的元素 队列 First in first out(FIFO) 1.队列的头文件#include&lt;queue&gt; 2.队列的定义 queue&lt;变量类型(int,char...)&gt; q(队列的名字可以自定义) 3常用函数 q.pop() 删掉队列最前面的元素 q.front() 返回值为栈顶元素的值 q.push() 在队尾压入新元素 q.back() 返回值为队列最后一个元素栈和队列的通用函数 栈和队列的通用函数 q/s.empty() 如果栈(队列)为空返回true，否则返回false q/s.size()返回栈(队列)中元素的个数 sort排序(默认为升序)1234567891011121314#include&lt;bits/stdc++.h&gt; //sort的头文件为algorithm,此处的头文件为万能头文件using namespace std;int main()&#123; int n,a[100]; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; sort(a,a+n); for(int i=0;i&lt;n;i++) cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; puts(&quot;&quot;); return 0;&#125; 若想更改成降序排列，需要添加一个自定义函数123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;bool cmp(int a,int b) //变成降序&#123; return a&gt;b;&#125;int main()&#123; int n,a[100]; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; sort(a,a+n,cmp); for(int i=0;i&lt;n;i++) cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; puts(&quot;&quot;); return 0;&#125; 2018-11-30 第二次训练第二次训练主要讲了二分查找，二分答案等。 二分法的使用条件 答案区间上下限确定，即最终答案在哪个范围是容易知道的。 检验某值是否可行是个简单活，即给你个值，你能很容易的判断是不是符合题目要求。 可行解满足区间单调性，即若x是可行解，则在答案区间内x+1（也可能是x-1）也可行。几个关于二分查找的函数因为二分查找的显著优越性，c++的库中封装了几个于二分查找有关的函数。1231.lower_bound(起始地址，结束地址，要查找的数值) 返回的是大于或等于val的第一个元素位置。2.upper_bound(起始地址，结束地址，要查找的数值) 返回的是大于val的第一个元素位置。3.binary_search(起始地址，结束地址，要查找的数值) 返回的是是否存在这么一个数，是一个bool值。 第三次训练第三次训练我们讲了一些特殊容器(STL)的用法.(stl内容太复杂了,我就先不总结了，以后补上） 快速幂(自学)代码实现12345678910 int poww(int a,int b)&#123; int ans=1,base=a; while(b!=0)&#123; if(b&amp;1!=0)//判断每次循环a的奇偶 ans*=base; base*=base; b&gt;&gt;=1;//去除b的二进制数中的最后一位 &#125; return ans;&#125; 快速幂的时间复杂度： O(log₂N)]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>c/c++</tag>
        <tag>Useful</tag>
        <tag>Tutorial</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[德鲁大叔观后感]]></title>
    <url>%2F2019%2F03%2F26%2Fmoive-feeling-Uncle_drew%2F</url>
    <content type="text"><![CDATA[德鲁大叔 第一次听说德鲁大叔这个词是某可乐的广告，刚刚沉迷于篮球的我，在网上把几部广告都看完了。讲的是我欧文和NBA的球星换上老人妆去街球场扮猪吃老虎的故事。广告毕竟是短的，但是还是能体现出欧文的骚气的哈哈。 然后经听说了欧文拍摄了这部电影，还是很期待的，但是网上各种消息说内地是不会上映的，两分钟的宣传片不知道看了多少遍。应该是上年的十月份左右吧，这部电影上映了，果然内地没有，在网上各种找资源啊，一开始还没有，过了一两个月，慢慢的找到了资源，刚找到的那天我第一次在学校熬夜了，熬夜看完了这部电影，怎么会有这么好看的电影，这是我的第一感觉，满满的都是震撼，我都不知道该怎么去描述。通过一场球赛映射出慢慢的人生道理，让我对欧文的崇拜愈发加深。那一晚我截下了好多精彩照片，但是由于特殊原因丢失了，但是德鲁大叔这部电影在我的手机和电脑上都有存着。用痴迷来形容我是很贴切的，一有时间就看那部电影，现在我还能回忆起来那部电影从开头到结尾的每一帧画面，每一句经典的台词。上学期英语老师组织电影配音，我毫不犹豫地选择了这部电影，哈哈毕竟喜欢。 最振奋人心的就是又过了一段时间，有消息说要在内地上映了，我没去看首映，不想自己一个人去看的。可是第二天我没忍住还是去看了，但我买了两张票，我幻想着她就在我身边跟我一起看。整个放映厅除了我没别人了，真的感觉的不值，真正有意义的电影没人看。 这部电影讲的就是一个因为年少时一次失误的篮球少年从打球到教练并且赌上自己的一切想要获得洛克公园的冠军的故事，但是他的死对头夺走了他的球队还有他的女友。他开始到处去寻找组建自己新的球队，却到处碰壁，接着他遇见了德鲁大叔，在整部电影里如神一般的存在，德鲁大叔带着他一起找回当年的队友，准备拿回当年因为特殊原因失去的冠军，中间历经很多磨练，最后由篮球少年的一次绝杀夺得了冠军正好与他年少时的失误有了一个对比。剧情虽然简单，甚至有点狗血，但我觉得只要是我们打球的人都会感动，眼酸。成长就行一场球赛，总会有许多的磕磕绊绊，但是我们能做的只有克服它，迎难而上。 其实关于这部电影感触这么深还是因为篮球吧，高二开始接触篮球，现在已经三年了，时间虽然不长，但是它的魅力早就深深的吸引住了我，甚至不再允许我有其他的爱好了，因为时间都想给它。晚上不吃饭去打球，中午不睡觉去打球，逃课打球，不开心时打球，高兴时打球，它能治愈你所有的负面状态，每次都仿佛打不完，打完球回到教室趴在座位上睡一觉，这种日子已经一去不复返了。 有句话很对：无篮球不兄弟，因为篮球我结识了我最好的兄弟，也认识了很多有趣的人。可能你们本不认识，但在球场上一起打一次球就会很熟了。我喜欢篮球，感谢它带给我的一切。我喜欢的台词 It&#39;s like a perfectly orchestrated symphony. 打篮球就像演奏一首精心编排的交响乐 And what&#39;s in it for you? Love,yongblood.Only love. 那你是为了什么打篮球？ 热爱，小伙子，只有热爱。 It&#39;s getting to be about that time,ain&#39;t it? 是时候展现真正的技术了 不是吗？ There&#39;s a fine line between confidence and arrogance. 自信与自大 界限分明 This game is all mental.All mental. 篮球运动关乎精神状态 精神状态 Hand down,man down 真是手起刀落 Once a shooter,always a shooter. 一朝为投手 终身是投手 You don&#39;t stop playing &#39;couse you get old.You get old &#39;cause you stop playing. 你不是因为老了才不打球，而是你决定不打球的那一刻，你才是真的老了。 Nothing a few Ws can&#39;t fix. 没有什么是赢点球解决不了的 Play the game the right way,it fixs everything. 用最恰当的方式打一场比赛 会修复一切 What&#39;s there not to love? 篮球有让人不爱上的理由吗 Basketball&#39;s the most reliable thing in the world.Don&#39;t complain,don&#39;t ask any questions.You bounce it,comes right back up. 篮球是世界上最可靠的东西 不要抱怨 也不要问任何问题 你运球 然后它弹回你手里 唯她，篮球与兄弟不可辜负。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[祝某凡生日快乐]]></title>
    <url>%2F2019%2F03%2F26%2FImportant%2F</url>
    <content type="text"><![CDATA[今天我姐某凡生日快乐，22了，永远18！(手动滑稽，祝她生日快乐。记住了今天！！！]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[离散数学程序作业]]></title>
    <url>%2F2019%2F03%2F26%2FDiscrete-mathematics%2F</url>
    <content type="text"><![CDATA[我们离散数学课的老师布置了相关的程序作业，我将在这里分享我的作业答案以及想法。 第一章作业能够输入五个连接词符号据说这些个符号也可以在各种输入法的表情符号里找到，那样时会很方便哈！下面我来总结一下我发现的方法123∧ 合取 unicode十六进制：2227∨ 析取 unicode十六进制：2228¬ 非 unicode十六进制：00AC(不区分大小写) Ascii十进制： 172 以上三种符号均可以在进入WPS后点击菜单栏的插入--符号--其他符号选项中进行添加，自己找这些符号也可以在弹出的框框里面选择编码以及对应的值直接搜索到。12↔ 等价 → 蕴涵 以上两种符号可以在插入--公式--插入新公式中找到。示例是在word里面进行的，经我测试ppt中操作是一样的，但是在excel中插入新公式我也不知道为什么不能点，可以直接从word/ppt复制粘贴。 判断是否为合式公式 这个问题有好多方法，递归，栈，数什么高深的东西，但显然我这种小小白是绝对做不出来的，当然只能用暴力的方法了，咳咳，那谁不是曾经说过吗，暴力出奇迹。python还不是很熟悉，我先用c++来实现。 我的方法是遍历字符串中的每一个字符，通过对不同情况的分析，进行分类处理。 我们来看看这个问题，要判断是否为合式公式，那我们首先应该了解一下何为合式公式。 合式公式：将命题变项用联结词和圆括号按照一定的逻辑关系联结起来的符号串称为合式公式。 由于这几个符号的输入比较麻烦，我们这里做一下简单的替换 &amp; 合取 | 析取 ! 非 - 蕴含 = 等价例如p&amp;q !p !(p&amp;q)&amp;s|r均为合式公式，而qwp q&amp;&amp;d等均不是合式公式。代码实现(具体分情况请参考注释)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;using namespace std;char s[100000];int main()&#123; bool flag; scanf(&quot;%s&quot;,s); flag=1;//定义一个布尔类型的变量，初始赋值为1，代表是合式公式，每种条件下的判断中若发现不是合式公式，就改变flag的值为0，代表不是合式公式。 if(s[0]==&apos;)&apos;||s[0]==&apos;&amp;&apos;||s[0]==&apos;-&apos;||s[0]==&apos;=&apos;||s[0]==&apos;|&apos;)//若第一个字符就是联结词或者右括号，显然不是合式公式。 &#123; puts(&quot;Not well formed!&quot;); return 0; &#125; for(int i=0;i&lt;strlen(s);i++)//这里的这种情况判断的是如果有两个字母（即原子命题）在一起，显然也不是合式公式。 &#123; if(s[i]&gt;=65&amp;&amp;s[i]&lt;=90||s[i]&gt;=97&amp;&amp;s[i]&lt;=122) &#123; if(s[i+1]&gt;=65&amp;&amp;s[i+1]&lt;=90||s[i+1]&gt;=97&amp;&amp;s[i+1]&lt;=122) &#123; puts(&quot;Not well formed!&quot;); return 0; &#125; &#125; &#125; for(int i=1;i&lt;strlen(s);i++)//这里的这种情况判断的是如果有两个联结词（不包括非）在一起，显然也不是合式公式。 &#123; if(s[i]==&apos;&amp;&apos;||s[i]==&apos;|&apos;||s[i]==&apos;-&apos;||s[i]==&apos;=&apos;) &#123; if(s[i+1]==&apos;&amp;&apos;||s[i+1]==&apos;|&apos;||s[i+1]==&apos;-&apos;||s[i+1]==&apos;=&apos;||s[i-1]==&apos;&amp;&apos;||s[i-1]==&apos;|&apos;||s[i-1]==&apos;-&apos;||s[i-1]==&apos;=&apos;) &#123; flag=0; break; &#125; &#125; else if(s[i]==&apos;!&apos;)//如果非后面加的是联结词，显然也不是合式公式。 &#123; if(s[i+1]==&apos;&amp;&apos;||s[i+1]==&apos;|&apos;||s[i+1]==&apos;-&apos;||s[i+1]==&apos;=&apos;) &#123; flag=0; break; &#125; if(s[i+1]==&apos;!&apos;||s[i-1]==&apos;!&apos;)//如果几个非连在一起可以看成是一个。 break; else if(s[i+1]&gt;122||s[i+1]&lt;65) &#123; flag=0; break; &#125; else if(s[i+1]&gt;90&amp;&amp;s[i+1]&lt;97)//此处判断的是非后面是否加的是原子命题。 &#123; flag=0; break; &#125; &#125; &#125; stack&lt;char&gt; sta;//设定一个栈用来检测左右括号的匹配性。 for(int i=0;i&lt;strlen(s);i++) &#123; if(s[i]==&apos;)&apos;&amp;&amp;sta.empty())//如果是右括号且此时栈空（说明此右括号的前面没有与之配的左括号，所以不是合式公式）。 &#123; flag=0; break; &#125; if(s[i]==&apos;(&apos;)//如果是左括号就入栈。 &#123; sta.push(s[i]); &#125; if(s[i]==&apos;)&apos;&amp;&amp;!sta.empty())//如果是右括号，且栈不空就将栈顶的左括号除去。 &#123; sta.pop(); &#125; &#125; if(!sta.empty())//如果字符串循环完毕且栈中还有元素，说明有左括号不存在与之对应的右括号，即不为合式公式。 flag=0; if(flag) puts(&quot;Well formed&quot;); else puts(&quot;Not well informed&quot;); return 0;&#125; 求合式公式的层次给出任意命题公式的成真赋值给出任意命题公式的成假赋值判断任一命题公式的公式类型]]></content>
      <categories>
        <category>Discrete mathematics</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>python</tag>
        <tag>Discrete mathematics</tag>
        <tag>WPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[河南理工大学18级算法协会招新赛(第二场)非官方题解]]></title>
    <url>%2F2019%2F03%2F26%2Fhpuoj%2F</url>
    <content type="text"><![CDATA[3月10日举办了协会的第二次招新赛，为了方(ceng)便(re)广(du)大同学学习，顺便提醒自己要补题，写一下我做题时候的思考以及会的题的思路跟大家分享一下顺便互相学习！毕竟我们小白之间交流还是轻松点（手动滑稽我校oj：HPUOJ本场招新赛：河南理工大学18级算法协会招新赛(第二场) A. wzy学长温暖的签到题题目描述单测试点时限: 1.0 秒 内存限制: 256 MB 每位ACMer（JBer）都是从a+b开始的！作为本场比赛的良心出题人，怎么能忘记出a+b这么经典的题目呢？请作为ACMer的你来尝试解决它吧！ 输入单组输入每行输入两个实数a，b（用空格隔开） 输出输出a+b的结果（结果保留两位小数） 样例input1 1output2.00input1.555 1.001output2.56提示0≤a,b≤100请使用double定义变量，并使用%lf输入和输出 题意分析这道题确实没有什么难得，简单的a+b，很多人也都a了，提示写的明明白白(wzy学长是真的可爱 代码实现12345678#include&lt;stdio.h&gt;int main()&#123; double a,b; scanf(&quot;%lf %lf&quot;,&amp;a,&amp;b); printf(&quot;%.2lf\n&quot;,a+b); return 0;&#125; B. 分糖果题目描述单测试点时限: 2.0 秒 内存限制: 512 MB Codancer 现在有n颗糖果，现在他要把这n颗糖果全部分给两个小朋友Dicer和thelittleboy,已知第i颗糖果能够使小朋友的开心值增加i,为了不让两个小朋友争吵，他必须使两个小朋友最终的开心值的差值最小化，现在Codancer很头疼，请你快来帮帮他吧QAQ。 输入单组输入输入一个数n,代表codancer的糖的数量。(1≤n≤1000000000) 输出输出两个小朋友的开心值的最小差值 样例input3output0input1output1 题意分析输入一个数n，题意就是把从1-n个数分成两组让他们的和的差最小。这道题我看到第一感觉就是找规律，其实规律无非也就哪几种。这道题我们可以列出来几个情况求出来答案来找规律1 2 3 4 5 6 7 8123456789糖果数量 分配方案 最小差值1 1 0 12 1 2 13 1，2 3 04 1，4 2.3 05 1，2，5 3，4 16 1，2，3，5 4，6 17 1，2，5，6 3，4，7 08 4,6,8 1,2,3,5,7 0 现在看起来规律就很明显了，1，1，0，0，1，1，0，0......在找规律的过程中我发现从1到n的和如果是偶数，最小差值就是0，如果是奇数，最小差值就是1.于是我直接定义了一个求和函数后判断奇偶，直接T了。。。其实可以发现1100是四个一组出现的，直接n对4求余判断余数就好了。 代码实现1234567891011#include&lt;stdio.h&gt;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); if(n%4==0||n%4==3) puts(&quot;0&quot;); else puts(&quot;1&quot;); return 0;&#125; 有些题掌握了规律实现起来就会很简单。(什么时候codancer能给我们发糖吃呢 C. 中位数题目描述单测试点时限: 2.0 秒 内存限制: 512 MB 给出一个1−n的排列，统计该排列有多少个长度为奇数的连续子序列的中位数是k。中位数是指把所有元素从小到大排列后，位于中间的数。接下来一行n个数代表这个排列。 输入单组输入一行两个数n,k代表排列的长度以及中位数。(1≤n≤100000,1≤k≤n) 输出输出满足条件的区间个数。 样例input7 45 7 2 4 3 1 6output4提示样例解释：满足条件的区间为{4}, {7,2,4}, {5,7,2,4,3}和{5,7,2,4,3,1,6}。 题意分析这道题刚看见以为是很简单的一道题，WA了几次之后才发现并不简单。最后好像也没几个人做出来这道题。学长讲的时候也没听懂。。咳咳，确实挺难。这两天为了更好的帮(ceng)助(re)大(du)家，这几天也是一直在搞这道题。不断地查阅资料，现在也差不多是搞懂了，快点来帮(ceng)助(re)大(du)家。参考于：洛谷P1627题解中位数说明这个区间内大于他的数的数量与小于他的数的数量相等。且这个题中符合题意的区间顺序是必须与输入一样的，不能更改。先找到中位数的位置标记一下，然后输入的同时对每一个数进行判断，大于中位数的标记为1，小于中位数的标记为-1。然后从中位数的左边开始第一次循环，对标记求和，如果有和为0的情况（即大于中位数的数的数量与小于中位数的数量相等），即说明这是一个符合题意的区间。接着对右边开始第二次循环，与第一次循环相等的步骤，但是要多一步，就是要考虑中位数位于区间中间（不是两端）的情况。具体可以在代码中解释。最后得到的答案还要加一，因为中位数自己一个区间也是可以的。 代码实现123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;int a[100050],flag[100050],f[200050];const int key=100000;int main()&#123; int n,k,bj,s,ans; cin&gt;&gt;n&gt;&gt;k; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; if(a[i]==k) bj=i; else if(a[i]&gt;k) flag[i]=1; else flag[i]=-1; &#125;//进行标记 s=ans=0; for(int i=bj-1;i&gt;=1;i--) &#123; s+=flag[i]; f[s+key]++;//用一个f数组来记录s为为-1，0，1时候的个数 if(s==0) ans++; &#125; s=0; for(int i=bj+1;i&lt;=n;i++) &#123; s+=flag[i]; if(s==0) ans++; ans+=f[-s+key];//中位数在区间中的情况。 &#125; ans+=1; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 咳咳，可以对着样例和代码自己跑一遍可以加深一下理解。 D. 打麻将题目描述单测试点时限: 2.0 秒 内存限制: 512 MB 打麻将实在是太有趣了，不知道大家过年的时候有没有打麻将呢？ 我是十分喜欢打麻将的，但是因为我不够聪明，所以我经常会诈胡(不具备胡牌的条件而胡牌)，因此我希望你能帮我判断一下我当前的手牌是否符合胡牌的条件。 为了简化这个问题，我们规定胡牌的条件如下： 你必须有且仅能有一个对子(即两张相同的牌)。除了那个对子之外，其他的都是刻子(3张相同的牌)。(刻子的数量可以为0)我们用两个字符表示一张麻将： B，T, W 分别表示牌的种类为 筒子，条子，万子 。(可能你不知道这是什么意思，不过没有关系，你只需要知道这三种类型的牌是互不相同的。)数字1~9表示牌上的数字。另外用HZ，FC，BB，EE，WW，SS，NN 来分别表示除了 筒子，条子，万子 以外的 红中，发财，白板，东风，西风，南风，北风 。对于两种牌来说，只要表示它们的两个字符中第一个字符或第二个字符任意一个不同，那么它们就是不同的牌，每种牌最多只有四张。(例如：B1 和 B2，B1 和 T1,HZ 和 FC 都是不同的。)输入第一行是一个数字T，表示你需要判断的次数。(1 \leq T \leq 10000)接下来2*T行，前一行是一个数字 n 是你的手牌数，2≤n≤14，接下来一行有 n 对字符，每一对字符代表你的一张手牌。保证不会有未知的牌型，不会有任何一种牌出现超过四次，但是你的手牌数因为某种原因可能会是正常出牌不能出现的个数。输出如果可以胡牌请输出 YES，否则输出 NO 。 样例input314B1 B1 B1 T1 T1 T1 W1 W1 W1 HZ HZ HZ WW WW2BB BB7BB BB B1 B1 B1 B2 B2outputYESYESNO 题意分析题面看起来很长，但是我们需要学会如何找到有用的信息。这道题我们需要知道的就是我们手中的牌只能有一种是出现了两次，别的牌出现的只能是三次。思路一清晰实现起来就会简单点了。这道题如果按我的方法的话希望大家补一下相关的知识：基础容器之map以及c++中的string(用char数组应该也是可以的，但是string会方便一些)类型。更详细的解释我会加在代码里。 代码实现123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string s[15]; int n,a; cin&gt;&gt;n; map&lt;string,int&gt; ma; while(n--) &#123; ma.clear();//因为是多组输入，所以每次开始时都需要将map清空，避免干扰到下一次的判断。 int flag=1; cin&gt;&gt;a; for(int i=0;i&lt;a;i++) &#123; cin&gt;&gt;s[i]; ma[s[i]]++; &#125; map&lt;string,int&gt;::iterator it; for(it=ma.begin();it!=ma.end();it++) &#123; if(it-&gt;second==1||it-&gt;second==4) &#123; flag=0; break; &#125;//如果有出现一次的或者出现四次的，肯定不能胡牌。 if(it-&gt;second==2) flag++;//判断出现两次的牌的数量。 &#125; if(flag==2)//因为flag定义时的赋值是1，所以如果现在的值是2则说明出项两次的牌（字符串）只有一个，符合条件，可以胡牌。否则就不能胡牌。 puts(&quot;YES&quot;); else puts(&quot;NO&quot;); &#125; return 0;&#125; (咳咳，我还是个麻将“高手”呢， E. 假票题目描述单测试点时限: 2.0 秒 内存限制: 512 MB 春天到了，万物复苏，乍暖还寒。H城为了庆祝春天的到来，将要举办一场盛大的舞会。 由于舞会非常的盛大，H城许多的居民都想参加舞会，但是舞厅大小有限，只能容纳n个人，为了防止到时候位置不够，人太拥挤，H城城主决定在舞会开始前进行售票。城主规定，每个人只能买一张票，每张票都会有其固定的编号（1~n）。但是有一个人，由于没抢到票，居然制造了一张与真票一模一样的假票！城主知道这个消息后，当然不能允许这种行为，因此就派出他最信任的大臣你去找出制造假票的人。 输入多组输入，处理到文件结束 第一行两个数n,m (1&lt;=n&lt;=10000,0&lt;=m&lt;=n+1)，表示总共售出n张票，编号为 1 ~ n，m表示舞会当天到场的人数（注意：由于有些人可能当天有事来不了，这种情况下你可能找不到制造假票的人）。 接下来一行m个数a1,a2,.....,am，表示检票口收到的所有票的编号。 输出如果能找到假票，则输出假票编号，否则输出-1。 样例input5 63 1 4 2 3 55 31 2 4output3-1 题意分析这个题还是比较容易读懂的，就是让你输出一组数中出现了两次的数。我一开始用的是先排序然后判断每一项与它后面那一项是否相等来判断是否有出现两次的，如果有，就将这个数输出，没有就输出-1，但是不知道为什么会WA，于是又改用了map，还好最后过了。 补题排序的那种方法也是可以的，只不过因为是多组输入，因为第一次的输入票的数量如果比第二次输入的多，此时就可能会存在数组中还依然存在着一些上一组的数据，导致结果错误。参考我之前的错误代码发现其中判断是否相等的时候多循环了一次——最后一次，这就会导致WA了。改一下就行了。代码请看下面。（感谢学长哈） 这题我跟小伙伴讨论之后发现用set也是可以的，比较前后的和的大小即可，有兴趣的可以自己实现一下。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;using namespace std;int a[10050];int main()&#123; map&lt;int,int&gt; ma; int n,m,b; while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;m)) &#123; bool flag=1; ma.clear(); while(m--) &#123; cin&gt;&gt;b; ma[b]++; &#125; map&lt;int,int&gt;::iterator it; for(it=ma.begin();it!=ma.end();it++) &#123; if(it-&gt;second==2) &#123; cout&lt;&lt;it-&gt;first&lt;&lt;endl; flag=0; break; &#125; &#125; if(flag) cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl; &#125; return 0;&#125;#include&lt;bits/stdc++.h&gt;using namespace std;int a[10050];int main()&#123; int n,m; while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;m)) &#123; int ans=-1; for(int i=0;i&lt;m;i++) &#123; cin&gt;&gt;a[i]; &#125; sort(a,a+m); for(int i=0;i&lt;m-1;i++) &#123; if(a[i]==a[i+1]) &#123; ans=a[i]; break; &#125; &#125; if(ans!=-1) cout&lt;&lt;ans&lt;&lt;endl; else puts(&quot;-1&quot;); &#125; return 0;&#125; F. 字符串博弈题目描述单测试点时限: 2.0 秒 内存限制: 512 MB 一天Codancer和Todest玩游戏。现在有一个由大写字母组成的字符串s，Codancer和Todest轮流进行一下操作：如果存在i使得s[i]=s[i+1],就可以把这两个字符从s中删除。比如原本s为ABBA,现在可以把BB删除，此时s就变为AA。如果一方不能再执行此操作时，该方即为败者。现在Codancer先手，判断Codancer能否获胜。 输入单组输入输入字符串s。1≤|s|≤10000 输出如果Codancer能够获胜输出”YES”,否则输出”NO”。(不加引号)。 样例inputABBAoutputNO 题意分析我对这道题的理解就是将字符串中相邻且相同的两个字母消掉，消到不能再消，统计消除的次数就是能进行的回合数，再对回合数的奇偶进行判断就可以了。但是消除的实现还是用栈（不会的可以补一下知识，这个我的博客中也有相关的文章不过是偏实用性（就是只讲了几种函数的用法）的）比较轻松。关于栈的传送门：Uncle_drew最帅 代码实现1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;char s[10005];int main()&#123; stack&lt;char&gt; sta; cin&gt;&gt;s; int a=0; for(int i=0;i&lt;strlen(s);i++) &#123; if(i&gt;0) &#123; if(sta.top()==s[i]) &#123; sta.pop(); a++; continue; &#125; &#125; sta.push(s[i]); &#125; if(a%2==0) puts(&quot;NO&quot;); else puts(&quot;YES&quot;);&#125; (Todest很帅的，小学妹们抓住机会，ε=ε=ε=┏(゜ロ゜;)┛ G. 小w的过路费(暂无)H. 超级简单的斐波那契数列题目描述单测试点时限: 1.0 秒 内存限制: 256 MB 众所周知，斐波那契数列又称黄金分割数列，由数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入 斐波那契的通项公式为：计算斐波那契的第n项是一件容易的事，但是如果给出第n项的斐波那契数num，你能反推出n吗？ 试一试吧！ 输入第一行一个整数T (0≤T≤100)，表示测试组数。之后的T行，每行一个斐波那契数num (num≠0,1) 输出对于每个测试数据，输出一行表示数num是斐波那契数列的第几项 样例input225output35提示保证num在斐波那契数列的前200000项中 题意分析一开始我看错题，以为是数列的最大值不超过200000.。。。直接交了3次，WA了3次。。。所以说看题还是很重要的。我们昨天也都听学长说了，斐波(肥波)那契数列第50项已经爆了unsigned long long了。所以我们直接存是不现实的，这时候就需要存储的时候对其取模然后存储，并且用map存储一下每个值对应的斐波(肥波)那契数列的项数。因为输入的数会很大，所以我们需要用到字符串输入，然后用到一个很XX的东西——对字符串表示的大数取模。 代码实现对用字符串输入的大数取模(感谢学长！123456789cin&gt;&gt;s;ll ans,num; ll l=strlen(s);num=0;for(ll i=0;i&lt;l;i++)&#123; num=num*10+s[i]-&apos;0&apos;; num%=maxx;&#125;//num就是这个大数取模之后的结果。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//这道题比赛的时候我是没写出来的，赛后补题。学会了大数取模屁颠屁颠的跑去交题#include&lt;bits/stdc++.h&gt;using namespace std;const int maxx=1e9+7;typedef long long ll;ll f[200050];char s[100000];int main()&#123; map&lt;ll,ll&gt; ma; f[0]=0; f[1]=1; for(ll i=2;i&lt;200001;i++) &#123; f[i]=(f[i-1]+f[i-2])%maxx; ma[f[i]]=i; &#125;//对斐波(肥波)那契数列进行取模存储 ll n; cin&gt;&gt;n; while(n--) &#123; cin&gt;&gt;s; ll ans,num; num=0; for(ll i=0;i&lt;strlen(s);i++) &#123; num=num*10+s[i]-&apos;0&apos;; num%=maxx; &#125; cout&lt;&lt;ma[num]&lt;&lt;endl; &#125; return 0;&#125; //然后TLE了。。。观察一下(hao jiu)代码会发现我在大数取模的for循环里面每次都对s的长度重新求一次，这样是很耗费时间的，自然会tle，改一下就好#include&lt;bits/stdc++.h&gt;using namespace std;const int maxx=1e9+7;typedef long long ll;ll f[200050];char s[100000];int main()&#123; ios::sync_with_stdio(false); map&lt;ll,ll&gt; ma; f[0]=0; f[1]=1; for(ll i=2;i&lt;200001;i++) &#123; f[i]=(f[i-1]+f[i-2])%maxx; ma[f[i]]=i; &#125; ll n; cin&gt;&gt;n; while(n--) &#123; cin&gt;&gt;s; ll ans,num,l; l=strlen(s);//先把长度求出来，用的时候直接用 num=0; for(ll i=0;i&lt;l;i++) &#123; num=num*10+s[i]-&apos;0&apos;; num%=maxx; &#125; cout&lt;&lt;ma[num]&lt;&lt;endl; &#125; return 0;&#125; 取模的部分也可以这样写 for(ll i=0;i&lt;s.length();i++) &#123; num=num*10+s[i]-&apos;0&apos;; num%=maxx; &#125; I. 斐波那契（非递归）题目描述单测试点时限: 2.0 秒 内存限制: 512 MB 请输出斐波那契的第n项 输入多组输入处理到文件结束，每组输入一个数n。1≤n≤10000 输出输出第n个斐波那契数对109+7取模的结果 样例input34output23 题意分析简单的斐波(肥波)那契数列问题，与J题差不多，不过加了取模。直接代码就行了。 代码实现12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;typedef long long ll;const int maxn=1e9+7;ll f[10005];int main()&#123; f[0]=0; f[1]=1; for(int i=2;i&lt;10001;i++) &#123; f[i]=f[i-1]+f[i-2]; f[i]=f[i]%maxn; &#125;//打表 int a; while(~scanf(&quot;%d&quot;,&amp;a)) &#123; cout&lt;&lt;f[a]&lt;&lt;endl; &#125; return 0;&#125; J. 斐波那契数列题目描述单测试点时限: 2.0 秒 内存限制: 512 MB 请输出斐波那契的第n项 输入单组输入每组输入一个数n。0≤n≤10 输出输出斐波那契数列的第n项 样例input0output0input1output1 题意分析妥妥的签到 代码实现123456789101112131415#include&lt;stdio.h&gt;int a[15];int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); a[0]=0; a[1]=1; for(int i=2;i&lt;=10;i++) &#123; a[i]=a[i-1]+a[i-2]; &#125;//打表 printf(&quot;%d\n&quot;,a[n]); return 0;&#125; 咳咳，写这个“题解”，我是为了帮助同学，没有骗访问量没有没有。有不懂的可以直接qq我或者网页右下角有一个可以实时联系我的小框框你们可以直接跟我聊天，看见就会回复的，有什么不同的想法和思路可以在评论区发表一下意见，毕竟不是官方题解，考虑的可能不周全莫名其妙的a题，集思广益。]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>c/c++</tag>
        <tag>Useful</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Even Substrings]]></title>
    <url>%2F2019%2F03%2F26%2FCodeForces-1139A%2F</url>
    <content type="text"><![CDATA[cf果然上瘾，刚才补的一题赶紧记下来。😀 1139 A Even Substringscf传送门：Even Substringsvj传送门：Even Substrings 题目描述You are given a string s=s1s2…sn of length n, which only contains digits 1, 2, ..., 9. A substring s[l…r] of s is a string slsl+1sl+2…sr. A substring s[l…r] of s is called even if the number represented by it is even. Find the number of even substrings of s. Note, that even if some substrings are equal as strings, but have different l and r, they are counted as different substrings. InputThe first line contains an integer n (1≤n≤65000) — the length of the string s. The second line contains a string s of length n. The string s consists only of digits 1, 2, ..., 9. OutputPrint the number of even substrings of s. ExamplesInput41234Output6Input42244Output10NoteIn the first example, the [l,r] pairs corresponding to even substrings are: s[1…2]s[2…2]s[1…4]s[2…4]s[3…4]s[4…4]In the second example, all 10 substrings of s are even substrings. Note, that while substrings s[1…1] and s[2…2] both define the substring &quot;2&quot;, they are still counted as different substrings. 题意分析这道题说实话直接看我真的看不懂，然后我借助翻译，，，发现还是看不懂。经过一段时间的挣扎和猜题意终于是看懂了这道题。这道题就是输入一个字符串，让我们判断它的子串中偶数的个数，偶数指的就是把子串看成是整形的偶数。字符串的长度最大时65000，所以两重for是肯定不能用的，这时候就显现出了思维的重要性。如果这个字符串表示的数是偶数，那么它的最后一位一定是2或2的倍数。根据这一点就可以判断了。具体看代码 代码实现1234567891011121314151617#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; int n; string s,l; cin&gt;&gt;n&gt;&gt;s; int ans=0; for(int i=0;i&lt;n;i++) &#123; if((s[i]-&apos;0&apos;)%2==0) ans+=(i+1); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>Thinking</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Game 23]]></title>
    <url>%2F2019%2F03%2F26%2FCodeForces-1141A%2F</url>
    <content type="text"><![CDATA[萌新小白白看到昨晚cf上有一场div.3难度的比赛，于是我就勇敢的踏上了签到的路。 1141A Game 23cf传送门：Game 23vj传送门：Game 23 题目描述A. Game 23Polycarp plays &quot;Game 23&quot;. Initially he has a number n and his goal is to transform it to m. In one move, he can multiply n by 2 or multiply n by 3. He can perform any number of moves. Print the number of moves needed to transform n to m. Print -1 if it is impossible to do so. It is easy to prove that any way to transform n to m contains the same number of moves (i.e. number of moves doesn&#39;t depend on the way of transformation). InputThe only line of the input contains two integers n and m (1≤n≤m≤5⋅108). OutputPrint the number of moves to transform n to m, or -1 if there is no solution. ExamplesInput120 51840Output7Input42 42Output0Input48 72Output-1NoteIn the first example, the possible sequence of moves is: 120→240→720→1440→4320→12960→25920→51840. The are 7 steps in total. In the second example, no moves are needed. Thus, the answer is 0. In the third example, it is impossible to transform 48 to 72. 题意分析因为是全英文的题面，我选择了先看样例，又看到了提示，因为紧张加小激动我把题意理解错了。。。以为是个水题（对大佬是真水题吧）。题目要求就是输入两个数，问你从第一个数变成第二个数需要几步，变化的方法是乘以2或者乘以3，如果可以，输出步数，不可以的话就输出“-1”，听学长说是质因子分解，可是我不会（哈哈哈哈，以后会了再来试试。经过我跟小伙伴的一波探讨发现可以用第二个数对第一个数先求余，如果余数不为0，直接输出“-1”。余数如果为0，就对两数的商进行处理，除以三能除尽就一直除直到除不尽，再判断，如果除以二能除尽就一直除直到除不尽，每循环一次次数加一，最后都除不尽的时候需要在进行一次判断了看现在的商是不是1，如果不是则说明变化的过程中只有二和三是不够的，所以需要输出“-1”，反之输出次数即可。 代码实现123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; ll n,m,k,a,b; cin&gt;&gt;n&gt;&gt;m; if(m%n!=0) cout&lt;&lt;&quot;-1&quot;; ll s=0; if(m%n==0) &#123; k=m/n; while(k%3==0) &#123; k/=3; s++; &#125; while(k%2==0) &#123; k/=2; s++; &#125; if(k!=1) &#123; cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl; return 0; &#125; cout&lt;&lt;s; &#125; cout&lt;&lt;endl; return 0; &#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
        <tag>Thinking</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCD和LCM]]></title>
    <url>%2F2019%2F03%2F26%2FGCD-LCM%2F</url>
    <content type="text"><![CDATA[GCD和LCM是很常用的，但是之前一直记不住，用一篇博客总结一下，希望自己能加强记忆！ GCD(最大公约数)定义 gcd,最大公因数（英语：highest common factor，hcf）也称最大公约数（英语：greatest common divisor，gcd）是数学词汇，指能够整除多个整数的最大正整数。而多个整数不能都为零。 c/c++语言实现求GCD 求两个整数最大公约数主要的方法有： 穷举法 素因数分解 短除法 辗转相除法 这里我们主要用辗转相除法(又称欧几里得算法)求最大公因数。辗转相除法：用较大数除以较小数，再用出现的余数（第一余数）去除除数，再用出现的余数（第二余数）去除第一余数，如此反复，直到最后余数是0为止。如果是求两个数的最大公约数，那么最后的除数就是这两个数的最大公约数。具体代码实现 1234567891011121314int gcd(int x,int y)&#123; if(y==0) return x; else return gcd(y,x%y);&#125;//这种方法可以用到三目运算符来简化代码int gcd(int x.int y)&#123; return y==0?x:gcd(y,x%y);&#125; 上面这种写法用到了递归，还有就是不用递归的写法 1234567891011int gcd(int x,int y)&#123; int z; while(y!=0) &#123; z=x%y; x=y; y=z; &#125; return x;&#125; 上面两种写法本质上是一样的，就是辗转相除法. 实例分析HDUOJ 2504题目描述又见GCDTime Limit: 1000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) 有三个正整数a,b,c(a,b,c是三个大于0小于1e6的数)，其中c不等于b。若a和c的最大公约数为b，现已知a和b，求满足条件的最小的c。 Input第一行输入一个n，表示有n组测试数据，接下来的n行，每行输入两个正整数a,b。 Output输出对应的c，每组测试数据占一行。 Sample Input26 212 4Sample Output48题目分析这是一道简单的考察最大公约数的问题。给定两个数a,b求满足gcd(a,c)=b的最小的c的值且c不等于b。数据范围在1e6以内，并且c是b的倍数，所以可以每次给b加c，每次判断是不是答案即可。即123c=2*b; //因为b是a,c的最大公约数，所以c肯定是大于等于b的。又因为题目中了b不等于c，所以给c定初值为2*b。while(gcd(a,c)!=b) b+=c; //c是b的倍数，所以可以每次给b加c 完整代码实现 1234567891011121314151617181920#include&lt;stdio.h&gt;int gcd(int x,int y)&#123; if(y==0) return x; return gcd(y,x%y);&#125;int main()&#123; int a,b,n; scanf(&quot;%d&quot;,&amp;n); while(n--) &#123; scanf(&quot;%d %d&quot;,&amp;a,&amp;b); int c=2*b; while(gcd(a,c)!=b) c+=b; printf(&quot;%d\n&quot;,c); &#125; return 0;&#125; 在vj上提交运行的结果 LCM(最小公倍数)定义LCM,两个或多个整数公有的倍数叫做它们的公倍数，其中除0以外最小的一个公倍数就叫做这几个整数的最小公倍数。 c/c++实现求LCMn个数的最小公倍数就等于这n个数乘积的绝对值除以这n个数的最大公约数。即lcm(a,b)=a*b/gcd(a,b)。换句话说就是，如果n个数以及这n个数的最大公约数已知，就能求出这n个数的最小公倍数。具体代码实现 12345678int gcd(int x,int y)&#123; return y==0?x:gcd(y,x%y);&#125;int lcm(int x,int y)&#123; return x*y/gcd(x,y);&#125; 实例分析蓝桥杯历届试题 核桃的数量题目描述历届试题 核桃的数量时间限制：1.0s 内存限制：256.0MB 问题描述小张是软件项目经理，他带领3个开发组。工期紧，今天都在加班呢。为鼓舞士气，小张打算给每个组发一袋核桃（据传言能补脑）。他的要求是： 各组的核桃数量必须相同 各组内必须能平分核桃（当然是不能打碎的） 尽量提供满足1,2条件的最小数量（节约闹革命嘛） 输入格式输入包含三个正整数a, b, c，表示每个组正在加班的人数，用空格分开（a,b,c是三个小于30的数）输出格式输出一个正整数，表示每袋核桃的数量。样例输入12 4 5样例输出120样例输入23 1 1样例输出23题目分析 经过看题的过程可以发现这只是一个让求三个数的最小公倍数的水题，直接写就行。具体代码实现 12345678910111213141516#include&lt;stdio.h&gt;int gcd(int x,int y)&#123; return y==0?x:gcd(y,x%y);&#125;int lcm(int x,int y)&#123; return x*y/gcd(x,y);&#125;int main()&#123; int a,b,c; scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c); printf(&quot;%d\n&quot;,lcm(lcm(a,b),c)); return 0;&#125; 在蓝桥评测系统上提交运行的结果 总结关于最大公约数以及最小公倍数的东西先总结到这里，以后再有拓展的话会继续添加。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo背景的更换]]></title>
    <url>%2F2019%2F03%2F26%2Fbackground-hexo%2F</url>
    <content type="text"><![CDATA[博客搭建好之后，只有空荡荡的一篇感悟，显得有点萧瑟。这明显不符合我的气质，所以必须装饰一下。首先我选择换一个背景，因为简单（手动滑稽）。我通过我经过换背景的愉快艰辛历程总结一下换背景的一些经验。找到自己喜欢的图片，把它放进文件myblog\themes\next\source\images(博客主题中的文件夹)然后去找到myblog\themes\next\source\css\_custom中的custom.styl在里面填入代码1234567body&#123; background:url(/images/(你选择要作为背景的图片).jpg); background-size:cover; background-repeat:no-repeat; background-attachment:fixed; background-position:center;&#125; 然后重新载入一次就可以看到自己的背景了。浅色背景还好，如果背景颜色较深，需要更改透明度什么的，我继续学习！！！]]></content>
      <categories>
        <category>Tutorial</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[map的应用之Summarize to the Power of Two]]></title>
    <url>%2F2019%2F03%2F26%2FCodeForces-1005C%2F</url>
    <content type="text"><![CDATA[萌新小白白渴望提升，学着大佬的样子去打cf，发现div3的题还是可以磕磕绊绊(WA多点)的做出来的。记录一下 CodeForces - 1005C Summarize to the Power of Twocf原题传送门:cf真好玩vjudge传送门:cf真好玩 题目描述A sequence a1,a2,…,an is called good if, for each element ai, there exists an element aj (i≠j) such that ai+aj is a power of two (that is, 2d for some non-negative integer d). For example, the following sequences are good: [5,3,11] (for example, for a1=5 we can choose a2=3. Note that their sum is a power of two. Similarly, such an element can be found for a2 and a3),[1,1,1,1023],[7,39,89,25,89],[].Note that, by definition, an empty sequence (with a length of 0) is good. For example, the following sequences are not good: [16] (for a1=16, it is impossible to find another element aj such that their sum is a power of two),[4,16] (for a1=4, it is impossible to find another element aj such that their sum is a power of two),[1,3,2,8,8,8] (for a3=2, it is impossible to find another element aj such that their sum is a power of two).You are given a sequence a1,a2,…,an. What is the minimum number of elements you need to remove to make it good? You can delete an arbitrary set of elements. InputThe first line contains the integer n (1≤n≤120000) — the length of the given sequence. The second line contains the sequence of integers a1,a2,…,an (1≤ai≤109). OutputPrint the minimum number of elements needed to be removed from the given sequence in order to make it good. It is possible that you need to delete all n elements, make it empty, and thus get a good sequence. ExamplesInput64 7 1 5 4 9Output1Input51 2 3 4 5Output2Input116Output1Input41 1 1 1023Output0NoteIn the first example, it is enough to delete one element a4=5. The remaining elements form the sequence [4,7,1,4,9], which is good. 题意分析啊，熟悉的全英文题面，虽然看起来有点吃力但还是要看的，不记得了之前在哪里听到过这样一句话，做程序员，不能排斥英语，你要学会去适应。也把这句话送给和我一样的小白白们。其实仔细看看还是可以懂个大概的，然后就可以看样例猜题意了。这道题的意思是给你一组数，每个数都可以和另外任意一个数（不包括他自己）进行求和，如果求和之后是2的N次方，这个数就可以存在在这个数列中。如果有一个数，和其他任意一个数相加都不是2的N次方，这个数就不符合要求，题目中要求输出的就是不符合条件的数字的个数（可以为0）。我一开始想着暴力判断再慢慢优化，然后发现我的优化能力不是很强（😭逃。然后想到了map。用2的N次方减去每一个数，判断差是否存在。具体看代码实现。 代码实现1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll a[200000];int main()&#123; map&lt;ll,ll&gt; ma; ll n,i,k,ans=0; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; ma[a[i]]++;//对a[i]出现的次数进行计数 &#125; for(int i=0;i&lt;n;i++) &#123; ll er=1,g=0,j=0; for(int j=0;j&lt;31;j++) &#123; if(ma[er-a[i]]!=0)//ma[er-a[i]]不为零说明差值在数列中存在 &#123; if(er-a[i]==a[i])//如果差值为它自己，就需要接着判断 &#123; if(ma[a[i]]&gt;1) g++; &#125; else g++; &#125; er*=2;//er就是2的N次方 &#125; if(g==0) ans++;//g为0则说明差值不存在或者差值与a[i]相等且a[i]只出现一次，即a[i]不是符合条件的数。 &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 小结随着慢慢的刷题，发现这些容器，函数什么的都贼好用，解决问题的时候应该多往这方面想一想。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>c/c++</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习笔记]]></title>
    <url>%2F2019%2F03%2F26%2Fpython_study%2F</url>
    <content type="text"><![CDATA[持续更新ing………………我们上学期学习了python，但是觉得学的很浅，因为python的实用性我决定剩下的python要自学起来，起码可以用python做一些题吧。我会把我难以理解或者积下来的知识点放进这篇文章中。推荐大家去https://www.liaoxuefeng.com/ 廖雪峰的官方网站学习，我是在本网站的基础上进行的学习以及自己的总结。 运算符python中的运算符有些跟c是不同的。python中有两种除法123456789101112/ 这个除法计算的结果是浮点数，即使两个整数恰好整除，结果也是浮点数；&gt;&gt;&gt; 10 / 33.3333333333333335&gt;&gt;&gt; 9 / 33.0// 这个是整除，不会四舍五入的&gt;&gt;&gt; 10 // 33&gt;&gt;&gt; 10 / 120.8333333333333334&gt;&gt;&gt; 10 // 120 各种函数ord()获取字符的整数表示chr()把编码转换为对应的字符123456789101112&gt;&gt;&gt; ord("崔")23828&gt;&gt;&gt; ord("美")32654&gt;&gt;&gt; ord("美")32654&gt;&gt;&gt; chr(23828)'崔'&gt;&gt;&gt; chr(32654)'美'&gt;&gt;&gt; chr(32654)'美' python的格式化python中的格式化方式跟c语言是一致的，用%实现。123456789%d 整数%f 浮点数%s 字符串%x 十六进制整数&gt;&gt;&gt; &apos;Hello, %s&apos; % &apos;world&apos;&apos;Hello, world&apos;&gt;&gt;&gt; &apos;Hi, %s, you have $%d.&apos; % (&apos;Michael&apos;, 1000000)&apos;Hi, Michael, you have $1000000.&apos;# 具体看来跟c还是有些出入的，注意一下 还有一种格式化输出的方式即format函数，这个我们上学期学过，我就不再总结了。 列表——listlist是一种有序的集合，可以随时添加和删除其中的元素。1234567891011&gt;&gt;&gt; girllist = ["崔美美","侍皮皮","顾六六"]&gt;&gt;&gt; girllist['崔美美', '侍皮皮', '顾六六']&gt;&gt;&gt; len(girllist)3&gt;&gt;&gt; girllist[0]'崔美美'&gt;&gt;&gt; girllist[-1]'顾六六'&gt;&gt;&gt; girllist[1]'侍皮皮' 可以用append函数向列表尾部增加新元素123&gt;&gt;&gt; girllist.append("jimila")&gt;&gt;&gt; girllist[3]'jimila' 还可以用insert函数把元素插入到指定的位置12345&gt;&gt;&gt; girllist['崔美美', '侍皮皮', '顾六六', 'jimila']&gt;&gt;&gt; girllist.insert(2,"drew")&gt;&gt;&gt; girllist['崔美美', '侍皮皮', 'drew', '顾六六', 'jimila'] pop函数可以直接删除列表末尾的元素123456&gt;&gt;&gt; girllist['崔美美', '侍皮皮', 'drew', '顾六六', 'jimila']&gt;&gt;&gt; girllist.pop()'jimila'&gt;&gt;&gt; girllist['崔美美', '侍皮皮', 'drew', '顾六六'] 也可以用pop(i)删除指定位置的元素123456&gt;&gt;&gt; girllist['崔美美', '侍皮皮', 'drew', '顾六六']&gt;&gt;&gt; girllist.pop(2)'drew'&gt;&gt;&gt; girllist['崔美美', '侍皮皮', '顾六六'] 要把某个元素替换成别的元素，可以直接赋值给对应的索引位置12345&gt;&gt;&gt; girllist['崔美美', '侍皮皮', '顾六六']&gt;&gt;&gt; girllist[0] = "悦美美"&gt;&gt;&gt; girllist['悦美美', '侍皮皮', '顾六六']]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
</search>
